<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>Hexo</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Hexo"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Hexo"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="website"><meta property="og:title" content="Hexo"><meta property="og:url" content="https://baymine.github.io/"><meta property="og:site_name" content="Hexo"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://baymine.github.io/img/og_image.png"><meta property="article:author" content="John Doe"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://baymine.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://Baymine.github.io"},"headline":"Hexo","image":["https://baymine.github.io/img/og_image.png"],"author":{"@type":"Person","name":"John Doe"},"publisher":{"@type":"Organization","name":"Hexo","logo":{"@type":"ImageObject"}},"description":""}</script><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head><body class="is-1-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">Hexo</a></div><div class="navbar-menu"><div class="navbar-end"></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-12"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-03-25T07:29:44.000Z" title="3/25/2021, 3:29:44 PM">2021-03-25</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-03-08T11:47:18.992Z" title="3/8/2023, 7:47:18 PM">2023-03-08</time></span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/03/25/%E3%80%8A%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%8B%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">《算法笔记》第十一章(动态规划)</a></p><div class="content"><p>@[toc]</p>
<h1 id="动态规划介绍"><a href="#动态规划介绍" class="headerlink" title="动态规划介绍"></a>动态规划介绍</h1><p><strong>动态规划（Dynamic Programming</strong>)用于解决一类最优化问题。它将一个问题划分成几个相同的子问题，通过找到子问题的全局最优解，得到整个问题的最优解。<br><br><br><strong>DP与贪心算法的主要区别是</strong>：<u>贪心算法选用的是当前步骤的最优解，但是DP采用的是当前子问题的全局最优解。</u>DP因为每一步都是当前子问题的全局最优解，所以最后的一个子问题（原问题）也是全局最优解。而贪心算法由于是局部最优解，所以只能得到一个局部最优解。<br><img src="https://img-blog.csdnimg.cn/20210317203300613.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在动态规划的一类问题中，子问题之间会出现重叠子问题，为了避免重复计算，可以用一个数组变量作为备忘录，记录当前的子问题的最优解。<br>下面是求解斐波那契数列的问题：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">F</span><span class="params">(<span class="type">int</span> n)</span> </span>{</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">F</span>(n - <span class="number">1</span>) + <span class="built_in">F</span>(n - <span class="number">2</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><br>可以注意到在求解最终结果之前，这个算法花费了大量的时间去计算一些重复的问题，因为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="31.91ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 14104.3 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D439" d="M48 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H742Q749 676 749 669Q749 664 736 557T722 447Q720 440 702 440H690Q683 445 683 453Q683 454 686 477T689 530Q689 560 682 579T663 610T626 626T575 633T503 634H480Q398 633 393 631Q388 629 386 623Q385 622 352 492L320 363H375Q378 363 398 363T426 364T448 367T472 374T489 386Q502 398 511 419T524 457T529 475Q532 480 548 480H560Q567 475 567 470Q567 467 536 339T502 207Q500 200 482 200H470Q463 206 463 212Q463 215 468 234T473 274Q473 303 453 310T364 317H309L277 190Q245 66 245 60Q245 46 334 46H359Q365 40 365 39T363 19Q359 6 353 0H336Q295 2 185 2Q120 2 86 2T48 1Z"/></g><g data-mml-node="mo" transform="translate(749,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1138,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1960.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(2960.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(3460.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(4127.2,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mi" transform="translate(5183,0)"><path data-c="1D439" d="M48 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H742Q749 676 749 669Q749 664 736 557T722 447Q720 440 702 440H690Q683 445 683 453Q683 454 686 477T689 530Q689 560 682 579T663 610T626 626T575 633T503 634H480Q398 633 393 631Q388 629 386 623Q385 622 352 492L320 363H375Q378 363 398 363T426 364T448 367T472 374T489 386Q502 398 511 419T524 457T529 475Q532 480 548 480H560Q567 475 567 470Q567 467 536 339T502 207Q500 200 482 200H470Q463 206 463 212Q463 215 468 234T473 274Q473 303 453 310T364 317H309L277 190Q245 66 245 60Q245 46 334 46H359Q365 40 365 39T363 19Q359 6 353 0H336Q295 2 185 2Q120 2 86 2T48 1Z"/></g><g data-mml-node="mo" transform="translate(5932,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(6321,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(7143.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(8143.4,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mo" transform="translate(8643.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(9254.7,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mi" transform="translate(10254.9,0)"><path data-c="1D439" d="M48 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H742Q749 676 749 669Q749 664 736 557T722 447Q720 440 702 440H690Q683 445 683 453Q683 454 686 477T689 530Q689 560 682 579T663 610T626 626T575 633T503 634H480Q398 633 393 631Q388 629 386 623Q385 622 352 492L320 363H375Q378 363 398 363T426 364T448 367T472 374T489 386Q502 398 511 419T524 457T529 475Q532 480 548 480H560Q567 475 567 470Q567 467 536 339T502 207Q500 200 482 200H470Q463 206 463 212Q463 215 468 234T473 274Q473 303 453 310T364 317H309L277 190Q245 66 245 60Q245 46 334 46H359Q365 40 365 39T363 19Q359 6 353 0H336Q295 2 185 2Q120 2 86 2T48 1Z"/></g><g data-mml-node="mo" transform="translate(11003.9,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(11392.9,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(12215.1,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(13215.3,0)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/></g><g data-mml-node="mo" transform="translate(13715.3,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>，所以在完成第一个递归的时候，其实第二个递归式已经被计算过了，所以可以将这个结果利用起来。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN = 10</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">F</span><span class="params">(<span class="type">int</span> n)</span> </span>{</span><br><span class="line">		<span class="comment">//将数组初始化为-1.表示该结果未被计算</span></span><br><span class="line">		<span class="type">int</span>*dp = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line">		<span class="built_in">fill</span>(dp, dp + n, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (dp[n] != <span class="number">-1</span>)<span class="keyword">return</span> dp[n];</span><br><span class="line">		<span class="keyword">else</span> {</span><br><span class="line">			dp[n] = <span class="built_in">F</span>(n - <span class="number">1</span>) + <span class="built_in">F</span>(n - <span class="number">2</span>);</span><br><span class="line">			<span class="keyword">return</span> dp[n];</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//当只需要第n个斐波那契数的时候，使用三个变量滚动更新即可</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">F</span><span class="params">(<span class="type">int</span> n)</span> </span>{</span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//三个变量分别表示F(n-2)、F(n-1)、F(n)</span></span><br><span class="line">		<span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>, c = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++n) {</span><br><span class="line">			c = a + b;</span><br><span class="line">			a = b;</span><br><span class="line">			b = c;</span><br><span class="line">		}</span><br><span class="line">	}</span><br></pre></td></tr></table></figure><br>通过记忆之前的计算结果，避免了重复子问题的求解，从而使求解的时间复杂度由原先的O(<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="2.279ex" height="1.528ex" role="img" focusable="false" viewbox="0 -675.5 1007.3 675.5"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g></g></g></g></svg></mjx-container>)转变成O(<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewbox="0 -442 600 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>)。</p>
<h2 id="递推写法"><a href="#递推写法" class="headerlink" title="递推写法"></a>递推写法</h2><p>现在看一个数塔问题，需要求解从顶层到最底层的所形成的最大的数字。如下图：<br><img src="https://img-blog.csdnimg.cn/20210317213841404.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>从最顶层开始，我们先假设下一层的各个元素到最低层所形成的最大数字都已经知道了，并且存放在一个二维数组中。在上图中，最顶层的元素到最层的所形成的最大数字可以表示为：</p>
<script type="math/tex; mode=display">dp[1][1] = max(dp[2][1],dp[2][2]) + val[1][1]</script><p><font color="#999AAA"><em>其中，dp存放各节点到最底层形成的最大数字，val存放当前节点的所存储的值。</em></font></p>
<p>同样的，每一个子问题的求解也可以用与头节点相同的方法进行求解。所以可以得到一个<strong>状态转移方程</strong>：</p>
<script type="math/tex; mode=display">dp[i][j] = max(dp[i+1][j],dp[i+1][j+1]) + val[i][j]</script><p>这样就得到了一个上下层之间的关系式。这也就是说我们可以利用下层的结果来求解上层！又注意到，最底层节点到最底层节点所能形成最大的数字就是其本身！所以通过自底向上（Bottom-up）的方法，可以逐步向上求解的最终的问题的答案！<br>这种算法的分析模式似乎就是<strong>从上往下分析最优解的结构，从下往上求解最优解</strong>。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">numTower</span><span class="params">(<span class="type">int</span> f[maxn][maxn])</span></span>{</span><br><span class="line">	<span class="comment">//边界	</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n;++j){</span><br><span class="line">		dp[n][j] = f[n][j];</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//向上更新各节点的最优结果</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = n <span class="number">-1</span>; i &gt;= <span class="number">1</span>; i--){</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i;j++){</span><br><span class="line">			dp[i][j] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][j],dp[i + <span class="number">1</span>][j + <span class="number">1</span>]) + f[i][j];</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></table></figure><br>这一类问题有一个共同点，那就是拥有<strong>最优子结构(Optimal Structure)</strong>，通过这个最优子结构可以构造出这个问题的最优解。<br>这样一个问题想要用动态规划进行求解，需要满足两个条件：<strong>拥有重叠子问题和最优子结构</strong>。前者是发挥动态规划优势条件，后者是产生状态转移方程的条件。<br><code>递归与递推</code>的写法在本质上是一致的，但是在写法上存在一些区别，<code>递归</code>是通过向下递归，一步步得到最优解的（就像是先利用还未被解出来的结果）所以是<strong>自顶向下</strong>的。而<code>递推</code>需要一步步获得子问题的最优解（就像是利用的是求解出来的结果），所以是<strong>自底向上</strong>的。</p>
<h1 id="最大连续子序列和"><a href="#最大连续子序列和" class="headerlink" title="最大连续子序列和"></a>最大连续子序列和</h1><p>问题描述：</p>
<blockquote>
<p>给定一个数字数列<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex;" xmlns="http://www.w3.org/2000/svg" width="13.631ex" height="2.059ex" role="img" focusable="false" viewbox="0 -716 6025 910"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"/></g><g data-mml-node="mn" transform="translate(783,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g><g data-mml-node="mo" transform="translate(1186.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="msub" transform="translate(1631.2,0)"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"/></g><g data-mml-node="mn" transform="translate(783,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(2984.4,0)"><path data-c="2026" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60ZM525 60Q525 84 542 102T585 120Q609 120 627 104T646 61Q646 36 629 18T586 0T543 17T525 60ZM972 60Q972 84 989 102T1032 120Q1056 120 1074 104T1093 61Q1093 36 1076 18T1033 0T990 17T972 60Z"/></g><g data-mml-node="mo" transform="translate(4323.1,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="msub" transform="translate(4767.8,0)"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"/></g><g data-mml-node="mi" transform="translate(783,-150) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g></g></g></svg></mjx-container>,求<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="18.988ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 8392.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(345,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">，</text></g><g data-mml-node="mi" transform="translate(1345,0)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"/></g><g data-mml-node="mo" transform="translate(1757,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mn" transform="translate(2146,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(2923.8,0)"><path data-c="2264" d="M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"/></g><g data-mml-node="mi" transform="translate(3979.6,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(4602.3,0)"><path data-c="2264" d="M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"/></g><g data-mml-node="mi" transform="translate(5658.1,0)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"/></g><g data-mml-node="mo" transform="translate(6347.9,0)"><path data-c="2264" d="M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"/></g><g data-mml-node="mi" transform="translate(7403.7,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(8003.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>，使得<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.666ex;" xmlns="http://www.w3.org/2000/svg" width="13.541ex" height="2.286ex" role="img" focusable="false" viewbox="0 -716 5985.1 1010.2"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"/></g><g data-mml-node="mi" transform="translate(783,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g><g data-mml-node="mo" transform="translate(1299.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mo" transform="translate(2299.4,0)"><path data-c="2026" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60ZM525 60Q525 84 542 102T585 120Q609 120 627 104T646 61Q646 36 629 18T586 0T543 17T525 60ZM972 60Q972 84 989 102T1032 120Q1056 120 1074 104T1093 61Q1093 36 1076 18T1033 0T990 17T972 60Z"/></g><g data-mml-node="mo" transform="translate(3638.1,0)"><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"/></g><g data-mml-node="mo" transform="translate(4082.7,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="msub" transform="translate(4860.7,0)"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"/></g><g data-mml-node="mi" transform="translate(783,-150) scale(0.707)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"/></g></g></g></g></svg></mjx-container>最大，输出这个最大和</p>
</blockquote>
<h2 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h2><p>首先可以采用枚举的方式，从第一个元素开始。让<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="0.781ex" height="1.52ex" role="img" focusable="false" viewbox="0 -661 345 672"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>固定，让<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.462ex;" xmlns="http://www.w3.org/2000/svg" width="0.932ex" height="1.957ex" role="img" focusable="false" viewbox="0 -661 412 865"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"/></g></g></g></svg></mjx-container>指针向后移动，统计最大值，然后将<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="0.781ex" height="1.52ex" role="img" focusable="false" viewbox="0 -661 345 672"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>向后移动，重复上面的操作。这样枚举过程需要的时间复杂度为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.832ex" height="2.452ex" role="img" focusable="false" viewbox="0 -833.9 2577.6 1083.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="msup" transform="translate(1152,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(633,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(2188.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>，加上求和过程中的复杂度为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2141 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1752,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>，总复杂度为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.832ex" height="2.451ex" role="img" focusable="false" viewbox="0 -833.2 2577.6 1083.2"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="msup" transform="translate(1152,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(633,363) scale(0.707)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/></g></g><g data-mml-node="mo" transform="translate(2188.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>,如果用数组记住原先的计算结果，通过推算求得子序列的和，那么总复杂度为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.832ex" height="2.452ex" role="img" focusable="false" viewbox="0 -833.9 2577.6 1083.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="msup" transform="translate(1152,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(633,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(2188.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>.</p>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>将<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.353ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 1924 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g><g data-mml-node="mi" transform="translate(520,0)"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/></g><g data-mml-node="mo" transform="translate(1023,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mi" transform="translate(1301,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1646,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g></g></g></svg></mjx-container>作为以<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="2.437ex" height="1.977ex" role="img" focusable="false" viewbox="0 -716 1077 873.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"/></g><g data-mml-node="mi" transform="translate(783,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g></g></g></svg></mjx-container>结尾的、和最大的连续子序列，这样<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.353ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 1924 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g><g data-mml-node="mi" transform="translate(520,0)"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/></g><g data-mml-node="mo" transform="translate(1023,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mi" transform="translate(1301,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1646,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g></g></g></svg></mjx-container>的取值为：</p>
<script type="math/tex; mode=display">dp[i] = max\{A[i],dp[i-1]+A[i]\}</script><p>这也就是选择加或者不加之前元素的序列，看看哪个序列和更大。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> A[maxn], dp[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sumOfserial</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="comment">//输入</span></span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) {</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A[i]);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//边界</span></span><br><span class="line">	dp[<span class="number">0</span>] = A[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">//更新状态数组</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) {</span><br><span class="line">		dp[i] = <span class="built_in">max</span>(A[i], dp[i - <span class="number">1</span>] + A[i]);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//找到最大的结果所在的位置</span></span><br><span class="line">	<span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) {</span><br><span class="line">		<span class="keyword">if</span> (dp[i] &gt; dp[k]) k = i;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//输出结果</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[k]);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<h1 id="最长不下降子序列（LIS）"><a href="#最长不下降子序列（LIS）" class="headerlink" title="最长不下降子序列（LIS）"></a>最长不下降子序列（LIS）</h1><p>LIS(Longest Increasing Sequence)问题描述</p>
<blockquote>
<p>在一个数字序列中，找到一个最长的子序列（可以不连续），使得这个序列是不下降（非递减）的。</p>
</blockquote>
<h2 id="暴力求解"><a href="#暴力求解" class="headerlink" title="暴力求解"></a>暴力求解</h2><p>如果采用暴力解法，即每个元素都有两种情况，加入子序列或者是不加入子序列，将每一个元素进行枚举，找出最长的LIS，更新最大长度，但是这样的时间复杂度为O(<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="2.279ex" height="1.528ex" role="img" focusable="false" viewbox="0 -675.5 1007.3 675.5"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mi" transform="translate(533,363) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g></g></g></svg></mjx-container>)。</p>
<h2 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h2><p>现在尝试使用动态规划进行求解。将<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.353ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 1924 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g><g data-mml-node="mi" transform="translate(520,0)"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/></g><g data-mml-node="mo" transform="translate(1023,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mi" transform="translate(1301,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1646,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g></g></g></svg></mjx-container>当成以<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="0.781ex" height="1.52ex" role="img" focusable="false" viewbox="0 -661 345 672"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>结尾的LIS，将第<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="0.781ex" height="1.52ex" role="img" focusable="false" viewbox="0 -661 345 672"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>个序列元素作为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="3.735ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 1651 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"/></g><g data-mml-node="mo" transform="translate(750,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mi" transform="translate(1028,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1373,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g></g></g></svg></mjx-container>，想要找到最长的序列，就需要遍历<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="0.781ex" height="1.52ex" role="img" focusable="false" viewbox="0 -661 345 672"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>之前的所有<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.505ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 1991 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g><g data-mml-node="mi" transform="translate(520,0)"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/></g><g data-mml-node="mo" transform="translate(1023,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mi" transform="translate(1301,0)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"/></g><g data-mml-node="mo" transform="translate(1713,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g></g></g></svg></mjx-container>，尝试将<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="3.735ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 1651 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"/></g><g data-mml-node="mo" transform="translate(750,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mi" transform="translate(1028,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1373,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g></g></g></svg></mjx-container>加入到这个子序列中，看是否能形成更大的LIS。所以<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.353ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 1924 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g><g data-mml-node="mi" transform="translate(520,0)"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/></g><g data-mml-node="mo" transform="translate(1023,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mi" transform="translate(1301,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1646,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g></g></g></svg></mjx-container>的状态转移方程为：</p>
<script type="math/tex; mode=display">dp[i] = max\{1, dp[j]+1\}\\(j = 1,2,....,i-1 \&\& A[j]<A[i])</script><p>当$A[i]$加到所有的子序列中都不能够成LIS时，那就只能$A[i]$自己形成一个子序列，所以为1。<br>整个算法时间复杂度$O(n^2)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入参数为序列以及序列元素个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LSP</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		dp[i] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (A[i] &gt;= A[j] &amp;&amp; (dp[j] + <span class="number">1</span> &gt; dp[i])) &#123;</span><br><span class="line">				dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ans = ans &gt; dp[i] ? ans : dp[i];</span><br><span class="line">		<span class="comment">//ans = max(ans, dp[i]);</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="最长公共子序列-LCS"><a href="#最长公共子序列-LCS" class="headerlink" title="最长公共子序列(LCS)"></a>最长公共子序列(LCS)</h1><p>问题描述</p>
<blockquote>
<p>给定两个字符串（或数字序列）A和B，求一个字符串，使得这个字符串是A和B的最长公共部分（子序列可以不重合）<br>例如：“sadstory”和“adminsorry”的最长公共子序列为“adsory”</p>
</blockquote>
<h2 id="暴力解法-1"><a href="#暴力解法-1" class="headerlink" title="暴力解法"></a>暴力解法</h2><p>每一个元素都有选或者不选两种选择，所以想要遍历所有的元素需要的时间复杂度为$O(2^{m+n})$,选出来的序列需要进行比较(用分别指向两个序列的指针)，这需要的时间复杂度为$O(max(m,n))$,所以总的时间复杂度为$O(2^{m+n}\times max(m,n))$</p>
<h2 id="动态规划-2"><a href="#动态规划-2" class="headerlink" title="动态规划"></a>动态规划</h2><p>首先定义dp数组，将$dp[i][j]$作为A的$(1 \sim i)$子串和B的$(1\sim j)$子串所能形成的最长的公共子串。</p>
<p><img src="https://img-blog.csdnimg.cn/20210328152444324.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>从上图可以看出，有两种情况：</p>
<script type="math/tex; mode=display">dp[i][j]=\left\{
\begin{aligned}
dp[i-1][j-1], A[i] == B[j]\\
max\{dp[i-1][j],dp[i][j-1]\}, A[i] != B[j]
\end{aligned}
\right.</script><p>同时也可以看到二维矩阵的四周就是动态规划的边界。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100</span>;</span><br><span class="line"><span class="type">char</span> A[N], B[N];<span class="comment">//两个目标字符串数组</span></span><br><span class="line"><span class="type">int</span> dp[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="comment">//Input those datas.Note that the index is starting from 1</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; ++i) {</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;A[i]);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; ++i) {</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;B[i]);</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//Calculating the length from 1.</span></span><br><span class="line">	<span class="type">int</span> lenA = <span class="built_in">strlen</span>(A + <span class="number">1</span>);</span><br><span class="line">	<span class="type">int</span> lenB = <span class="built_in">strlen</span>(B + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Boundary</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= lenA; ++i) {</span><br><span class="line">		dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= lenB; ++i) {</span><br><span class="line">		dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//State Transition Equations</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= lenA; ++i) {</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= lenB; ++j) {</span><br><span class="line">			<span class="keyword">if</span> (A[i] == B[j]) {</span><br><span class="line">				dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">else</span> {</span><br><span class="line">				dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Output the result</span></span><br><span class="line">	cout &lt;&lt; dp[lenA][lenB] &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<h1 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h1><p>运用动态规划的方法可以将原先的暴力解法的时间复杂度<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.832ex" height="2.451ex" role="img" focusable="false" viewbox="0 -833.2 2577.6 1083.2"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="msup" transform="translate(1152,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(633,363) scale(0.707)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/></g></g><g data-mml-node="mo" transform="translate(2188.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>变成<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.832ex" height="2.452ex" role="img" focusable="false" viewbox="0 -833.9 2577.6 1083.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="msup" transform="translate(1152,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(633,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(2188.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>。还是像原先的一样，只要子序列是否为回文子串，需要通过判断子串两端的元素是否相同，然后再利用该子串的子串来判断整体子串是否为回文子串。用公式表示为：<br>将<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="6.543ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2892 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g><g data-mml-node="mi" transform="translate(520,0)"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/></g><g data-mml-node="mo" transform="translate(1023,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mi" transform="translate(1301,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1646,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g><g data-mml-node="mo" transform="translate(1924,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mi" transform="translate(2202,0)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"/></g><g data-mml-node="mo" transform="translate(2614,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g></g></g></svg></mjx-container>定义为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="3.498ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 1546 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"/></g><g data-mml-node="mo" transform="translate(645,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mi" transform="translate(923,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1268,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g></g></g></svg></mjx-container>至<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="3.649ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 1613 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"/></g><g data-mml-node="mo" transform="translate(645,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mi" transform="translate(923,0)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"/></g><g data-mml-node="mo" transform="translate(1335,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g></g></g></svg></mjx-container>是否为回文序列，是则为1，否则为0.</p>
<script type="math/tex; mode=display">dp[i][j]=\left\{
\begin{aligned}
dp[i+1][j-1],S[i] == S[j]\\
0,S[i]!=S[j]
\end{aligned}
\right.</script><p>边界：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="47.497ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 20993.8 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g><g data-mml-node="mi" transform="translate(520,0)"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/></g><g data-mml-node="mo" transform="translate(1023,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mi" transform="translate(1301,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1646,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g><g data-mml-node="mo" transform="translate(1924,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mi" transform="translate(2202,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(2547,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g><g data-mml-node="mo" transform="translate(3102.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(4158.6,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(4658.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(5103.2,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g><g data-mml-node="mi" transform="translate(5623.2,0)"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/></g><g data-mml-node="mo" transform="translate(6126.2,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mi" transform="translate(6404.2,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(6749.2,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g><g data-mml-node="mo" transform="translate(7027.2,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mi" transform="translate(7305.2,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(7872.4,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(8872.7,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(9372.7,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g><g data-mml-node="mo" transform="translate(9928.4,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mo" transform="translate(10984.2,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(11373.2,0)"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"/></g><g data-mml-node="mo" transform="translate(12018.2,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mi" transform="translate(12296.2,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(12641.2,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g><g data-mml-node="mo" transform="translate(13197,0)"><g data-mml-node="text"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="text" transform="translate(778,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g></g><g data-mml-node="mi" transform="translate(15030.8,0)"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"/></g><g data-mml-node="mo" transform="translate(15675.8,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mi" transform="translate(15953.8,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(16521,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(17521.2,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(18021.2,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g><g data-mml-node="mo" transform="translate(18299.2,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(18688.2,0)"><path data-c="3F" d="M226 668Q190 668 162 656T124 632L114 621Q116 621 119 620T130 616T145 607T157 591T162 567Q162 544 147 529T109 514T71 528T55 566Q55 625 100 661T199 704Q201 704 210 704T224 705H228Q281 705 320 692T378 656T407 612T416 567Q416 503 361 462Q267 395 247 303Q242 279 242 241V224Q242 205 239 202T222 198T205 201T202 218V249Q204 320 220 371T255 445T292 491T315 537Q317 546 317 574V587Q317 604 315 615T304 640T277 661T226 668ZM162 61Q162 89 180 105T224 121Q247 119 264 104T281 61Q281 31 264 16T222 1Q197 1 180 16T162 61Z"/></g><g data-mml-node="mn" transform="translate(19160.2,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(19938,0)"><path data-c="3A" d="M78 370Q78 394 95 412T138 430Q162 430 180 414T199 371Q199 346 182 328T139 310T96 327T78 370ZM78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"/></g><g data-mml-node="mn" transform="translate(20493.8,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g></g></svg></mjx-container><br>但是直接将<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="0.781ex" height="1.52ex" role="img" focusable="false" viewbox="0 -661 345 672"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>和<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.462ex;" xmlns="http://www.w3.org/2000/svg" width="0.932ex" height="1.957ex" role="img" focusable="false" viewbox="0 -661 412 865"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"/></g></g></g></svg></mjx-container>从小到大枚举（ <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.462ex;" xmlns="http://www.w3.org/2000/svg" width="19.325ex" height="1.968ex" role="img" focusable="false" viewbox="0 -666 8541.4 870"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(622.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(1678.6,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g><g data-mml-node="mo" transform="translate(2178.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(2623.2,0)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"/></g><g data-mml-node="mo" transform="translate(3313,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(4368.8,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(4868.8,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mn" transform="translate(5313.4,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mo" transform="translate(5813.4,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mn" transform="translate(6258.1,0)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/></g><g data-mml-node="mo" transform="translate(6924.8,0)"><path data-c="2026" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60ZM525 60Q525 84 542 102T585 120Q609 120 627 104T646 61Q646 36 629 18T586 0T543 17T525 60ZM972 60Q972 84 989 102T1032 120Q1056 120 1074 104T1093 61Q1093 36 1076 18T1033 0T990 17T972 60Z"/></g><g data-mml-node="mo" transform="translate(8263.4,0)"><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"/></g></g></g></svg></mjx-container>）会导致一些问题。因为动态规划是自底向上的，所以只有将子问题解出来，才能解决更大的子问题。但是在这个问题中，例如需要计算<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="7.093ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3135 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g><g data-mml-node="mi" transform="translate(520,0)"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/></g><g data-mml-node="mo" transform="translate(1023,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mn" transform="translate(1301,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g><g data-mml-node="mo" transform="translate(1801,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g><g data-mml-node="mo" transform="translate(2079,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mn" transform="translate(2357,0)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"/></g><g data-mml-node="mo" transform="translate(2857,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g></g></g></svg></mjx-container>的时候，会需要<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="7.093ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3135 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g><g data-mml-node="mi" transform="translate(520,0)"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/></g><g data-mml-node="mo" transform="translate(1023,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mn" transform="translate(1301,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(1801,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g><g data-mml-node="mo" transform="translate(2079,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mn" transform="translate(2357,0)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/></g><g data-mml-node="mo" transform="translate(2857,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g></g></g></svg></mjx-container>的结果，但是这个问题的结果并没有求解出来。所以需要转换枚举方式。<br>注意到每次进行状态转移的时候，都是将子串的长度减少了一，所以可以考虑先将所有长度小的子串全部计算出来，然后再求长度更长的子串。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Palindrome</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line">	<span class="type">char</span> S[maxn];</span><br><span class="line">	<span class="type">int</span> dp[maxn][maxn];</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Input datas</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxn; ++i) {</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;S[i]);</span><br><span class="line">	}</span><br><span class="line">	<span class="type">int</span> len = <span class="built_in">strlen</span>(S), ans = <span class="number">1</span>;<span class="comment">//'ans'stores the length of longest subarray</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//Initializing dp array</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxn; ++i) {</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; maxn; ++j) {</span><br><span class="line">			dp[i][j] = <span class="number">0</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Set up Boundaries</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) {</span><br><span class="line">		dp[i][i] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (i &lt; len - <span class="number">1</span>) {</span><br><span class="line">			<span class="keyword">if</span> (S[i] == S[i + <span class="number">1</span>]) {</span><br><span class="line">				dp[i][i + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">				ans = <span class="number">2</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//State Transition Equation</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> L = <span class="number">3</span>; L &lt;= len; L++) {</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i + L - <span class="number">1</span> &lt; len; ++i) {</span><br><span class="line">			<span class="type">int</span> j = i + L - <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (S[i] == S[j] &amp;&amp; dp[i + <span class="number">1</span>][j - <span class="number">1</span>] == <span class="number">1</span>) {</span><br><span class="line">				dp[i][j] = <span class="number">1</span>;</span><br><span class="line">				ans = L;<span class="comment">//Updating the length</span></span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><strong>To Be Continue…</strong></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-03-10T00:00:41.000Z" title="3/10/2021, 8:00:41 AM">2021-03-10</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-03-08T11:48:51.427Z" title="3/8/2023, 7:48:51 PM">2023-03-08</time></span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/03/10/%E7%AE%97%E6%B3%95%E2%9E%A1%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98/">算法➡数学问题</a></p><div class="content"><h1 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h1><p>8➡10:</p>
<script type="math/tex; mode=display">123_{oct} = 3 \times8^0+2\times8^1+1\times8^2 = 83_{dec}</script><p>10➡8:</p>
<script type="math/tex; mode=display">
\left.\ \begin{aligned}
83_{dec} \div 8 = 10 ······3\\
10_{dec}\div 8 = 1······2\\
1_{dec} \div8 = 0······1\\
\end{aligned}
\right\uparrow</script><p>其他的都是类似的。从低进制到高进制就按照第一种方式，否则按照第二种方式，二者实际上是一个逆过程。其他的可以先转换成十进制，然后再转换成目标进制。</p>
<h1 id="最大公约数与最小公倍数"><a href="#最大公约数与最小公倍数" class="headerlink" title="最大公约数与最小公倍数"></a>最大公约数与最小公倍数</h1><p>最大公约数可以用于分数运算的时候的化简。</p>
<h2 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h2><p>最大公约数可以利用欧几里得算法（辗转相除法）进行求解。</p>
<blockquote>
<p>设a、b均为正整数，则gcd(a,b) = gcd(b, a%b)</p>
</blockquote>
<p>有了递推式之后，还需要一个递归边界，因为0与任意数字a的最大公约数为a，所以可以利用这个作为递归的出口。<br>在这里需要a&gt;b所以应该在先判断a和b的大小。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd1</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(a &lt; b){</span><br><span class="line">		<span class="type">int</span> temp = a;</span><br><span class="line">		a = b;</span><br><span class="line">		b = temp;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(b == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//等价形式</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(a &lt; b){</span><br><span class="line">		<span class="type">int</span> temp = a;</span><br><span class="line">		a = b;</span><br><span class="line">		b = temp;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> !b ? a : <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//辗转相除法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd3</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(a &lt; b){</span><br><span class="line">		<span class="type">int</span> temp = a;</span><br><span class="line">		a = b;</span><br><span class="line">		b = temp;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">while</span>(b != <span class="number">0</span>){</span><br><span class="line">		<span class="type">int</span> temp = a % b;</span><br><span class="line">		a = b;</span><br><span class="line">		b = temp;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> a;	</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h1 id="素数"><a href="#素数" class="headerlink" title="素数"></a>素数</h1><h2 id="判断素数"><a href="#判断素数" class="headerlink" title="判断素数"></a>判断素数</h2><p>素数的定义是除了1和本身之外不能被其他整数整除的一类数。因为假设一个数字k可以整除数字n，那么有<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.798ex;" xmlns="http://www.w3.org/2000/svg" width="10.274ex" height="2.397ex" role="img" focusable="false" viewbox="0 -706.5 4541.3 1059.3"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mfrac"><g data-mml-node="mi" transform="translate(220,394) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(247.9,-345) scale(0.707)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g><rect width="624.3" height="60" x="120" y="220"/></g><g data-mml-node="mo" transform="translate(1086.5,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"/></g><g data-mml-node="mi" transform="translate(2086.7,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g><g data-mml-node="mo" transform="translate(2885.5,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mi" transform="translate(3941.3,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>所以这里可以得到，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.798ex;" xmlns="http://www.w3.org/2000/svg" width="1.955ex" height="2.397ex" role="img" focusable="false" viewbox="0 -706.5 864.3 1059.3"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mfrac"><g data-mml-node="mi" transform="translate(220,394) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(247.9,-345) scale(0.707)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g><rect width="624.3" height="60" x="120" y="220"/></g></g></g></svg></mjx-container>也是可以整除n的。这也就是说这两个数一定是一个大于等于sqrt(n)，一个小于sqrt(n)的，所以只需要遍历2~sqrt(n)(范围之内的所有整数，检查是否存在能够整除目标数字的数即可)（反证法，假设该数能够整除目标数字，而能够整除目标数字的数是成对出现的）<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(<span class="type">int</span> n)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(n &lt;= <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">else</span>{<span class="comment">//这个else语句是可以不要的</span></span><br><span class="line">		<span class="type">int</span> sqr = <span class="built_in">sqrt</span>(<span class="number">1.0</span> * n);<span class="comment">//由于sqrt函数需要浮点型，所以这里乘以1.0</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= sqr; ++i){</span><br><span class="line">			<span class="keyword">if</span>(n % i == <span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<h2 id="素数表的获取"><a href="#素数表的获取" class="headerlink" title="素数表的获取"></a>素数表的获取</h2><p>由于判断一个数字是否属于素数的时间复杂度为O(<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.491ex;" xmlns="http://www.w3.org/2000/svg" width="3.287ex" height="2.398ex" role="img" focusable="false" viewbox="0 -843 1453 1060"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msqrt"><g transform="translate(853,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g><g data-mml-node="mo" transform="translate(0,-17)"><path data-c="221A" d="M95 178Q89 178 81 186T72 200T103 230T169 280T207 309Q209 311 212 311H213Q219 311 227 294T281 177Q300 134 312 108L397 -77Q398 -77 501 136T707 565T814 786Q820 800 834 800Q841 800 846 794T853 782V776L620 293L385 -193Q381 -200 366 -200Q357 -200 354 -197Q352 -195 256 15L160 225L144 214Q129 202 113 190T95 178Z"/></g><rect width="600" height="60" x="853" y="723"/></g></g></g></svg></mjx-container>),所以想要获取n个素数的时间复杂度为O(n* <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.491ex;" xmlns="http://www.w3.org/2000/svg" width="3.287ex" height="2.398ex" role="img" focusable="false" viewbox="0 -843 1453 1060"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msqrt"><g transform="translate(853,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g><g data-mml-node="mo" transform="translate(0,-17)"><path data-c="221A" d="M95 178Q89 178 81 186T72 200T103 230T169 280T207 309Q209 311 212 311H213Q219 311 227 294T281 177Q300 134 312 108L397 -77Q398 -77 501 136T707 565T814 786Q820 800 834 800Q841 800 846 794T853 782V776L620 293L385 -193Q381 -200 366 -200Q357 -200 354 -197Q352 -195 256 15L160 225L144 214Q129 202 113 190T95 178Z"/></g><rect width="600" height="60" x="853" y="723"/></g></g></g></svg></mjx-container> )<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">101</span>;</span><br><span class="line"><span class="type">int</span> prime[maxn], pNum = <span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> p[maxn] = {<span class="number">0</span>};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Find_Prime</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; maxn; ++i){</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">isPrime</span>(i) == <span class="literal">true</span>){</span><br><span class="line">			prime[pNum++] = i;</span><br><span class="line">			p[i] = <span class="literal">true</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></table></figure><br>还有一种算法是欧拉筛选法，其时间复杂度为O(nlong long n)</p>
<h1 id="质因子分解"><a href="#质因子分解" class="headerlink" title="质因子分解"></a>质因子分解</h1><p> 质因子分解就是将一个非质数分解成素数的乘积，素数在乘积中可以重复出现。</p>
<blockquote>
<p>对一个正整数n 来说，如果它存在［2, n］范围内的质因子，要么这些质因子全部小于等于sqrt(n），要么只存在一个大于sqrt(n）的质因子，而其余质因子全部小于等于sqrt(n）</p>
</blockquote>
<p>算法思想：求出素数表，然后用输入的参数x与该素数取余数，直到无法被整除，换下一个素数，直到x变成0。之后按照格式进行输出。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自己写的，水平有限，后续会对此进行优化</span></span><br><span class="line"><span class="comment">//判断是否为质数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(<span class="type">int</span> x)</span> </span>{</span><br><span class="line">	<span class="keyword">if</span> (x &lt; <span class="number">2</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">double</span> sq = <span class="built_in">sqrt</span>(x * <span class="number">1.0</span>);</span><br><span class="line">	<span class="type">int</span> num = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">while</span> (num &lt;= sq) {</span><br><span class="line">		<span class="keyword">if</span> (x % num == <span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		num++;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//质数的结构体，包含质数数字本身，以及在分解式中出现的次数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">prime</span>{</span><br><span class="line">	<span class="type">int</span> data = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//质因子分解</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prime_factorization</span><span class="params">(<span class="type">int</span> x)</span> </span>{</span><br><span class="line">	prime prime_list[<span class="number">200</span>];</span><br><span class="line">	<span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> copy = x;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//考虑到输入参数本身就是质数的情况，边界设置为i&lt;=x</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x; ++i) {</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">isPrime</span>(i))prime_list[index++].data = i;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) {</span><br><span class="line">		<span class="type">int</span> temp = prime_list[i].data;</span><br><span class="line">		<span class="keyword">while</span> (x % temp == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span>) {</span><br><span class="line">			prime_list[i].num++;</span><br><span class="line">			x /= temp;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//输出</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d="</span>, copy);</span><br><span class="line">	<span class="type">bool</span> flag = <span class="literal">true</span>;<span class="comment">//标记是否为第一个数字</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= index; ++i) {</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; prime_list[i].num; ++j) {</span><br><span class="line">			<span class="keyword">if</span> (flag != <span class="literal">true</span>)<span class="built_in">printf</span>(<span class="string">"*"</span>);</span><br><span class="line">			<span class="comment">//printf("*");</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d"</span>, prime_list[i].data);</span><br><span class="line">			flag = <span class="literal">false</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//getchar();</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h1 id="大数运算"><a href="#大数运算" class="headerlink" title="大数运算"></a>大数运算</h1><h2 id="大数乘法"><a href="#大数乘法" class="headerlink" title="大数乘法"></a>大数乘法</h2><p>将两个数字按照位从小到大从低位到高位依次加入到数组中。将其中的一个乘数从按位从小到大乘以另外一个数，加到数组中。每一位只加上计算结果的个位数，进位加到下一位中。最后的结果数组中可能还会有某一位超过十的数字的位，这时候就取余，调整成各位就可以了。</p>
<p><img src="https://img-blog.csdnimg.cn/20210320111018908.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初级版本，还有在后序进行改进的</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">stimuMulti</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> an, <span class="type">int</span> b[],<span class="type">int</span> bn)</span> </span>{</span><br><span class="line">		<span class="comment">//初始化结果数组</span></span><br><span class="line">		<span class="type">int</span> result[<span class="number">100</span>];</span><br><span class="line">		<span class="built_in">fill</span>(result, result + <span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//计算各位的值</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= bn; ++i) {</span><br><span class="line">			<span class="type">int</span> carry = <span class="number">0</span>;<span class="comment">//进位</span></span><br><span class="line">			<span class="type">int</span> index_result = i;<span class="comment">//错位相加（开始的位置错一位）</span></span><br><span class="line">			<span class="comment">//关键部分</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= an; ++j) {</span><br><span class="line">				result[index_result++] += (b[i] * a[j]) % <span class="number">10</span>;</span><br><span class="line">				carry = (a[j] * b[i]) / <span class="number">10</span>;</span><br><span class="line">				result[index_result] += carry;</span><br><span class="line">			}</span><br><span class="line">			<span class="comment">//将最后一位的下一位作为结束标志</span></span><br><span class="line">			<span class="keyword">if</span> (i == bn)result[++index_result] = <span class="number">-1</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="comment">//调整，将大于十的位调整为小于十</span></span><br><span class="line">		<span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (result[i++] != <span class="number">-1</span>) {</span><br><span class="line">			<span class="keyword">if</span> (result[i] &gt;= <span class="number">10</span>) {</span><br><span class="line">				<span class="type">int</span> carry = result[i] / <span class="number">10</span>;</span><br><span class="line">				result[i] %= <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">				<span class="comment">//当最后一位需要进位的时候</span></span><br><span class="line">				<span class="keyword">if</span> (result[i + <span class="number">1</span>] == <span class="number">-1</span>) {</span><br><span class="line">					result[i + <span class="number">2</span>] = <span class="number">-1</span>;</span><br><span class="line">					result[i + <span class="number">1</span>]++;</span><br><span class="line">				}</span><br><span class="line">				result[i + <span class="number">1</span>] += carry;</span><br><span class="line"></span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="comment">//输出</span></span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">		<span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i - <span class="number">2</span>; j &gt;= <span class="number">1</span>; --j) {</span><br><span class="line">			<span class="comment">//将最高位前面的0全部忽略掉</span></span><br><span class="line">			<span class="keyword">if</span> (result[j] == <span class="number">0</span> &amp;&amp; flag == <span class="literal">false</span>) {</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			}</span><br><span class="line">			flag = <span class="literal">true</span>;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d"</span>, result[j]);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="literal">false</span>)<span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h1 id="几何问题"><a href="#几何问题" class="headerlink" title="几何问题"></a>几何问题</h1><h2 id="由三点的坐标求所构成的三角形的面积"><a href="#由三点的坐标求所构成的三角形的面积" class="headerlink" title="由三点的坐标求所构成的三角形的面积"></a>由三点的坐标求所构成的三角形的面积</h2><p>有几个比较常用的计算面积公式：</p>
<script type="math/tex; mode=display">S_{\Delta ABC} =  \frac 12 \vert \vec a\vert \vert \vec b\vert sin<\vec a,\vec b ></script><p>海伦公式：</p>
<script type="math/tex; mode=display">S_{\Delta ABC} = \sqrt {p(p-a)(p-b)(p-c)},其中p = \frac {a+b+c}{2}</script><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用了第一个求面积的公式</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">point</span>{</span><br><span class="line">	<span class="type">double</span> x,y;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//求两点形成的向量</span></span><br><span class="line"><span class="function">point <span class="title">decPoint</span><span class="params">(point p1, point p2)</span></span>{</span><br><span class="line">	point res;</span><br><span class="line">	res.x = p1.x - p2.x;</span><br><span class="line">	res.y = p1.y - p2.y;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//求两向量的叉乘</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">mutiPoint</span><span class="params">(point p1, point p2)</span></span>{</span><br><span class="line">	<span class="keyword">return</span> (p1.x*p2.y - p2.x*p1.y);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//求面积</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">areaOfThreePoint</span><span class="params">(point a, point b, point c)</span></span>{</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">fabs</span>(<span class="built_in">multipoint</span>(<span class="built_in">decPoint</span>(B, A), <span class="built_in">decPonint</span>(C, A))/<span class="number">2.0</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="判断点是否在三角形内"><a href="#判断点是否在三角形内" class="headerlink" title="判断点是否在三角形内"></a>判断点是否在三角形内</h2><p>针对这个问题有几个虽然麻烦但是十分直观的做法。1.计算该点和三角形三点组成的面积之和，若于三角形面积相等，则该点在三角形内。2.计算该点与三角形所有任意两点组成的夹角之和，判断是否等于360°。<br><img src="https://img-blog.csdnimg.cn/20210320135214157.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>还有一种是利用叉乘。想要该点在三角形内，只需要该点在三条边的下面/上面。如果该点在三角形内部，那么该点与三角形三点形成的向量和三角形三条边形成的向量的叉乘的方向是一致的。叉乘的计算方式如下：</p>
<script type="math/tex; mode=display">设a(x_1,y_1),b(x_2,y_2),则\vec a×\vec b = (x_1*y_2-x_1*y_1)\vec j, \vec a×\vec b = \vert a\vert \vert b\vert*sin(\theta)</script><p>
</p><p>所以可以借用两个向量的叉乘的正负情况，判断二者是否在同一方向上。<br><img src="https://img-blog.csdnimg.cn/20210320194633693.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>算法思想：创建一个方向函数，将三点的坐标作为参数，计算出各边的向量，然后计算出叉乘，将叉乘的结果的正负作为返回值。判断所有的叉乘结果的符号是否都相等。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//转载自牛客网https://www.nowcoder.com/questionTerminal/f9c4290baed0406cbbe2c23dd687732c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">direction</span><span class="params">(<span class="type">double</span> x1, <span class="type">double</span> y1, <span class="type">double</span> x2, <span class="type">double</span> y2, <span class="type">double</span> x3, <span class="type">double</span> y3)</span></span>{</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    求向量V和点(x3, y3)之间的位置关系，(x1, y1)是V的起点，(x2, y2)是V的终点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//得到向量V</span></span><br><span class="line">    x2 -= x1;</span><br><span class="line">    y2 -= y1;</span><br><span class="line">    <span class="comment">//V的起点(x1, y1)与目标点(x3, y3)构成新的向量U</span></span><br><span class="line">    x3 -= x1;</span><br><span class="line">    y3 -= y1;</span><br><span class="line">    <span class="type">double</span> res = x3 * y2 - x2 * y3;<span class="comment">//求两向量U和V的外积（叉积）</span></span><br><span class="line">    <span class="keyword">if</span>(res &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//&lt;0在逆时针方向</span></span><br><span class="line">    <span class="keyword">if</span>(res == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//=0共线</span></span><br><span class="line">    <span class="keyword">if</span>(res &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//&gt;0说明点在向量顺时针方向</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="type">double</span> x1, y1;</span><br><span class="line">    <span class="type">double</span> x2, y2;</span><br><span class="line">    <span class="type">double</span> x3, y3;</span><br><span class="line">    cin &gt;&gt; x1 &gt;&gt; y1;</span><br><span class="line">    cin &gt;&gt; x2 &gt;&gt; y2;</span><br><span class="line">    cin &gt;&gt; x3 &gt;&gt; y3;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> x4, y4;</span><br><span class="line">    cin &gt;&gt; x4 &gt;&gt; y4;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(x1, y1)与(x2, y2)构成向量V1</span></span><br><span class="line">    <span class="comment">//(x2, y2)与(x3, y3)构成向量V2</span></span><br><span class="line">    <span class="comment">//(x3, y3)与(x1, y1)构成向量V3</span></span><br><span class="line">    <span class="type">int</span> res1 = <span class="built_in">direction</span>(x1, y1, x2, y2, x4, y4);</span><br><span class="line">    <span class="type">int</span> res2 = <span class="built_in">direction</span>(x2, y2, x3, y4, x4, y4);</span><br><span class="line">    <span class="type">int</span> res3 = <span class="built_in">direction</span>(x3, y3, x1, y1, x4, y4);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">abs</span>(res1 + res2 + res3) == <span class="number">3</span>){<span class="comment">//全-1或全1，表示点(x4, y4)同时在三个向量的同一侧</span></span><br><span class="line">        cout &lt;&lt; <span class="string">"Yes"</span>;</span><br><span class="line">    }<span class="keyword">else</span> {</span><br><span class="line">        cout &lt;&lt; <span class="string">"No"</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<h1 id="集合问题"><a href="#集合问题" class="headerlink" title="集合问题"></a>集合问题</h1><h2 id="子集问题"><a href="#子集问题" class="headerlink" title="子集问题"></a>子集问题</h2><p>原文：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/qT6WgR6Qwn7ayZkI3AineA">https://mp.weixin.qq.com/s/qT6WgR6Qwn7ayZkI3AineA</a></p>
<h3 id="数学归纳法"><a href="#数学归纳法" class="headerlink" title="数学归纳法"></a>数学归纳法</h3><p>对于<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="7.668ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3389.3 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="7B" d="M434 -231Q434 -244 428 -250H410Q281 -250 230 -184Q225 -177 222 -172T217 -161T213 -148T211 -133T210 -111T209 -84T209 -47T209 0Q209 21 209 53Q208 142 204 153Q203 154 203 155Q189 191 153 211T82 231Q71 231 68 234T65 250T68 266T82 269Q116 269 152 289T203 345Q208 356 208 377T209 529V579Q209 634 215 656T244 698Q270 724 324 740Q361 748 377 749Q379 749 390 749T408 750H428Q434 744 434 732Q434 719 431 716Q429 713 415 713Q362 710 332 689T296 647Q291 634 291 499V417Q291 370 288 353T271 314Q240 271 184 255L170 250L184 245Q202 239 220 230T262 196T290 137Q291 131 291 1Q291 -134 296 -147Q306 -174 339 -192T415 -213Q429 -213 431 -216Q434 -219 434 -231Z"/></g><g data-mml-node="mn" transform="translate(500,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(1000,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mn" transform="translate(1444.7,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mo" transform="translate(1944.7,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mn" transform="translate(2389.3,0)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/></g><g data-mml-node="mo" transform="translate(2889.3,0)"><path data-c="7D" d="M65 731Q65 745 68 747T88 750Q171 750 216 725T279 670Q288 649 289 635T291 501Q292 362 293 357Q306 312 345 291T417 269Q428 269 431 266T434 250T431 234T417 231Q380 231 345 210T298 157Q293 143 292 121T291 -28V-79Q291 -134 285 -156T256 -198Q202 -250 89 -250Q71 -250 68 -247T65 -230Q65 -224 65 -223T66 -218T69 -214T77 -213Q91 -213 108 -210T146 -200T183 -177T207 -139Q208 -134 209 3L210 139Q223 196 280 230Q315 247 330 250Q305 257 280 270Q225 304 212 352L210 362L209 498Q208 635 207 640Q195 680 154 696T77 713Q68 713 67 716T65 731Z"/></g></g></g></svg></mjx-container>的子集，通过观察发现，原数组的子集跟它子集的子集是有关联的。注意到：<script type="math/tex">Subset_{\{1,2,3\}} -Subset_{\{1,2\}} = \{3\},\{1,3\},\{2,3\},\{1,2,3\}</script><br>而这个子集又是可以从<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.531ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2444.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="7B" d="M434 -231Q434 -244 428 -250H410Q281 -250 230 -184Q225 -177 222 -172T217 -161T213 -148T211 -133T210 -111T209 -84T209 -47T209 0Q209 21 209 53Q208 142 204 153Q203 154 203 155Q189 191 153 211T82 231Q71 231 68 234T65 250T68 266T82 269Q116 269 152 289T203 345Q208 356 208 377T209 529V579Q209 634 215 656T244 698Q270 724 324 740Q361 748 377 749Q379 749 390 749T408 750H428Q434 744 434 732Q434 719 431 716Q429 713 415 713Q362 710 332 689T296 647Q291 634 291 499V417Q291 370 288 353T271 314Q240 271 184 255L170 250L184 245Q202 239 220 230T262 196T290 137Q291 131 291 1Q291 -134 296 -147Q306 -174 339 -192T415 -213Q429 -213 431 -216Q434 -219 434 -231Z"/></g><g data-mml-node="mn" transform="translate(500,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(1000,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mn" transform="translate(1444.7,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mo" transform="translate(1944.7,0)"><path data-c="7D" d="M65 731Q65 745 68 747T88 750Q171 750 216 725T279 670Q288 649 289 635T291 501Q292 362 293 357Q306 312 345 291T417 269Q428 269 431 266T434 250T431 234T417 231Q380 231 345 210T298 157Q293 143 292 121T291 -28V-79Q291 -134 285 -156T256 -198Q202 -250 89 -250Q71 -250 68 -247T65 -230Q65 -224 65 -223T66 -218T69 -214T77 -213Q91 -213 108 -210T146 -200T183 -177T207 -139Q208 -134 209 3L210 139Q223 196 280 230Q315 247 330 250Q305 257 280 270Q225 304 212 352L210 362L209 498Q208 635 207 640Q195 680 154 696T77 713Q68 713 67 716T65 731Z"/></g></g></g></svg></mjx-container>的子集中，每一个子集加上一个元素3之后的结果。同样，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.531ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2444.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="7B" d="M434 -231Q434 -244 428 -250H410Q281 -250 230 -184Q225 -177 222 -172T217 -161T213 -148T211 -133T210 -111T209 -84T209 -47T209 0Q209 21 209 53Q208 142 204 153Q203 154 203 155Q189 191 153 211T82 231Q71 231 68 234T65 250T68 266T82 269Q116 269 152 289T203 345Q208 356 208 377T209 529V579Q209 634 215 656T244 698Q270 724 324 740Q361 748 377 749Q379 749 390 749T408 750H428Q434 744 434 732Q434 719 431 716Q429 713 415 713Q362 710 332 689T296 647Q291 634 291 499V417Q291 370 288 353T271 314Q240 271 184 255L170 250L184 245Q202 239 220 230T262 196T290 137Q291 131 291 1Q291 -134 296 -147Q306 -174 339 -192T415 -213Q429 -213 431 -216Q434 -219 434 -231Z"/></g><g data-mml-node="mn" transform="translate(500,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(1000,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mn" transform="translate(1444.7,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mo" transform="translate(1944.7,0)"><path data-c="7D" d="M65 731Q65 745 68 747T88 750Q171 750 216 725T279 670Q288 649 289 635T291 501Q292 362 293 357Q306 312 345 291T417 269Q428 269 431 266T434 250T431 234T417 231Q380 231 345 210T298 157Q293 143 292 121T291 -28V-79Q291 -134 285 -156T256 -198Q202 -250 89 -250Q71 -250 68 -247T65 -230Q65 -224 65 -223T66 -218T69 -214T77 -213Q91 -213 108 -210T146 -200T183 -177T207 -139Q208 -134 209 3L210 139Q223 196 280 230Q315 247 330 250Q305 257 280 270Q225 304 212 352L210 362L209 498Q208 635 207 640Q195 680 154 696T77 713Q68 713 67 716T65 731Z"/></g></g></g></svg></mjx-container>的子集又可以通过<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="3.394ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 1500 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="7B" d="M434 -231Q434 -244 428 -250H410Q281 -250 230 -184Q225 -177 222 -172T217 -161T213 -148T211 -133T210 -111T209 -84T209 -47T209 0Q209 21 209 53Q208 142 204 153Q203 154 203 155Q189 191 153 211T82 231Q71 231 68 234T65 250T68 266T82 269Q116 269 152 289T203 345Q208 356 208 377T209 529V579Q209 634 215 656T244 698Q270 724 324 740Q361 748 377 749Q379 749 390 749T408 750H428Q434 744 434 732Q434 719 431 716Q429 713 415 713Q362 710 332 689T296 647Q291 634 291 499V417Q291 370 288 353T271 314Q240 271 184 255L170 250L184 245Q202 239 220 230T262 196T290 137Q291 131 291 1Q291 -134 296 -147Q306 -174 339 -192T415 -213Q429 -213 431 -216Q434 -219 434 -231Z"/></g><g data-mml-node="mn" transform="translate(500,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(1000,0)"><path data-c="7D" d="M65 731Q65 745 68 747T88 750Q171 750 216 725T279 670Q288 649 289 635T291 501Q292 362 293 357Q306 312 345 291T417 269Q428 269 431 266T434 250T431 234T417 231Q380 231 345 210T298 157Q293 143 292 121T291 -28V-79Q291 -134 285 -156T256 -198Q202 -250 89 -250Q71 -250 68 -247T65 -230Q65 -224 65 -223T66 -218T69 -214T77 -213Q91 -213 108 -210T146 -200T183 -177T207 -139Q208 -134 209 3L210 139Q223 196 280 230Q315 247 330 250Q305 257 280 270Q225 304 212 352L210 362L209 498Q208 635 207 640Q195 680 154 696T77 713Q68 713 67 716T65 731Z"/></g></g></g></svg></mjx-container>的子集加上元素2之后得来。<br>所以，</p>
<script type="math/tex; mode=display">Subset_{\{1,2,3\}} = Subset_{\{1,2\}} + \{Subset_{\{1,2\}} append \{3\}\}\\
Subset_{\{1,2\}} = Subset_{\{1\}} + \{Subset_{\{1\}} append \{2\}\}\\
Subset_{\{1\}} = Subset_{\{\}} + \{Subset_{\{\}} append \{1\}\}</script><p>所以可以将空数组作为基元素。<br><img src="https://img-blog.csdnimg.cn/20210322082910901.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) {</span><br><span class="line">    <span class="comment">// base case，返回一个空集</span></span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> {{}};</span><br><span class="line">    <span class="comment">// 把最后一个元素拿出来</span></span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">back</span>();</span><br><span class="line">    nums.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="comment">// 先递归算出前面元素的所有子集</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res = <span class="built_in">subsets</span>(nums);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> size = res.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">        <span class="comment">// 然后在之前的结果之上追加</span></span><br><span class="line">        res.<span class="built_in">push_back</span>(res[i]);<span class="comment">//这里是将原先的数组赋值了一份过来然后再往结尾的地方加上最后一个元素</span></span><br><span class="line">        res.<span class="built_in">back</span>().<span class="built_in">push_back</span>(n);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>但是这种写法的时间复杂度和空间复杂度很大[O(<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="6.402ex" height="1.553ex" role="img" focusable="false" viewbox="0 -675.5 2829.7 686.5"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(822.2,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"/></g><g data-mml-node="msup" transform="translate(1822.4,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mi" transform="translate(533,363) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g></g></g></svg></mjx-container>)]，下面用的是回溯法去求解。</p>
<h3 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h3><p>下面是<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&amp;mid=2247485007&amp;idx=1&amp;sn=ceb42ba2f341af34953d158358c61f7c&amp;chksm=9bd7f847aca071517fe0889d2679ead78b40caf6978ebc1d3d8355d6693acc7ec3aca60823f0&amp;scene=178&amp;cur_album_id=1318883740306948097#rd">东哥</a>总结的回溯法模板：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line">def backtrack(路径, 选择列表):</span><br><span class="line">    if 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        return</span><br><span class="line">    for 选择 in 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure><br>可以发现，前半部分因为是递归的因素，所以会不断在选择列表中加入元素，当递归全部结束的时候，会不断将原先加入的元素剔除，再进行递归，这个就类似于树的深度优先遍历。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) {</span><br><span class="line">    <span class="comment">// 记录走过的路径</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; track;</span><br><span class="line">    <span class="built_in">backtrack</span>(nums, <span class="number">0</span>, track);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start, vector&lt;<span class="type">int</span>&gt;&amp; track)</span> </span>{</span><br><span class="line">    res.<span class="built_in">push_back</span>(track);</span><br><span class="line">    <span class="comment">// 注意 i 从 start 开始递增</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; nums.<span class="built_in">size</span>(); i++) {</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        track.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        <span class="comment">// 回溯</span></span><br><span class="line">        <span class="built_in">backtrack</span>(nums, i + <span class="number">1</span>, track);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        track.<span class="built_in">pop_back</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><br>将这个过程可视化：<br><img src="https://img-blog.csdnimg.cn/20210324082353329.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>由上图可以发现，每个节点都是子集，所以在继续访问节点之前，先将节点信息保存。进行回溯的条件为，判断可供选择元素的数量，体现在循环数组中，当没有元素可供选择的时候，for语句就会退出。这时候就会退出全部算法，或者是退出当前递归层。返回递归的时候，将向量中的元素弹出，并且更新选择列表（体现在递归函数的输入的参数）。注意这里的选择列表的选取方式，这里更新之后的选择列表就是当前标志指针所指的之后的所有元素。</p>
<h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><p>每次都选取一个元素，并做好标记（防止元素被重复选取），然后重新遍历一遍所有元素，与之匹配，直到数组中的数量满足要求，将结果输出。</p>
<p><img src="https://img-blog.csdnimg.cn/20210324091018987.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//处理排列的idex号位</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">generateP</span><span class="params">(<span class="type">int</span> index)</span></span>{</span><br><span class="line"></span><br><span class="line">	<span class="comment">//这是递归边界，前面的元素全部排列完毕，现在是要将数组输出</span></span><br><span class="line">	<span class="keyword">if</span> (index == n + <span class="number">1</span>) {</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) {</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d"</span>, p[i]);</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历检查所有的元素，这里引用了外部的变量n，由主函数定义</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">1</span>; x &lt;= n; ++x) {</span><br><span class="line">		<span class="comment">//哈希表是来表示索引元素是否已经加入数组了</span></span><br><span class="line">		<span class="keyword">if</span> (hashTable[x] == <span class="literal">false</span>) {</span><br><span class="line">			p[index] = x;<span class="comment">//以x作为头部的时候</span></span><br><span class="line">			hashTable[x] = <span class="literal">true</span>;<span class="comment">//更新状态</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//这里是继续下一位，注意这里还没有将哈希表重置，所以原先作为首部的元素是不会再被赋值了</span></span><br><span class="line">			<span class="built_in">generateP</span>(index + <span class="number">1</span>);</span><br><span class="line">			hashTable[x] = <span class="literal">false</span>;<span class="comment">//完成递归项中的一个，重置状态</span></span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	count++;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p></p></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-03-07T08:48:19.000Z" title="3/7/2021, 4:48:19 PM">2021-03-07</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-03-08T11:48:52.198Z" title="3/8/2023, 7:48:52 PM">2023-03-08</time></span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/03/07/%E3%80%8A%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%9B%BE%EF%BC%89/">《算法笔记》数据结构（图）</a></p><div class="content"><h1 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h1><p>图有两种存储方式：邻接表和邻接矩阵。邻接矩阵需要的空间较大，一般适用于顶点数目不超过1000的情况</p>
<h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><p>相当于一个离散的平面直角坐标系，每一个坐标代表一对节点的相互之间的关系，当两节点不直接相连的时候，这个坐标上的值可以设为0、-1或者是无穷大。否则可以在该点上赋值为这两点之间的权值。<img src="https://img-blog.csdnimg.cn/20210227084657192.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><p>将这些节点之间的关系保存在几个链表中，每一个链表都是在描述一个节点的连接情况。可以将这些数据保存在向量中。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>;<span class="comment">//顶点个数</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;Adj[N];</span><br><span class="line"><span class="comment">//之后直接将节点的信息连接到相应的向量之后</span></span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Create</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; ++i) {</span><br><span class="line">		Adj[i].<span class="built_in">push_back</span>(x);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//当需要存放更多节点信息的时候，可以用结构体+构造函数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> v, w;</span><br><span class="line">	<span class="built_in">Node</span>(<span class="type">int</span> _v, <span class="type">int</span> _w) :<span class="built_in">v</span>(_v), <span class="built_in">w</span>(_w) {};</span><br><span class="line">};</span><br><span class="line"><span class="comment">//赋值：Adj[1].push_back(Node(3,4));</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><p>遍历就是将图中所有的节点都访问一遍，要做到不重复访问，不遗漏。主要的方法有深度优先和广度优先。</p>
<h2 id="深度优先"><a href="#深度优先" class="headerlink" title="深度优先"></a>深度优先</h2><p>访问的时候优先访问下一层的节点，运用递归的话，在递归返回的时候就相当于一次回溯，然后继续递归，即向下访问。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAXV = <span class="number">1000</span>;<span class="comment">//最大顶点数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">100000000000</span>;<span class="comment">//一个很大的数字</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//邻接矩阵:检查其邻接节点是否存在然后逐一访问。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adjacency_matrix</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> n, G[MAXV][MAXV];<span class="comment">//n为顶点数</span></span><br><span class="line">	<span class="type">bool</span> vis[MAXV] = { <span class="literal">false</span> };<span class="comment">//访问数组，没访问的数组赋值为false</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> depth)</span> </span>{</span><br><span class="line">		vis[u] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//将该节点的所有相邻的节点全部访问一遍</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; n; ++n) {</span><br><span class="line">			<span class="comment">//该节点未被访问且与访问节点相联</span></span><br><span class="line">			<span class="keyword">if</span> (vis[v] == <span class="literal">false</span> &amp;&amp; G[u][v] != INF)<span class="built_in">DFS</span>(v, depth + <span class="number">1</span>);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//确保所有连通子图都被访问到</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">DFSTrave</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">0</span>; u &lt; n; ++u) {</span><br><span class="line">			<span class="keyword">if</span> (vis[u] == <span class="literal">false</span>)<span class="built_in">DFS</span>(u, <span class="number">1</span>);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"><span class="comment">//邻接表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adjancency_list</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;Adh[MAXV];</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="type">bool</span> vis[MAXV] = { <span class="literal">false</span> };</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> depth)</span> </span>{</span><br><span class="line">		vis[u] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//Traveling node u's all neighbours</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Adj[u].<span class="built_in">size</span>(); ++i) {</span><br><span class="line">			<span class="type">int</span> v = Adj[u][i];<span class="comment">//u节点的第i+1的邻接节点</span></span><br><span class="line">			<span class="keyword">if</span> (vis[v] == <span class="literal">false</span>)<span class="built_in">DFS</span>(v, depth + <span class="number">1</span>);<span class="comment">//没有访问则向下访问</span></span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">DFSTrave</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="comment">//保证所有连通子图的节点都被访问到</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> u = <span class="number">0</span>; u &lt; n; ++u) {</span><br><span class="line">			<span class="keyword">if</span> (vis[u] == <span class="literal">false</span>)<span class="built_in">DFS</span>(u, <span class="number">1</span>);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">};</span><br></pre></td></tr></table></figure></p>
<h2 id="广度优先"><a href="#广度优先" class="headerlink" title="广度优先"></a>广度优先</h2><p>  在遍历过程中优先访问一个节点的所有的相邻的节点。这个时候需要借助队列，将该节点的所有相连节点加入到队列中，在队列中的节点顺序就是最终的广度优先遍历的顺序。同时，为了防止重复访问，需要建立一个数组，将节点的序号作为数组的下标，作为该节点是否被访问的标识。<br><br>   <strong>算法思想</strong>：先将起始节点加入到队列中，然后不断取出队列中的元素，访问并加入到队列中，并将该点相连的节点加入到队列中，直到队列中的元素为空。<br><br> 判断一个节点v1是否与另一个节点v2是否相连：<br> 邻接矩阵中，只需要确定[v1,v2]所对应的值是否为1，是则为相连，反之不相连。<br><br> 在邻接表中，只需要遍历这个节点所连接的那一条邻接表即可。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, G[MAXV][MAXV];</span><br><span class="line"><span class="type">bool</span> inq[MAXV] = { <span class="literal">false</span> };</span><br><span class="line"></span><br><span class="line"><span class="comment">//广度优先邻接矩阵版：先将首个节点入队，</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BFS_AdjMatrix</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(<span class="type">int</span> u)</span> </span>{</span><br><span class="line">		queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//将首节点放到队列中</span></span><br><span class="line">		q.<span class="built_in">push</span>(u);</span><br><span class="line">		inq[u] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//将相邻的节点加入到队列中</span></span><br><span class="line">		<span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) {</span><br><span class="line">			<span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">			q.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; n; ++v) {</span><br><span class="line">				<span class="keyword">if</span> (inq[v] == <span class="literal">false</span> &amp;&amp; G[u][v] != INF) {</span><br><span class="line">					q.<span class="built_in">push</span>(v);</span><br><span class="line">					inq[v] = <span class="literal">true</span>;<span class="comment">//访问之后加入队列，改变标识</span></span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">BFSTrave</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="comment">//将未被访问过的节点全部访问一遍</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">0</span>; u &lt; n; ++u) {</span><br><span class="line">			<span class="keyword">if</span> (inq[u] == <span class="literal">false</span>)<span class="built_in">BFS</span>(u);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//邻接表：访问节点的方式为遍历该向量的所有节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BFS_AdjList</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;Adj[MAXV];<span class="comment">//这其实相当于一个二维向量</span></span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="type">bool</span> inq[MAXV] = { <span class="literal">false</span> };<span class="comment">//判断节点是否在队列中</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(<span class="type">int</span> u)</span> </span>{</span><br><span class="line">		queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">		q.<span class="built_in">push</span>(u);</span><br><span class="line">		inq[u] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">		{</span><br><span class="line">			<span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">			q.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Adj[u].<span class="built_in">size</span>(); ++i) {</span><br><span class="line">				<span class="type">int</span> v = Adj[u][i];</span><br><span class="line">				<span class="keyword">if</span> (inq[v] == <span class="literal">false</span>) {</span><br><span class="line">					q.<span class="built_in">push</span>(v);</span><br><span class="line">					inq[v] = <span class="literal">true</span>;</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">BFSTravel</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">0</span>; u &lt; n; ++u) {</span><br><span class="line">			<span class="keyword">if</span> (inq[u] == <span class="literal">false</span>)<span class="built_in">BFS</span>(u);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//当想要得出所有节点的所在层的信息的时候：利用结构体，在其中加上层次这一变量</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">	{</span><br><span class="line">		<span class="type">int</span> v;<span class="comment">//节点编号</span></span><br><span class="line">		<span class="type">int</span> layer;<span class="comment">//所在层次，头节点为第0层</span></span><br><span class="line">	};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(<span class="type">int</span> s)</span> </span>{</span><br><span class="line">		vector&lt;Node&gt;Adj[MAXV];</span><br><span class="line">		<span class="type">int</span> n;</span><br><span class="line">		<span class="type">bool</span> inq[MAXV] = { <span class="literal">false</span> };</span><br><span class="line">		queue&lt;Node&gt;q;</span><br><span class="line">		Node start;<span class="comment">//第一个访问的节点</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//初始化首个节点</span></span><br><span class="line">		start.v = s;</span><br><span class="line">		start.layer = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		q.<span class="built_in">push</span>(start);</span><br><span class="line">		inq[start.v] = <span class="literal">true</span>;<span class="comment">//做好相应的标识</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">		{</span><br><span class="line">			Node topNode = q.<span class="built_in">front</span>();</span><br><span class="line">			q.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="type">int</span> u = topNode.v;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Adj[u].<span class="built_in">size</span>(); ++i) {</span><br><span class="line">				<span class="comment">//将next赋值为该节点连接的节点</span></span><br><span class="line">				Node next = Adj[u][i];</span><br><span class="line">				next.layer = topNode.layer + <span class="number">1</span>;<span class="comment">//赋值为上一层的层数+1</span></span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (inq[next.v] == <span class="literal">false</span>) {</span><br><span class="line">					q.<span class="built_in">push</span>(next);</span><br><span class="line">					inq[next.v] = <span class="literal">true</span>;</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">};</span><br></pre></td></tr></table></figure></p>
<h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><p>这类问题是求解图中从源点到图中任一节点的最短的距离（路径）。主要的算法有Dijkstra算法、Bellman-Ford算法、SPFA算法、Floyd算法。</p>
<h3 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h3><p>算法图示（取自<a target="_blank" rel="noopener" href="https://en.wikipedia.iwiki.eu.org/wiki/Dijkstra%27s_algorithm">Wikipedia</a>）<br><img src="https://img-blog.csdnimg.cn/20210302185505437.gif" alt="在这里插入图片描述"><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Dijkstra算法</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXV = <span class="number">1000</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e9</span>;<span class="comment">//无穷大</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//寻找最短距离</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//邻接矩阵:先找到与源点最近的相邻节点，然后从该节点出发，遍历该节点的所有的未被访问的相邻的节点，并更新最小权值</span></span><br><span class="line"><span class="comment">//O(V*(V+V)) = O(V^2)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SPD_AdjMatrix</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> n, G[MAXV][MAXV];<span class="comment">//分别为顶点数和以邻接矩阵形式存储的图</span></span><br><span class="line">	<span class="type">int</span> d[MAXV];<span class="comment">//该节点到源点的最短距离</span></span><br><span class="line">	<span class="type">bool</span> vis[MAXV] = { <span class="literal">false</span> };<span class="comment">//访问数组，以图节点的编号作为索引</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="type">int</span> s)</span></span>{</span><br><span class="line">		<span class="built_in">fill</span>(d, d + MAXV, INF);<span class="comment">//将所有的节点初始化为极大值</span></span><br><span class="line">		d[s] = <span class="number">0</span>;<span class="comment">//源点到源点的距离为0</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//找到与起点相邻的路径最短的节点</span></span><br><span class="line">		<span class="type">int</span> u = <span class="number">-1</span>, MIN = INF;<span class="comment">//最短距离的节点编号和距离</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) {</span><br><span class="line">			<span class="comment">//遍历所有相邻节点</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) {</span><br><span class="line">				<span class="comment">//未被访问，并且距离权值小于之前记录的最小值</span></span><br><span class="line">				<span class="keyword">if</span> (vis[j] == <span class="literal">false</span> &amp;&amp; d[j] &lt; MIN) {</span><br><span class="line">					u = j;</span><br><span class="line">					MIN = d[j];</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="comment">//说明剩下的顶点与起点s不相连通</span></span><br><span class="line">		<span class="keyword">if</span> (u == <span class="number">-1</span>)<span class="keyword">return</span>;</span><br><span class="line">		vis[u] = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; n; ++v) {</span><br><span class="line">			<span class="comment">//与该节点相连且未被访问且以该节点为中介的权值比原先的权值更小</span></span><br><span class="line">			<span class="keyword">if</span> (vis[v] == <span class="literal">false</span> &amp;&amp; G[u][v] != INF &amp;&amp; d[u] + G[u][v] &lt; d[v]) {</span><br><span class="line">				d[v] = d[u] + G[u][v];</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//要记录最短路径的具体情况，可以记录每个节点最短路径的前驱，将该节点作为数组下标，数组中的值作为前驱节点的编号</span></span><br><span class="line">	<span class="type">int</span> pre[MAXV];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">DijkstraPath</span><span class="params">(<span class="type">int</span> s)</span> </span>{</span><br><span class="line">		<span class="built_in">fill</span>(d, d + MAXV, INF);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)pre[i] = i;<span class="comment">//(添加)初始化，将每个节点的前驱初试化为其本身</span></span><br><span class="line">		d[s] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//找到与起点相邻的路径最短的节点</span></span><br><span class="line">		<span class="type">int</span> u = <span class="number">-1</span>, MIN = INF;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) {</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) {</span><br><span class="line">				<span class="keyword">if</span> (vis[j] == <span class="literal">false</span> &amp;&amp; d[j] &lt; MIN) {</span><br><span class="line">					u = j;</span><br><span class="line">					MIN = d[j];</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span> (u == <span class="number">-1</span>)<span class="keyword">return</span>;</span><br><span class="line">		vis[u] = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; n; ++v) {</span><br><span class="line">			<span class="keyword">if</span> (vis[v] == <span class="literal">false</span> &amp;&amp; G[u][v] != INF &amp;&amp; d[u] + G[u][v] &lt; d[v]) {</span><br><span class="line">				d[v] = d[u] + G[u][v];</span><br><span class="line">				pre[v] = u;<span class="comment">//(添加)将节点前驱初始化</span></span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//输出路径</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> v)</span> </span>{</span><br><span class="line">		<span class="keyword">if</span> (v == s) {</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, s);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">DFS</span>(s, pre[v]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, v);</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//邻接表：O(V^2 + E)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SPD_AdjList</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Node</span>{</span><br><span class="line">		<span class="type">int</span> v, dis;</span><br><span class="line">	};</span><br><span class="line">	vector&lt;Node&gt;Adj[MAXV];</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="type">int</span> d[MAXV];</span><br><span class="line">	<span class="type">bool</span> vis[MAXV] = { <span class="literal">false</span> };</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="type">int</span> s)</span> </span>{</span><br><span class="line">		<span class="built_in">fill</span>(d, d + MAXV, INF);</span><br><span class="line">		d[s] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) {</span><br><span class="line">			<span class="type">int</span> u = <span class="number">-1</span>, MIN = INF;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) {</span><br><span class="line">				<span class="keyword">if</span> (vis[j] == <span class="literal">false</span> &amp;&amp; d[j] &lt; MIN) {</span><br><span class="line">					u = j;</span><br><span class="line">					MIN = d[j];</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">if</span> (u == <span class="number">-1</span>)<span class="keyword">return</span>;</span><br><span class="line">			vis[u] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//利用向量的特性，直接获取相邻的节点</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; Adj[u].<span class="built_in">size</span>(); ++j) {</span><br><span class="line">				<span class="type">int</span> v = Adj[u][j].v;</span><br><span class="line">				<span class="comment">//检查是否满足条件</span></span><br><span class="line">				<span class="keyword">if</span> (vis[v] == <span class="literal">false</span> &amp;&amp; d[u] + Adj[u][j].dis &lt; d[v]) {</span><br><span class="line">					d[v] = d[u] + Adj[u][j].dis;</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>To Be Continue…</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-02-27T00:14:48.000Z" title="2/27/2021, 8:14:48 AM">2021-02-27</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-03-08T11:44:49.723Z" title="3/8/2023, 7:44:49 PM">2023-03-08</time></span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/02/27/%E3%80%8A%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%8B%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E7%AE%97%E6%B3%95%E5%88%9D%E6%AD%A5%EF%BC%88%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3%EF%BC%89/">《算法笔记》第四章：算法初步（算法思想）</a></p><div class="content"><p><font color="#999AAA"><br><strong>Learn to learn</strong><br>1.Whenever I tackle a new subject, one of my first thoughts is what kind of structure am I trying to build. What would be the input situations that should cause me to remember this knowledge? How do I need to manipulate it, discriminate between similar-seeming situations, calculate or reason with it?<br>2.When my end goal is to solve a practical problem, <strong><em>I should begin thinking about applications.</em></strong></font></p>
<hr>
<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><p>选择排序：从无序表中选择最值元素，放到有序表的末端<br>插入排序：将无序表中的以一个元素插入到有序表中的相应的位置</p>
<h2 id="sort-函数"><a href="#sort-函数" class="headerlink" title="sort 函数"></a>sort 函数</h2><p><font color="#999AAA"><br>C语言：qsort函数</font></p>
<p><font color="#999AAA"><br><br>C++：sort函数（方便，推荐使用，需要加上#include &lt;<span>\</span>algorithm\&gt;和using namespace std;）</font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数模板</span></span><br><span class="line"><span class="built_in">sort</span>(首元素地址,尾元素地址,比较函数（可选项）)；</span><br><span class="line"><span class="comment">//比较char类型时，默认按照字典序</span></span><br><span class="line"><span class="comment">//之后的cmp函数（Compare）可以自定义，以达到不同的排序效果，默认情况下是从小到大</span></span><br><span class="line"><span class="comment">//实现从大到小输出</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="keyword">return</span> a &gt; b</span>;</span><br><span class="line">.....</span><br><span class="line"><span class="built_in">sort</span>(a, a + <span class="number">4</span>, cmp);<span class="comment">//从大到小排序</span></span><br><span class="line"><span class="comment">//*原因？*</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对结构体数组的排序</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>{</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">}ssd[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//编写cmp函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(a.x != b.x) <span class="keyword">return</span> a.x &gt; b.x;</span><br><span class="line">	esle <span class="keyword">return</span> a.y &lt; b.y;<span class="comment">//如果x相等则按照y的值进行排序</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//容器的排序（vector、string 、deque）</span></span><br><span class="line">sort（vector.<span class="built_in">begin</span>(),vector.<span class="built_in">end</span>(),cmp）;</span><br><span class="line"><span class="comment">//可以调用相应的方法作为排序的标准</span></span><br></pre></td></tr></table></figure>
<h1 id="散列"><a href="#散列" class="headerlink" title="散列"></a>散列</h1><p>散列是典型的运用空间换时间策略的方法，就是将数据存储在一个更加容易访问的数据结构中，例如数组。可以将数组的下标和数组中存储的元素结合起来，这样可以根据下标的信息直接访问数组内的信息。根据映射的方式不同，散列分为不同的类型。</p>
<h2 id="线性散列"><a href="#线性散列" class="headerlink" title="线性散列"></a>线性散列</h2><p>就先上面的例子一样，直接将数组内的信息与数组的下标相结合，这样查询的时间复杂度将为O(1)</p>
<h2 id="取留余数法"><a href="#取留余数法" class="headerlink" title="取留余数法"></a>取留余数法</h2><p>把关键值除以某个数之后的余数作为散列的关键值。<script type="math/tex">H_{(key)}=key \% mod</script>当取mod是一个素数的时候，可以尽可能地覆盖[0, mod)范围内的所有数，还有为了不越界，数组的大小应该不小于mod。当两个数与一个数的模相等的时候，这时候就产生了冲突。</p>
<h3 id="线性探测法"><a href="#线性探测法" class="headerlink" title="线性探测法"></a>线性探测法</h3><p>检查<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.8ex;" xmlns="http://www.w3.org/2000/svg" width="9.572ex" height="2.345ex" role="img" focusable="false" viewbox="0 -683 4231 1036.5"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D43B" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 219 683Q260 681 355 681Q389 681 418 681T463 682T483 682Q499 682 499 672Q499 670 497 658Q492 641 487 638H485Q483 638 480 638T473 638T464 637T455 637Q416 636 405 634T387 623Q384 619 355 500Q348 474 340 442T328 395L324 380Q324 378 469 378H614L615 381Q615 384 646 504Q674 619 674 627T617 637Q594 637 587 639T580 648Q580 650 582 660Q586 677 588 679T604 682Q609 682 646 681T740 680Q802 680 835 681T871 682Q888 682 888 672Q888 645 876 638H874Q872 638 869 638T862 638T853 637T844 637Q805 636 794 634T776 623Q773 618 704 340T634 58Q634 51 638 51Q646 48 692 46H723Q729 38 729 37T726 19Q722 6 716 0H701Q664 2 567 2Q533 2 504 2T458 2T437 1Q420 1 420 10Q420 15 423 24Q428 43 433 45Q437 46 448 46H454Q481 46 514 49Q520 50 522 50T528 55T534 64T540 82T547 110T558 153Q565 181 569 198Q602 330 602 331T457 332H312L279 197Q245 63 245 58Q245 51 253 49T303 46H334Q340 38 340 37T337 19Q333 6 327 0H312Q275 2 178 2Q144 2 115 2T69 2T48 1Q31 1 31 10Q31 12 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"/></g><g data-mml-node="TeXAtom" transform="translate(864,-176.7) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(389,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g><g data-mml-node="mi" transform="translate(910,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g><g data-mml-node="mi" transform="translate(1376,0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1866,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g><g data-mml-node="mo" transform="translate(2730.7,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(3731,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container>的情况。这种方法易产生扎堆，在一定程度上会降低效率</p>
<h3 id="平方探查法"><a href="#平方探查法" class="headerlink" title="平方探查法"></a>平方探查法</h3><p>检查<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.8ex;" xmlns="http://www.w3.org/2000/svg" width="29.44ex" height="2.687ex" role="img" focusable="false" viewbox="0 -833.9 13012.4 1187.4"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D43B" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 219 683Q260 681 355 681Q389 681 418 681T463 682T483 682Q499 682 499 672Q499 670 497 658Q492 641 487 638H485Q483 638 480 638T473 638T464 637T455 637Q416 636 405 634T387 623Q384 619 355 500Q348 474 340 442T328 395L324 380Q324 378 469 378H614L615 381Q615 384 646 504Q674 619 674 627T617 637Q594 637 587 639T580 648Q580 650 582 660Q586 677 588 679T604 682Q609 682 646 681T740 680Q802 680 835 681T871 682Q888 682 888 672Q888 645 876 638H874Q872 638 869 638T862 638T853 637T844 637Q805 636 794 634T776 623Q773 618 704 340T634 58Q634 51 638 51Q646 48 692 46H723Q729 38 729 37T726 19Q722 6 716 0H701Q664 2 567 2Q533 2 504 2T458 2T437 1Q420 1 420 10Q420 15 423 24Q428 43 433 45Q437 46 448 46H454Q481 46 514 49Q520 50 522 50T528 55T534 64T540 82T547 110T558 153Q565 181 569 198Q602 330 602 331T457 332H312L279 197Q245 63 245 58Q245 51 253 49T303 46H334Q340 38 340 37T337 19Q333 6 327 0H312Q275 2 178 2Q144 2 115 2T69 2T48 1Q31 1 31 10Q31 12 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"/></g><g data-mml-node="TeXAtom" transform="translate(864,-176.7) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(389,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g><g data-mml-node="mi" transform="translate(910,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g><g data-mml-node="mi" transform="translate(1376,0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1866,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g><g data-mml-node="mo" transform="translate(2730.7,0)"><path data-c="B1" d="M56 320T56 333T70 353H369V502Q369 651 371 655Q376 666 388 666Q402 666 405 654T409 596V500V353H707Q722 345 722 333Q722 320 707 313H409V40H707Q722 32 722 20T707 0H70Q56 7 56 20T70 40H369V313H70Q56 320 56 333Z"/></g><g data-mml-node="msup" transform="translate(3731,0)"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mn" transform="translate(533,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(4667.5,0)"><g data-mml-node="mo"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">、</text></g></g><g data-mml-node="msub" transform="translate(5667.5,0)"><g data-mml-node="mi"><path data-c="1D43B" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 219 683Q260 681 355 681Q389 681 418 681T463 682T483 682Q499 682 499 672Q499 670 497 658Q492 641 487 638H485Q483 638 480 638T473 638T464 637T455 637Q416 636 405 634T387 623Q384 619 355 500Q348 474 340 442T328 395L324 380Q324 378 469 378H614L615 381Q615 384 646 504Q674 619 674 627T617 637Q594 637 587 639T580 648Q580 650 582 660Q586 677 588 679T604 682Q609 682 646 681T740 680Q802 680 835 681T871 682Q888 682 888 672Q888 645 876 638H874Q872 638 869 638T862 638T853 637T844 637Q805 636 794 634T776 623Q773 618 704 340T634 58Q634 51 638 51Q646 48 692 46H723Q729 38 729 37T726 19Q722 6 716 0H701Q664 2 567 2Q533 2 504 2T458 2T437 1Q420 1 420 10Q420 15 423 24Q428 43 433 45Q437 46 448 46H454Q481 46 514 49Q520 50 522 50T528 55T534 64T540 82T547 110T558 153Q565 181 569 198Q602 330 602 331T457 332H312L279 197Q245 63 245 58Q245 51 253 49T303 46H334Q340 38 340 37T337 19Q333 6 327 0H312Q275 2 178 2Q144 2 115 2T69 2T48 1Q31 1 31 10Q31 12 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"/></g><g data-mml-node="TeXAtom" transform="translate(864,-176.7) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(389,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g><g data-mml-node="mi" transform="translate(910,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g><g data-mml-node="mi" transform="translate(1376,0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1866,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g><g data-mml-node="mo" transform="translate(8398.3,0)"><path data-c="B1" d="M56 320T56 333T70 353H369V502Q369 651 371 655Q376 666 388 666Q402 666 405 654T409 596V500V353H707Q722 345 722 333Q722 320 707 313H409V40H707Q722 32 722 20T707 0H70Q56 7 56 20T70 40H369V313H70Q56 320 56 333Z"/></g><g data-mml-node="msup" transform="translate(9398.5,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mn" transform="translate(533,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(10501.7,0)"><path data-c="2026" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60ZM525 60Q525 84 542 102T585 120Q609 120 627 104T646 61Q646 36 629 18T586 0T543 17T525 60ZM972 60Q972 84 989 102T1032 120Q1056 120 1074 104T1093 61Q1093 36 1076 18T1033 0T990 17T972 60Z"/></g><g data-mml-node="mo" transform="translate(11840.4,0)"><path data-c="2026" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60ZM525 60Q525 84 542 102T585 120Q609 120 627 104T646 61Q646 36 629 18T586 0T543 17T525 60ZM972 60Q972 84 989 102T1032 120Q1056 120 1074 104T1093 61Q1093 36 1076 18T1033 0T990 17T972 60Z"/></g></g></g></svg></mjx-container>(先正后负)<br>如果超出了边长，则把<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.8ex;" xmlns="http://www.w3.org/2000/svg" width="10.608ex" height="2.687ex" role="img" focusable="false" viewbox="0 -833.9 4688.5 1187.4"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D43B" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 219 683Q260 681 355 681Q389 681 418 681T463 682T483 682Q499 682 499 672Q499 670 497 658Q492 641 487 638H485Q483 638 480 638T473 638T464 637T455 637Q416 636 405 634T387 623Q384 619 355 500Q348 474 340 442T328 395L324 380Q324 378 469 378H614L615 381Q615 384 646 504Q674 619 674 627T617 637Q594 637 587 639T580 648Q580 650 582 660Q586 677 588 679T604 682Q609 682 646 681T740 680Q802 680 835 681T871 682Q888 682 888 672Q888 645 876 638H874Q872 638 869 638T862 638T853 637T844 637Q805 636 794 634T776 623Q773 618 704 340T634 58Q634 51 638 51Q646 48 692 46H723Q729 38 729 37T726 19Q722 6 716 0H701Q664 2 567 2Q533 2 504 2T458 2T437 1Q420 1 420 10Q420 15 423 24Q428 43 433 45Q437 46 448 46H454Q481 46 514 49Q520 50 522 50T528 55T534 64T540 82T547 110T558 153Q565 181 569 198Q602 330 602 331T457 332H312L279 197Q245 63 245 58Q245 51 253 49T303 46H334Q340 38 340 37T337 19Q333 6 327 0H312Q275 2 178 2Q144 2 115 2T69 2T48 1Q31 1 31 10Q31 12 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"/></g><g data-mml-node="TeXAtom" transform="translate(864,-176.7) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(389,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g><g data-mml-node="mi" transform="translate(910,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g><g data-mml-node="mi" transform="translate(1376,0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1866,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g><g data-mml-node="mo" transform="translate(2730.7,0)"><path data-c="B1" d="M56 320T56 333T70 353H369V502Q369 651 371 655Q376 666 388 666Q402 666 405 654T409 596V500V353H707Q722 345 722 333Q722 320 707 313H409V40H707Q722 32 722 20T707 0H70Q56 7 56 20T70 40H369V313H70Q56 320 56 333Z"/></g><g data-mml-node="msup" transform="translate(3731,0)"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g><g data-mml-node="mn" transform="translate(554,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g></g></g></svg></mjx-container>对表长进行取模。<br>如果出现小于零的情况<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.8ex;" xmlns="http://www.w3.org/2000/svg" width="38.48ex" height="2.687ex" role="img" focusable="false" viewbox="0 -833.9 17008 1187.4"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mo" transform="translate(389,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="msub" transform="translate(778,0)"><g data-mml-node="mi"><path data-c="1D43B" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 219 683Q260 681 355 681Q389 681 418 681T463 682T483 682Q499 682 499 672Q499 670 497 658Q492 641 487 638H485Q483 638 480 638T473 638T464 637T455 637Q416 636 405 634T387 623Q384 619 355 500Q348 474 340 442T328 395L324 380Q324 378 469 378H614L615 381Q615 384 646 504Q674 619 674 627T617 637Q594 637 587 639T580 648Q580 650 582 660Q586 677 588 679T604 682Q609 682 646 681T740 680Q802 680 835 681T871 682Q888 682 888 672Q888 645 876 638H874Q872 638 869 638T862 638T853 637T844 637Q805 636 794 634T776 623Q773 618 704 340T634 58Q634 51 638 51Q646 48 692 46H723Q729 38 729 37T726 19Q722 6 716 0H701Q664 2 567 2Q533 2 504 2T458 2T437 1Q420 1 420 10Q420 15 423 24Q428 43 433 45Q437 46 448 46H454Q481 46 514 49Q520 50 522 50T528 55T534 64T540 82T547 110T558 153Q565 181 569 198Q602 330 602 331T457 332H312L279 197Q245 63 245 58Q245 51 253 49T303 46H334Q340 38 340 37T337 19Q333 6 327 0H312Q275 2 178 2Q144 2 115 2T69 2T48 1Q31 1 31 10Q31 12 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"/></g><g data-mml-node="TeXAtom" transform="translate(864,-176.7) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(389,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g><g data-mml-node="mi" transform="translate(910,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g><g data-mml-node="mi" transform="translate(1376,0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1866,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g><g data-mml-node="mo" transform="translate(3508.7,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="msup" transform="translate(4509,0)"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g><g data-mml-node="mn" transform="translate(554,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(5466.5,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mi" transform="translate(5855.5,0)"><path data-c="25" d="M465 605Q428 605 394 614T340 632T319 641Q332 608 332 548Q332 458 293 403T202 347Q145 347 101 402T56 548Q56 637 101 693T202 750Q241 750 272 719Q359 642 464 642Q580 642 650 732Q662 748 668 749Q670 750 673 750Q682 750 688 743T693 726Q178 -47 170 -52Q166 -56 160 -56Q147 -56 142 -45Q137 -36 142 -27Q143 -24 363 304Q469 462 525 546T581 630Q528 605 465 605ZM207 385Q235 385 263 427T292 548Q292 617 267 664T200 712Q193 712 186 709T167 698T147 668T134 615Q132 595 132 548V527Q132 436 165 403Q183 385 203 385H207ZM500 146Q500 234 544 290T647 347Q699 347 737 292T776 146T737 0T646 -56Q590 -56 545 0T500 146ZM651 -18Q679 -18 707 24T736 146Q736 215 711 262T644 309Q637 309 630 306T611 295T591 265T578 212Q577 200 577 146V124Q577 -18 647 -18H651Z"/></g><g data-mml-node="mi" transform="translate(6688.5,0)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="mi" transform="translate(7392.5,0)"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"/></g><g data-mml-node="mi" transform="translate(8037.5,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(8382.5,0)"><path data-c="1D467" d="M347 338Q337 338 294 349T231 360Q211 360 197 356T174 346T162 335T155 324L153 320Q150 317 138 317Q117 317 117 325Q117 330 120 339Q133 378 163 406T229 440Q241 442 246 442Q271 442 291 425T329 392T367 375Q389 375 411 408T434 441Q435 442 449 442H462Q468 436 468 434Q468 430 463 420T449 399T432 377T418 358L411 349Q368 298 275 214T160 106L148 94L163 93Q185 93 227 82T290 71Q328 71 360 90T402 140Q406 149 409 151T424 153Q443 153 443 143Q443 138 442 134Q425 72 376 31T278 -11Q252 -11 232 6T193 40T155 57Q111 57 76 -3Q70 -11 59 -11H54H41Q35 -5 35 -2Q35 13 93 84Q132 129 225 214T340 322Q352 338 347 338Z"/></g><g data-mml-node="mi" transform="translate(8847.5,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g><g data-mml-node="mo" transform="translate(9535.7,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mi" transform="translate(10536,0)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="mi" transform="translate(11240,0)"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"/></g><g data-mml-node="mi" transform="translate(11885,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(12230,0)"><path data-c="1D467" d="M347 338Q337 338 294 349T231 360Q211 360 197 356T174 346T162 335T155 324L153 320Q150 317 138 317Q117 317 117 325Q117 330 120 339Q133 378 163 406T229 440Q241 442 246 442Q271 442 291 425T329 392T367 375Q389 375 411 408T434 441Q435 442 449 442H462Q468 436 468 434Q468 430 463 420T449 399T432 377T418 358L411 349Q368 298 275 214T160 106L148 94L163 93Q185 93 227 82T290 71Q328 71 360 90T402 140Q406 149 409 151T424 153Q443 153 443 143Q443 138 442 134Q425 72 376 31T278 -11Q252 -11 232 6T193 40T155 57Q111 57 76 -3Q70 -11 59 -11H54H41Q35 -5 35 -2Q35 13 93 84Q132 129 225 214T340 322Q352 338 347 338Z"/></g><g data-mml-node="mi" transform="translate(12695,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g><g data-mml-node="mo" transform="translate(13161,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mi" transform="translate(13550,0)"><path data-c="25" d="M465 605Q428 605 394 614T340 632T319 641Q332 608 332 548Q332 458 293 403T202 347Q145 347 101 402T56 548Q56 637 101 693T202 750Q241 750 272 719Q359 642 464 642Q580 642 650 732Q662 748 668 749Q670 750 673 750Q682 750 688 743T693 726Q178 -47 170 -52Q166 -56 160 -56Q147 -56 142 -45Q137 -36 142 -27Q143 -24 363 304Q469 462 525 546T581 630Q528 605 465 605ZM207 385Q235 385 263 427T292 548Q292 617 267 664T200 712Q193 712 186 709T167 698T147 668T134 615Q132 595 132 548V527Q132 436 165 403Q183 385 203 385H207ZM500 146Q500 234 544 290T647 347Q699 347 737 292T776 146T737 0T646 -56Q590 -56 545 0T500 146ZM651 -18Q679 -18 707 24T736 146Q736 215 711 262T644 309Q637 309 630 306T611 295T591 265T578 212Q577 200 577 146V124Q577 -18 647 -18H651Z"/></g><g data-mml-node="mi" transform="translate(14383,0)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="mi" transform="translate(15087,0)"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"/></g><g data-mml-node="mi" transform="translate(15732,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(16077,0)"><path data-c="1D467" d="M347 338Q337 338 294 349T231 360Q211 360 197 356T174 346T162 335T155 324L153 320Q150 317 138 317Q117 317 117 325Q117 330 120 339Q133 378 163 406T229 440Q241 442 246 442Q271 442 291 425T329 392T367 375Q389 375 411 408T434 441Q435 442 449 442H462Q468 436 468 434Q468 430 463 420T449 399T432 377T418 358L411 349Q368 298 275 214T160 106L148 94L163 93Q185 93 227 82T290 71Q328 71 360 90T402 140Q406 149 409 151T424 153Q443 153 443 143Q443 138 442 134Q425 72 376 31T278 -11Q252 -11 232 6T193 40T155 57Q111 57 76 -3Q70 -11 59 -11H54H41Q35 -5 35 -2Q35 13 93 84Q132 129 225 214T340 322Q352 338 347 338Z"/></g><g data-mml-node="mi" transform="translate(16542,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g></g></g></svg></mjx-container>(其中TSize为表长)<br>为了避免负数出现的麻烦，可以只进行正向的平方探测。</p>
<h3 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h3><p>将哈希值相同的元素连接成一个单链表，表头元素就是数组的元素</p>
<p>在标准模板库中，有map可以直接使用hash表的功能（C++11以后可以用unordered_map，速度更快）。另外将一对或者是多对的整数映射成一个整数的方法可以是像十进制数那样，一个数字代表十位一个代表个位。（<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.8ex;" xmlns="http://www.w3.org/2000/svg" width="21.241ex" height="2.345ex" role="img" focusable="false" viewbox="0 -683 9388.6 1036.5"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D43B" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 219 683Q260 681 355 681Q389 681 418 681T463 682T483 682Q499 682 499 672Q499 670 497 658Q492 641 487 638H485Q483 638 480 638T473 638T464 637T455 637Q416 636 405 634T387 623Q384 619 355 500Q348 474 340 442T328 395L324 380Q324 378 469 378H614L615 381Q615 384 646 504Q674 619 674 627T617 637Q594 637 587 639T580 648Q580 650 582 660Q586 677 588 679T604 682Q609 682 646 681T740 680Q802 680 835 681T871 682Q888 682 888 672Q888 645 876 638H874Q872 638 869 638T862 638T853 637T844 637Q805 636 794 634T776 623Q773 618 704 340T634 58Q634 51 638 51Q646 48 692 46H723Q729 38 729 37T726 19Q722 6 716 0H701Q664 2 567 2Q533 2 504 2T458 2T437 1Q420 1 420 10Q420 15 423 24Q428 43 433 45Q437 46 448 46H454Q481 46 514 49Q520 50 522 50T528 55T534 64T540 82T547 110T558 153Q565 181 569 198Q602 330 602 331T457 332H312L279 197Q245 63 245 58Q245 51 253 49T303 46H334Q340 38 340 37T337 19Q333 6 327 0H312Q275 2 178 2Q144 2 115 2T69 2T48 1Q31 1 31 10Q31 12 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"/></g><g data-mml-node="TeXAtom" transform="translate(864,-176.7) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(389,0)"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"/></g><g data-mml-node="mo" transform="translate(1140,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g><g data-mml-node="mo" transform="translate(2272.9,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mi" transform="translate(3328.7,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/></g><g data-mml-node="mo" transform="translate(4122.9,0)"><path data-c="2217" d="M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z"/></g><g data-mml-node="mi" transform="translate(4845.2,0)"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"/></g><g data-mml-node="mi" transform="translate(5604.2,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mi" transform="translate(6133.2,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(6733.2,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mi" transform="translate(7210.2,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g><g data-mml-node="mo" transform="translate(7898.4,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mi" transform="translate(8898.6,0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>）</p>
<h3 id="map的常见用法"><a href="#map的常见用法" class="headerlink" title="map的常见用法"></a>map的常见用法</h3><p>map函数可以将任何类型映射到其他的任何类型（包括容器），使用map函数需要添加\<map>头文件，需要加上using namespace std;<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个map</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">map&lt;映射前的类型，映射后的类型&gt;容器名称</span><br><span class="line"><span class="comment">//注意一点，如果是字符串到整型的的映射必须是string而不能使用char数组</span></span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">char</span>, <span class="type">int</span>&gt;mp;</span><br><span class="line"><span class="comment">//map容器的访问方式</span></span><br><span class="line"><span class="comment">//通过下标访问</span></span><br><span class="line">mp[<span class="string">'c'</span>] = <span class="number">20</span>;<span class="comment">//注意这个是唯一的，后续的赋值会覆盖原先的值</span></span><br><span class="line"><span class="comment">//运用迭代器</span></span><br><span class="line"><span class="comment">//迭代器定义</span></span><br><span class="line">map&lt;typename1, typename2&gt;::iterator it;<span class="comment">//这两个类型名称是定义map时定义的变量类型</span></span><br><span class="line"><span class="comment">//访问键值</span></span><br><span class="line">it-&gt;first;it-&gt;second;</span><br><span class="line"><span class="comment">//遍历map中的所有键值的循环</span></span><br><span class="line"><span class="keyword">for</span>(map&lt;<span class="type">char</span>,<span class="type">int</span>&gt;::iterator it = mp.<span class="built_in">begin</span>(); it != map.<span class="built_in">end</span>();it++){...}</span><br><span class="line"><span class="comment">//map是使用红黑树实现的，会以键从小到大的顺序自动排序</span></span><br></pre></td></tr></table></figure></map></p>
<h4 id="map常用函数"><a href="#map常用函数" class="headerlink" title="map常用函数"></a>map常用函数</h4><div class="table-container">
<table>
<thead>
<tr>
<th>函数名</th>
<th>功能</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>find(key)</td>
<td>返回键为key的映射的迭代器</td>
<td>O(logN) N为映射个数</td>
</tr>
<tr>
<td>erase()</td>
<td>删除一个元素、删除一个区间内的所有元素</td>
<td>传入迭代器：O(1)<br>传入键值：O(log(N))（N为map中的元素个数）</td>
</tr>
<tr>
<td>size()</td>
<td>获得map中映射的对数</td>
<td>O(1)</td>
</tr>
<tr>
<td>clear()</td>
<td>清空map中所有的元素</td>
<td>O(N)</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//运用范例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	map&lt;<span class="type">char</span>, <span class="type">int</span>&gt;mp;</span><br><span class="line">	mp[<span class="string">'a'</span>] = <span class="number">1</span>;</span><br><span class="line">	mp[<span class="string">'b'</span>] = <span class="number">2</span>;</span><br><span class="line">	map&lt;<span class="type">char</span>, <span class="type">int</span>&gt;::iterator it = mp.<span class="built_in">find</span>(<span class="string">'b'</span>);</span><br><span class="line">	mp.<span class="built_in">erase</span>(it);</span><br><span class="line">	mp.<span class="built_in">erase</span>(<span class="string">'b'</span>);<span class="comment">//与上面的作用相同</span></span><br><span class="line">	mp.<span class="built_in">erase</span>(it, mp.<span class="built_in">end</span>());<span class="comment">//传入删除的区间</span></span><br><span class="line">	mp.<span class="built_in">size</span>();</span><br><span class="line">	mp.<span class="built_in">clear</span>();</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将字母映射成十进制数</span></span><br><span class="line"><span class="comment">//算法思想：将26个字母看成26进制数，然后转换成相应的十进制数，转换过程为：</span></span><br><span class="line"><span class="comment">//个位数加上更高位数乘以进制数，这个可以类比十进制数的构成，因为传入的时候是从高位开始的（从左向右读取），</span></span><br><span class="line"><span class="comment">//所以可以将每一次输入的数字都是在个位数，其他的按照进制数倍增</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">hashFunc</span><span class="params">(<span class="type">char</span> S[], <span class="type">int</span> len)</span> </span>{</span><br><span class="line">	<span class="type">int</span> id = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) {</span><br><span class="line">		id = id * <span class="number">26</span> + (S[i] - <span class="string">'A'</span>);<span class="comment">//个位数+更高位数*进制数</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, id);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> id;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//当还遇到小写字母的时候</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">hashFunc</span><span class="params">(<span class="type">char</span> S[], <span class="type">int</span> len)</span></span>{</span><br><span class="line">	<span class="type">int</span> id = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i){</span><br><span class="line">		<span class="keyword">if</span>(S[i] &gt;= <span class="string">'A'</span> &amp;&amp; S[i] &lt;= <span class="string">'Z'</span>){</span><br><span class="line">			id = id * <span class="number">52</span> + (S[i] - <span class="string">'A'</span>);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(S[i] &gt;= <span class="string">'a'</span> &amp;&amp; S[i] &lt;= <span class="string">'z'</span>){</span><br><span class="line">			id = id * <span class="number">52</span> + (S[i] - <span class="string">'a'</span>) + <span class="number">26</span>;<span class="comment">//注意这里加上的26，是因为在这个52进制当中，大写字母在前面</span></span><br><span class="line">			<span class="comment">//类比十进制， 8 = 3 + 5；</span></span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> id;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//如果还出现了数字，则将进制数扩大到62</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><h2 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h2><p>这种思想让我想到了一个成语：众人拾柴火焰高。将”火焰高“这个目的划分成“众人拾柴”，这个规模较小而与原问题相似的子问题。这包含分治思想的三个方面：首先将一个问题进行分解，然后求解子问题，最后将问题的结果合并成原问题的结果。这样的话你只需要专注于一个小问题就可以。当然，<strong>子问题应该是相互独立的、没有交叉的。</strong></p>
<h2 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h2><p>   这实际上是一种分治思想，这样做的结果就是只需要专注于一个小问题即可，但是与之前“拾柴”的的例子不一样，之前的像是单层的分解，但是递归应该是多层次的。<br>    在使用递归的时候应该注意两点，<strong>递归式和递归边界</strong>。这也就是怎么划分和划分到什么地步的问题。<br>    下面是求解全排列的问题：在全排列问题中，每一个元素只有两种状态，被选和没有被选，只需要所有的元素的这两种状态全部遍历一遍就可以了。在选和不选中做抉择，可以将所有情况画成一棵树，这棵树就叫做<strong>决策树</strong><br>    <img src="https://img-blog.csdnimg.cn/20210319081859195.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="图源水印"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全排列，字典序</span></span><br><span class="line"><span class="comment">//头部应该是不断更新的，也就是子排列中的头部</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">算法思想：先确定排列的首部，然后剩下的子序列做同样的操作，这样就可以将问题不断减小。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;<span class="comment">//待排元素的个数</span></span><br><span class="line"><span class="type">int</span> p[maxn];<span class="comment">//存储当前排列</span></span><br><span class="line"><span class="type">int</span> hashTable[maxn] = { <span class="literal">false</span> };<span class="comment">//判断索引元素是否在排列数组中</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;<span class="comment">//统计全排列的个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//处理排列的idex号位</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">generateP</span><span class="params">(<span class="type">int</span> index)</span></span>{</span><br><span class="line"></span><br><span class="line">	<span class="comment">//这是递归边界，前面的元素全部排列完毕，现在是要将数组输出</span></span><br><span class="line">	<span class="keyword">if</span> (index == n + <span class="number">1</span>) {</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) {</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d"</span>, p[i]);</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历检查所有的元素，这里引用了外部的变量n，由主函数定义（作为参数是不是好点？）</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">1</span>; x &lt;= n; ++x) {</span><br><span class="line">		<span class="comment">//哈希表是来表示索引元素是否已经加入数组了</span></span><br><span class="line">		<span class="keyword">if</span> (hashTable[x] == <span class="literal">false</span>) {</span><br><span class="line">			p[index] = x;<span class="comment">//以x作为头部的时候</span></span><br><span class="line">			hashTable[x] = <span class="literal">true</span>;<span class="comment">//更新状态</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//这里是继续下一位，注意这里还没有将哈希表重置，所以原先作为首部的元素是不会再被赋值了</span></span><br><span class="line">			<span class="built_in">generateP</span>(index + <span class="number">1</span>);</span><br><span class="line">			hashTable[x] = <span class="literal">false</span>;<span class="comment">//完成递归项中的一个，重置状态</span></span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	count++;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	n = <span class="number">9</span>;<span class="comment">//表示输出1~3的全排列同时还表示全排列的数组元素个数</span></span><br><span class="line">	<span class="built_in">generateP</span>(<span class="number">1</span>);<span class="comment">//表示从P[1]开始</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n%d"</span>, count);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>在一点条件下，之后的实例都无法满足要求，这时候可以直接退出该层递归，返回上一层。这种方法成为<strong>回溯</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//n皇后问题，n*n的格子中，放入n个皇后，这n个皇后不能在同行、列、对角线</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;<span class="comment">//待排元素的个数</span></span><br><span class="line"><span class="type">int</span> p[maxn];<span class="comment">//存储当前排列</span></span><br><span class="line"><span class="type">int</span> hashTable[maxn] = { <span class="literal">false</span> };<span class="comment">//判断索引元素是否在排列数组中</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;<span class="comment">//统计全排列的个数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">generateP</span><span class="params">(<span class="type">int</span> index)</span> </span>{</span><br><span class="line">	<span class="keyword">if</span> (index == n + <span class="number">1</span>) {</span><br><span class="line">		count++;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">1</span>; x &lt;= n; x++) {</span><br><span class="line">		<span class="keyword">if</span> (hashTable[x] == <span class="literal">false</span>) {</span><br><span class="line">			<span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> pre = <span class="number">1</span>; pre &lt; index; pre++) {</span><br><span class="line">				<span class="comment">//检查是否在同一对角线上，注意进入if语句之后该次循环就会被跳过</span></span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">abs</span>(index - pre) == <span class="built_in">abs</span>(x - p[pre])) {</span><br><span class="line">					flag = <span class="literal">false</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">if</span> (flag) {</span><br><span class="line">				p[index] = x;</span><br><span class="line">				hashTable[x] = <span class="literal">true</span>;</span><br><span class="line">				<span class="built_in">generateP</span>(index + <span class="number">1</span>);</span><br><span class="line">				hashTable[x] = <span class="literal">false</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><p>用局部最优来达到全局最优的结果。分为在线算法（Online Algorithms）和离线算法（Offline Algorithms），可以证明在线算法无法得到最优解。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//B1020月饼</span></span><br><span class="line"><span class="comment">//忽略最后注释部分</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">mooncake</span> {</span><br><span class="line">	<span class="type">double</span> store;</span><br><span class="line">	<span class="type">double</span> sell;</span><br><span class="line">	<span class="type">double</span> price;</span><br><span class="line">}cake[<span class="number">1010</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义函数的时候一定要大括号</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(mooncake a, mooncake b)</span> </span>{</span><br><span class="line">	<span class="keyword">return</span> a.price &gt; b.price;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>{</span><br><span class="line">	<span class="type">int</span> n;<span class="comment">//月饼种类</span></span><br><span class="line">	<span class="type">double</span> D;<span class="comment">//市场需求量</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%lf"</span>, &amp;n, &amp;D);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化库存</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) {</span><br><span class="line">		<span class="comment">//少些%不会报错，但会出错</span></span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;cake[i].store);</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//初始化利润</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) {</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;cake[i].sell);</span><br><span class="line">		cake[i].price = cake[i].sell / cake[i].store;<span class="comment">//计算单价</span></span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//将数组由根据单价由大到小排列</span></span><br><span class="line">	<span class="built_in">sort</span>(cake, cake + n, cmp);</span><br><span class="line"></span><br><span class="line">	<span class="type">double</span> ans = <span class="number">0</span>;<span class="comment">//最大利润</span></span><br><span class="line">	<span class="comment">//枚举各种月饼</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) {</span><br><span class="line">		<span class="comment">//检查是否满足市场需求量</span></span><br><span class="line">		<span class="keyword">if</span> (cake[i].store &lt;= D) {</span><br><span class="line">			D -= cake[i].store;<span class="comment">//更新需求量</span></span><br><span class="line">			ans += cake[i].sell;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span> {</span><br><span class="line">			ans += cake[i].price * D;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%.2f\n"</span>, ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">算法思想：先算出单价利润最大的月饼，然后将对应的全部卖出，要考虑的</span></span><br><span class="line"><span class="comment">需要较为进阶的语言知识，现阶段还是不要这样做为好，直接定义最大的情况下的数组即可</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#include&lt;cstdio&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">struct MoonPie{</span></span><br><span class="line"><span class="comment">    int rep;//库存</span></span><br><span class="line"><span class="comment">    int profit;//利润</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    MoonPie(){};</span></span><br><span class="line"><span class="comment">    MoonPie(int _rep){</span></span><br><span class="line"><span class="comment">        rep = _rep;</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment">    MoonPie(int _profit){</span></span><br><span class="line"><span class="comment">        profit = _profit;</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    int value = profit / (double)rep;</span></span><br><span class="line"><span class="comment">};</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">int main(void){</span></span><br><span class="line"><span class="comment">    int n;//月饼种类</span></span><br><span class="line"><span class="comment">    int re;//需求量</span></span><br><span class="line"><span class="comment">    int profit,rep;</span></span><br><span class="line"><span class="comment">    in maxValue = 0;//最大单价</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    scanf("%d %d",&amp;n,&amp;re);</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    //输入数据，定义动态数组，</span></span><br><span class="line"><span class="comment">    int *p = new int[n];</span></span><br><span class="line"><span class="comment">    //找出单个利润最大的月饼</span></span><br><span class="line"><span class="comment">    //初始化数据</span></span><br><span class="line"><span class="comment">    for(int i = 1; i &lt;= n; ++i){</span></span><br><span class="line"><span class="comment">        scanf("%d",&amp;rep);</span></span><br><span class="line"><span class="comment">        p[i] = MoonPie(rep);</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment">    for(int i = 1; i &lt;= n; ++i){</span></span><br><span class="line"><span class="comment">        scanf("%d",&amp;profit);</span></span><br><span class="line"><span class="comment">        p[i] = MoonPie(profit);</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment">    for(int i = 1; i &lt;= n; ++i){</span></span><br><span class="line"><span class="comment">        if(maxValue &lt; p[i].value) maxValue = p[i].value;</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment">    //比较市场需求量和库存，计算最终的利润</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> x)</span></span>{</span><br><span class="line">	<span class="type">int</span> mid;<span class="comment">//查找区间的中间的位置</span></span><br><span class="line">	<span class="keyword">while</span>(left &lt;= right){</span><br><span class="line">		mid = (left + right)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(A[mid] == x) <span class="keyword">return</span> mid;<span class="comment">//找到</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//更新查找区间</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(A[mid] &gt; x)right = mid <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//当查找范围较大时，（left+right可能会越界）这个时候可以用mid = left+(right-left)/2  代替</span></span><br></pre></td></tr></table></figure>
<p>当查找的元素数组中包含重复的元素时，这也就是说目标元素在数组中可能不止一个，这个时候就应该返回目标元素所在的区间。算法的总体思路：对于一个有序表，找出第一个与目标元素相等的位置和第一个与目标元素不相等的位置，得到对应的区间<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找出目标数组的上界，第一个大于等于x的元素的位置</span></span><br><span class="line"><span class="comment">//注意在这里二分法的上界是n因为当x不存在的时候，位置范围可能在数组范围之外的那个元素的位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lower_bound</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> x)</span></span>{</span><br><span class="line">	<span class="type">int</span> mid;</span><br><span class="line">	<span class="comment">//注意这个判断条件，只是确定x的范围，对x是否存在并不关心（？）</span></span><br><span class="line">	<span class="keyword">while</span> (left &lt; right){</span><br><span class="line">		mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(A[mid] &gt;= x)right = mid;</span><br><span class="line">		<span class="keyword">else</span> left = mid +<span class="number">1</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> left;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//同样的求目标元素的上界，即数组元素第一次与目标元素不相同的时候，与求下界的函数相比，主要的区别就在于</span></span><br><span class="line"><span class="comment">//判断语句中少了等于，这样当指向这个数组元素的时候，就会继续进行原先的步骤,因为这个函数的主要目的就是找到第一个与目标元素不相等的元素的位置</span></span><br></pre></td></tr></table></figure><br>二分查找的思想本质上就是利用目标左右两端的情况，来不断调整范围，以实现向目标趋近的目的。所以，二分法不仅仅可以用于查询满足条件的目标，还可以求目标的近似。下面是一个求<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.225ex;" xmlns="http://www.w3.org/2000/svg" width="3.061ex" height="2.398ex" role="img" focusable="false" viewbox="0 -960.5 1353 1060"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msqrt"><g transform="translate(853,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(0,100.5)"><path data-c="221A" d="M95 178Q89 178 81 186T72 200T103 230T169 280T207 309Q209 311 212 311H213Q219 311 227 294T281 177Q300 134 312 108L397 -77Q398 -77 501 136T707 565T814 786Q820 800 834 800Q841 800 846 794T853 782V776L620 293L385 -193Q381 -200 366 -200Q357 -200 354 -197Q352 -195 256 15L160 225L144 214Q129 202 113 190T95 178Z"/></g><rect width="500" height="60" x="853" y="840.5"/></g></g></g></svg></mjx-container>的近似值 的例子<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">算法思想：考虑函数f(x) = x^2，想要求sqrt(2),只需要找到函数值趋向于2的数即可。先比较区间中点mid的与f(x)的</span></span><br><span class="line"><span class="comment">大小，若mid&gt;f(x), 则从[left,mid]中去寻找，其他情况类似，直到达到想要的精度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> esp = <span class="number">1e-5</span>;<span class="comment">//需要的精度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">f</span><span class="params">(<span class="type">double</span> x)</span> <span class="keyword">return</span> x * x</span>;<span class="comment">//关系函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">calSqrt</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="type">double</span> left = <span class="number">1</span>, right = <span class="number">2</span>, mid;<span class="comment">//左、右区间范围，中间元素指针</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(right - left &gt; esp){<span class="comment">//检查是否满足精度</span></span><br><span class="line">		mid = (left + right)/<span class="number">2</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//更新区间信息</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">f</span>(mid) &gt; <span class="number">2</span>)right = mid;</span><br><span class="line">		<span class="keyword">else</span> left = mid;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> mid;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//这本质上就是求解一个方程，因为算法只能逼近与一个点，所以需要在区间内只有一个目标，或者说保证二者的关系是单调的</span></span><br></pre></td></tr></table></figure></p>
<h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><blockquote>
<p>题目描述：给定三个正数a、b、m（a&lt;<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex;" xmlns="http://www.w3.org/2000/svg" width="25.702ex" height="2.394ex" role="img" focusable="false" viewbox="0 -864 11360.2 1058"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"/></g><g data-mml-node="mn" transform="translate(1033,393.1) scale(0.707)"><path data-c="39" d="M352 287Q304 211 232 211Q154 211 104 270T44 396Q42 412 42 436V444Q42 537 111 606Q171 666 243 666Q245 666 249 666T257 665H261Q273 665 286 663T323 651T370 619T413 560Q456 472 456 334Q456 194 396 97Q361 41 312 10T208 -22Q147 -22 108 7T68 93T121 149Q143 149 158 135T173 96Q173 78 164 65T148 49T135 44L131 43Q131 41 138 37T164 27T206 22H212Q272 22 313 86Q352 142 352 280V287ZM244 248Q292 248 321 297T351 430Q351 508 343 542Q341 552 337 562T323 588T293 615T246 625Q208 625 181 598Q160 576 154 546T147 441Q147 358 152 329T172 282Q197 248 244 248Z"/></g></g><g data-mml-node="mo" transform="translate(1436.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(1881.2,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g><g data-mml-node="mo" transform="translate(2588,0)"><path data-c="3C" d="M694 -11T694 -19T688 -33T678 -40Q671 -40 524 29T234 166L90 235Q83 240 83 250Q83 261 91 266Q664 540 678 540Q681 540 687 534T694 519T687 505Q686 504 417 376L151 250L417 124Q686 -4 687 -5Q694 -11 694 -19Z"/></g><g data-mml-node="msup" transform="translate(3643.8,0)"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"/></g><g data-mml-node="TeXAtom" transform="translate(1033,393.1) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z" transform="translate(500,0)"/></g></g></g><g data-mml-node="mo" transform="translate(5433.9,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mn" transform="translate(5878.5,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(6656.3,0)"><path data-c="3C" d="M694 -11T694 -19T688 -33T678 -40Q671 -40 524 29T234 166L90 235Q83 240 83 250Q83 261 91 266Q664 540 678 540Q681 540 687 534T694 519T687 505Q686 504 417 376L151 250L417 124Q686 -4 687 -5Q694 -11 694 -19Z"/></g><g data-mml-node="mi" transform="translate(7712.1,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(8867.9,0)"><path data-c="3C" d="M694 -11T694 -19T688 -33T678 -40Q671 -40 524 29T234 166L90 235Q83 240 83 250Q83 261 91 266Q664 540 678 540Q681 540 687 534T694 519T687 505Q686 504 417 376L151 250L417 124Q686 -4 687 -5Q694 -11 694 -19Z"/></g><g data-mml-node="msup" transform="translate(9923.7,0)"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"/></g><g data-mml-node="mn" transform="translate(1033,393.1) scale(0.707)"><path data-c="39" d="M352 287Q304 211 232 211Q154 211 104 270T44 396Q42 412 42 436V444Q42 537 111 606Q171 666 243 666Q245 666 249 666T257 665H261Q273 665 286 663T323 651T370 619T413 560Q456 472 456 334Q456 194 396 97Q361 41 312 10T208 -22Q147 -22 108 7T68 93T121 149Q143 149 158 135T173 96Q173 78 164 65T148 49T135 44L131 43Q131 41 138 37T164 27T206 22H212Q272 22 313 86Q352 142 352 280V287ZM244 248Q292 248 321 297T351 430Q351 508 343 542Q341 552 337 562T323 588T293 615T246 625Q208 625 181 598Q160 576 154 546T147 441Q147 358 152 329T172 282Q197 248 244 248Z"/></g></g></g></g></svg></mjx-container>),求<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.127ex;" xmlns="http://www.w3.org/2000/svg" width="5.942ex" height="2.058ex" role="img" focusable="false" viewbox="0 -853.7 2626.3 909.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mi" transform="translate(562,363) scale(0.707)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g></g><g data-mml-node="mi" transform="translate(915.3,0)"><path data-c="25" d="M465 605Q428 605 394 614T340 632T319 641Q332 608 332 548Q332 458 293 403T202 347Q145 347 101 402T56 548Q56 637 101 693T202 750Q241 750 272 719Q359 642 464 642Q580 642 650 732Q662 748 668 749Q670 750 673 750Q682 750 688 743T693 726Q178 -47 170 -52Q166 -56 160 -56Q147 -56 142 -45Q137 -36 142 -27Q143 -24 363 304Q469 462 525 546T581 630Q528 605 465 605ZM207 385Q235 385 263 427T292 548Q292 617 267 664T200 712Q193 712 186 709T167 698T147 668T134 615Q132 595 132 548V527Q132 436 165 403Q183 385 203 385H207ZM500 146Q500 234 544 290T647 347Q699 347 737 292T776 146T737 0T646 -56Q590 -56 545 0T500 146ZM651 -18Q679 -18 707 24T736 146Q736 215 711 262T644 309Q637 309 630 306T611 295T591 265T578 212Q577 200 577 146V124Q577 -18 647 -18H651Z"/></g><g data-mml-node="mi" transform="translate(1748.3,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>）</p>
</blockquote>
<p>算法分析:因为数字的数量级太大，直接通过循环来求解需要的时间会很多（时间复杂度为O(n)）,可以借用快速幂的方法：</p>
<script type="math/tex; mode=display">a^b=\left\{
\begin{aligned}
 \ a *a^{b-1} （b为奇数）\\a^{\frac b2}*a^{\frac b2}（b为偶数） \\
\end{aligned}
\right.</script><p>这样可以将幂次的乘积进一步减少<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快速幂的递归形式</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="comment">//参数分别为底数、指数、模数</span></span><br><span class="line"><span class="function">LL <span class="title">binaryPow</span><span class="params">(LL a, LL b, LL m)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(b == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//递归出口</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(b % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> a * <span class="built_in">binaryPow</span>(a, b - <span class="number">1</span>, m) % m;</span><br><span class="line">	<span class="keyword">else</span> {</span><br><span class="line">		LL mul = <span class="built_in">binaryPow</span>(a, b / <span class="number">2</span>, m);</span><br><span class="line">		<span class="keyword">return</span> mul * mul % m;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="comment">//if(b % 2 == 1)还可以这样写if (b &amp; 1)代替，后者就是检查b的二进制形式的最后</span></span><br><span class="line"><span class="comment">//一位是否是1，是则为奇数，否则为偶数</span></span><br><span class="line"><span class="comment">//还有注意返回时不要写：</span></span><br><span class="line"><span class="keyword">return</span> (<span class="built_in">binariPow</span>(a, b / <span class="number">2</span>, m) * <span class="built_in">binariPow</span>(a, b / <span class="number">2</span>, m)) % m;</span><br><span class="line"><span class="comment">//因为这样会导致额外的运算</span></span><br></pre></td></tr></table></figure></p>
<p>To Be Continue…</p>
<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>双指针法分为两种，一种是首尾指针，一种是快慢指针，前者用于</p>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h2 id="其他高效技巧与算法"><a href="#其他高效技巧与算法" class="headerlink" title="其他高效技巧与算法"></a>其他高效技巧与算法</h2><h3 id="回溯（动态规划）"><a href="#回溯（动态规划）" class="headerlink" title="回溯（动态规划）"></a>回溯（动态规划）</h3><p>动态规划的关键就是将一个问题划分成几个相互之间有交集的子问题。典型的问题就是求最优解的问题，可以从前到后，不断将最优的解放到数组中，这样要求解该轮下的最优解，只需要将所有情况都试一遍，然后比较出最优的那一个即可。这个过程就像是遍历一棵树，找到最优子节点，然后以子节点作为头节点继续遍历，直到满足条件。</p>
<p><img src="https://img-blog.csdnimg.cn/20210317102844192.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>动态规划问题的分析模式：</p>
<blockquote>
<p>1.分析最优解的结构<br>2.递归地定义最优解的值<br>3.计算最优解（从低向上）<br>4.展示结果</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#找出数组中两两不相邻的数字的最大值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">de_opt</span>(<span class="params">arr</span>):</span><br><span class="line">	opt = np.zeros(<span class="built_in">len</span>(arr))</span><br><span class="line">	opt[<span class="number">0</span>] = arr[<span class="number">0</span>]</span><br><span class="line">	opt[<span class="number">1</span>] = <span class="built_in">max</span>(arr[<span class="number">0</span>], arr[<span class="number">1</span>])</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">len</span>(arr)):</span><br><span class="line">		A = opt[i-<span class="number">2</span>] + arr[i]</span><br><span class="line">		B = opt[i-<span class="number">1</span>]</span><br><span class="line">		opt[i] = <span class="built_in">max</span>(A,B)</span><br><span class="line">	<span class="keyword">return</span> opt[<span class="built_in">len</span>(arr) - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#递归写法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rec_opt</span>(<span class="params">arr, i</span>)</span><br><span class="line">	<span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">return</span> arr[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">elif</span> i == <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">max</span>(arr[<span class="number">0</span>], arr[<span class="number">1</span>])</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		A = rec_opt(arr, i - <span class="number">2</span>) + arr[i]</span><br><span class="line">		B = rec_opt(arr, i - <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">max</span>(A, B)</span><br></pre></td></tr></table></figure>
<p>回溯（sù）：将选择一种情况作为一个结果，然后将不选择该情况作为另一个结果，找出两种情况的最优解，得到局部的最优解。<br><img src="https://img-blog.csdnimg.cn/20210317104724690.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-02-25T02:46:43.000Z" title="2/25/2021, 10:46:43 AM">2021-02-25</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-03-08T11:44:22.495Z" title="3/8/2023, 7:44:22 PM">2023-03-08</time></span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/02/25/%E3%80%8A%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%83%A8%E5%88%86-STL-%E9%93%BE%E8%A1%A8-%E6%A0%91/">《算法笔记》数据结构部分(STL&amp;链表&amp;树)</a></p><div class="content"><h1 id="C-STL"><a href="#C-STL" class="headerlink" title="C++ STL"></a>C++ STL</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个栈</span></span><br><span class="line">stack &lt;<span class="keyword">typename</span>&gt; name;</span><br><span class="line"></span><br><span class="line"><span class="comment">//stack函数实例</span></span><br><span class="line">stack.<span class="built_in">push</span>(x);<span class="comment">//将元素x加入到栈中</span></span><br><span class="line">stack.<span class="built_in">top</span>();<span class="comment">//获取栈顶元素</span></span><br><span class="line">stack.<span class="built_in">pop</span>();<span class="comment">//将栈顶元素弹出</span></span><br><span class="line">stack.<span class="built_in">empty</span>();<span class="comment">//判断栈是否为空，返回值类型为空</span></span><br><span class="line">stack.<span class="built_in">size</span>();<span class="comment">//返回栈内元素</span></span><br></pre></td></tr></table></figure>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队列的定义</span></span><br><span class="line">queue&lt; <span class="keyword">typename</span> &gt; name;</span><br><span class="line"></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line"><span class="comment">//queue函数实例</span></span><br><span class="line">Q.<span class="built_in">push</span>(x);<span class="comment">//将元素x入队</span></span><br><span class="line">Q.<span class="built_in">front</span>();<span class="comment">//获取队首元素</span></span><br><span class="line">Q.<span class="built_in">back</span>();<span class="comment">//获取队尾元素</span></span><br><span class="line">Q.<span class="built_in">pop</span>();<span class="comment">//将队首元素出队</span></span><br><span class="line">Q.<span class="built_in">empty</span>();<span class="comment">//判断队列是否为空</span></span><br><span class="line">Q.<span class="built_in">size</span>();<span class="comment">//队列中元素的个数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="优先队列（Priority-queue）"><a href="#优先队列（Priority-queue）" class="headerlink" title="优先队列（Priority_queue）"></a>优先队列（Priority_queue）</h3><p>优先队列就是按照元素的优先级来确定对首部的元素的队列，它是由堆实现的，这种优先级的规则可以自定义。优先队列可以用于计算哈夫曼树最短路径权值，可以对Dijkstra算法进行优化，还可以解决一些贪心问题。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	priority_queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">	q.<span class="built_in">push</span>(<span class="number">3</span>);<span class="comment">//将3入队</span></span><br><span class="line">	q.<span class="built_in">empty</span>();<span class="comment">//检查队列是否为空</span></span><br><span class="line">	q.<span class="built_in">pop</span>();<span class="comment">//将优先级最高的元素出队</span></span><br><span class="line">	q.<span class="built_in">size</span>();<span class="comment">//队列的大小</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//第一个参数是元素类型，第二个是承载底层数据结构堆的容器，第三个是参数的比较类，less&lt;int&gt;表示数字越大优先级越高</span></span><br><span class="line">	priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt;q_1;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//当想以结构体中的数据作为优先级的时候，应该堆操作符进行重载</span></span><br><span class="line"><span class="comment">//使用时直接将相应的结构体定义的变量直接入队即可</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">fruit</span> {</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> price;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//价格高的优先级高</span></span><br><span class="line">	<span class="comment">//由于队列默认将优先级高的放在队首，如果将小于号重载为大于号，最后会将规则反向</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt; (fruit f1, fruit f2) {</span><br><span class="line">		<span class="keyword">return</span> f1.price &lt; f2.price;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以将比较函数写在结构体外面</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span>{	</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(fruit f1, fruit f2)</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> f1.price &gt; f2.price;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line">priority_queue&lt;fruit, vector&lt;<span class="type">int</span>&gt;, cmp&gt;p_2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当结构体数据较大应该使用引用来提高效率</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">friend bool operator &lt; (const fruit&amp; f1, const fruit&amp; f2) {</span></span><br><span class="line"><span class="comment">	....</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
<h2 id="pair采用方法"><a href="#pair采用方法" class="headerlink" title="pair采用方法"></a>pair采用方法</h2><p>pair可以用于快速定义一个相当于拥有两个变量的结构体。使用pair需要添加函数头utility.当然map函数头中包含前者。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个pair变量，并初始化</span></span><br><span class="line">pair&lt;typename1, typename2&gt;<span class="built_in">name</span>(initial1, initial2);</span><br><span class="line"><span class="comment">//定义一个临时pair变量</span></span><br><span class="line">name = <span class="built_in">make_pair</span>(initial1, initial2);</span><br></pre></td></tr></table></figure></p>
<h3 id="pair函数的操作"><a href="#pair函数的操作" class="headerlink" title="pair函数的操作"></a>pair函数的操作</h3><p><strong>比较两个pair函数</strong>:可以直接用比较符，规则是先比较第一个的大小，当相等时比较第二个元素的大小<br><strong>常见用途</strong>：1.代替二元结构体机器构造函数。2.作为map的键值进行插入。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	map&lt;string, <span class="type">int</span>&gt;mp;<span class="comment">//定义一个哈希表</span></span><br><span class="line">	<span class="comment">//往哈希表中插入两个对键值</span></span><br><span class="line">	mp.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">"hey"</span>, <span class="number">5</span>));</span><br><span class="line">	mp.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;string, <span class="type">int</span>&gt;(<span class="string">"Hei"</span>, <span class="number">10</span>));</span><br><span class="line">	<span class="comment">//利用迭代器遍历哈希表</span></span><br><span class="line">	<span class="keyword">for</span>(map&lt;string, <span class="type">int</span>&gt;::iterator it = mp.<span class="built_in">begin</span>();it != mp.<span class="built_in">end</span>();++it){</span><br><span class="line">		cout&lt;&lt;it-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h2><p>需要包含文件头vector 和using namespace std;<br>定义方式：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">typename</span>&gt; vector_name;</span><br></pre></td></tr></table></figure><br>操作：<br>1.获取元素的最后一个元素<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector_name.<span class="built_in">end</span>()<span class="number">-1</span>;<span class="comment">//注意end是指向最后一个元素的下一位</span></span><br><span class="line">vector_name.<span class="built_in">back</span>();</span><br><span class="line">vector_name.<span class="built_in">rbegine</span>();</span><br><span class="line">vector_name.<span class="built_in">at</span>(vector_name.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br></pre></td></tr></table></figure></p>
<h2 id="集合set"><a href="#集合set" class="headerlink" title="集合set"></a>集合set</h2><p>集合是一种内部有序且不含重复元素的容器。当数据加入到集合中是，会自动去重和排序，默认排序是从小到大。要使用集合需要加上set函数头，并且使用std名字空间。</p>
<p>定义方式：(其实容器定义的方式都大同小异)</p>
<blockquote>
<p>迭代器不是指针，是类模板，表现的像指针。他只是模拟了指针的一些功能，通过重载了指针的一些操作符，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.452ex;" xmlns="http://www.w3.org/2000/svg" width="20.49ex" height="2.149ex" role="img" focusable="false" viewbox="0 -750 9056.4 950"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mo" transform="translate(1055.8,0)"><path data-c="3E" d="M84 520Q84 528 88 533T96 539L99 540Q106 540 253 471T544 334L687 265Q694 260 694 250T687 235Q685 233 395 96L107 -40H101Q83 -38 83 -20Q83 -19 83 -17Q82 -10 98 -1Q117 9 248 71Q326 108 378 132L626 250L378 368Q90 504 86 509Q84 513 84 520Z"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(2111.6,0)"><g data-mml-node="mo"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">、</text></g></g><g data-mml-node="mo" transform="translate(3333.8,0)"><path data-c="2217" d="M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(4056,0)"><g data-mml-node="mo"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">、</text></g></g><g data-mml-node="mo" transform="translate(5278.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mo" transform="translate(6278.4,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(7056.4,0)"><g data-mml-node="mo"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">、</text></g></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(8056.4,0)"><g data-mml-node="mo"><path data-c="2014" d="M0 248V285H999V248H0Z"/></g></g></g></g></svg></mjx-container>等封装了指针<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="keyword">typename</span>&gt; name;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>访问方式：（集合只能通过迭代器访问）<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义迭代器</span></span><br><span class="line">set&lt;<span class="keyword">typename</span>&gt;::iterator it;</span><br><span class="line"></span><br><span class="line"><span class="comment">//除了vector和string之外，其他的STL都不支持*（it+1）的访问方式</span></span><br><span class="line"><span class="comment">//枚举</span></span><br><span class="line">set&lt;<span class="type">int</span>&gt;st;</span><br><span class="line"><span class="comment">//initialize</span></span><br><span class="line">.......</span><br><span class="line"><span class="keyword">for</span>(set&lt;<span class="type">int</span>&gt;::iterator it = st.<span class="built_in">begin</span>(); it != st.<span class="built_in">end</span>();it++){</span><br><span class="line">	<span class="built_in">visit</span>(*it);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><br>set常用的函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">insert</span>(x);<span class="comment">//将x加入set，并实现递增排序和去重(O(logN))</span></span><br><span class="line"><span class="built_in">find</span>(value);<span class="comment">//找到对应value的迭代器(O(logN))</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">erase</span>(it);<span class="comment">//删除迭代器所指的元素，可以通过find函数找到对应的迭代器</span></span><br><span class="line"><span class="built_in">erase</span>(value);<span class="comment">//删除值为value的元素。时间复杂度O(logN)</span></span><br><span class="line"><span class="built_in">erase</span>(first, last);<span class="comment">//删除区间元素，删除区间为[first, last)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">size</span>();<span class="comment">//set中元素的个数O（1）</span></span><br><span class="line"><span class="built_in">clear</span>();<span class="comment">//delete all elements within the set </span></span><br></pre></td></tr></table></figure><br>使用unordered_set,只进行去重而不进行排序，速度比set要快很多。</p>
<h2 id="字符串类型String"><a href="#字符串类型String" class="headerlink" title="字符串类型String"></a>字符串类型String</h2><p>string类型将字符串数组的一些常用操作封装起来，使用时需要添加文件头string（注意一点string和string.h是不一样的），还需要std的名字空间。<br>初始化<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//define &amp; initializing</span></span><br><span class="line">string str = <span class="string">"abc"</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Access</span></span><br><span class="line"><span class="comment">//1.By subindex</span></span><br><span class="line">str[<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<p>想要输入或者输出字符串，只能使用cin和cout。需要用printf输出，可以使用c_str()函数将string类型转换成字符串数组<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,str.<span class="built_in">c_str</span>());</span><br></pre></td></tr></table></figure><br>通过迭代器访问<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//define. It no needs typename </span></span><br><span class="line">string::iterator it;</span><br><span class="line"><span class="keyword">for</span>(string::iterator it = str.<span class="built_in">begin</span>(); it != str.<span class="built_in">end</span>();++it){</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%c"</span>, *it);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><br>string和vector一样，能够直接通过对迭代器加减某数字实现访问。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.<span class="built_in">begin</span>() + <span class="number">3</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="函数实例"><a href="#函数实例" class="headerlink" title="函数实例"></a>函数实例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//连接两string类型</span></span><br><span class="line">str3 = str2 + str1;</span><br><span class="line">str1 += str2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按照字典序比较两string类型的大小</span></span><br><span class="line">str1 &gt;= str2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回string类型的长度</span></span><br><span class="line">str.<span class="built_in">size</span>();</span><br><span class="line">str.<span class="built_in">length</span>();</span><br></pre></td></tr></table></figure>
<p>insert()函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str.<span class="built_in">insert</span>(pos,string);<span class="comment">//在str的第pos位插入stringO(N)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//str的3号位插入str2</span></span><br><span class="line">(prototype-&gt;)<span class="built_in">insert</span>(it,it2,it3);<span class="comment">//串[it2, it3)插入到it对应的位置上</span></span><br><span class="line">str.<span class="built_in">insert</span>(str.<span class="built_in">begin</span>() + <span class="number">3</span>, str2.<span class="built_in">begin</span>(), str2.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><br>erase()删除<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除单个元素</span></span><br><span class="line"><span class="built_in">erase</span>(it);<span class="comment">//删除元素的迭代器</span></span><br><span class="line"><span class="built_in">erase</span>(fist,last);<span class="comment">//删除区间[first, last)的元素</span></span><br><span class="line"><span class="built_in">erase</span>(pos,length);<span class="comment">//pos开始删除length个字符个数</span></span><br><span class="line"><span class="built_in">clear</span>();<span class="comment">//清空</span></span><br></pre></td></tr></table></figure><br>其他<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">substr</span>(pos,len);<span class="comment">//冲pos开始获取长度为len的子串</span></span><br><span class="line">string::npos; <span class="comment">//一个常数等于-1或者是unsigned_int的最大值，用于find函数失配的返回值</span></span><br><span class="line"><span class="built_in">find</span>(str2);<span class="comment">//找到str2在字符串中第一次出现的位置，找不到返回string::npos.时间复杂度O(nm)</span></span><br><span class="line"></span><br><span class="line">str.<span class="built_in">replace</span>(pos, len, str2);<span class="comment">//将str从pos位开始长度为len的子串替换成str2</span></span><br><span class="line">str.<span class="built_in">replace</span>(it1,it2,str2);<span class="comment">//把迭代器范围内[it1,it2)的子串换成str2</span></span><br></pre></td></tr></table></figure></p>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h3 id="链表的概念"><a href="#链表的概念" class="headerlink" title="链表的概念"></a>链表的概念</h3><p>链表的物理地址是可以是不连续的，但是链表逻辑上是连续的。链表包含两个部分，一个用于存储数据，一个用于存储下一个节点的内存地址，以保证逻辑上的连续。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链表的结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>{</span><br><span class="line">	<span class="keyword">typename</span> data;<span class="comment">//数据域</span></span><br><span class="line">	node* next;<span class="comment">//指针域</span></span><br><span class="line">};</span><br></pre></td></tr></table></figure></p>
<h3 id="链表节点的空间分配"><a href="#链表节点的空间分配" class="headerlink" title="链表节点的空间分配"></a>链表节点的空间分配</h3><p>为链表节点分配空间可以利用两种函数：malloc(C语言) 和new(C++)。但是在空间分配之后，需要队空间进行释放，否则在一些情况下就会导致<strong>内存泄漏</strong>（在一些大型程序中，可能会导致弃用的空间一直被占用，而使得无法申请新的空间）。</p>
<h4 id="malloc函数"><a href="#malloc函数" class="headerlink" title="malloc函数"></a>malloc函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typename</span>* p = (<span class="keyword">typename</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">typename</span>));</span><br><span class="line"><span class="comment">/*整个过程就是malloc函数申请一个于数据类型大小一致的空间，这个时</span></span><br><span class="line"><span class="comment">候返回的指针是void类型，然后将他强制转化成int类型，并分配给</span></span><br><span class="line"><span class="comment">typename指针。申请失败的时候会返回空指针</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//释放内存</span></span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="comment">//本质上就是将p指针指向空地址，原先的地址占用状态被修改</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="new运算符（推荐使用）"><a href="#new运算符（推荐使用）" class="headerlink" title="new运算符（推荐使用）"></a>new运算符（推荐使用）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//申请一个节点空间</span></span><br><span class="line"><span class="keyword">typename</span>* p = <span class="keyword">new</span> <span class="keyword">typename</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取消对该节点的占用</span></span><br><span class="line"><span class="built_in">delete</span>(p;</span><br></pre></td></tr></table></figure>
<h3 id="链表的基本操作"><a href="#链表的基本操作" class="headerlink" title="链表的基本操作"></a>链表的基本操作</h3><h4 id="创建链表（运用for语句实现）"><a href="#创建链表（运用for语句实现）" class="headerlink" title="创建链表（运用for语句实现）"></a>创建链表（运用for语句实现）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传入的数组为每个节点的数据域的值</span></span><br><span class="line"><span class="comment">//尾插法：需要一个链表最后一个节点的指针。</span></span><br><span class="line"><span class="function">node* <span class="title">create</span> <span class="params">(<span class="type">int</span> Array[])</span></span>{</span><br><span class="line">	node *p, *pre, *head;</span><br><span class="line">	head = <span class="keyword">new</span> node;<span class="comment">//创建头节点</span></span><br><span class="line">	head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	pre = head;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i){</span><br><span class="line">		<span class="comment">//创建新结点：1.申请空间；2.完成指针域和数据域的赋值</span></span><br><span class="line">		p = <span class="keyword">new</span> node;</span><br><span class="line">		p-&gt;data = Array[i];</span><br><span class="line">		p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//更新状态指针</span></span><br><span class="line">		pre-&gt;next = p;</span><br><span class="line">		pre = p;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">]</span><br><span class="line"><span class="comment">//注意一点在删除一个节点的时候需要有一个指向该节点的指针，以便后续删除该节点</span></span><br></pre></td></tr></table></figure>
<h3 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h3><p>静态链表的主要原理就是Hash。它利用数组的下标作为相应节点的地址，适用于节点地址是比较小的整数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态链表节点的定义方式</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>{</span><br><span class="line">	<span class="keyword">typename</span> data;</span><br><span class="line">	<span class="type">int</span> next;<span class="comment">//注意这里的地址是一个整型变量</span></span><br><span class="line">}node[size];</span><br></pre></td></tr></table></figure><br>需要注意一点：因为静态链表是由数组实现的，所以就可能需要对其进行排序，但是如果这时候结构体类型名和结构体变量名相同（是允许的），sort函数就与出现编译错误。<br>（例题：A1032）<br>静态链表的使用步骤：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义静态链表</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>{</span><br><span class="line">	<span class="type">int</span> address;</span><br><span class="line">	<span class="keyword">typename</span> data;</span><br><span class="line">	<span class="type">int</span> next;</span><br><span class="line">	XXX;<span class="comment">//节点的某些性质</span></span><br><span class="line">}node[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化静态链表:将性质量定义为正常情况达不到的数字</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAXN; ++i){</span><br><span class="line">	node[i].XXX = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//标记（针对性质操作）</span></span><br><span class="line"><span class="comment">//可以针对性质进行统计，标记</span></span><br><span class="line"><span class="type">int</span> p = begin, count = <span class="number">0</span>;<span class="comment">//用于开始遍历和统计</span></span><br><span class="line"><span class="keyword">while</span>(p != <span class="number">-1</span>){</span><br><span class="line">	XXX = <span class="number">1</span>;</span><br><span class="line">	count++;</span><br><span class="line">	p = node[p]-&gt;next;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//简化操作</span></span><br><span class="line"><span class="comment">//由于静态链表直接采用地址映射的方式，这可能会导致地址</span></span><br><span class="line"><span class="comment">//不是连续的，此时应该将有效节点转移到左端，可以通过排</span></span><br><span class="line"><span class="comment">//序（sort函数）来实现（结合初始化的值）</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><h3 id="深度优先搜索（DFS）"><a href="#深度优先搜索（DFS）" class="headerlink" title="深度优先搜索（DFS）"></a>深度优先搜索（DFS）</h3><p>深度优先遍历会优先解决一种情况下的所有情况之后，再去解决其他的情况。如果能将一个事件的各个情况写成树形结构，就可以很容易地通过这种方法解决。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">有n 件物品，每件物品的重量为w[i］，价值为c[i］。现在需要选出若干件物品放入一个容</span></span><br><span class="line"><span class="comment">量为V 的背包中，使得在选入背包的物品重量和不超过容量V 的前提下，让背包中物品的价</span></span><br><span class="line"><span class="comment">值之和最大，求最大价值。(l&lt;n&lt;20)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">30</span>;</span><br><span class="line"><span class="type">int</span> n;<span class="comment">//物品数量</span></span><br><span class="line"><span class="type">int</span> V;<span class="comment">//背包容量</span></span><br><span class="line"><span class="type">int</span> maxValue = <span class="number">0</span>;<span class="comment">//最大的价值</span></span><br><span class="line"><span class="type">int</span> w[maxn], c[maxn];<span class="comment">//分别为单个物品的重量个价值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//参数分别为物品编号，总质量，总价值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> sumW, <span class="type">int</span> sumC)</span></span>{</span><br><span class="line">	<span class="keyword">if</span> (index == n) {<span class="comment">//完成对所有物品的选用</span></span><br><span class="line">		<span class="keyword">if</span> (sumW &lt;= V &amp;&amp; sumC &gt; maxValue) {<span class="comment">//检查当前方案是否满足条件</span></span><br><span class="line">			maxValue = sumC;<span class="comment">//更新最大价值</span></span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//对index号的物品，有两种结果，放入背包或是不放入背包</span></span><br><span class="line">	<span class="built_in">DFS</span>(index + <span class="number">1</span>, sumW, sumC);<span class="comment">//不放入背包</span></span><br><span class="line">	<span class="built_in">DFS</span>(index + <span class="number">1</span>, sumW + w[index], sumC + c[index]);<span class="comment">//放入背包</span></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;V);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) {</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;w[i]);<span class="comment">//重量</span></span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) {</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;c[i]);<span class="comment">//价值</span></span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">DFS</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//从第零件物品开始，此时的价值和重量都是0</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, maxValue);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><br>注意到在加入index号的物品时，总重量发生变化，这可能会导致结果不满足条件，<u>如果能在进入递归之前能够进行检查，能够减少一些不必要的递归</u><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在递归之前加上判断条件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS_A</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> sumW, <span class="type">int</span> sumC)</span> </span>{</span><br><span class="line">	<span class="keyword">if</span>(index == n)<span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">DFS_A</span>(index + <span class="number">1</span>, sumW, sumC);</span><br><span class="line">	<span class="comment">//检查质量是否满足要求，以确定是否进入递归</span></span><br><span class="line">	<span class="keyword">if</span> (sumW + w[index] &lt;= V) {</span><br><span class="line">		<span class="keyword">if</span> (sumC + c[index] &gt; maxValue)maxValue = sumC + c[index];</span><br><span class="line">		<span class="built_in">DFS_A</span>(index + <span class="number">1</span>, sumW + w[index], sumC + c[index]);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></table></figure><br>深度优先遍历的方法可以用于解决获取最优“子序列”的问题，也就是满足基本条件下的最优序列。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">问题描述：给定N个整数，从中选择K个数，使这K个数之和恰好等于给定的整数X，求出元素</span></span><br><span class="line"><span class="comment">平方和最大的结果</span></span><br><span class="line"><span class="comment">算法思想：利用一个数组，将已经选择的整数放入其中，当选择index号数字时，将</span></span><br><span class="line"><span class="comment">这个数字加入到数组中，进入递归，之后再将这个数字取出，进入不选择index号数</span></span><br><span class="line"><span class="comment">的递归。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k, x, maxSumSqu = <span class="number">-1</span>, A[maxn];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;temp, ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS_BSqu</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> nowK, <span class="type">int</span> sum, <span class="type">int</span> sumSqu)</span> </span>{</span><br><span class="line">	<span class="keyword">if</span> (nowK == k &amp;&amp; sum == x) {</span><br><span class="line">		<span class="keyword">if</span> (sumSqu &gt; maxSumSqu) {</span><br><span class="line">			maxSumSqu = sumSqu;</span><br><span class="line">			ans = temp;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (index == n || nowK &gt; k || sum &gt; x)<span class="keyword">return</span>;</span><br><span class="line">	temp.<span class="built_in">push_back</span>(A[index]);</span><br><span class="line">	<span class="built_in">DFS_BSqu</span>(index + <span class="number">1</span>, nowK + <span class="number">1</span>, sum + A[index], sumSqu + A[index] * A[index]);</span><br><span class="line">	temp.<span class="built_in">pop_back</span>();</span><br><span class="line">	<span class="built_in">DFS_BSqu</span>(index + <span class="number">1</span>, nowK, sum, sumSqu);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="广度优先"><a href="#广度优先" class="headerlink" title="广度优先"></a>广度优先</h3><p>广度优先类似于先解决简单的问题（离起点最近）然后再一步步深入。广度优先会先遍历所有的情况，对于求最优解的情况有优势。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">问题描述：给定一个n*m大小的迷宫，其中*代表不可通过的墙</span></span><br><span class="line"><span class="comment">壁，而“.”代表平地，S表示起点，T代表终点。移动过程中，如</span></span><br><span class="line"><span class="comment">果当前位置是（x,y）（下标从0开始），且每次只能往前上下</span></span><br><span class="line"><span class="comment">左右移动，求从起点到终点的最小步数。</span></span><br><span class="line"><span class="comment">算法思想：可以将迷宫当作树型结构，将迷宫的起点作为树的</span></span><br><span class="line"><span class="comment">根节点现在问题转换成找到迷宫终点所在树的层数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> x, y;<span class="comment">//记录当前的位置</span></span><br><span class="line">	<span class="type">int</span> step;<span class="comment">//步数（层数）</span></span><br><span class="line">}S,T,Node;<span class="comment">//分别为起点，重点，临时节点</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;<span class="comment">//分别为行，列</span></span><br><span class="line"><span class="type">char</span> maze[maxn][maxn];<span class="comment">//迷宫信息</span></span><br><span class="line"><span class="type">bool</span> inq[maxn][maxn] = { <span class="literal">false</span> };<span class="comment">//检查此位置是否遍历过</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//增量数组，XY组合表示一个节点上下左右四个方向的位置</span></span><br><span class="line"><span class="type">int</span> X[<span class="number">4</span>] = { <span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span> };</span><br><span class="line"><span class="type">int</span> Y[<span class="number">4</span>] = { <span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span> };</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查（x,y）这个位置是否应该入队</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">test</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>{</span><br><span class="line">	<span class="comment">//超出边界</span></span><br><span class="line">	<span class="keyword">if</span> (x &gt;= n || x &lt; <span class="number">0</span> || y &gt;= m || y &lt; <span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="comment">//遇到墙壁</span></span><br><span class="line">	<span class="keyword">if</span> (maze[x][y] == <span class="string">'*'</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="comment">//检查是否入队。入队则是之前访问过的位置</span></span><br><span class="line">	<span class="keyword">if</span> (inq[x][y] == <span class="literal">true</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//表示该位置有效</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BFS</span><span class="params">()</span> </span>{</span><br><span class="line">	queue&lt;node&gt;q;</span><br><span class="line">	q.<span class="built_in">push</span>(S);<span class="comment">//将起点加入到队列中</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断当前访问的位置（出队的位置）是否为终点</span></span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) {</span><br><span class="line">		node top = q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="comment">//该位置为终点，直接返回此时的深度</span></span><br><span class="line">		<span class="keyword">if</span> (top.x == T.x &amp;&amp; top.y == T.y) {</span><br><span class="line">			<span class="keyword">return</span> top.step;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="comment">//检查该位置4个方向上的情况</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) {</span><br><span class="line">			<span class="type">int</span> newX = top.x + X[i];</span><br><span class="line">			<span class="type">int</span> newY = top.y + Y[i];</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">test</span>(newX, newY)) {</span><br><span class="line">				<span class="comment">//新节点，更新相关的信息</span></span><br><span class="line">				Node.x = newX, Node.y = newY;</span><br><span class="line">				Node.step = Node.step + <span class="number">1</span>;</span><br><span class="line">				q.<span class="built_in">push</span>(Node);</span><br><span class="line">				inq[newX][newY] = <span class="literal">true</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>{</span><br><span class="line">	<span class="comment">//迷宫规格</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="comment">//传入迷宫信息</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) {</span><br><span class="line">		<span class="built_in">getchar</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) {</span><br><span class="line">			maze[i][j] = <span class="built_in">getchar</span>();</span><br><span class="line">		}</span><br><span class="line">		maze[i][m + <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;S.x, &amp;S.y, &amp;T.x, &amp;T.y);</span><br><span class="line">	S.step = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="built_in">BFS</span>());</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>值得注意的一点，当将一个元素push入队的时候，其本质就是将该元素的一个副本入队，所以，队列中的元素和原数据来源是相互独立的。</p>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>二叉树可以通过递归的方式定义，也就是可以将二叉树的子树看作一个新的二叉树。注意一点，二叉树的左右节点是由严格区分的。</p>
<h3 id="二叉树的存储和操作"><a href="#二叉树的存储和操作" class="headerlink" title="二叉树的存储和操作"></a>二叉树的存储和操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树结构体的定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>{</span><br><span class="line">	<span class="keyword">typename</span> data;</span><br><span class="line">	node* lchild;</span><br><span class="line">	node* rchild;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">node* root = <span class="literal">NULL</span>;<span class="comment">//建树之前根节点不存在，将其设为NULL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//新建节点:申请空间，赋值，初始化，返回节点地址</span></span><br><span class="line"><span class="function">node* <span class="title">newNode</span><span class="params">(<span class="type">int</span> v)</span></span>{</span><br><span class="line">	node* Node = <span class="keyword">new</span> node;</span><br><span class="line">	Node-&gt;data = v;</span><br><span class="line">	Node-&gt;lchild = Node-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> Node;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//搜索节点:检查特殊情况和满足条件的情况，然后用同样的方法检查其他的节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">search</span><span class="params">(node* root, <span class="type">int</span> x, <span class="type">int</span> newdata)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>)<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(root-&gt;data == x)root-&gt;data = newdata;</span><br><span class="line">	<span class="built_in">search</span>(root-&gt;lchild, x, newdata);</span><br><span class="line">	<span class="built_in">search</span>(root-&gt;rchild, x, newdata);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树节点的插入,注意这里输入的参数是引用型的，因为要对这个树进行修改</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(node* &amp;root, <span class="type">int</span> x)</span></span>{</span><br><span class="line">	<span class="comment">//查找失败，这就是要插入节点的地方</span></span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>){</span><br><span class="line">		root = <span class="built_in">newNode</span>(x);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(根据条件检查检索的方向)<span class="built_in">insert</span>(root-&gt;lchild,x);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">insert</span>(root-&gt;rchild,x);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树的建立</span></span><br><span class="line"><span class="function">node* <span class="title">Create</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> n)</span></span>{</span><br><span class="line">	node* root = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i){</span><br><span class="line">		<span class="built_in">insert</span>(root,data[i]);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p><img src="https://img-blog.csdnimg.cn/20210401083819611.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*中序遍历（非递归）：先找到最左边的节点，在寻找的过程中将途中的节点加入到栈中，当遇到根节点的时候，</span></span><br><span class="line"><span class="comment">取出栈顶元素（这一步相当于回溯），访问其右节点，然后继续原先的循环</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrderWithoutRecursion2</span><span class="params">(BTNode* root)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">//空树</span></span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">//树非空</span></span><br><span class="line">	BTNode* p = root;</span><br><span class="line">	stack&lt;BTNode*&gt; s;</span><br><span class="line">	<span class="keyword">while</span> (!s.<span class="built_in">empty</span>() || p)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (p)</span><br><span class="line">		{</span><br><span class="line">			s.<span class="built_in">push</span>(p);</span><br><span class="line">			p = p-&gt;lchild;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			p = s.<span class="built_in">top</span>();</span><br><span class="line">			s.<span class="built_in">pop</span>();</span><br><span class="line">			cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">4</span>) &lt;&lt; p-&gt;data;</span><br><span class="line">			p = p-&gt;rchild;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">先序遍历（非递归）：在访问头节点的同时先将右节点加入到栈中，然后再继续访问左子树。当没有左孩子的时候</span></span><br><span class="line"><span class="comment">访问右节点，表现为取出栈顶元素，进行访问</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrderWithoutRecursion</span><span class="params">(BTNode* root)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>)<span class="keyword">return</span>;</span><br><span class="line">	stack&lt;BTNode*&gt;s;</span><br><span class="line">	BTNode* p = root;</span><br><span class="line">	s.<span class="built_in">push</span>(root);</span><br><span class="line">	<span class="keyword">while</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">visit</span>(p);</span><br><span class="line">		<span class="keyword">if</span>(p-&gt;rchild)s.<span class="built_in">push</span>(p-&gt;rchild);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(p-&gt;lchild)p = p-&gt;lchild;</span><br><span class="line">		<span class="keyword">else</span>{<span class="comment">//访问右子树</span></span><br><span class="line">			p = s.<span class="built_in">top</span>();</span><br><span class="line">			s.<span class="built_in">pop</span>();</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">后序遍历（非递归）：后序遍历有一个问题，需要当前访问的节点是父节点的左孩子还是右孩子，如果是左孩子，就访问</span></span><br><span class="line"><span class="comment">右孩子，否则访问头节点。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postOrderWithoutRecursion</span><span class="params">(BTNode* root)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>)<span class="keyword">return</span>;</span><br><span class="line">	stack&lt;BTNode*&gt;s;</span><br><span class="line">	BTNode* pCur, *pLastVisit;</span><br><span class="line"></span><br><span class="line">	pCur = root;</span><br><span class="line">	pLastVisit = <span class="literal">NULL</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//Find out the leftmost element of the tree.</span></span><br><span class="line">	<span class="keyword">while</span>(pCur){</span><br><span class="line">		s.<span class="built_in">push</span>(pCur);</span><br><span class="line">		pCur = pCur-&gt;lchild;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">while</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">	{</span><br><span class="line">		pCur = s.<span class="built_in">top</span>();</span><br><span class="line">		s.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//访问头节点的条件：无右孩子或者是右孩子已经被访问</span></span><br><span class="line">		<span class="keyword">if</span>(pCur-&gt;rchild == <span class="literal">NULL</span> || pCur-&gt;rchild == pLastVisit){</span><br><span class="line">			<span class="built_in">visit</span>(pCur);</span><br><span class="line">			pLastVisit = pCur;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span>{</span><br><span class="line">			s.<span class="built_in">push</span>(pCur);</span><br><span class="line">			pCur = pCur-&gt;rchild;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//找到右子树的最左边的节点</span></span><br><span class="line">			<span class="keyword">while</span>(pCur){</span><br><span class="line">				s.<span class="built_in">push</span>(pCur);</span><br><span class="line">				pCur = pCur-&gt;lchild;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归版</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">xOrder</span><span class="params">(node* root)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>)<span class="keyword">return</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//'* = printf("%d\n",root-&gt;data);</span></span><br><span class="line">	*<span class="comment">//前序遍历</span></span><br><span class="line">	<span class="built_in">xOrder</span>(root-&gt;lchild);</span><br><span class="line">	*<span class="comment">//中序遍历</span></span><br><span class="line">	<span class="built_in">xOrder</span>(root-&gt;rchild);</span><br><span class="line">	*<span class="comment">//后序遍历</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//层次遍历:每次完成一个节点的遍历，就需要检查其是否为叶子节点，否则加入到队列中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LayerOrder</span><span class="params">(node* root)</span></span>{</span><br><span class="line">	queue&lt;node*&gt;q;</span><br><span class="line">	q.<span class="built_in">push</span>(root);</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>()){</span><br><span class="line">		node* now = q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d"</span>,now-&gt;data);</span><br><span class="line">		<span class="keyword">if</span>(now-&gt;lchild != <span class="literal">NULL</span>)q.<span class="built_in">push</span>(now-&gt;lchhild);</span><br><span class="line">		<span class="keyword">if</span>(now-&gt;rchild != <span class="literal">NULL</span>)q.<span class="built_in">push</span>(now-&gt;rchild);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果还想要直到当前节点所在的层数，可以在结构体中做好标记</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>{</span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">	<span class="type">int</span> layer;</span><br><span class="line">	node* lchild;</span><br><span class="line">	node* rchild;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LayerOrder</span><span class="params">(node* root)</span></span>{</span><br><span class="line">	queue&lt;node*&gt;<span class="number">1</span>;</span><br><span class="line">	root-&gt;layer = <span class="number">1</span>;</span><br><span class="line">	q.<span class="built_in">push</span>(root);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>()){</span><br><span class="line">		node* now = q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d"</span>,now-&gt;data);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//更新节点信息之后，再将节点入队</span></span><br><span class="line">		<span class="keyword">if</span>(now-&gt;lchild != <span class="literal">NULL</span>){</span><br><span class="line">			now-&gt;lchild-&gt;layer = now-&gt;layer + <span class="number">1</span>;</span><br><span class="line">			q.<span class="built_in">push</span>(now-&gt;lchild);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(now-&gt;rchild != <span class="literal">NULL</span>){</span><br><span class="line">			now-&gt;rchild-&gt;layer = now-&gt;layer + <span class="number">1</span>;</span><br><span class="line">			q.<span class="built_in">push</span>(now-&gt;rchild);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="树的静态实现-非二叉树"><a href="#树的静态实现-非二叉树" class="headerlink" title="树的静态实现(非二叉树)"></a>树的静态实现(非二叉树)</h3><p>实现静态写法是为了避免指针可能带来的错误。主要的思想就是将树的孩子节点存储在一个向量（“变长数组”）中。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>{</span><br><span class="line">	<span class="keyword">typename</span> data;</span><br><span class="line">	vector&lt;node&gt; child;<span class="comment">//??</span></span><br><span class="line">}Node[maxn];</span><br><span class="line"><span class="comment">//如果不需要数据域，可以用如下方法定义</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;child[maxn];<span class="comment">//这里定义了maxn个向量</span></span><br></pre></td></tr></table></figure></p>
<h3 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先序遍历：先访问节点，之后递归地遍历其孩子节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(<span class="type">int</span> root)</span></span>{</span><br><span class="line">	<span class="built_in">visit</span>(root);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; Node[root].child.<span class="built_in">size</span>();++i){</span><br><span class="line">		<span class="built_in">PreOrder</span>(Node[root].child[i]);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="comment">//层序遍历：先访问头节点，然后将孩子节点入队，直到队列为空</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LayerOrder</span><span class="params">(<span class="type">int</span> root)</span></span>{</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt;Q;</span><br><span class="line">	Q.<span class="built_in">push</span> (root);</span><br><span class="line">	<span class="keyword">while</span>(!Q.<span class="built_in">empty</span>()){</span><br><span class="line">		<span class="type">int</span> front = Q.<span class="built_in">front</span>();</span><br><span class="line">		Q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="built_in">visit</span>(Q);</span><br><span class="line">		<span class="comment">//下面是访问该节点所有孩子节点的方法</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; Node[front].child.<span class="built_in">size</span>();++i){</span><br><span class="line">			Q.<span class="built_in">push</span>(Node[front].child[i]);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h3><p>二叉查找树是节点按照一定规律排列的树，根节点的数据域大于或者小于左右孩子节点的数据域。同时二叉查找树还可以是一个空树。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉查找树的操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//新建一个节点：申请空间，赋值初始化，返回节点地址</span></span><br><span class="line"><span class="function">node* <span class="title">newNode</span><span class="params">(<span class="type">int</span> v)</span></span>{</span><br><span class="line">	node* Node = <span class="keyword">new</span> node;</span><br><span class="line">	Node-&gt;data = v;</span><br><span class="line">	Node-&gt;lchild = Node -&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> Node;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找二叉查找树中数据域为x的节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">search</span> <span class="params">(node* root, <span class="type">int</span> x)</span></span>{</span><br><span class="line">	<span class="comment">//递归出口</span></span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>){</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"search failed\n"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//根据当前节点值得情况，决定递归方向</span></span><br><span class="line">	<span class="keyword">if</span>(x == root-&gt;data)<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,root-&gt;data);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(x &lt; root-&gt;data) <span class="built_in">search</span>(root-&gt;lchild, x);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">search</span>(root-&gt;rchild, x);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入一个数据域为x的新节点（注意这里的root是需要引用，后续修改）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span> <span class="params">(node* &amp;root, <span class="type">int</span> x)</span></span>{</span><br><span class="line">	<span class="comment">//当查找失败的时候，这个地方即为节点插入的位置</span></span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>){</span><br><span class="line">		root = <span class="built_in">newNode</span>(x);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//由数据域的情况决定递归的方向</span></span><br><span class="line">	<span class="keyword">if</span>(x == root-&gt;data)<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(x &lt; root-&gt;data)<span class="built_in">insert</span>(root-&gt;lchild, x);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">insert</span>(root-&gt;rchild, x);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉查找树的建立</span></span><br><span class="line"><span class="function">node* <span class="title">Crate</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> n)</span></span>{</span><br><span class="line">	node* root = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//将数组数据找到一个合适的地方插入</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)<span class="built_in">insert</span>(root,data[i]);</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉查找树的删除</span></span><br><span class="line"><span class="comment">//可以用根节点的前去或者后继来代替被删除的头节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//找到极值点的过程就是不断向左或者向右的过程，直到遇到空节点</span></span><br><span class="line"><span class="comment">//找到以root为头节点的最大全职的节点</span></span><br><span class="line"><span class="function">node* <span class="title">findMax</span><span class="params">(node* root)</span></span>{</span><br><span class="line">	<span class="keyword">while</span>(root-&gt;child != <span class="literal">NULL</span>)root = root -&gt; rchild;</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//找到权值最小的节点</span></span><br><span class="line"><span class="function">node* <span class="title">findMin</span><span class="params">(node* root)</span></span>{</span><br><span class="line">	<span class="keyword">while</span>(root-&gt;lchild != <span class="literal">NULL</span>)root = root-&gt;lchild;</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除节点：想用前驱后者后继节点覆盖要删除的节点，然后问题就转换成删除前驱或后继节点</span></span><br><span class="line"><span class="comment">//先找到想要删除的节点，然后判断节点的类型，然后再进行相应的递归操作</span></span><br><span class="line"><span class="comment">//删除以root为根节点的权值为x的节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteNode</span><span class="params">(node* &amp;root, <span class="type">int</span> x)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>)<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">//找到需要删除的节点</span></span><br><span class="line">	<span class="keyword">if</span>(root-&gt;data == x){</span><br><span class="line">		<span class="comment">//当需要删除的节点为叶节点，直接删除</span></span><br><span class="line">		<span class="keyword">if</span>(root-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; root-&gt;rchild == <span class="literal">NULL</span>)root = <span class="literal">NULL</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//左孩子非空，则用右孩子的极值替换该节点，然后删除该极值节点</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;lchild != <span class="literal">NULL</span>){</span><br><span class="line">			node* pre = <span class="built_in">findMax</span>(root-&gt;lchild);</span><br><span class="line">			root-&gt;data = pre-&gt;data;</span><br><span class="line">			<span class="built_in">deleteNode</span>(root-&gt;lchild,pre-&gt;data);</span><br><span class="line">		}</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//右孩子非空，操作同上</span></span><br><span class="line">		<span class="keyword">else</span>{</span><br><span class="line">			node* next = <span class="built_in">findMin</span>(root-&gt;rchild);</span><br><span class="line">			root-&gt;data = next -&gt; data;</span><br><span class="line">			<span class="built_in">deleteNode</span>(root-&gt;rchild, next-&gt;data);</span><br><span class="line">		}</span><br><span class="line">	<span class="comment">//寻找需要删除的节点</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;data &gt; x)<span class="built_in">deleteNode</span>(root-&gt;lshild,x);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">deleteNode</span>(root-&gt;rchild, x);</span><br><span class="line">	}	</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>对于删除节点的操作，可以进行优化，主要里利用极值节点坑定没有左子树或右子树的性质，将该极值节点的子树直接连接到该极值节点的父节点上即可。<br>加入一直删除前驱或者后继，就会导致最后树变得十分不平衡，解决这个方法可以采取交替删除前驱后继或者是记录子树高度，优先在高度更高的的子树中删除节点。</p>
<h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>平衡二叉树是左右子树高度相差不超过1的二叉树。这样的结构可以保证在大多数操作下保持O(logn)的性能。因为当二叉树严重失衡时，二叉树退化成链表，此时操作的时间复杂度变为O(n)。在平衡二叉树中，右子树与左子树的高度之差称为该节点的<strong>平衡因子</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//节点结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>{</span><br><span class="line">	<span class="type">int</span> v, height;<span class="comment">//节点权值和子树高度</span></span><br><span class="line">	node* lchild, *rchild; </span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成一个新的节点</span></span><br><span class="line"><span class="function">node* <span class="title">newNode</span><span class="params">(<span class="type">int</span> v)</span></span>{</span><br><span class="line">	node* Node = <span class="keyword">new</span> node;<span class="comment">//申请节点空间</span></span><br><span class="line">	Node-&gt;v = v;<span class="comment">//节点权值</span></span><br><span class="line">	Node-&gt;height = <span class="number">1</span>;<span class="comment">//该节点本身的高度</span></span><br><span class="line">	Node-&gt;lchild = Node-&gt;rchild = <span class="literal">NULL</span>;<span class="comment">//初始化孩子节点</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取当前树的高度:从结构体变量中获取</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getHeight</span><span class="params">(node* root)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> root-&gt;height;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算平衡因子:左子树高度减去右子树高度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getBalanceFactor</span><span class="params">(node* root)</span></span>{</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">getHeight</span>(root-&gt;lchild) - <span class="built_in">getHeight</span>(root-&gt;rchild);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新当前节点的高度:孩子节点的最大高度加上节点本身</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateHeight</span><span class="params">(node* root)</span></span>{</span><br><span class="line">	root-&gt;height = <span class="built_in">max</span>(<span class="built_in">getHeight</span>(root-&gt;lchild), <span class="built_in">getHeight</span>(root-&gt;rchild)) + <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//ALV的查找操作与二叉排序树的操作完全一致</span></span><br></pre></td></tr></table></figure>
<p>对于ALV的插入操作，要根据树的结构做出相应的不同的操作。（BF：Balance Factor）<br>树型| 判定条件|调整方法|<br>—|———-|————-<br>LL| BF(root) = 2;BF(root-&gt;lchild) = 1|对root进行右旋|<br>LR|BF(root) = 2;BF(root-&gt;lchild) = -1|先对root-&gt;lchild进行左旋后对root进行右旋<br>RR|BF(root) = -2;BF(root-&gt;lchild) = -1|对root进行左旋<br>RL|BF(root) = -2;BF(root-&gt;lchild) = 1|先对右子树进行右旋，再对root左旋<br>通过表格，可以总结：L代表根节点是正数，R代表孩子节点的负数。<br>下图时LL和LR型的树的调整示意图<br><img src="https://img-blog.csdnimg.cn/20210223093952989.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210223094002206.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>注意到LR型是将LR先左旋转换成LL型的二叉树然后再执行右旋的，所以LR型的二叉树的调整可以由基本的左旋右旋组合而来。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左旋:将右孩子的左孩子连接到头节点处，其原先的左孩子连接到原先的头节点的右孩子处</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">L</span><span class="params">(node*&amp; root)</span></span>{</span><br><span class="line">	node* temp = root-&gt;rchild;</span><br><span class="line">	root-&gt;rchild = temp-&gt;lchild;</span><br><span class="line">	temp-&gt;lchild = root;</span><br><span class="line">	<span class="comment">//跟新调整之后的节点高度</span></span><br><span class="line">	<span class="built_in">updateHeight</span>(root);</span><br><span class="line">	<span class="built_in">uodateHeight</span>(temp);</span><br><span class="line">	root = temp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//右旋</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">R</span><span class="params">(node*&amp; root)</span></span>{</span><br><span class="line">	node* temp = root-&gt;lchild;</span><br><span class="line">	root-&gt;lchild = temp-&gt;rchild;</span><br><span class="line">	temp-&gt;rchild = root;</span><br><span class="line">	<span class="built_in">updateHeight</span>(root);</span><br><span class="line">	<span class="built_in">uodateHeight</span>(temp);</span><br><span class="line">	root = temp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入节点：找到插入的位置，判断插入后树的类型，然后再做相应的操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span> <span class="params">(node*&amp;root,<span class="type">int</span> v)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>){</span><br><span class="line">		root = <span class="built_in">newNode</span>(v);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//节点小，则在左子树中插入</span></span><br><span class="line">	<span class="keyword">if</span>(v &lt; root-&gt;v){</span><br><span class="line">		<span class="built_in">insert</span>(root-&gt;lchild,v);</span><br><span class="line">		<span class="comment">//更新节点信息，</span></span><br><span class="line">		<span class="built_in">updateHeight</span>(root);</span><br><span class="line">		<span class="comment">//L</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">getBalanceFactor</span>(root) == <span class="number">2</span>){</span><br><span class="line">			<span class="comment">//LL</span></span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">getBalanceFactor</span>(root-&gt;lchild)==<span class="number">1</span>) <span class="built_in">R</span>(root);</span><br><span class="line">			<span class="comment">//LR</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">getBalanceFactor</span>(root-&gt;lchild)==<span class="number">-1</span>){</span><br><span class="line">			<span class="built_in">L</span>(root-&gt;lchild);</span><br><span class="line">			<span class="built_in">R</span>(root);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span>{</span><br><span class="line">		<span class="comment">//从右子树中插入节点</span></span><br><span class="line">		<span class="built_in">insert</span>(root-&gt;rchild,v);</span><br><span class="line">		<span class="built_in">updateHeight</span>(root);</span><br><span class="line">		<span class="comment">//R</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">getBalanceFactor</span>(root) == <span class="number">-2</span>){</span><br><span class="line">			<span class="comment">//RR</span></span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">getBalanceFactor</span>(root-&gt;rchild)==<span class="number">-1</span>)<span class="built_in">L</span>(root);</span><br><span class="line">			<span class="comment">//RL</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">getBalanceFactor</span>(root-&gt;rchild) == <span class="number">1</span>){</span><br><span class="line">				<span class="built_in">R</span>(root-&gt;rchild);</span><br><span class="line">				<span class="built_in">L</span>(root);</span><br><span class="line">			}<span class="comment">//else if</span></span><br><span class="line">		}<span class="comment">//if</span></span><br><span class="line">	}<span class="comment">//else</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">//AVL树的建立</span></span><br><span class="line"><span class="function">node* <span class="title">Create</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> n)</span></span>{</span><br><span class="line">	node* root = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)<span class="built_in">insert</span>(root,data[i]);</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><blockquote>
<p>在计算机科学中，并查集（英文：Disjoint-set data structure，直译为不交集数据结构）是一种数据结构，用于处理一些不交集（Disjoint sets，一系列没有重复元素的集合）的合并及查询问题。并查集支持如下操作：<br>查询：查询某个元素属于哪个集合，通常是返回集合内的一个“代表元素”。这个操作是为了判断两个元素是否在同一个集合之中。<br>合并：将两个集合合并为一个。<br>添加：添加一个新集合，其中有一个新元素。添加操作不如查询和合并操作重要，常常被忽略。</p>
</blockquote>
<p>以下是并查集得一些基本操作。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> father[N];</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initialSet</span><span class="params">(<span class="type">int</span> father[], <span class="type">int</span> N)</span> </span>{</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) {</span><br><span class="line">		father[i] = i;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找:根节点的父节点就是其本身</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findFather</span><span class="params">(<span class="type">int</span> x)</span> </span>{</span><br><span class="line">	<span class="keyword">while</span> (x != father[x]) {</span><br><span class="line">		x = father[x];</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//递归版本</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findFatherRe</span><span class="params">(<span class="type">int</span> x)</span> </span>{</span><br><span class="line">	<span class="comment">//递归出口</span></span><br><span class="line">	<span class="keyword">if</span> (x == father[x])<span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">findFather</span>(father[x]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//并查集合并：先判断两节点是否再同一并查集中（判断根节点是否相同），然后再将其中一个根节点的父节点指向另一个根节点</span></span><br><span class="line"><span class="comment">//这样能能够保证并查集是个树型结构，不会出现环</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>{</span><br><span class="line">	<span class="type">int</span> faA = <span class="built_in">findFather</span>(a);</span><br><span class="line">	<span class="type">int</span> faB = <span class="built_in">findFather</span>(b);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//当二者不是统一并查集时合并</span></span><br><span class="line">	<span class="keyword">if</span> (faA != faB){</span><br><span class="line">		father[faA] = father[faB];</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//路径压缩：将搜索的时间复杂度由O(n)变为O(1)，其实就是将所有节点的父节点全部指向根节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findFatherPatheShorten</span><span class="params">(<span class="type">int</span> x)</span></span>{</span><br><span class="line">	<span class="type">int</span> a = x;<span class="comment">//找到根节点，同时保存初始节点</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//找到根节点</span></span><br><span class="line">	<span class="keyword">while</span> (x != father[x]) {</span><br><span class="line">		x = father[x];</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//将该节点的父节点指向根节点，并保存该节点原先的父节点的信息</span></span><br><span class="line">	<span class="keyword">while</span> (a != father[a]) {</span><br><span class="line">		<span class="type">int</span> z = a;</span><br><span class="line">		a = father[a];</span><br><span class="line">		father[z] = x;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归版本</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findFatherRSRec</span><span class="params">(<span class="type">int</span> v)</span> </span>{</span><br><span class="line">	<span class="keyword">if</span> (v == father[v])<span class="keyword">return</span> v;</span><br><span class="line">	<span class="keyword">else</span>{</span><br><span class="line">		<span class="type">int</span> F = <span class="built_in">findFather</span>(father[v]);</span><br><span class="line">		father[v] = F;</span><br><span class="line">		<span class="keyword">return</span> F;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>堆本质上就是满足父节点大于（或小于）孩子节点的二叉树。所有节点存储在一个数组当中，这样i节点的孩子节点分别为$2<em>i<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.452ex;" xmlns="http://www.w3.org/2000/svg" width="2.262ex" height="2.149ex" role="img" focusable="false" viewbox="0 -750 1000 950"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">和</text></g></g></g></svg></mjx-container>2</em>i+1$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> heap[maxn], n = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span> </span>{</span><br><span class="line">	<span class="type">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//向下调整O(logn)：从low到high。找出该节点得该子节点中最大得节点，然后于该节点进行比较，若孩子节点较大，则与孩子节点进行交换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">downAdjust</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high)</span> </span>{</span><br><span class="line">	<span class="type">int</span> i = low, j = i * <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">while</span> (j &lt;= high) {</span><br><span class="line">		<span class="comment">//找出孩子节点中较大的</span></span><br><span class="line">		<span class="keyword">if</span> (j + <span class="number">1</span> &lt;= high &amp;&amp; heap[j + <span class="number">1</span>] &gt; heap[j]) ++j;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//与父节点进行比较</span></span><br><span class="line">		<span class="keyword">if</span> (heap[j] &gt; heap[i]) {</span><br><span class="line">			<span class="built_in">swap</span>(heap[j], heap[i]);</span><br><span class="line">			i = j;</span><br><span class="line">			j = i * <span class="number">2</span>;<span class="comment">//这里只去检查被调整的元素是否满足堆的条件，因为为改动的节点应该是满足堆的要求的</span></span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span>{</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//建堆O(n):从最后一个非叶节点往后进行循环，这是对原先数组进行了排序，以满足堆的要求</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createHeap</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span>; i &gt;= <span class="number">1</span>; --i)<span class="built_in">downAdjust</span>(i, n);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除堆顶元素O(logn)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteTop</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="comment">//将最后一个元素代替堆顶元素，然后减少节点数量</span></span><br><span class="line">	heap[<span class="number">1</span>] = heap[n--];</span><br><span class="line">	<span class="built_in">downAdjust</span>(<span class="number">1</span>, n);<span class="comment">//改动了这个节点就从这个节点进行调整</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//向上调整：当插入一个节点的时候，这个节点被放到最后，逐个与其父节点比较，直到该节点小于父节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upAdjust</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high)</span></span>{</span><br><span class="line">	<span class="type">int</span> i = high, j = i / <span class="number">2</span>;<span class="comment">//high就是最后一个节点，即插入的节点</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//父节点在范围之内</span></span><br><span class="line">	<span class="keyword">while</span> (j &gt;= low) {</span><br><span class="line">		<span class="keyword">if</span> (heap[j] &lt; heap[i]) {</span><br><span class="line">			<span class="built_in">swap</span>(heap[j], heap[i]);</span><br><span class="line">			i = j;</span><br><span class="line">			j = i / <span class="number">2</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加元素，借用上面的函数:加入节点，然后进行相应的调整</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span> </span>{</span><br><span class="line">	heap[++n] = x;</span><br><span class="line">	<span class="built_in">upAdjust</span>(<span class="number">1</span>, n);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//堆排序:将头节点与最后一个节点进行交换，然后对堆进行调整</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="built_in">createHeap</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt; <span class="number">1</span>; i--){</span><br><span class="line">		<span class="built_in">swap</span>(heap[i], heap[<span class="number">1</span>]);</span><br><span class="line">		<span class="built_in">downAdjust</span>(<span class="number">1</span>, i - <span class="number">1</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<h3 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h3><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.iwiki.eu.org/wiki/File:Huffman_algorithm.gif">哈夫曼树构建过程</a><br>用语言描述就是，先将队列中权值最小的两个节点合并成新的节点，加入到队列中，然后一直按照这个规律执行，直到队列中只剩下一个节点。这个时候头节点的权值就是最短路径权值<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下是求一个实例的最短路径的权值的算法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;<span class="type">long</span> <span class="type">long</span>, vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;, greater&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> temp, x, y, ans = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"&amp;d"</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) {</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;temp);</span><br><span class="line">		q.<span class="built_in">push</span>(temp);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (q.<span class="built_in">size</span>()&gt;<span class="number">1</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="comment">//获取前两个最大节点</span></span><br><span class="line">		x = q.<span class="built_in">top</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		y = q.<span class="built_in">top</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//将节点合并之后再入队</span></span><br><span class="line">		q.<span class="built_in">push</span>(x + y);</span><br><span class="line">		<span class="comment">//统计最短路径权值</span></span><br><span class="line">		ans += x + y;</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><br>哈夫曼编码是一种用于无损数据压缩的熵编码（权编码）算法，它可以根据数据的一些特点（如出现频率）来制定相应长度的编码从而达到数据压缩的目的。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-01-09T13:32:23.000Z" title="1/9/2021, 9:32:23 PM">2021-01-09</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-03-08T11:43:03.329Z" title="3/8/2023, 7:43:03 PM">2023-03-08</time></span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/01/09/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Java学习笔记</a></p><div class="content"><h1 id="Java学习"><a href="#Java学习" class="headerlink" title="Java学习"></a>Java学习</h1><font color="#999AAA">学习[廖雪峰博客](https://www.liaoxuefeng.com/wiki/1252599548343744)笔记
</font>




<h2 id="基本运算符"><a href="#基本运算符" class="headerlink" title="基本运算符"></a>基本运算符</h2><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>||：短路或；&amp;&amp;：短路与（一些非法的语句会被忽略）；！：逻辑非</p>
<p>其中逻辑运算符只能操作布尔型数据。（注意一点，在Java中不能用1、0来代替True、False，因为前者是整型后者是布尔型）<br>逻辑运算与短路运算的结果是一致的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">x</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="type">boolean</span> <span class="variable">y</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="type">short</span> <span class="variable">z</span> <span class="operator">=</span> <span class="number">42</span>;</span><br><span class="line">		<span class="comment">//if(y == true)</span></span><br><span class="line">		<span class="keyword">if</span> (( z++==<span class="number">42</span> ) &amp;&amp; ( y = <span class="literal">true</span> )) z++;<span class="comment">//注意z++是先进行判断之后才自增的！！，所以本语句是可以被执行的</span></span><br><span class="line">		<span class="keyword">if</span> (( x = <span class="literal">false</span>) || (++z == <span class="number">45</span> )) z++;</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">"z="</span> + z);</span><br><span class="line">        <span class="comment">//Output:46</span></span><br></pre></td></tr></table></figure></p>
<h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>左移相当于*2，但是有限度（最左边的数为1的时候，结果会变成负数）右移前右边的位根据数字的符号决定（1的话就用1来填，否则就用0来填）<br>&gt;&gt;&gt;：无符号位移操作</p>
<blockquote>
<p>最高效的方式计算2 * 8：2&lt;&lt;3 or 8 &lt;&lt; 1</p>
</blockquote>
<p>位运算符:&amp;(and)、 |(or)、 ^(xor)、 ~(not)</p>
<h3 id="交换两变量的值"><a href="#交换两变量的值" class="headerlink" title="交换两变量的值"></a>交换两变量的值</h3><p>方式一：定义一个临时变量<br>方式二：先将两数合并，然后再分离<br>   （:可能超出存储范围；有局限性）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num1 = num1 + num2;</span><br><span class="line">num2 = num1 - num2;</span><br><span class="line">num1 = num1 - num2;</span><br></pre></td></tr></table></figure><br>方式三：（运用位运算符关系：m = k ^ n = (m ^ n) ^ n）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num1 = num1 ^ num2;</span><br><span class="line">num2 = num1 ^ num2;</span><br><span class="line">num1 = num1 ^ num2;</span><br></pre></td></tr></table></figure></p>
<h3 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h3><p>表达式1和表达式2要求是一致的，二者能够统一成一个类型（因为它的结果是会被赋值给单个变量的）</p>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>需要包含三点：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.导入对应的类（utility）</span></span><br><span class="line"><span class="keyword">import</span>  java.util.Scanner;<span class="comment">//注意最后的分号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IO</span>{</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>{</span><br><span class="line">    	<span class="comment">//2.创建scanner变量</span></span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);<span class="comment">//创建scanner传入：System.in、System.out分别代表标准输入和输出。</span></span><br><span class="line">		System.out.println(<span class="string">"Input Your name: "</span>);</span><br><span class="line">        <span class="comment">//3.访问输入变量中的成员</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> scanner.nextLine();<span class="comment">//传入的是字符串类型，注意这种类型转换是自动的</span></span><br><span class="line">		System.out.println(<span class="string">"Input Your age: "</span>);</span><br><span class="line">		<span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> scanner.nextInt();<span class="comment">//传入的是整型（注意next之后的语句）</span></span><br><span class="line">		System.out.printf(<span class="string">"Hi, %s,you are %d\n"</span>,name,age);</span><br></pre></td></tr></table></figure></p>
<h3 id="条件判断语句"><a href="#条件判断语句" class="headerlink" title="条件判断语句"></a>条件判断语句</h3><h4 id="判等语句”-“："><a href="#判等语句”-“：" class="headerlink" title="判等语句”==“："></a>判等语句”==“：</h4><p> 这种判断运算符可以用来判断了两个值类型的变量是否相等，但是对于引用型变量就变成判断两个变量是否指向同一个对象。要判断引用类型的变量内容是否相等需要使用<strong>equals（）方法</strong>（注意这是变量类型String下面的一种方法）<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IO</span> {    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>{        </span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="literal">null</span>;        </span><br><span class="line">        <span class="comment">//注意当s1为null时，直接调用equals方法会导致NullPointException错误，       </span></span><br><span class="line">        <span class="comment">//为了避免这种情况，就利用短路运算，规避这种错误        </span></span><br><span class="line">        <span class="keyword">if</span> (s1 != <span class="literal">null</span> &amp;&amp; s1.equals(<span class="string">"hello"</span>)){            </span><br><span class="line">            System.out.println((<span class="string">"hello"</span>));       </span><br><span class="line">        }   </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<h4 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意switch语句具有穿透性，所以每一项都需要以break结尾，且不能有大括号，判断语句也可以是字符串，是比较其中的内容是否相等</span></span><br><span class="line"><span class="keyword">switch</span>（option）{</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">        ....</span><br><span class="line">        <span class="keyword">break</span>;   </span><br><span class="line">        </span><br><span class="line"> <span class="comment">//java12</span></span><br><span class="line"> <span class="keyword">case</span> <span class="string">"***"</span> -&gt; ....;<span class="comment">//当具有多条语句的时候，需要用大括号括起来，其不需要break</span></span><br><span class="line"> <span class="comment">//还可以直接返回参数</span></span><br><span class="line"> <span class="type">int</span> <span class="variable">opt</span> <span class="operator">=</span> <span class="keyword">switch</span>(fruit){......}</span><br><span class="line"> <span class="keyword">yield</span> code;<span class="comment">//这个是switch语句的返回值，作为默认返回的方式</span></span><br></pre></td></tr></table></figure>
<h4 id="for-语句"><a href="#for-语句" class="headerlink" title="for 语句"></a>for 语句</h4><p> esp.（for each 循环）</p>
<h1 id="eg："><a href="#eg：" class="headerlink" title="eg："></a>eg：</h1> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] ns = {...};<span class="comment">//数组初始化</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> n : ns){....}<span class="comment">//数组遍历</span></span><br><span class="line"><span class="comment">//但是这种方式没有办法拿到数组的索引</span></span><br></pre></td></tr></table></figure>
<h2 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h2><h3 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h3><p>java标准库提供了Arrays.toString()，可以用来快速打印数组内容</p>
<h3 id="数组的排序"><a href="#数组的排序" class="headerlink" title="数组的排序"></a>数组的排序</h3><p>调用Java的内置排序功能</p>
<blockquote>
<p>import java.util.Arrays;<br>Arrays.sort(Arrays_name);//排序算法的调用</p>
</blockquote>
<p>注意一点，数组的第一个元素就是指向该数组的指针</p>
<h3 id="访问多维数组"><a href="#访问多维数组" class="headerlink" title="访问多维数组"></a>访问多维数组</h3><p>初始化的方式与C语言的一致，利用Java标准库输出：</p>
<blockquote>
<p>Arrays.deepToString</p>
<p>注意一点，在多维数组中，.length表示的多为数组中的数组的个数</p>
</blockquote>
<h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><p>NULL</p>
<h2 id="面对对象编程"><a href="#面对对象编程" class="headerlink" title="面对对象编程"></a>面对对象编程</h2><h3 id="面对对象基础"><a href="#面对对象基础" class="headerlink" title="面对对象基础"></a>面对对象基础</h3><p> 简单来说就是我们都是一类（class）人，但是每个我们都是不同的实例（instance），各有各的性格特点<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Class_Name</span>{</span><br><span class="line">	<span class="keyword">public</span> member_name;<span class="comment">//public表示外部可以访问;这些是类的字段（Field）</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">//创建实例</span></span><br><span class="line"><span class="type">Class_Name</span> <span class="variable">instanceName</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Class_Name</span>();</span><br><span class="line"><span class="comment">//访问实例的字段</span></span><br><span class="line">instanceName.field;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h4 id="类方法："><a href="#类方法：" class="headerlink" title="类方法："></a>类方法：</h4><h5 id="private-方法"><a href="#private-方法" class="headerlink" title="private 方法"></a>private 方法</h5><p>为了避免外部代码直接去访问field，可以用private修饰field，这样可以拒绝外部的访问。但是外部代码想要访问，就需要借助方法（method）<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">Person</span>{</span><br><span class="line">	<span class="keyword">private</span> String name;<span class="comment">//实例（instance）</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">	<span class="keyword">private</span> String nickName；</span><br><span class="line"></span><br><span class="line">	<span class="comment">//下面是private的方法</span></span><br><span class="line">	<span class="comment">//访问内部字段</span></span><br><span class="line">	<span class="keyword">public</span> String getName{</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getAge</span><span class="params">()</span>{</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.age;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//同时可以检查输入的值是否合法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>{<span class="comment">//这里是方法参数</span></span><br><span class="line">	<span class="comment">//发现违法输入，抛出异常</span></span><br><span class="line">		<span class="keyword">if</span>(name == <span class="literal">null</span> || name.isBlank()){</span><br><span class="line">			<span class="keyword">throw</span> IllegalArgumentException(<span class="string">"Invalid name"</span>); </span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="comment">//如果没有冲突，则可以忽略this，如：return name；</span></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//下面是可变参数的一个示例。（类型...）</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNickName</span><span class="params">(String... names)</span>{<span class="comment">//参数也可以写成：String[] names</span></span><br><span class="line">		<span class="built_in">this</span>.nickName = names;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//调用方式:varianName.setNickName(" *** " ," **** ");</span></span><br><span class="line">	<span class="comment">/*注意：前几个方法的参数是以复制后形式传入的，而这个方法的参数若是数组</span></span><br><span class="line"><span class="comment">	的话，就是以引用的方式传入的，所以在外部代码中，之前传入的数组的会导</span></span><br><span class="line"><span class="comment">	致内部数组的变化（类似于传值、传址）</span></span><br><span class="line"><span class="comment">	**引用类型参数的传递，调用放的变量，和接受方的变量，指向的是同一个对象。双方任意一方修改这个对象都会影响对方**</span></span><br><span class="line"><span class="comment">	之前的复制参数的传递方式成为参数绑定机制</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">//第一private相当于对变量进行了封装，而public这作为外部的接口。</span></span><br><span class="line"><span class="comment">//这里注意一下this指针的运用，用于在类内部指代内部本身。（屋子内的物品分布的地图）</span></span><br></pre></td></tr></table></figure></p>
<h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><p> <strong>之前些的这部分写得太烂了，这部分最后是重写的（我终于知道在代码中加太多注释的话，在复习的会哭的）</strong></p>
<p> 在类定义的时候定义一个构造方法，这可以在创建实例的时候顺便将字段都初始化了<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在类中，定义一个与类名相同的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ClassName</span> <span class="params">(type instanceName1, type instanceName2)</span>;<span class="comment">//参变量是需要初始化的变量</span></span><br><span class="line"><span class="comment">//定义的同时初始化</span></span><br><span class="line"><span class="type">className</span> <span class="variable">varianName</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">className</span>(initialValue1,initialValue2);</span><br><span class="line"><span class="comment">//Java的构造函数与C语言类似（几乎一致）</span></span><br><span class="line"><span class="comment">//默认构造函数</span></span><br><span class="line"><span class="keyword">public</span> ClassName</span><br><span class="line"><span class="comment">//没有初始化的字段：引用类型-&gt;null; 数值类型-&gt;默认值，int-&gt;0;boolean -&gt;false;</span></span><br><span class="line"><span class="comment">//可以在类定义当中定义多个构造方法，调用的时候会根据传入的参数的个数匹配至相应的构造方法</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ClassName</span>();<span class="comment">//这个时候就会调用默认的构造方法</span></span><br><span class="line"><span class="comment">//一种方法可以调用另一种方法，这里用到this指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在类定义的内部：</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span>{</span><br><span class="line">	<span class="built_in">this</span>(name,<span class="number">18</span>);<span class="comment">//这里调用了另外一个方法</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<p>&lt;hr style=” border:solid; width:100px; height:1px;” color=#000000 size=1”&gt;<br>构造方法就是为了能够在定义变量的时候方便初始化。作用就像是C++中的结构体的构造函数，但是Java中的构造方法与C++中的有一些不同。</p>
<blockquote>
<p>和普通方法相比，构造方法没有返回值（也没有void），调用构造方法，必须用new操作符。</p>
</blockquote>
<p>下面是运用实例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> {</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> {</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    }</span><br><span class="line">	<span class="comment">//默认构造函数</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>{};</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.age;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用：直接初始化了成员变量</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">"Xiao Ming"</span>, <span class="number">15</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h5 id="方法重载（Overload）（同名但拥有不同的参数类型的方法）"><a href="#方法重载（Overload）（同名但拥有不同的参数类型的方法）" class="headerlink" title="方法重载（Overload）（同名但拥有不同的参数类型的方法）"></a>方法重载（Overload）（同名但拥有不同的参数类型的方法）</h5><p>允许出现<strong>同名但拥有不同的参数类型的方法</strong>，但是这些方法的返回值应该具有相同的返回值。这样使得调用变得更加方便。注意重载的方法应该完成相似的功能。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继续之前的案例</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">setName</span><span class="params">(String name)</span>{</span><br><span class="line">	<span class="built_in">this</span>.name = name;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//方法重载</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">steName</span><span class="params">(String name, String familyName)</span>{</span><br><span class="line">	<span class="built_in">this</span>.name = name + <span class="string">" "</span> + familyName;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>继承就是在原有的类的字段和方法上进行拓展，形成一个新的类，Java中运用关键字<strong>extends</strong>来实现继承。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>{...}<span class="comment">//超类（super class）、父类（parent class）、基类（base class）</span></span><br><span class="line"><span class="comment">//对原先的类进行继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">person</span>{...}<span class="comment">//子类（subclass）、拓展类（extended class）</span></span><br><span class="line"><span class="comment">//注意子类中不能定义父类中重名的字段！</span></span><br></pre></td></tr></table></figure></p>
<h5 id="继承树"><a href="#继承树" class="headerlink" title="继承树"></a>继承树</h5><p>这类的继承结构就像是树的结构，所有定义的类都有对应的父类，上例中，Person的父类就是Object（这个类就相当于树中的头节点，没有父类），同样与树类似，每一个类只有一个父节点（除了Object），及只能继承自一个类。</p>
<h5 id="protected（仅能被继承树中的成员所访问的变量）"><a href="#protected（仅能被继承树中的成员所访问的变量）" class="headerlink" title="protected（仅能被继承树中的成员所访问的变量）"></a>protected（仅能被继承树中的成员所访问的变量）</h5><p>父类中private的字段是没有办法被子类访问的，但是protected的字段可以被所有的子类所访问（继承树内部）。</p>
<h5 id="super-子类构造方法时使用"><a href="#super-子类构造方法时使用" class="headerlink" title="super(子类构造方法时使用)"></a>super(子类构造方法时使用)</h5><p>当在子类中引用父类的字段时，就可以用super指代（联想到this是指代自己，super是指代父类）一般情况下，super.name、this.name、name(name 为父类中的一个字段)都是一样的，编译器会自动定位字段的位置。但是在子类中需要生成构造函数的时候，情况就发生变化了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*在Java中任何类的构造方法必须是调用父类的构造方法，在没有明确调用父类的构造方法时候，</span></span><br><span class="line"><span class="comment">会默认一个super（），但是父类中并没有无参数的构造方法，这时候就会报错。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Class Student <span class="keyword">extends</span> <span class="title class_">Person</span>{</span><br><span class="line">	<span class="keyword">protected</span> <span class="type">int</span> score;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name,<span class="type">int</span> age,<span class="type">int</span> score)</span>{</span><br><span class="line">		<span class="built_in">super</span>()；<span class="comment">//自动调用父类的构造方法,出错</span></span><br><span class="line">		<span class="comment">//这个时候只需要调用父类中已经定义的构造方法即可</span></span><br><span class="line">		<span class="built_in">this</span>.score = score;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*所以当父类没有默认的构造方法时，必须写明调用super（），以便定位到合适的构造方法中。</span></span><br><span class="line"><span class="comment">（回忆之前所的，当自己定义一个构造方法时，原有的默认构造方法就被覆盖了）</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><br>还有一点，子类是不会继承父类的任何构造方法。</p>
<h5 id="阻止继承（sealed）"><a href="#阻止继承（sealed）" class="headerlink" title="阻止继承（sealed）"></a>阻止继承（sealed）</h5><p>只要一个class没有final修饰符，任何类都可以从该类中继承。但是为了防止继承被滥用，Java15中允许使用 <strong>sealed</strong>类型，通过<strong>permits</strong>明确可以继承的子类名称<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Shape</span> <span class="keyword">permits</span> Rect, Circle{...}<span class="comment">//permits之后时允许继承的子类</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>sealed类在Java 15中目前是预览状态，要启用它，必须使用参数—enable-preview和—source 15</p>
</blockquote>
<h5 id="向上转型-amp-向下转型"><a href="#向上转型-amp-向下转型" class="headerlink" title="向上转型&向下转型"></a>向上转型&amp;向下转型</h5><p>这种向上向下的关系是针对继承树的，总的来说，字符/方法少的不能向字符/方法多的转型，否则Java虚拟机就会报<strong>ClassCastException</strong>.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向下转型实例</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>()<span class="comment">//Person类型p1指向Students实例</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> (Student) p1;<span class="comment">//向下转型,出现错误，因为原先的类中可能不存在子类中的方法</span></span><br><span class="line"><span class="comment">//向上转型实例</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();<span class="comment">//向下转型</span></span><br></pre></td></tr></table></figure><br>为了避免在向下转型的过程中出现错误，可以用<strong>instanceof</strong>实现判断一个变量所指向的实例是否是指定类型，或者是这个类型的子类。（A is instance of ClassName?True or False?）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">	<span class="keyword">if</span>(p <span class="keyword">instanceof</span> Student){</span><br><span class="line">		<span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> (Student) p;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//在java14中可以在判断语句中直接转型为制定变量（预览功能，启用需要参数）</span></span><br><span class="line">	<span class="comment">//这样写更加整洁</span></span><br><span class="line">	<span class="keyword">if</span>(p <span class="keyword">instanceof</span> Student s){</span><br><span class="line">		System.out.println(s.getname);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></table></figure><br>最后在使用继承的时候要注意逻辑的一致性，继承的双方应该是包含和被包含的关系，而不是有交集的关系。</p>
<h5 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h5><h6 id="覆写"><a href="#覆写" class="headerlink" title="覆写"></a>覆写</h6><p>父类的方法可以被子类的完全相同的方法所覆写（修改相应方法的功能）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类的方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>{</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>{</span><br><span class="line">		System.out.println(<span class="string">"  "</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="comment">//子类对父类方法进行覆写</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>{</span><br><span class="line">	<span class="meta">@override</span><span class="comment">//帮助检查是否正确进行了覆写（非必须）</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span> <span class="params">()</span>{</span><br><span class="line">		System.out.println(<span class="string">"***"</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="comment">//重载（overload）：对一个方法进行补充性修改，名称一致，但是参数、功能可以发生变化</span></span><br><span class="line"><span class="comment">//覆写(override):对一个方法的功能进行修改，相应的功能名称都应该相同</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注意一点，Java调用方法的过程中，调用的是所指向的类的对应的方法，这意味着所调用的方法与所对应的父类无关</span></span><br><span class="line"><span class="comment">这样在定义一个函数的时候，由于传入的参数类型不确定，这就导致所调用的方法也是不确定的。</span></span><br><span class="line"><span class="comment">（Java中定义的类型和所指向的类型可以是不一致的）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Run</span><span class="params">(Person p)</span>{</span><br><span class="line">	<span class="comment">//这时候无法确定是Person的方法还是Student的方法</span></span><br><span class="line">	p.run();</span><br><span class="line">}</span><br><span class="line"><span class="comment">//利用这个特点，可以通过传入不同类型的参数，以实现调用不同的功能的方法</span></span><br><span class="line"><span class="comment">//的目的,这样就实现了功能的拓展，而又不需要修改基于父类的代码</span></span><br></pre></td></tr></table></figure><br>  所有的类都最终继承自Object，这就意味着在必要情况下可以覆写Object的方法。其有一下几个重要方法：</p>
<ol>
<li>toString():将instance输出为String</li>
<li>equals():判断两个instance是否逻辑相等</li>
<li>hashCode():计算一个instance的哈希值</li>
</ol>
<p>在子类中，想要调用父类的方法，可以用super来调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Student <span class="keyword">extends</span> <span class="title class_">Person</span>{</span><br><span class="line">	<span class="meta">@override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>{</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">super</span>.hello()+<span class="string">"!"</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//当一个方法不想让子类进行覆写的时候，在方法前加上final关键字</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">hello_1</span><span class="params">()</span>{</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Hello, "</span>+name;</span><br><span class="line">	}<span class="comment">//子类进行覆写会导致编译错误</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">//不希望被继承的类</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ClassName</span>{...}</span><br><span class="line"><span class="comment">//不希望被修改的字段,常出现在构造方法中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">"***"</span>;</span><br><span class="line"><span class="comment">//提一下：在方法的参数当中出现三个英文句号，代表参数个数不确定，依照输入参数的个数来确定</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">totalTax</span><span class="params">(Income... incomes)</span>{...}</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h5 id="抽象类-amp-接口"><a href="#抽象类-amp-接口" class="headerlink" title="抽象类&接口"></a>抽象类&amp;接口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当父类方法只是定义方法签名，本身没有实际的意义，这时候应该将父类方法声明为抽象方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>{</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//这样的类运行时会报错，需要将类本身也声明为抽象类型,此类方法无法被实例化（无法用于定义变量）</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span>{</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h6 id="面向抽象编程"><a href="#面向抽象编程" class="headerlink" title="面向抽象编程"></a>面向抽象编程</h6><p>上层类只是定义规范，对于方法的实现并不关心，这相当于对方法的实现过程进行了封装。<br>实现方法就是用抽象类型去引用具体子类的实例。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br></pre></td></tr></table></figure></p>
<h6 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h6><p>当一个抽象类中没有字段，所有的方法都是抽象类，这个时候应该将将这个类定义为接口：<strong>Interface</strong><br>在接口中所有的方法都是默认是public abstract，所以这两个修饰符在定义方法的时候都不写出来，当一个类去实现接口的时候需要使用<strong>implements</strong>关键字。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span>{...}<span class="comment">//定义一个接口，接口中不能有字段</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Person</span>{...}<span class="comment">//实现一个接口</span></span><br><span class="line"><span class="comment">//在Java中一个类只能继承自唯一的一个类，但是可以实现多个方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Run</span>,Walk{...}<span class="comment">//实现两个接口</span></span><br><span class="line"><span class="comment">//一个接口还可以继承自另一个接口，这就相当于拓展了接口的方法</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Teacher</span> <span class="keyword">extends</span> <span class="title class_">Person</span>{....}</span><br></pre></td></tr></table></figure><br> 当实现一个接口的时候，需要覆写接口中所有的方法，但是可以不用覆写default方法，这实际上就是一种默认的方法功能，可以“不初始化”。<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span>{</span><br><span class="line">	<span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>{...}<span class="comment">//无法访问字段</span></span><br><span class="line">}		</span><br></pre></td></tr></table></figure></p>
<h5 id="静态字段和静态方法"><a href="#静态字段和静态方法" class="headerlink" title="静态字段和静态方法"></a>静态字段和静态方法</h5><h6 id="静态字段"><a href="#静态字段" class="headerlink" title="静态字段"></a>静态字段</h6><p>用static修饰，独立于实例，在任何一个实例当中修改都会修改静态字段的值，这就是说所有实例中的同一个静态字段都是同一个字段（在同一个存储空间当中）。所以在访问静态字段的时候，最好是使用类名来访问：<strong>类名.静态字段</strong></p>
<h6 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h6><p>调用静态方法不需要实例变量，直接通过类名即可。</p>
<blockquote>
<p>静态方法属于类而不属于实例，所以在静态方法内部是无法访问this变量，也无法访问实例字段，只能访问静态字段</p>
<h6 id="接口的静态字段"><a href="#接口的静态字段" class="headerlink" title="接口的静态字段"></a>接口的静态字段</h6><p>接口的静态字段必须是final类型的，又因为接口的字段只能是public static final类型的，所以这样的修饰符是可以省略的。</p>
<h6 id="包"><a href="#包" class="headerlink" title="包"></a>包</h6><p>为了避免因为类名相同的而导致的冲突，在Java中定义了一种名字空间，成为包（package），一个类的完成类名是：<strong>包名.类名</strong>，没有写包名的类会使用默认包，这样容易造成名字冲突，所以建议将包名写出来。（注意，<strong>包没有父子关系</strong>，这也就是说com.apache和com.apache.abc是不同的包）</p>
<h6 id="包的作用域"><a href="#包的作用域" class="headerlink" title="包的作用域"></a>包的作用域</h6><p>位于同一个包的类可以访问包的作用域的字段和方法（允许访问package的没有public、private修饰的class、以及没有public、protected、private修饰的字段和方法。注意这里的意思是能访问，不是只能访问，public修饰的方法在同一个包情况下当然可以被访问）</p>
<h6 id="调用其他的class：import"><a href="#调用其他的class：import" class="headerlink" title="调用其他的class：import"></a>调用其他的class：import</h6><p>package_sample<br>└─ bin<br>     ├─ hong<br>     │  └─ Person.class<br>    │  ming<br>    │  └─ Person.class<br>    └─ mr<br>          └─ jun<br>               └─ Arrays.class</p>
</blockquote>
<p>假设一个包的结构如上图。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用方法①:直接完成写出类名</span></span><br><span class="line">mr.jun.<span class="type">Arrays</span> <span class="variable">arrays</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">mr</span>.jun.Arrays();</span><br><span class="line"><span class="comment">//调用方法②：用import语句,导入对应的包</span></span><br><span class="line"><span class="keyword">import</span> mr.jun.Arrays;<span class="comment">//导入这个包下的Arrays类</span></span><br><span class="line"><span class="keyword">import</span> mr.jun.*;<span class="comment">//导入这个包下的所有的类（不推荐，可能引起混乱）</span></span><br><span class="line"><span class="comment">//导入一个类的静态字段和静态方法</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.*;<span class="comment">//导入system类中的所有静态方法</span></span><br><span class="line">out.println(<span class="string">"..."</span>);<span class="comment">//可用√</span></span><br></pre></td></tr></table></figure><br>在编译器遇到一个类名称的时候，按照一下顺序查找这个类<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[是否是完整的类名]--是--&gt;B(直接根据完整类名查找这个类)</span><br><span class="line">A--否--&gt;C(查找当前package是否存在这个类名)</span><br><span class="line">C--&gt;D(查找import的包)--&gt;E(查找java.lang包)</span><br></pre></td></tr></table></figure><br>如果没有找到最后就报错。<br>在编写class 的时候，编译器会自动import两个包：导入当前包的其他class、默认：import java.lang.*.导入的包的名称不能相同，如有重名，另一个应该到写入完整的类名。为了避免冲突，要注意能和java.lang和JDK常用类的类名重名<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个语句应该就是在声明包的位置</span></span><br><span class="line"><span class="keyword">package</span> com.itranswarp.sample;</span><br><span class="line"></span><br><span class="line"><span class="comment">//导入包，写明包的具体位置</span></span><br><span class="line"><span class="keyword">import</span> com.itranswarp.world.Person;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">		<span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">"小明"</span>);</span><br><span class="line">		System.out.println(p1.hello());</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<h5 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h5><div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th>作用范围</th>
<th>补充</th>
</tr>
</thead>
<tbody>
<tr>
<td>public</td>
<td>只要有class的访问权限，定义位public的方法和字段就可以被访问</td>
<td>相当于一个对外的接口</td>
</tr>
<tr>
<td>private</td>
<td>无法被其他类访问，但是可以通过嵌套类（nested class）访问</td>
<td>用方法内的public方法访问private方法，使外部可以访问方法内部的private方法</td>
</tr>
<tr>
<td>protected</td>
<td>字段和方法能被子类及其子类访问</td>
<td>限制访问范围只能在继承树中才访问</td>
</tr>
<tr>
<td>package</td>
<td>同一个包内能访问对应的方法字段</td>
<td>有点像名字空间</td>
</tr>
<tr>
<td>局部变量</td>
<td>在方法内部定义的变量成为局部变量</td>
<td>在范围之外就会失效，像形参之类的</td>
</tr>
<tr>
<td>final</td>
<td>class：防止被继承<br>字段：防止被重新赋值<br>局部变量：防止重新赋值<br>方法：防止被覆写</td>
<td>就相当于静态变量</td>
</tr>
</tbody>
</table>
</div>
<p><em>注意事项：</em> 1.尽可能少地对外暴露字段和方法，也就是说要尽可能减少public地使用<br>2.将方法定义位package有利于测试，测试类和被测试类只要在同一个包中，测试代码就可以访问被测试类的权限方法<br>3.一个.java类只能有一个public类，且文件名和public类必须相同。</p>
<h5 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h5><p>在其他类中定义的类称为内部类。<br>①：Inner Class（内部类）：依托于外部类，能够访问外部类的private字段和方法。<br>创建方法：Outer.Inner inner = outer.new Inner();<br>编译后：Outer编译位Outer.class,内部类编译为Outer$Inner.class</p>
<p>②：Anonymous Class（匿名类）在其他类的内部实例化<br>创建方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>(){<span class="comment">//这里是定义了一个接口</span></span><br><span class="line">	<span class="comment">//方法</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">//继承自普通类</span></span><br><span class="line">HashMap&lt;String, String&gt;map2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(){};</span><br></pre></td></tr></table></figure><br>编译后：main$1.class(main是public修饰的)<br>③：Static Nested Class（静态内部类）用static修饰，无法应用Outer.this，可以访问private修饰的变量</p>
<h5 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h5><p>模块申明了依赖关系，只有声明依赖关系之后才能将需要的类导入<br>(While need it, learn it)</p>
<h4 id="Java核心类"><a href="#Java核心类" class="headerlink" title="Java核心类"></a>Java核心类</h4><h1 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h1><h2 id="在命令行中运行Java程序"><a href="#在命令行中运行Java程序" class="headerlink" title="在命令行中运行Java程序"></a>在命令行中运行Java程序</h2><p>可以在执行语句后面加上参数列表，在程序中将会被保存至args参数列表中，用下标索引的方式可以直接访问传入的参数。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-01-09T12:45:14.000Z" title="1/9/2021, 8:45:14 PM">2021-01-09</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-03-08T11:43:43.952Z" title="3/8/2023, 7:43:43 PM">2023-03-08</time></span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/01/09/%E3%80%8AComputer-Systems-A-Programmer-Perspective-3rd-ed%E3%80%8B/">《Computer Systems: A Programmer Perspective 3rd ed》</a></p><div class="content"><h1 id="第一章-A-Tour-of-Computer-Systems"><a href="#第一章-A-Tour-of-Computer-Systems" class="headerlink" title="第一章 A Tour of Computer Systems"></a>第一章 A Tour of Computer Systems</h1><p><font color="#999AAA"><br>&amp;#8195这本书的前言部分主要介绍了本书主要包含的内容（the hardware architecture, the operating system, the compiler, the network）还有一些学习的预备知识（C语言、Lunux系统）。</font></p>
<p><font color="#999AAA"><br>&amp;#8195全文展开的逻辑是介绍Hello.c文件从编写到输出主要经历了什么</font></p>
<h2 id="1-1-Information-Is-Bits-Context"><a href="#1-1-Information-Is-Bits-Context" class="headerlink" title="1.1 Information Is Bits + Context"></a>1.1 Information Is Bits + Context</h2><p><font color="#999AAA"></font>这一部分主要讲程序文件在计算机中的存贮方式<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Hello,world!\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><br>这段代码在计算机中使用ASCII码存贮的，如下图：<br><img src="https://img-blog.csdnimg.cn/20210102154622739.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<blockquote>
<p>Most computer systems represent text characters using the ASCII standard<br>that represents each character with a unique byte-size integer value.<br>The hello.c program is stored in a file as a sequence of bytes</p>
</blockquote>
<p>注意每一行都是以换行符结束的，而换行符的ASCII码为10.<br><em>包含ASCII字符的文件为文本文件，其他的文件为二进制文件。</em><br>最后的注释部分介绍了C语言的优点，还有缺点：</p>
<blockquote>
<p>C pointers are a common source of confusion and programming errors.</p>
</blockquote>
<p>&lt;hr style=” border:solid; width:100px; height:1px;” color=#000000 size=1”&gt;</p>
<h2 id="1-2-Programs-Are-Translated-by-Other-Programs-into-Different-Forms"><a href="#1-2-Programs-Are-Translated-by-Other-Programs-into-Different-Forms" class="headerlink" title="1.2 Programs Are Translated by Other Programs into Different Forms"></a>1.2 Programs Are Translated by Other Programs into Different Forms</h2><p><img src="https://img-blog.csdnimg.cn/20210116102447818.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="一个程序文件的执行周期"><br>文件运行的时候会有四个阶段：<br>在预处理阶段，预处理器会处理带有#的语句，并将它直接插入到程序文本中。<br>编译阶段将文本文件转义成汇编语言文件，汇编语言相当于一种通用语言，能够使得不同的高级语言在同一个机器上运行。<br>汇编阶段将<em>hello.s</em>转换成机器语言，并将结果存储在<em>hello.o</em>文件当中，这时候的文件是可迁移的（relocatable object program）<br>链接阶段将程序文件中调用的一些函数方法的执行程序与主程序合并，使主程序调用的函数可以顺利运行，这时候的文件为<em>hello</em>,这时的文件已经准备好被加载入内存中，后被运行了。</p>
<h2 id="1-4-Processors-Read-and-Interpret-Instructions-Stored-in-Memory"><a href="#1-4-Processors-Read-and-Interpret-Instructions-Stored-in-Memory" class="headerlink" title="1.4 Processors Read and Interpret Instructions Stored in Memory"></a>1.4 Processors Read and Interpret Instructions Stored in Memory</h2><p><img src="https://img-blog.csdnimg.cn/20210119145938442.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>What’s happening when we entering a sequence of command.<br><img src="https://img-blog.csdnimg.cn/20210119152000654.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="1-5-Cache-Matter"><a href="#1-5-Cache-Matter" class="headerlink" title="1.5 Cache Matter"></a>1.5 Cache Matter</h2><p>Note that we spend a lot of time to move data form disk to main memory by bus. Which is so-call <em>processor-memory gap</em> .In order to improve the performance of the operations,we use a Cache Memory between Main memory and Register which will store the information which is most likely to need in the near future.It maybe small to store data but fast to fletch when we need it.</p>
<blockquote>
<p>Because of physical laws, larger storage devices are slower than smaller storage devices.</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210119152749480.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="1-6-Storage-Devices-Form-a-Hierarchy"><a href="#1-6-Storage-Devices-Form-a-Hierarchy" class="headerlink" title="1.6 Storage Devices Form a Hierarchy"></a>1.6 Storage Devices Form a Hierarchy</h2><p><img src="https://img-blog.csdnimg.cn/20210120143008803.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="1-7-The-Operating-System-Manages-the-Hardware"><a href="#1-7-The-Operating-System-Manages-the-Hardware" class="headerlink" title="1.7 The Operating System Manages the Hardware"></a>1.7 The Operating System Manages the Hardware</h2><p><img src="https://img-blog.csdnimg.cn/20210120151124190.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="1-7-1-Processes"><a href="#1-7-1-Processes" class="headerlink" title="1.7.1 Processes"></a>1.7.1 Processes</h3><p><img src="https://img-blog.csdnimg.cn/2021012015135845.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>To be continue</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><font color="#999AAA">

<p>1.英文术语：<br>interpreted language ：</p>
<blockquote>
<p>直译语言（英语：Interpreted language），又称直译式语言，是一种编程语言。这种类型的编程语言，会将代码一句一句直接运行，不需要像编译语言（Compiled language）一样，经过编译器先行编译为机器码，之后再运行。这种编程语言需要利用解释器，在运行期，动态将代码逐句直译（interpret）为机器码，或是已经预先编译为机器码的的子程序，之后再运行。<br>理论上，任何编程语言都可以是编译式，或直译式的。它们之间的区别，仅与程序的应用有关。许多编程语言同时采用编译器与解释器来实作，其中包括Lisp，Pascal，C，BASIC 与 Python。JAVA及C#采用混合方式，先将代码编译为bytecode，在运行时再进行直译。</p>
</blockquote>
<p>magnetic-disk &amp; solid state drives：磁盘和固态硬盘<br>lingking：链接器</p>
<blockquote>
<p>链接器（英语：Linker），又译为链结器、链接器，是一个进程，将一个或多个由编译器或汇编器生成的目标文档外加库链接为一个可执行文档。</p>
</blockquote>
<p>metadata：</p>
<blockquote>
<p>元数据（Metadata），又称元数据、诠释数据、中继数据元数据，为描述数据的数据（data about data），主要是描述数据属性（property）的信息，用来支持如指示保存位置、历史数据、资源寻找、文档记录等功能。元数据算是一种电子式目录，为了达到编制目录的目的，必须在描述并收藏数据的内容或特色，进而达成协助数据检索的目的。</p>
</blockquote>
<p>context exchange：</p>
<blockquote>
<p>上下文交换(英语：context switch)，又称环境切换，电脑术语，是一个保存和重建CPU的状态 (内文)，因此令多个进程(process)可以分享单一CPU资源的计算过程。要交换CPU上的进程时，必需先行保存目前进程的状态，再将欲运行的进程之状态读回CPU中。</p>
</blockquote>
<p>System Call:</p>
<blockquote>
<p>在计算机中，系统调用（英语：system call），又称为系统调用，指运行在用户空间的进程向操作系统内核请求需要更高权限运行的服务。系统调用提供用户进程与操作系统之间的接口。大多数系统交互式操作需求在内核态执行。如设备IO操作或者进程间通信。</p>
</blockquote>
</font></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-01-04T03:49:57.000Z" title="1/4/2021, 11:49:57 AM">2021-01-04</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-03-08T11:43:38.661Z" title="3/8/2023, 7:43:38 PM">2023-03-08</time></span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/01/04/Bug-%E8%AE%B0%E5%BD%95/">Bug 记录</a></p><div class="content"><h1 id="Bug-笔记"><a href="#Bug-笔记" class="headerlink" title="Bug 笔记"></a>Bug 笔记</h1><h2 id="VS-2019"><a href="#VS-2019" class="headerlink" title="VS 2019"></a>VS 2019</h2><p>1.<strong>警告    C6031    返回值被忽略: “scanf”。</strong><br>主要是没有检查输入是否成功。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改：加上一个条件判断语句</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure>
<p>2.<strong>变量不明确</strong>：这多半是因为变量名或者是函数名与现有库中的变量有冲突。</p>
<p>3.<strong>E0520    应使用“{…}”初始化聚合对象</strong></p>
<p>4.<strong>C4996    ‘fopen’: This function or variable may be unsafe. Consider using fopen_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS</strong>.<br>加上下面的语句，然后在 项目-&gt;属性-&gt;C/C++-&gt;预处理器-&gt;预处理器定义中添加_CRT_SECURE_NO_WARNINGS<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br></pre></td></tr></table></figure></p>
<p>5.<strong>C++不允许使用不完整的类型说明</strong><br>不完整类型是这样一种类型，它缺乏足够的信息例如长度去描述一个完整的对象。所以一个数组没有给定长度，直接赋值就会产生这样的错误。</p>
<p>6.<strong>c++ 非静态成员引用必须与特定对象相对</strong><br>这是在调用类成员函数的时候出现的问题<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">className::<span class="built_in">funcName</span>(para) <span class="comment">// Error</span></span><br><span class="line"></span><br><span class="line">className CN;</span><br><span class="line">CN.<span class="built_in">funcName</span>(para);<span class="comment">//Pass</span></span><br></pre></td></tr></table></figure><br><img src="https://img-blog.csdnimg.cn/20210416082241282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="PAT"><a href="#PAT" class="headerlink" title="PAT"></a>PAT</h2><p>1.（当输出结果为很大的数字时出现）比较赋值的变量一定要进行初始化，因为PAT编译器不会默认初始化为0.（基本上就是一个很大的随机数）</p>
<h1 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h1><p>sudo apt-get install g++-multilib<br>遇到一种情况，就是出现缺少一些库</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-01-03T00:16:33.000Z" title="1/3/2021, 8:16:33 AM">2021-01-03</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-03-08T11:40:01.165Z" title="3/8/2023, 7:40:01 PM">2023-03-08</time></span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/01/03/Wireshark-Lab-HTTP/">Wireshark Lab: HTTP</a></p><div class="content"><h1 id="Wireshark-Lab-HTTP"><a href="#Wireshark-Lab-HTTP" class="headerlink" title="Wireshark Lab: HTTP"></a>Wireshark Lab: HTTP</h1><h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><font color="#999AAA">

坚持型连接&amp;非坚持型连接：是否在同一个TCP连接上完成所有的请求/应答报文的传输？Y：坚持型，N:非坚持型。

#### HTTP的非坚持型连接
现在来看看当你点击一个超链接的时候会发生什么。
1.客户机会对超链接的服务器通过80端口（TCP默认端口号）发起一个TCP连接
2.客户机通过套接字向服务器发送HTTP请求报文
3.服务器收到报文之后，从自己的内存（RAM or disk）中获取被请求的对象，并将这些对象封装至HTTP请求报文（HTLM）中，然后通过套接字发送给客户机。
4.HTTP服务器请求关闭TCP连接
5.客户机获取请求的对象，TCP连接彻底关闭。客户机从恢复报文中获取文件
6.获取其他的对象，继续循环上面的步骤

由此可见，每当一个对象被正确接收的时候，之前的建立的TCP连接都会被关闭。一般情况下，浏览器会建立5到10个并行TCP连接，这样的平行连接可以减短响应时间。

![HTLM相应时间](https://img-blog.csdnimg.cn/20210102200933336.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70#pic_center)
由上图，非坚持型下的HTLM的相应时间为：
<mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.373ex;" xmlns="http://www.w3.org/2000/svg" width="22.641ex" height="1.88ex" role="img" focusable="false" viewbox="0 -666 10007.1 830.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/></g><g data-mml-node="TeXAtom" transform="translate(394,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/></g><g data-mml-node="mi" transform="translate(361,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="mi" transform="translate(846,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/></g><g data-mml-node="mi" transform="translate(1207,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mi" transform="translate(1736,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g></g></g><g data-mml-node="mo" transform="translate(2160,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(3215.8,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mo" transform="translate(3938,0)"><path data-c="2217" d="M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z"/></g><g data-mml-node="msub" transform="translate(4660.3,0)"><g data-mml-node="mi"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/></g><g data-mml-node="TeXAtom" transform="translate(394,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"/></g><g data-mml-node="mi" transform="translate(759,0)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="mi" transform="translate(1463,0)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g></g></g><g data-mml-node="mo" transform="translate(6858.8,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="msub" transform="translate(7859,0)"><g data-mml-node="mi"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/></g><g data-mml-node="TeXAtom" transform="translate(394,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/></g><g data-mml-node="mi" transform="translate(361,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(812,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mi" transform="translate(1341,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(1941,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/></g></g></g></g></g></svg></mjx-container>

#### HTTP的坚持型连接
非坚持型连接有以下几个缺点：
1.每一个请求对象都需要建立一次TCP连接，这样会导致额外的内存消耗

&gt; For each of these connections, TCP buffers must be allocated and TCP variables must be kept in both the client and server.

2.每一个对象的递交过程会导致两个RTT的时间消耗
##### 坚持型HTTP连接的断开

在HTTP1.1中，当TCP连接建立之后，剩余的对象都通过这个TCP连接递交。当递交结束之后，当这条TCP连接在一定的时间(a configurable timeout interval)没有被使用时，这条连接会自动关闭。

&gt; HTTP/2  builds on HTTP 1.1 by allowing multiple requests and replies to be interleaved in the same connection, and a mechanism for prioritizing HTTP message requests and replies within this connection.
（存疑）


![在这里插入图片描述](https://img-blog.csdnimg.cn/20210102184014664.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70#pic_center)

#### HTTP的报文格式
###### 请求报文
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个例子</span></span><br><span class="line"><span class="comment">//The great majority of HTTP request messages use the GET method.</span></span><br><span class="line">GET /somedir/page.html HTTP/<span class="number">1.1</span> <span class="comment">//the method field, the URL field, and the HTTP version field.</span></span><br><span class="line">Host: www.someschool.edu  <span class="comment">//对象所在的主机地址（Web代理缓存中需要）</span></span><br><span class="line">Connection: close<span class="comment">//表示非坚持型</span></span><br><span class="line">User-agent: Mozilla/<span class="number">5.0</span> <span class="comment">//浏览器的类型</span></span><br><span class="line">Accept-language: fr<span class="comment">//许多协商首部(negotiation header)中的一种</span></span><br></pre></td></tr></table></figure>
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210102204106878.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70#pic_center)
注意到上图出现的实体（Entity Body）部分，在GET方法中是空的，他在POST方法中，例如当用户提供搜索关键词的时候，POST仍然是向服务器请求获取网页，但是是网页特定的内容。
但是HTML表单（HTML form）通常用GET方法，并在URL（统一资源定位器）中加上输入的文本，就像这样：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当你在某个网站上面搜索“monkeys” 和“bananas”的时候，URL会变成下面这个样子</span></span><br><span class="line"> www.somesite.com/animalsearch?monkeys&amp;bananas</span><br></pre></td></tr></table></figure>
###### 应答报文
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个例子</span></span><br><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK<span class="comment">//the protocol version field, a status code（状态码：请求结果）, and a corresponding status message.</span></span><br><span class="line">Connection: close<span class="comment">//非坚持型</span></span><br><span class="line">Date: Tue, <span class="number">18</span> Aug <span class="number">2015</span> <span class="number">15</span>:<span class="number">44</span>:<span class="number">04</span> GMT<span class="comment">//服务器从自己的文件系统中获取被请求对象，并将它插入到回应报文中，后将它发送给客户机时的时间</span></span><br><span class="line">Server: Apache/<span class="number">2.2</span><span class="number">.3</span> (CentOS)<span class="comment">//服务器类型</span></span><br><span class="line">Last-Modified: Tue, <span class="number">18</span> Aug <span class="number">2015</span> <span class="number">15</span>:<span class="number">11</span>:<span class="number">03</span> GMT<span class="comment">// It is critical for object caching, both in the local client and in network cache servers (also known as proxy servers).</span></span><br><span class="line">Content-Length: <span class="number">6821</span><span class="comment">//被发送对象的比特数</span></span><br><span class="line">Content-Type: text/html<span class="comment">//发送主题的类型（HTML 文本）(The object type is officially indicated by the Content-Type: header and not by the file extension.)</span></span><br><span class="line">(data data data data data ...)<span class="comment">//报文核心部分（the meat of message）包含被请求的对象</span></span><br></pre></td></tr></table></figure>
报文请求结果类型：

&gt; 
&gt; **200 OK**: Request succeeded and the information is returned in the response.
**301 Moved Permanently**: Requested object has been permanently moved; the new URL is specified in Location : header of the response message. The client software will automatically retrieve the new URL.
**400 Bad Request**: This is a generic error code indicating that the request could not be understood by the server
**404 Not Found**: The requested document does not exist on this server.
**505 HTTP Version Not Supported**: The requested HTTP protocol version is not supported by the server.

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210102210031696.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70#pic_center)
状态行（state line）
表头行（header line）
(待续....)
</font>

<p>&lt;hr style=” border:solid; width:100px; height:1px;” color=#000000 size=1”&gt;</p>
<font color="#999AAA">

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><font color="#999AAA"><br>问题：<br>1.HTTP/2？（unsolved）</font></p>
</font></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-01-02T08:46:57.000Z" title="1/2/2021, 4:46:57 PM">2021-01-02</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-03-08T11:39:26.231Z" title="3/8/2023, 7:39:26 PM">2023-03-08</time></span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/01/02/Wireshark-Lab-Getting-Started/">Wireshark Lab:Getting Started</a></p><div class="content"><h1 id="Wireshark-Lab-Getting-Started"><a href="#Wireshark-Lab-Getting-Started" class="headerlink" title="Wireshark Lab:Getting Started"></a>Wireshark Lab:Getting Started</h1><p><font color="#999AAA">《计算机网络自顶向下方法7e》实验</font></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><font color="#999AAA">第一次实验主要就是介绍Wireshark应该怎么用，还有大致讲了Wireshark的工作原理。</font></p>
<h1 id="一、How-Wireshark-Works"><a href="#一、How-Wireshark-Works" class="headerlink" title="一、How Wireshark Works?"></a>一、How Wireshark Works?</h1><p><img src="https://img-blog.csdnimg.cn/20201231213649334.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_12,color_FFFFFF,t_70" alt><br>包嗅探器（Packet Sniffer）<br>其本身不主动运行，只是观察应用发送和接收的数据包，并保存这些数据包的一个备份。</p>
<blockquote>
<p>嗅探（Sniffers）是一种黑客的窃听手段，一般是指使用嗅探器对数据流的数据截获与封包分析（Packet analysis）。</p>
</blockquote>
<p>包捕捉器：接受数据链路层的帧，因为在这一层，数据包是最完整的（发送来的数据报没有被解封装，发送的数据报在这一层完成了所有的封装）。<br>包分析器：能够识别数据包的协议，以便将各层的协议部分从下一层的数据报中分离出来。</p>
<font color="#999AAA">



<h1 id="二、Wireshark的界面介绍"><a href="#二、Wireshark的界面介绍" class="headerlink" title="二、Wireshark的界面介绍"></a>二、Wireshark的界面介绍</h1><p><img src="https://img-blog.csdnimg.cn/20210102162028414.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h1 id="三、实验过程"><a href="#三、实验过程" class="headerlink" title="三、实验过程"></a>三、实验过程</h1><p>i）运行Wireshark，然后在浏览器中访问<a target="_blank" rel="noopener" href="http://gaia.cs.umass.edu/wireshark-labs/INTRO-wireshark-file1.html">http://gaia.cs.umass.edu/wireshark-labs/INTRO-wireshark-file1.html</a><br>ii）停止Wireshak，在过滤器中输入http。<br><img src="https://img-blog.csdnimg.cn/20210102163534330.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>在对应层可以看到对应协议的一些信息，例如在IP层可以看到数据包的发送者和接收者的IP地址。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><font color="#999AAA">How long did it take from when the HTTP GET message was sent until the HTTP<br>OK reply was received?（Unsolved）</font></p>
</font></div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/3/">Previous</a></div><div class="pagination-next"><a href="/page/5/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li><li><a class="pagination-link" href="/page/3/">3</a></li><li><a class="pagination-link is-current" href="/page/4/">4</a></li><li><a class="pagination-link" href="/page/5/">5</a></li></ul></nav></div><!--!--><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">Hexo</a><p class="is-size-7"><span>&copy; 2024 John Doe</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><!--!--><script data-pjax src="/js/main.js" defer></script><!--!--></body></html>