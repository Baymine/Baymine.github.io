<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/4/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/07/%E3%80%8A%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%9B%BE%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/07/%E3%80%8A%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%9B%BE%EF%BC%89/" class="post-title-link" itemprop="url">《算法笔记》数据结构（图）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-07 16:48:19" itemprop="dateCreated datePublished" datetime="2021-03-07T16:48:19+08:00">2021-03-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-08 19:48:52" itemprop="dateModified" datetime="2023-03-08T19:48:52+08:00">2023-03-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h1><p>图有两种存储方式：邻接表和邻接矩阵。邻接矩阵需要的空间较大，一般适用于顶点数目不超过1000的情况</p>
<h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><p>相当于一个离散的平面直角坐标系，每一个坐标代表一对节点的相互之间的关系，当两节点不直接相连的时候，这个坐标上的值可以设为0、-1或者是无穷大。否则可以在该点上赋值为这两点之间的权值。<img src="https://img-blog.csdnimg.cn/20210227084657192.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><p>将这些节点之间的关系保存在几个链表中，每一个链表都是在描述一个节点的连接情况。可以将这些数据保存在向量中。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>;<span class="comment">//顶点个数</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;Adj[N];</span><br><span class="line"><span class="comment">//之后直接将节点的信息连接到相应的向量之后</span></span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; ++i) &#123;</span><br><span class="line">		Adj[i].<span class="built_in">push_back</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当需要存放更多节点信息的时候，可以用结构体+构造函数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> v, w;</span><br><span class="line">	<span class="built_in">Node</span>(<span class="type">int</span> _v, <span class="type">int</span> _w) :<span class="built_in">v</span>(_v), <span class="built_in">w</span>(_w) &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//赋值：Adj[1].push_back(Node(3,4));</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><p>遍历就是将图中所有的节点都访问一遍，要做到不重复访问，不遗漏。主要的方法有深度优先和广度优先。</p>
<h2 id="深度优先"><a href="#深度优先" class="headerlink" title="深度优先"></a>深度优先</h2><p>访问的时候优先访问下一层的节点，运用递归的话，在递归返回的时候就相当于一次回溯，然后继续递归，即向下访问。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAXV = <span class="number">1000</span>;<span class="comment">//最大顶点数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">100000000000</span>;<span class="comment">//一个很大的数字</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//邻接矩阵:检查其邻接节点是否存在然后逐一访问。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adjacency_matrix</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> n, G[MAXV][MAXV];<span class="comment">//n为顶点数</span></span><br><span class="line">	<span class="type">bool</span> vis[MAXV] = &#123; <span class="literal">false</span> &#125;;<span class="comment">//访问数组，没访问的数组赋值为false</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> depth)</span> </span>&#123;</span><br><span class="line">		vis[u] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//将该节点的所有相邻的节点全部访问一遍</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; n; ++n) &#123;</span><br><span class="line">			<span class="comment">//该节点未被访问且与访问节点相联</span></span><br><span class="line">			<span class="keyword">if</span> (vis[v] == <span class="literal">false</span> &amp;&amp; G[u][v] != INF)<span class="built_in">DFS</span>(v, depth + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//确保所有连通子图都被访问到</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">DFSTrave</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">0</span>; u &lt; n; ++u) &#123;</span><br><span class="line">			<span class="keyword">if</span> (vis[u] == <span class="literal">false</span>)<span class="built_in">DFS</span>(u, <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//邻接表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adjancency_list</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;Adh[MAXV];</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="type">bool</span> vis[MAXV] = &#123; <span class="literal">false</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> depth)</span> </span>&#123;</span><br><span class="line">		vis[u] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//Traveling node u&#x27;s all neighbours</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Adj[u].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">			<span class="type">int</span> v = Adj[u][i];<span class="comment">//u节点的第i+1的邻接节点</span></span><br><span class="line">			<span class="keyword">if</span> (vis[v] == <span class="literal">false</span>)<span class="built_in">DFS</span>(v, depth + <span class="number">1</span>);<span class="comment">//没有访问则向下访问</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">DFSTrave</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//保证所有连通子图的节点都被访问到</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> u = <span class="number">0</span>; u &lt; n; ++u) &#123;</span><br><span class="line">			<span class="keyword">if</span> (vis[u] == <span class="literal">false</span>)<span class="built_in">DFS</span>(u, <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="广度优先"><a href="#广度优先" class="headerlink" title="广度优先"></a>广度优先</h2><p>&#8195; 在遍历过程中优先访问一个节点的所有的相邻的节点。这个时候需要借助队列，将该节点的所有相连节点加入到队列中，在队列中的节点顺序就是最终的广度优先遍历的顺序。同时，为了防止重复访问，需要建立一个数组，将节点的序号作为数组的下标，作为该节点是否被访问的标识。<br><br> &#8195; <strong>算法思想</strong>：先将起始节点加入到队列中，然后不断取出队列中的元素，访问并加入到队列中，并将该点相连的节点加入到队列中，直到队列中的元素为空。<br><br>&#8195;判断一个节点v1是否与另一个节点v2是否相连：<br>&#8195;邻接矩阵中，只需要确定[v1,v2]所对应的值是否为1，是则为相连，反之不相连。<br><br>&#8195;在邻接表中，只需要遍历这个节点所连接的那一条邻接表即可。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, G[MAXV][MAXV];</span><br><span class="line"><span class="type">bool</span> inq[MAXV] = &#123; <span class="literal">false</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//广度优先邻接矩阵版：先将首个节点入队，</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BFS_AdjMatrix</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">		queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//将首节点放到队列中</span></span><br><span class="line">		q.<span class="built_in">push</span>(u);</span><br><span class="line">		inq[u] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//将相邻的节点加入到队列中</span></span><br><span class="line">		<span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">			<span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">			q.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; n; ++v) &#123;</span><br><span class="line">				<span class="keyword">if</span> (inq[v] == <span class="literal">false</span> &amp;&amp; G[u][v] != INF) &#123;</span><br><span class="line">					q.<span class="built_in">push</span>(v);</span><br><span class="line">					inq[v] = <span class="literal">true</span>;<span class="comment">//访问之后加入队列，改变标识</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">BFSTrave</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//将未被访问过的节点全部访问一遍</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">0</span>; u &lt; n; ++u) &#123;</span><br><span class="line">			<span class="keyword">if</span> (inq[u] == <span class="literal">false</span>)<span class="built_in">BFS</span>(u);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//邻接表：访问节点的方式为遍历该向量的所有节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BFS_AdjList</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;Adj[MAXV];<span class="comment">//这其实相当于一个二维向量</span></span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="type">bool</span> inq[MAXV] = &#123; <span class="literal">false</span> &#125;;<span class="comment">//判断节点是否在队列中</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">		queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">		q.<span class="built_in">push</span>(u);</span><br><span class="line">		inq[u] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">			q.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Adj[u].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">				<span class="type">int</span> v = Adj[u][i];</span><br><span class="line">				<span class="keyword">if</span> (inq[v] == <span class="literal">false</span>) &#123;</span><br><span class="line">					q.<span class="built_in">push</span>(v);</span><br><span class="line">					inq[v] = <span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">BFSTravel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">0</span>; u &lt; n; ++u) &#123;</span><br><span class="line">			<span class="keyword">if</span> (inq[u] == <span class="literal">false</span>)<span class="built_in">BFS</span>(u);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//当想要得出所有节点的所在层的信息的时候：利用结构体，在其中加上层次这一变量</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> v;<span class="comment">//节点编号</span></span><br><span class="line">		<span class="type">int</span> layer;<span class="comment">//所在层次，头节点为第0层</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(<span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">		vector&lt;Node&gt;Adj[MAXV];</span><br><span class="line">		<span class="type">int</span> n;</span><br><span class="line">		<span class="type">bool</span> inq[MAXV] = &#123; <span class="literal">false</span> &#125;;</span><br><span class="line">		queue&lt;Node&gt;q;</span><br><span class="line">		Node start;<span class="comment">//第一个访问的节点</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//初始化首个节点</span></span><br><span class="line">		start.v = s;</span><br><span class="line">		start.layer = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		q.<span class="built_in">push</span>(start);</span><br><span class="line">		inq[start.v] = <span class="literal">true</span>;<span class="comment">//做好相应的标识</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			Node topNode = q.<span class="built_in">front</span>();</span><br><span class="line">			q.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="type">int</span> u = topNode.v;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Adj[u].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">				<span class="comment">//将next赋值为该节点连接的节点</span></span><br><span class="line">				Node next = Adj[u][i];</span><br><span class="line">				next.layer = topNode.layer + <span class="number">1</span>;<span class="comment">//赋值为上一层的层数+1</span></span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (inq[next.v] == <span class="literal">false</span>) &#123;</span><br><span class="line">					q.<span class="built_in">push</span>(next);</span><br><span class="line">					inq[next.v] = <span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><p>这类问题是求解图中从源点到图中任一节点的最短的距离（路径）。主要的算法有Dijkstra算法、Bellman-Ford算法、SPFA算法、Floyd算法。</p>
<h3 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h3><p>算法图示（取自<a target="_blank" rel="noopener" href="https://en.wikipedia.iwiki.eu.org/wiki/Dijkstra%27s_algorithm">Wikipedia</a>）<br><img src="https://img-blog.csdnimg.cn/20210302185505437.gif" alt="在这里插入图片描述"><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Dijkstra算法</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXV = <span class="number">1000</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e9</span>;<span class="comment">//无穷大</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//寻找最短距离</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//邻接矩阵:先找到与源点最近的相邻节点，然后从该节点出发，遍历该节点的所有的未被访问的相邻的节点，并更新最小权值</span></span><br><span class="line"><span class="comment">//O(V*(V+V)) = O(V^2)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SPD_AdjMatrix</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> n, G[MAXV][MAXV];<span class="comment">//分别为顶点数和以邻接矩阵形式存储的图</span></span><br><span class="line">	<span class="type">int</span> d[MAXV];<span class="comment">//该节点到源点的最短距离</span></span><br><span class="line">	<span class="type">bool</span> vis[MAXV] = &#123; <span class="literal">false</span> &#125;;<span class="comment">//访问数组，以图节点的编号作为索引</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">		<span class="built_in">fill</span>(d, d + MAXV, INF);<span class="comment">//将所有的节点初始化为极大值</span></span><br><span class="line">		d[s] = <span class="number">0</span>;<span class="comment">//源点到源点的距离为0</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//找到与起点相邻的路径最短的节点</span></span><br><span class="line">		<span class="type">int</span> u = <span class="number">-1</span>, MIN = INF;<span class="comment">//最短距离的节点编号和距离</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			<span class="comment">//遍历所有相邻节点</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">				<span class="comment">//未被访问，并且距离权值小于之前记录的最小值</span></span><br><span class="line">				<span class="keyword">if</span> (vis[j] == <span class="literal">false</span> &amp;&amp; d[j] &lt; MIN) &#123;</span><br><span class="line">					u = j;</span><br><span class="line">					MIN = d[j];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//说明剩下的顶点与起点s不相连通</span></span><br><span class="line">		<span class="keyword">if</span> (u == <span class="number">-1</span>)<span class="keyword">return</span>;</span><br><span class="line">		vis[u] = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; n; ++v) &#123;</span><br><span class="line">			<span class="comment">//与该节点相连且未被访问且以该节点为中介的权值比原先的权值更小</span></span><br><span class="line">			<span class="keyword">if</span> (vis[v] == <span class="literal">false</span> &amp;&amp; G[u][v] != INF &amp;&amp; d[u] + G[u][v] &lt; d[v]) &#123;</span><br><span class="line">				d[v] = d[u] + G[u][v];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//要记录最短路径的具体情况，可以记录每个节点最短路径的前驱，将该节点作为数组下标，数组中的值作为前驱节点的编号</span></span><br><span class="line">	<span class="type">int</span> pre[MAXV];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">DijkstraPath</span><span class="params">(<span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">fill</span>(d, d + MAXV, INF);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)pre[i] = i;<span class="comment">//(添加)初始化，将每个节点的前驱初试化为其本身</span></span><br><span class="line">		d[s] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//找到与起点相邻的路径最短的节点</span></span><br><span class="line">		<span class="type">int</span> u = <span class="number">-1</span>, MIN = INF;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">				<span class="keyword">if</span> (vis[j] == <span class="literal">false</span> &amp;&amp; d[j] &lt; MIN) &#123;</span><br><span class="line">					u = j;</span><br><span class="line">					MIN = d[j];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (u == <span class="number">-1</span>)<span class="keyword">return</span>;</span><br><span class="line">		vis[u] = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; n; ++v) &#123;</span><br><span class="line">			<span class="keyword">if</span> (vis[v] == <span class="literal">false</span> &amp;&amp; G[u][v] != INF &amp;&amp; d[u] + G[u][v] &lt; d[v]) &#123;</span><br><span class="line">				d[v] = d[u] + G[u][v];</span><br><span class="line">				pre[v] = u;<span class="comment">//(添加)将节点前驱初始化</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//输出路径</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (v == s) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, s);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">DFS</span>(s, pre[v]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, v);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//邻接表：O(V^2 + E)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SPD_AdjList</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">		<span class="type">int</span> v, dis;</span><br><span class="line">	&#125;;</span><br><span class="line">	vector&lt;Node&gt;Adj[MAXV];</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="type">int</span> d[MAXV];</span><br><span class="line">	<span class="type">bool</span> vis[MAXV] = &#123; <span class="literal">false</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">fill</span>(d, d + MAXV, INF);</span><br><span class="line">		d[s] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			<span class="type">int</span> u = <span class="number">-1</span>, MIN = INF;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">				<span class="keyword">if</span> (vis[j] == <span class="literal">false</span> &amp;&amp; d[j] &lt; MIN) &#123;</span><br><span class="line">					u = j;</span><br><span class="line">					MIN = d[j];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (u == <span class="number">-1</span>)<span class="keyword">return</span>;</span><br><span class="line">			vis[u] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//利用向量的特性，直接获取相邻的节点</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; Adj[u].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">				<span class="type">int</span> v = Adj[u][j].v;</span><br><span class="line">				<span class="comment">//检查是否满足条件</span></span><br><span class="line">				<span class="keyword">if</span> (vis[v] == <span class="literal">false</span> &amp;&amp; d[u] + Adj[u][j].dis &lt; d[v]) &#123;</span><br><span class="line">					d[v] = d[u] + Adj[u][j].dis;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>To Be Continue…</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/27/%E3%80%8A%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%8B%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E7%AE%97%E6%B3%95%E5%88%9D%E6%AD%A5%EF%BC%88%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/27/%E3%80%8A%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%8B%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E7%AE%97%E6%B3%95%E5%88%9D%E6%AD%A5%EF%BC%88%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3%EF%BC%89/" class="post-title-link" itemprop="url">《算法笔记》第四章：算法初步（算法思想）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-02-27 08:14:48" itemprop="dateCreated datePublished" datetime="2021-02-27T08:14:48+08:00">2021-02-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-08 19:44:49" itemprop="dateModified" datetime="2023-03-08T19:44:49+08:00">2023-03-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><font color="#999AAA"><br><strong>Learn to learn</strong><br>1.Whenever I tackle a new subject, one of my first thoughts is what kind of structure am I trying to build. What would be the input situations that should cause me to remember this knowledge? How do I need to manipulate it, discriminate between similar-seeming situations, calculate or reason with it?<br>2.When my end goal is to solve a practical problem, <strong><em>I should begin thinking about applications.</em></strong></font></p>
<hr>
<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><p>选择排序：从无序表中选择最值元素，放到有序表的末端<br>插入排序：将无序表中的以一个元素插入到有序表中的相应的位置</p>
<h2 id="sort-函数"><a href="#sort-函数" class="headerlink" title="sort 函数"></a>sort 函数</h2><p><font color="#999AAA"><br>C语言：qsort函数</font></p>
<p><font color="#999AAA"><br><br>C++：sort函数（方便，推荐使用，需要加上#include &lt;\algorithm\&gt;和using namespace std;）</font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数模板</span></span><br><span class="line"><span class="built_in">sort</span>(首元素地址,尾元素地址,比较函数（可选项）)；</span><br><span class="line"><span class="comment">//比较char类型时，默认按照字典序</span></span><br><span class="line"><span class="comment">//之后的cmp函数（Compare）可以自定义，以达到不同的排序效果，默认情况下是从小到大</span></span><br><span class="line"><span class="comment">//实现从大到小输出</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="keyword">return</span> a &gt; b</span>;</span><br><span class="line">.....</span><br><span class="line"><span class="built_in">sort</span>(a, a + <span class="number">4</span>, cmp);<span class="comment">//从大到小排序</span></span><br><span class="line"><span class="comment">//*原因？*</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对结构体数组的排序</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">&#125;ssd[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//编写cmp函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(a.x != b.x) <span class="keyword">return</span> a.x &gt; b.x;</span><br><span class="line">	esle <span class="keyword">return</span> a.y &lt; b.y;<span class="comment">//如果x相等则按照y的值进行排序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//容器的排序（vector、string 、deque）</span></span><br><span class="line">sort（vector.<span class="built_in">begin</span>(),vector.<span class="built_in">end</span>(),cmp）;</span><br><span class="line"><span class="comment">//可以调用相应的方法作为排序的标准</span></span><br></pre></td></tr></table></figure>
<h1 id="散列"><a href="#散列" class="headerlink" title="散列"></a>散列</h1><p>散列是典型的运用空间换时间策略的方法，就是将数据存储在一个更加容易访问的数据结构中，例如数组。可以将数组的下标和数组中存储的元素结合起来，这样可以根据下标的信息直接访问数组内的信息。根据映射的方式不同，散列分为不同的类型。</p>
<h2 id="线性散列"><a href="#线性散列" class="headerlink" title="线性散列"></a>线性散列</h2><p>就先上面的例子一样，直接将数组内的信息与数组的下标相结合，这样查询的时间复杂度将为O(1)</p>
<h2 id="取留余数法"><a href="#取留余数法" class="headerlink" title="取留余数法"></a>取留余数法</h2><p>把关键值除以某个数之后的余数作为散列的关键值。<script type="math/tex">H_{(key)}=key \% mod</script>当取mod是一个素数的时候，可以尽可能地覆盖[0, mod)范围内的所有数，还有为了不越界，数组的大小应该不小于mod。当两个数与一个数的模相等的时候，这时候就产生了冲突。</p>
<h3 id="线性探测法"><a href="#线性探测法" class="headerlink" title="线性探测法"></a>线性探测法</h3><p>检查$H_{(key)}+1$的情况。这种方法易产生扎堆，在一定程度上会降低效率</p>
<h3 id="平方探查法"><a href="#平方探查法" class="headerlink" title="平方探查法"></a>平方探查法</h3><p>检查$H<em>{(key)}\pm1^2、H</em>{(key)}\pm2^2 ……$(先正后负)<br>如果超出了边长，则把$H<em>{(key)}\pm k^2$对表长进行取模。<br>如果出现小于零的情况$((H</em>{(key)}- k^2)\%TSize + TSize)\%TSize$(其中TSize为表长)<br>为了避免负数出现的麻烦，可以只进行正向的平方探测。</p>
<h3 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h3><p>将哈希值相同的元素连接成一个单链表，表头元素就是数组的元素</p>
<p>在标准模板库中，有map可以直接使用hash表的功能（C++11以后可以用unordered<em>map，速度更快）。另外将一对或者是多对的整数映射成一个整数的方法可以是像十进制数那样，一个数字代表十位一个代表个位。（$H</em>{(P)} = x *Range + y$）</p>
<h3 id="map的常见用法"><a href="#map的常见用法" class="headerlink" title="map的常见用法"></a>map的常见用法</h3><p>map函数可以将任何类型映射到其他的任何类型（包括容器），使用map函数需要添加\<map>头文件，需要加上using namespace std;<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个map</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">map&lt;映射前的类型，映射后的类型&gt;容器名称</span><br><span class="line"><span class="comment">//注意一点，如果是字符串到整型的的映射必须是string而不能使用char数组</span></span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">char</span>, <span class="type">int</span>&gt;mp;</span><br><span class="line"><span class="comment">//map容器的访问方式</span></span><br><span class="line"><span class="comment">//通过下标访问</span></span><br><span class="line">mp[<span class="string">&#x27;c&#x27;</span>] = <span class="number">20</span>;<span class="comment">//注意这个是唯一的，后续的赋值会覆盖原先的值</span></span><br><span class="line"><span class="comment">//运用迭代器</span></span><br><span class="line"><span class="comment">//迭代器定义</span></span><br><span class="line">map&lt;typename1, typename2&gt;::iterator it;<span class="comment">//这两个类型名称是定义map时定义的变量类型</span></span><br><span class="line"><span class="comment">//访问键值</span></span><br><span class="line">it-&gt;first;it-&gt;second;</span><br><span class="line"><span class="comment">//遍历map中的所有键值的循环</span></span><br><span class="line"><span class="keyword">for</span>(map&lt;<span class="type">char</span>,<span class="type">int</span>&gt;::iterator it = mp.<span class="built_in">begin</span>(); it != map.<span class="built_in">end</span>();it++)&#123;...&#125;</span><br><span class="line"><span class="comment">//map是使用红黑树实现的，会以键从小到大的顺序自动排序</span></span><br></pre></td></tr></table></figure></map></p>
<h4 id="map常用函数"><a href="#map常用函数" class="headerlink" title="map常用函数"></a>map常用函数</h4><div class="table-container">
<table>
<thead>
<tr>
<th>函数名</th>
<th>功能</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>find(key)</td>
<td>返回键为key的映射的迭代器</td>
<td>O(logN) N为映射个数</td>
</tr>
<tr>
<td>erase()</td>
<td>删除一个元素、删除一个区间内的所有元素</td>
<td>传入迭代器：O(1)<br>传入键值：O(log(N))（N为map中的元素个数）</td>
</tr>
<tr>
<td>size()</td>
<td>获得map中映射的对数</td>
<td>O(1)</td>
</tr>
<tr>
<td>clear()</td>
<td>清空map中所有的元素</td>
<td>O(N)</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//运用范例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	map&lt;<span class="type">char</span>, <span class="type">int</span>&gt;mp;</span><br><span class="line">	mp[<span class="string">&#x27;a&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">	mp[<span class="string">&#x27;b&#x27;</span>] = <span class="number">2</span>;</span><br><span class="line">	map&lt;<span class="type">char</span>, <span class="type">int</span>&gt;::iterator it = mp.<span class="built_in">find</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">	mp.<span class="built_in">erase</span>(it);</span><br><span class="line">	mp.<span class="built_in">erase</span>(<span class="string">&#x27;b&#x27;</span>);<span class="comment">//与上面的作用相同</span></span><br><span class="line">	mp.<span class="built_in">erase</span>(it, mp.<span class="built_in">end</span>());<span class="comment">//传入删除的区间</span></span><br><span class="line">	mp.<span class="built_in">size</span>();</span><br><span class="line">	mp.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将字母映射成十进制数</span></span><br><span class="line"><span class="comment">//算法思想：将26个字母看成26进制数，然后转换成相应的十进制数，转换过程为：</span></span><br><span class="line"><span class="comment">//个位数加上更高位数乘以进制数，这个可以类比十进制数的构成，因为传入的时候是从高位开始的（从左向右读取），</span></span><br><span class="line"><span class="comment">//所以可以将每一次输入的数字都是在个位数，其他的按照进制数倍增</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">hashFunc</span><span class="params">(<span class="type">char</span> S[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> id = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">		id = id * <span class="number">26</span> + (S[i] - <span class="string">&#x27;A&#x27;</span>);<span class="comment">//个位数+更高位数*进制数</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, id);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当还遇到小写字母的时候</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">hashFunc</span><span class="params">(<span class="type">char</span> S[], <span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> id = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(S[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; S[i] &lt;= <span class="string">&#x27;Z&#x27;</span>)&#123;</span><br><span class="line">			id = id * <span class="number">52</span> + (S[i] - <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(S[i] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; S[i] &lt;= <span class="string">&#x27;z&#x27;</span>)&#123;</span><br><span class="line">			id = id * <span class="number">52</span> + (S[i] - <span class="string">&#x27;a&#x27;</span>) + <span class="number">26</span>;<span class="comment">//注意这里加上的26，是因为在这个52进制当中，大写字母在前面</span></span><br><span class="line">			<span class="comment">//类比十进制， 8 = 3 + 5；</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果还出现了数字，则将进制数扩大到62</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><h2 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h2><p>这种思想让我想到了一个成语：众人拾柴火焰高。将”火焰高“这个目的划分成“众人拾柴”，这个规模较小而与原问题相似的子问题。这包含分治思想的三个方面：首先将一个问题进行分解，然后求解子问题，最后将问题的结果合并成原问题的结果。这样的话你只需要专注于一个小问题就可以。当然，<strong>子问题应该是相互独立的、没有交叉的。</strong></p>
<h2 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h2><p>   这实际上是一种分治思想，这样做的结果就是只需要专注于一个小问题即可，但是与之前“拾柴”的的例子不一样，之前的像是单层的分解，但是递归应该是多层次的。<br>    在使用递归的时候应该注意两点，<strong>递归式和递归边界</strong>。这也就是怎么划分和划分到什么地步的问题。<br>    下面是求解全排列的问题：在全排列问题中，每一个元素只有两种状态，被选和没有被选，只需要所有的元素的这两种状态全部遍历一遍就可以了。在选和不选中做抉择，可以将所有情况画成一棵树，这棵树就叫做<strong>决策树</strong><br>    <img src="https://img-blog.csdnimg.cn/20210319081859195.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="图源水印"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全排列，字典序</span></span><br><span class="line"><span class="comment">//头部应该是不断更新的，也就是子排列中的头部</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">算法思想：先确定排列的首部，然后剩下的子序列做同样的操作，这样就可以将问题不断减小。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;<span class="comment">//待排元素的个数</span></span><br><span class="line"><span class="type">int</span> p[maxn];<span class="comment">//存储当前排列</span></span><br><span class="line"><span class="type">int</span> hashTable[maxn] = &#123; <span class="literal">false</span> &#125;;<span class="comment">//判断索引元素是否在排列数组中</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;<span class="comment">//统计全排列的个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//处理排列的idex号位</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">generateP</span><span class="params">(<span class="type">int</span> index)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//这是递归边界，前面的元素全部排列完毕，现在是要将数组输出</span></span><br><span class="line">	<span class="keyword">if</span> (index == n + <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, p[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历检查所有的元素，这里引用了外部的变量n，由主函数定义（作为参数是不是好点？）</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">1</span>; x &lt;= n; ++x) &#123;</span><br><span class="line">		<span class="comment">//哈希表是来表示索引元素是否已经加入数组了</span></span><br><span class="line">		<span class="keyword">if</span> (hashTable[x] == <span class="literal">false</span>) &#123;</span><br><span class="line">			p[index] = x;<span class="comment">//以x作为头部的时候</span></span><br><span class="line">			hashTable[x] = <span class="literal">true</span>;<span class="comment">//更新状态</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//这里是继续下一位，注意这里还没有将哈希表重置，所以原先作为首部的元素是不会再被赋值了</span></span><br><span class="line">			<span class="built_in">generateP</span>(index + <span class="number">1</span>);</span><br><span class="line">			hashTable[x] = <span class="literal">false</span>;<span class="comment">//完成递归项中的一个，重置状态</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	count++;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	n = <span class="number">9</span>;<span class="comment">//表示输出1~3的全排列同时还表示全排列的数组元素个数</span></span><br><span class="line">	<span class="built_in">generateP</span>(<span class="number">1</span>);<span class="comment">//表示从P[1]开始</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n%d&quot;</span>, count);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在一点条件下，之后的实例都无法满足要求，这时候可以直接退出该层递归，返回上一层。这种方法成为<strong>回溯</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//n皇后问题，n*n的格子中，放入n个皇后，这n个皇后不能在同行、列、对角线</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;<span class="comment">//待排元素的个数</span></span><br><span class="line"><span class="type">int</span> p[maxn];<span class="comment">//存储当前排列</span></span><br><span class="line"><span class="type">int</span> hashTable[maxn] = &#123; <span class="literal">false</span> &#125;;<span class="comment">//判断索引元素是否在排列数组中</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;<span class="comment">//统计全排列的个数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">generateP</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (index == n + <span class="number">1</span>) &#123;</span><br><span class="line">		count++;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">1</span>; x &lt;= n; x++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (hashTable[x] == <span class="literal">false</span>) &#123;</span><br><span class="line">			<span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> pre = <span class="number">1</span>; pre &lt; index; pre++) &#123;</span><br><span class="line">				<span class="comment">//检查是否在同一对角线上，注意进入if语句之后该次循环就会被跳过</span></span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">abs</span>(index - pre) == <span class="built_in">abs</span>(x - p[pre])) &#123;</span><br><span class="line">					flag = <span class="literal">false</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (flag) &#123;</span><br><span class="line">				p[index] = x;</span><br><span class="line">				hashTable[x] = <span class="literal">true</span>;</span><br><span class="line">				<span class="built_in">generateP</span>(index + <span class="number">1</span>);</span><br><span class="line">				hashTable[x] = <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><p>用局部最优来达到全局最优的结果。分为在线算法（Online Algorithms）和离线算法（Offline Algorithms），可以证明在线算法无法得到最优解。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//B1020月饼</span></span><br><span class="line"><span class="comment">//忽略最后注释部分</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">mooncake</span> &#123;</span><br><span class="line">	<span class="type">double</span> store;</span><br><span class="line">	<span class="type">double</span> sell;</span><br><span class="line">	<span class="type">double</span> price;</span><br><span class="line">&#125;cake[<span class="number">1010</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义函数的时候一定要大括号</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(mooncake a, mooncake b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.price &gt; b.price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n;<span class="comment">//月饼种类</span></span><br><span class="line">	<span class="type">double</span> D;<span class="comment">//市场需求量</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%lf&quot;</span>, &amp;n, &amp;D);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化库存</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="comment">//少些%不会报错，但会出错</span></span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;cake[i].store);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//初始化利润</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;cake[i].sell);</span><br><span class="line">		cake[i].price = cake[i].sell / cake[i].store;<span class="comment">//计算单价</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//将数组由根据单价由大到小排列</span></span><br><span class="line">	<span class="built_in">sort</span>(cake, cake + n, cmp);</span><br><span class="line"></span><br><span class="line">	<span class="type">double</span> ans = <span class="number">0</span>;<span class="comment">//最大利润</span></span><br><span class="line">	<span class="comment">//枚举各种月饼</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="comment">//检查是否满足市场需求量</span></span><br><span class="line">		<span class="keyword">if</span> (cake[i].store &lt;= D) &#123;</span><br><span class="line">			D -= cake[i].store;<span class="comment">//更新需求量</span></span><br><span class="line">			ans += cake[i].sell;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			ans += cake[i].price * D;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">算法思想：先算出单价利润最大的月饼，然后将对应的全部卖出，要考虑的</span></span><br><span class="line"><span class="comment">需要较为进阶的语言知识，现阶段还是不要这样做为好，直接定义最大的情况下的数组即可</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#include&lt;cstdio&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">struct MoonPie&#123;</span></span><br><span class="line"><span class="comment">    int rep;//库存</span></span><br><span class="line"><span class="comment">    int profit;//利润</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    MoonPie()&#123;&#125;;</span></span><br><span class="line"><span class="comment">    MoonPie(int _rep)&#123;</span></span><br><span class="line"><span class="comment">        rep = _rep;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    MoonPie(int _profit)&#123;</span></span><br><span class="line"><span class="comment">        profit = _profit;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    int value = profit / (double)rep;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">int main(void)&#123;</span></span><br><span class="line"><span class="comment">    int n;//月饼种类</span></span><br><span class="line"><span class="comment">    int re;//需求量</span></span><br><span class="line"><span class="comment">    int profit,rep;</span></span><br><span class="line"><span class="comment">    in maxValue = 0;//最大单价</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    scanf(&quot;%d %d&quot;,&amp;n,&amp;re);</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    //输入数据，定义动态数组，</span></span><br><span class="line"><span class="comment">    int *p = new int[n];</span></span><br><span class="line"><span class="comment">    //找出单个利润最大的月饼</span></span><br><span class="line"><span class="comment">    //初始化数据</span></span><br><span class="line"><span class="comment">    for(int i = 1; i &lt;= n; ++i)&#123;</span></span><br><span class="line"><span class="comment">        scanf(&quot;%d&quot;,&amp;rep);</span></span><br><span class="line"><span class="comment">        p[i] = MoonPie(rep);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    for(int i = 1; i &lt;= n; ++i)&#123;</span></span><br><span class="line"><span class="comment">        scanf(&quot;%d&quot;,&amp;profit);</span></span><br><span class="line"><span class="comment">        p[i] = MoonPie(profit);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    for(int i = 1; i &lt;= n; ++i)&#123;</span></span><br><span class="line"><span class="comment">        if(maxValue &lt; p[i].value) maxValue = p[i].value;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    //比较市场需求量和库存，计算最终的利润</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> mid;<span class="comment">//查找区间的中间的位置</span></span><br><span class="line">	<span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">		mid = (left + right)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(A[mid] == x) <span class="keyword">return</span> mid;<span class="comment">//找到</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//更新查找区间</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(A[mid] &gt; x)right = mid <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当查找范围较大时，（left+right可能会越界）这个时候可以用mid = left+(right-left)/2  代替</span></span><br></pre></td></tr></table></figure>
<p>当查找的元素数组中包含重复的元素时，这也就是说目标元素在数组中可能不止一个，这个时候就应该返回目标元素所在的区间。算法的总体思路：对于一个有序表，找出第一个与目标元素相等的位置和第一个与目标元素不相等的位置，得到对应的区间<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找出目标数组的上界，第一个大于等于x的元素的位置</span></span><br><span class="line"><span class="comment">//注意在这里二分法的上界是n因为当x不存在的时候，位置范围可能在数组范围之外的那个元素的位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lower_bound</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> mid;</span><br><span class="line">	<span class="comment">//注意这个判断条件，只是确定x的范围，对x是否存在并不关心（？）</span></span><br><span class="line">	<span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">		mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(A[mid] &gt;= x)right = mid;</span><br><span class="line">		<span class="keyword">else</span> left = mid +<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//同样的求目标元素的上界，即数组元素第一次与目标元素不相同的时候，与求下界的函数相比，主要的区别就在于</span></span><br><span class="line"><span class="comment">//判断语句中少了等于，这样当指向这个数组元素的时候，就会继续进行原先的步骤,因为这个函数的主要目的就是找到第一个与目标元素不相等的元素的位置</span></span><br></pre></td></tr></table></figure><br>二分查找的思想本质上就是利用目标左右两端的情况，来不断调整范围，以实现向目标趋近的目的。所以，二分法不仅仅可以用于查询满足条件的目标，还可以求目标的近似。下面是一个求$\sqrt{2}$的近似值 的例子<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">算法思想：考虑函数f(x) = x^2，想要求sqrt(2),只需要找到函数值趋向于2的数即可。先比较区间中点mid的与f(x)的</span></span><br><span class="line"><span class="comment">大小，若mid&gt;f(x), 则从[left,mid]中去寻找，其他情况类似，直到达到想要的精度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> esp = <span class="number">1e-5</span>;<span class="comment">//需要的精度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">f</span><span class="params">(<span class="type">double</span> x)</span> <span class="keyword">return</span> x * x</span>;<span class="comment">//关系函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">calSqrt</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">double</span> left = <span class="number">1</span>, right = <span class="number">2</span>, mid;<span class="comment">//左、右区间范围，中间元素指针</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(right - left &gt; esp)&#123;<span class="comment">//检查是否满足精度</span></span><br><span class="line">		mid = (left + right)/<span class="number">2</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//更新区间信息</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">f</span>(mid) &gt; <span class="number">2</span>)right = mid;</span><br><span class="line">		<span class="keyword">else</span> left = mid;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这本质上就是求解一个方程，因为算法只能逼近与一个点，所以需要在区间内只有一个目标，或者说保证二者的关系是单调的</span></span><br></pre></td></tr></table></figure></p>
<h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><blockquote>
<p>题目描述：给定三个正数a、b、m（a&lt;$10^9,b&lt;10^{18},1&lt;m&lt;10^9$),求$a^b\% m$）</p>
</blockquote>
<p>算法分析:因为数字的数量级太大，直接通过循环来求解需要的时间会很多（时间复杂度为O(n)）,可以借用快速幂的方法：</p>
<script type="math/tex; mode=display">a^b=\left\{
\begin{aligned}
 \ a *a^{b-1} （b为奇数）\\a^{\frac b2}*a^{\frac b2}（b为偶数） \\
\end{aligned}
\right.</script><p>这样可以将幂次的乘积进一步减少<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快速幂的递归形式</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="comment">//参数分别为底数、指数、模数</span></span><br><span class="line"><span class="function">LL <span class="title">binaryPow</span><span class="params">(LL a, LL b, LL m)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(b == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//递归出口</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(b % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> a * <span class="built_in">binaryPow</span>(a, b - <span class="number">1</span>, m) % m;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		LL mul = <span class="built_in">binaryPow</span>(a, b / <span class="number">2</span>, m);</span><br><span class="line">		<span class="keyword">return</span> mul * mul % m;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//if(b % 2 == 1)还可以这样写if (b &amp; 1)代替，后者就是检查b的二进制形式的最后</span></span><br><span class="line"><span class="comment">//一位是否是1，是则为奇数，否则为偶数</span></span><br><span class="line"><span class="comment">//还有注意返回时不要写：</span></span><br><span class="line"><span class="keyword">return</span> (<span class="built_in">binariPow</span>(a, b / <span class="number">2</span>, m) * <span class="built_in">binariPow</span>(a, b / <span class="number">2</span>, m)) % m;</span><br><span class="line"><span class="comment">//因为这样会导致额外的运算</span></span><br></pre></td></tr></table></figure></p>
<p>To Be Continue…</p>
<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>双指针法分为两种，一种是首尾指针，一种是快慢指针，前者用于</p>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h2 id="其他高效技巧与算法"><a href="#其他高效技巧与算法" class="headerlink" title="其他高效技巧与算法"></a>其他高效技巧与算法</h2><h3 id="回溯（动态规划）"><a href="#回溯（动态规划）" class="headerlink" title="回溯（动态规划）"></a>回溯（动态规划）</h3><p>动态规划的关键就是将一个问题划分成几个相互之间有交集的子问题。典型的问题就是求最优解的问题，可以从前到后，不断将最优的解放到数组中，这样要求解该轮下的最优解，只需要将所有情况都试一遍，然后比较出最优的那一个即可。这个过程就像是遍历一棵树，找到最优子节点，然后以子节点作为头节点继续遍历，直到满足条件。</p>
<p><img src="https://img-blog.csdnimg.cn/20210317102844192.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>动态规划问题的分析模式：</p>
<blockquote>
<p>1.分析最优解的结构<br>2.递归地定义最优解的值<br>3.计算最优解（从低向上）<br>4.展示结果</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#找出数组中两两不相邻的数字的最大值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">de_opt</span>(<span class="params">arr</span>):</span><br><span class="line">	opt = np.zeros(<span class="built_in">len</span>(arr))</span><br><span class="line">	opt[<span class="number">0</span>] = arr[<span class="number">0</span>]</span><br><span class="line">	opt[<span class="number">1</span>] = <span class="built_in">max</span>(arr[<span class="number">0</span>], arr[<span class="number">1</span>])</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">len</span>(arr)):</span><br><span class="line">		A = opt[i-<span class="number">2</span>] + arr[i]</span><br><span class="line">		B = opt[i-<span class="number">1</span>]</span><br><span class="line">		opt[i] = <span class="built_in">max</span>(A,B)</span><br><span class="line">	<span class="keyword">return</span> opt[<span class="built_in">len</span>(arr) - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#递归写法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rec_opt</span>(<span class="params">arr, i</span>)</span><br><span class="line">	<span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">return</span> arr[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">elif</span> i == <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">max</span>(arr[<span class="number">0</span>], arr[<span class="number">1</span>])</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		A = rec_opt(arr, i - <span class="number">2</span>) + arr[i]</span><br><span class="line">		B = rec_opt(arr, i - <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">max</span>(A, B)</span><br></pre></td></tr></table></figure>
<p>回溯（sù）：将选择一种情况作为一个结果，然后将不选择该情况作为另一个结果，找出两种情况的最优解，得到局部的最优解。<br><img src="https://img-blog.csdnimg.cn/20210317104724690.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/25/%E3%80%8A%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%83%A8%E5%88%86-STL-%E9%93%BE%E8%A1%A8-%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/25/%E3%80%8A%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%83%A8%E5%88%86-STL-%E9%93%BE%E8%A1%A8-%E6%A0%91/" class="post-title-link" itemprop="url">《算法笔记》数据结构部分(STL&链表&树)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-02-25 10:46:43" itemprop="dateCreated datePublished" datetime="2021-02-25T10:46:43+08:00">2021-02-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-08 19:44:22" itemprop="dateModified" datetime="2023-03-08T19:44:22+08:00">2023-03-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="C-STL"><a href="#C-STL" class="headerlink" title="C++ STL"></a>C++ STL</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个栈</span></span><br><span class="line">stack &lt;<span class="keyword">typename</span>&gt; name;</span><br><span class="line"></span><br><span class="line"><span class="comment">//stack函数实例</span></span><br><span class="line">stack.<span class="built_in">push</span>(x);<span class="comment">//将元素x加入到栈中</span></span><br><span class="line">stack.<span class="built_in">top</span>();<span class="comment">//获取栈顶元素</span></span><br><span class="line">stack.<span class="built_in">pop</span>();<span class="comment">//将栈顶元素弹出</span></span><br><span class="line">stack.<span class="built_in">empty</span>();<span class="comment">//判断栈是否为空，返回值类型为空</span></span><br><span class="line">stack.<span class="built_in">size</span>();<span class="comment">//返回栈内元素</span></span><br></pre></td></tr></table></figure>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队列的定义</span></span><br><span class="line">queue&lt; <span class="keyword">typename</span> &gt; name;</span><br><span class="line"></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line"><span class="comment">//queue函数实例</span></span><br><span class="line">Q.<span class="built_in">push</span>(x);<span class="comment">//将元素x入队</span></span><br><span class="line">Q.<span class="built_in">front</span>();<span class="comment">//获取队首元素</span></span><br><span class="line">Q.<span class="built_in">back</span>();<span class="comment">//获取队尾元素</span></span><br><span class="line">Q.<span class="built_in">pop</span>();<span class="comment">//将队首元素出队</span></span><br><span class="line">Q.<span class="built_in">empty</span>();<span class="comment">//判断队列是否为空</span></span><br><span class="line">Q.<span class="built_in">size</span>();<span class="comment">//队列中元素的个数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="优先队列（Priority-queue）"><a href="#优先队列（Priority-queue）" class="headerlink" title="优先队列（Priority_queue）"></a>优先队列（Priority_queue）</h3><p>优先队列就是按照元素的优先级来确定对首部的元素的队列，它是由堆实现的，这种优先级的规则可以自定义。优先队列可以用于计算哈夫曼树最短路径权值，可以对Dijkstra算法进行优化，还可以解决一些贪心问题。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	priority_queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">	q.<span class="built_in">push</span>(<span class="number">3</span>);<span class="comment">//将3入队</span></span><br><span class="line">	q.<span class="built_in">empty</span>();<span class="comment">//检查队列是否为空</span></span><br><span class="line">	q.<span class="built_in">pop</span>();<span class="comment">//将优先级最高的元素出队</span></span><br><span class="line">	q.<span class="built_in">size</span>();<span class="comment">//队列的大小</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//第一个参数是元素类型，第二个是承载底层数据结构堆的容器，第三个是参数的比较类，less&lt;int&gt;表示数字越大优先级越高</span></span><br><span class="line">	priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt;q_1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当想以结构体中的数据作为优先级的时候，应该堆操作符进行重载</span></span><br><span class="line"><span class="comment">//使用时直接将相应的结构体定义的变量直接入队即可</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">fruit</span> &#123;</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> price;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//价格高的优先级高</span></span><br><span class="line">	<span class="comment">//由于队列默认将优先级高的放在队首，如果将小于号重载为大于号，最后会将规则反向</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt; (fruit f1, fruit f2) &#123;</span><br><span class="line">		<span class="keyword">return</span> f1.price &lt; f2.price;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以将比较函数写在结构体外面</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span>&#123;	</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(fruit f1, fruit f2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> f1.price &gt; f2.price;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;fruit, vector&lt;<span class="type">int</span>&gt;, cmp&gt;p_2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当结构体数据较大应该使用引用来提高效率</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">friend bool operator &lt; (const fruit&amp; f1, const fruit&amp; f2) &#123;</span></span><br><span class="line"><span class="comment">	....</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
<h2 id="pair采用方法"><a href="#pair采用方法" class="headerlink" title="pair采用方法"></a>pair采用方法</h2><p>pair可以用于快速定义一个相当于拥有两个变量的结构体。使用pair需要添加函数头utility.当然map函数头中包含前者。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个pair变量，并初始化</span></span><br><span class="line">pair&lt;typename1, typename2&gt;<span class="built_in">name</span>(initial1, initial2);</span><br><span class="line"><span class="comment">//定义一个临时pair变量</span></span><br><span class="line">name = <span class="built_in">make_pair</span>(initial1, initial2);</span><br></pre></td></tr></table></figure></p>
<h3 id="pair函数的操作"><a href="#pair函数的操作" class="headerlink" title="pair函数的操作"></a>pair函数的操作</h3><p><strong>比较两个pair函数</strong>:可以直接用比较符，规则是先比较第一个的大小，当相等时比较第二个元素的大小<br><strong>常见用途</strong>：1.代替二元结构体机器构造函数。2.作为map的键值进行插入。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	map&lt;string, <span class="type">int</span>&gt;mp;<span class="comment">//定义一个哈希表</span></span><br><span class="line">	<span class="comment">//往哈希表中插入两个对键值</span></span><br><span class="line">	mp.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;hey&quot;</span>, <span class="number">5</span>));</span><br><span class="line">	mp.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;string, <span class="type">int</span>&gt;(<span class="string">&quot;Hei&quot;</span>, <span class="number">10</span>));</span><br><span class="line">	<span class="comment">//利用迭代器遍历哈希表</span></span><br><span class="line">	<span class="keyword">for</span>(map&lt;string, <span class="type">int</span>&gt;::iterator it = mp.<span class="built_in">begin</span>();it != mp.<span class="built_in">end</span>();++it)&#123;</span><br><span class="line">		cout&lt;&lt;it-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h2><p>需要包含文件头vector 和using namespace std;<br>定义方式：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">typename</span>&gt; vector_name;</span><br></pre></td></tr></table></figure><br>操作：<br>1.获取元素的最后一个元素<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector_name.<span class="built_in">end</span>()<span class="number">-1</span>;<span class="comment">//注意end是指向最后一个元素的下一位</span></span><br><span class="line">vector_name.<span class="built_in">back</span>();</span><br><span class="line">vector_name.<span class="built_in">rbegine</span>();</span><br><span class="line">vector_name.<span class="built_in">at</span>(vector_name.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br></pre></td></tr></table></figure></p>
<h2 id="集合set"><a href="#集合set" class="headerlink" title="集合set"></a>集合set</h2><p>集合是一种内部有序且不含重复元素的容器。当数据加入到集合中是，会自动去重和排序，默认排序是从小到大。要使用集合需要加上set函数头，并且使用std名字空间。</p>
<p>定义方式：(其实容器定义的方式都大同小异)</p>
<blockquote>
<p>迭代器不是指针，是类模板，表现的像指针。他只是模拟了指针的一些功能，通过重载了指针的一些操作符，$-&gt;、*、++ 、—$等封装了指针<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="keyword">typename</span>&gt; name;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>访问方式：（集合只能通过迭代器访问）<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义迭代器</span></span><br><span class="line">set&lt;<span class="keyword">typename</span>&gt;::iterator it;</span><br><span class="line"></span><br><span class="line"><span class="comment">//除了vector和string之外，其他的STL都不支持*（it+1）的访问方式</span></span><br><span class="line"><span class="comment">//枚举</span></span><br><span class="line">set&lt;<span class="type">int</span>&gt;st;</span><br><span class="line"><span class="comment">//initialize</span></span><br><span class="line">.......</span><br><span class="line"><span class="keyword">for</span>(set&lt;<span class="type">int</span>&gt;::iterator it = st.<span class="built_in">begin</span>(); it != st.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">	<span class="built_in">visit</span>(*it);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>set常用的函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">insert</span>(x);<span class="comment">//将x加入set，并实现递增排序和去重(O(logN))</span></span><br><span class="line"><span class="built_in">find</span>(value);<span class="comment">//找到对应value的迭代器(O(logN))</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">erase</span>(it);<span class="comment">//删除迭代器所指的元素，可以通过find函数找到对应的迭代器</span></span><br><span class="line"><span class="built_in">erase</span>(value);<span class="comment">//删除值为value的元素。时间复杂度O(logN)</span></span><br><span class="line"><span class="built_in">erase</span>(first, last);<span class="comment">//删除区间元素，删除区间为[first, last)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">size</span>();<span class="comment">//set中元素的个数O（1）</span></span><br><span class="line"><span class="built_in">clear</span>();<span class="comment">//delete all elements within the set </span></span><br></pre></td></tr></table></figure><br>使用unordered_set,只进行去重而不进行排序，速度比set要快很多。</p>
<h2 id="字符串类型String"><a href="#字符串类型String" class="headerlink" title="字符串类型String"></a>字符串类型String</h2><p>string类型将字符串数组的一些常用操作封装起来，使用时需要添加文件头string（注意一点string和string.h是不一样的），还需要std的名字空间。<br>初始化<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//define &amp; initializing</span></span><br><span class="line">string str = <span class="string">&quot;abc&quot;</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Access</span></span><br><span class="line"><span class="comment">//1.By subindex</span></span><br><span class="line">str[<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<p>想要输入或者输出字符串，只能使用cin和cout。需要用printf输出，可以使用c_str()函数将string类型转换成字符串数组<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,str.<span class="built_in">c_str</span>());</span><br></pre></td></tr></table></figure><br>通过迭代器访问<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//define. It no needs typename </span></span><br><span class="line">string::iterator it;</span><br><span class="line"><span class="keyword">for</span>(string::iterator it = str.<span class="built_in">begin</span>(); it != str.<span class="built_in">end</span>();++it)&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, *it);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>string和vector一样，能够直接通过对迭代器加减某数字实现访问。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.<span class="built_in">begin</span>() + <span class="number">3</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="函数实例"><a href="#函数实例" class="headerlink" title="函数实例"></a>函数实例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//连接两string类型</span></span><br><span class="line">str3 = str2 + str1;</span><br><span class="line">str1 += str2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按照字典序比较两string类型的大小</span></span><br><span class="line">str1 &gt;= str2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回string类型的长度</span></span><br><span class="line">str.<span class="built_in">size</span>();</span><br><span class="line">str.<span class="built_in">length</span>();</span><br></pre></td></tr></table></figure>
<p>insert()函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str.<span class="built_in">insert</span>(pos,string);<span class="comment">//在str的第pos位插入stringO(N)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//str的3号位插入str2</span></span><br><span class="line">(prototype-&gt;)<span class="built_in">insert</span>(it,it2,it3);<span class="comment">//串[it2, it3)插入到it对应的位置上</span></span><br><span class="line">str.<span class="built_in">insert</span>(str.<span class="built_in">begin</span>() + <span class="number">3</span>, str2.<span class="built_in">begin</span>(), str2.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><br>erase()删除<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除单个元素</span></span><br><span class="line"><span class="built_in">erase</span>(it);<span class="comment">//删除元素的迭代器</span></span><br><span class="line"><span class="built_in">erase</span>(fist,last);<span class="comment">//删除区间[first, last)的元素</span></span><br><span class="line"><span class="built_in">erase</span>(pos,length);<span class="comment">//pos开始删除length个字符个数</span></span><br><span class="line"><span class="built_in">clear</span>();<span class="comment">//清空</span></span><br></pre></td></tr></table></figure><br>其他<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">substr</span>(pos,len);<span class="comment">//冲pos开始获取长度为len的子串</span></span><br><span class="line">string::npos; <span class="comment">//一个常数等于-1或者是unsigned_int的最大值，用于find函数失配的返回值</span></span><br><span class="line"><span class="built_in">find</span>(str2);<span class="comment">//找到str2在字符串中第一次出现的位置，找不到返回string::npos.时间复杂度O(nm)</span></span><br><span class="line"></span><br><span class="line">str.<span class="built_in">replace</span>(pos, len, str2);<span class="comment">//将str从pos位开始长度为len的子串替换成str2</span></span><br><span class="line">str.<span class="built_in">replace</span>(it1,it2,str2);<span class="comment">//把迭代器范围内[it1,it2)的子串换成str2</span></span><br></pre></td></tr></table></figure></p>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h3 id="链表的概念"><a href="#链表的概念" class="headerlink" title="链表的概念"></a>链表的概念</h3><p>链表的物理地址是可以是不连续的，但是链表逻辑上是连续的。链表包含两个部分，一个用于存储数据，一个用于存储下一个节点的内存地址，以保证逻辑上的连续。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链表的结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="keyword">typename</span> data;<span class="comment">//数据域</span></span><br><span class="line">	node* next;<span class="comment">//指针域</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="链表节点的空间分配"><a href="#链表节点的空间分配" class="headerlink" title="链表节点的空间分配"></a>链表节点的空间分配</h3><p>为链表节点分配空间可以利用两种函数：malloc(C语言) 和new(C++)。但是在空间分配之后，需要队空间进行释放，否则在一些情况下就会导致<strong>内存泄漏</strong>（在一些大型程序中，可能会导致弃用的空间一直被占用，而使得无法申请新的空间）。</p>
<h4 id="malloc函数"><a href="#malloc函数" class="headerlink" title="malloc函数"></a>malloc函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typename</span>* p = (<span class="keyword">typename</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">typename</span>));</span><br><span class="line"><span class="comment">/*整个过程就是malloc函数申请一个于数据类型大小一致的空间，这个时</span></span><br><span class="line"><span class="comment">候返回的指针是void类型，然后将他强制转化成int类型，并分配给</span></span><br><span class="line"><span class="comment">typename指针。申请失败的时候会返回空指针</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//释放内存</span></span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="comment">//本质上就是将p指针指向空地址，原先的地址占用状态被修改</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="new运算符（推荐使用）"><a href="#new运算符（推荐使用）" class="headerlink" title="new运算符（推荐使用）"></a>new运算符（推荐使用）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//申请一个节点空间</span></span><br><span class="line"><span class="keyword">typename</span>* p = <span class="keyword">new</span> <span class="keyword">typename</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取消对该节点的占用</span></span><br><span class="line"><span class="built_in">delete</span>(p;</span><br></pre></td></tr></table></figure>
<h3 id="链表的基本操作"><a href="#链表的基本操作" class="headerlink" title="链表的基本操作"></a>链表的基本操作</h3><h4 id="创建链表（运用for语句实现）"><a href="#创建链表（运用for语句实现）" class="headerlink" title="创建链表（运用for语句实现）"></a>创建链表（运用for语句实现）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传入的数组为每个节点的数据域的值</span></span><br><span class="line"><span class="comment">//尾插法：需要一个链表最后一个节点的指针。</span></span><br><span class="line"><span class="function">node* <span class="title">create</span> <span class="params">(<span class="type">int</span> Array[])</span></span>&#123;</span><br><span class="line">	node *p, *pre, *head;</span><br><span class="line">	head = <span class="keyword">new</span> node;<span class="comment">//创建头节点</span></span><br><span class="line">	head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	pre = head;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)&#123;</span><br><span class="line">		<span class="comment">//创建新结点：1.申请空间；2.完成指针域和数据域的赋值</span></span><br><span class="line">		p = <span class="keyword">new</span> node;</span><br><span class="line">		p-&gt;data = Array[i];</span><br><span class="line">		p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//更新状态指针</span></span><br><span class="line">		pre-&gt;next = p;</span><br><span class="line">		pre = p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">]</span><br><span class="line"><span class="comment">//注意一点在删除一个节点的时候需要有一个指向该节点的指针，以便后续删除该节点</span></span><br></pre></td></tr></table></figure>
<h3 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h3><p>静态链表的主要原理就是Hash。它利用数组的下标作为相应节点的地址，适用于节点地址是比较小的整数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态链表节点的定义方式</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">	<span class="keyword">typename</span> data;</span><br><span class="line">	<span class="type">int</span> next;<span class="comment">//注意这里的地址是一个整型变量</span></span><br><span class="line">&#125;node[size];</span><br></pre></td></tr></table></figure><br>需要注意一点：因为静态链表是由数组实现的，所以就可能需要对其进行排序，但是如果这时候结构体类型名和结构体变量名相同（是允许的），sort函数就与出现编译错误。<br>（例题：A1032）<br>静态链表的使用步骤：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义静态链表</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">	<span class="type">int</span> address;</span><br><span class="line">	<span class="keyword">typename</span> data;</span><br><span class="line">	<span class="type">int</span> next;</span><br><span class="line">	XXX;<span class="comment">//节点的某些性质</span></span><br><span class="line">&#125;node[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化静态链表:将性质量定义为正常情况达不到的数字</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAXN; ++i)&#123;</span><br><span class="line">	node[i].XXX = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//标记（针对性质操作）</span></span><br><span class="line"><span class="comment">//可以针对性质进行统计，标记</span></span><br><span class="line"><span class="type">int</span> p = begin, count = <span class="number">0</span>;<span class="comment">//用于开始遍历和统计</span></span><br><span class="line"><span class="keyword">while</span>(p != <span class="number">-1</span>)&#123;</span><br><span class="line">	XXX = <span class="number">1</span>;</span><br><span class="line">	count++;</span><br><span class="line">	p = node[p]-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//简化操作</span></span><br><span class="line"><span class="comment">//由于静态链表直接采用地址映射的方式，这可能会导致地址</span></span><br><span class="line"><span class="comment">//不是连续的，此时应该将有效节点转移到左端，可以通过排</span></span><br><span class="line"><span class="comment">//序（sort函数）来实现（结合初始化的值）</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><h3 id="深度优先搜索（DFS）"><a href="#深度优先搜索（DFS）" class="headerlink" title="深度优先搜索（DFS）"></a>深度优先搜索（DFS）</h3><p>深度优先遍历会优先解决一种情况下的所有情况之后，再去解决其他的情况。如果能将一个事件的各个情况写成树形结构，就可以很容易地通过这种方法解决。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">有n 件物品，每件物品的重量为w[i］，价值为c[i］。现在需要选出若干件物品放入一个容</span></span><br><span class="line"><span class="comment">量为V 的背包中，使得在选入背包的物品重量和不超过容量V 的前提下，让背包中物品的价</span></span><br><span class="line"><span class="comment">值之和最大，求最大价值。(l&lt;n&lt;20)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">30</span>;</span><br><span class="line"><span class="type">int</span> n;<span class="comment">//物品数量</span></span><br><span class="line"><span class="type">int</span> V;<span class="comment">//背包容量</span></span><br><span class="line"><span class="type">int</span> maxValue = <span class="number">0</span>;<span class="comment">//最大的价值</span></span><br><span class="line"><span class="type">int</span> w[maxn], c[maxn];<span class="comment">//分别为单个物品的重量个价值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//参数分别为物品编号，总质量，总价值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> sumW, <span class="type">int</span> sumC)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (index == n) &#123;<span class="comment">//完成对所有物品的选用</span></span><br><span class="line">		<span class="keyword">if</span> (sumW &lt;= V &amp;&amp; sumC &gt; maxValue) &#123;<span class="comment">//检查当前方案是否满足条件</span></span><br><span class="line">			maxValue = sumC;<span class="comment">//更新最大价值</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//对index号的物品，有两种结果，放入背包或是不放入背包</span></span><br><span class="line">	<span class="built_in">DFS</span>(index + <span class="number">1</span>, sumW, sumC);<span class="comment">//不放入背包</span></span><br><span class="line">	<span class="built_in">DFS</span>(index + <span class="number">1</span>, sumW + w[index], sumC + c[index]);<span class="comment">//放入背包</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;V);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);<span class="comment">//重量</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;c[i]);<span class="comment">//价值</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">DFS</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//从第零件物品开始，此时的价值和重量都是0</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, maxValue);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>注意到在加入index号的物品时，总重量发生变化，这可能会导致结果不满足条件，<u>如果能在进入递归之前能够进行检查，能够减少一些不必要的递归</u><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在递归之前加上判断条件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS_A</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> sumW, <span class="type">int</span> sumC)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(index == n)<span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">DFS_A</span>(index + <span class="number">1</span>, sumW, sumC);</span><br><span class="line">	<span class="comment">//检查质量是否满足要求，以确定是否进入递归</span></span><br><span class="line">	<span class="keyword">if</span> (sumW + w[index] &lt;= V) &#123;</span><br><span class="line">		<span class="keyword">if</span> (sumC + c[index] &gt; maxValue)maxValue = sumC + c[index];</span><br><span class="line">		<span class="built_in">DFS_A</span>(index + <span class="number">1</span>, sumW + w[index], sumC + c[index]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>深度优先遍历的方法可以用于解决获取最优“子序列”的问题，也就是满足基本条件下的最优序列。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">问题描述：给定N个整数，从中选择K个数，使这K个数之和恰好等于给定的整数X，求出元素</span></span><br><span class="line"><span class="comment">平方和最大的结果</span></span><br><span class="line"><span class="comment">算法思想：利用一个数组，将已经选择的整数放入其中，当选择index号数字时，将</span></span><br><span class="line"><span class="comment">这个数字加入到数组中，进入递归，之后再将这个数字取出，进入不选择index号数</span></span><br><span class="line"><span class="comment">的递归。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k, x, maxSumSqu = <span class="number">-1</span>, A[maxn];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;temp, ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS_BSqu</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> nowK, <span class="type">int</span> sum, <span class="type">int</span> sumSqu)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (nowK == k &amp;&amp; sum == x) &#123;</span><br><span class="line">		<span class="keyword">if</span> (sumSqu &gt; maxSumSqu) &#123;</span><br><span class="line">			maxSumSqu = sumSqu;</span><br><span class="line">			ans = temp;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (index == n || nowK &gt; k || sum &gt; x)<span class="keyword">return</span>;</span><br><span class="line">	temp.<span class="built_in">push_back</span>(A[index]);</span><br><span class="line">	<span class="built_in">DFS_BSqu</span>(index + <span class="number">1</span>, nowK + <span class="number">1</span>, sum + A[index], sumSqu + A[index] * A[index]);</span><br><span class="line">	temp.<span class="built_in">pop_back</span>();</span><br><span class="line">	<span class="built_in">DFS_BSqu</span>(index + <span class="number">1</span>, nowK, sum, sumSqu);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="广度优先"><a href="#广度优先" class="headerlink" title="广度优先"></a>广度优先</h3><p>广度优先类似于先解决简单的问题（离起点最近）然后再一步步深入。广度优先会先遍历所有的情况，对于求最优解的情况有优势。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">问题描述：给定一个n*m大小的迷宫，其中*代表不可通过的墙</span></span><br><span class="line"><span class="comment">壁，而“.”代表平地，S表示起点，T代表终点。移动过程中，如</span></span><br><span class="line"><span class="comment">果当前位置是（x,y）（下标从0开始），且每次只能往前上下</span></span><br><span class="line"><span class="comment">左右移动，求从起点到终点的最小步数。</span></span><br><span class="line"><span class="comment">算法思想：可以将迷宫当作树型结构，将迷宫的起点作为树的</span></span><br><span class="line"><span class="comment">根节点现在问题转换成找到迷宫终点所在树的层数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x, y;<span class="comment">//记录当前的位置</span></span><br><span class="line">	<span class="type">int</span> step;<span class="comment">//步数（层数）</span></span><br><span class="line">&#125;S,T,Node;<span class="comment">//分别为起点，重点，临时节点</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;<span class="comment">//分别为行，列</span></span><br><span class="line"><span class="type">char</span> maze[maxn][maxn];<span class="comment">//迷宫信息</span></span><br><span class="line"><span class="type">bool</span> inq[maxn][maxn] = &#123; <span class="literal">false</span> &#125;;<span class="comment">//检查此位置是否遍历过</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//增量数组，XY组合表示一个节点上下左右四个方向的位置</span></span><br><span class="line"><span class="type">int</span> X[<span class="number">4</span>] = &#123; <span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span> &#125;;</span><br><span class="line"><span class="type">int</span> Y[<span class="number">4</span>] = &#123; <span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查（x,y）这个位置是否应该入队</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">test</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//超出边界</span></span><br><span class="line">	<span class="keyword">if</span> (x &gt;= n || x &lt; <span class="number">0</span> || y &gt;= m || y &lt; <span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="comment">//遇到墙壁</span></span><br><span class="line">	<span class="keyword">if</span> (maze[x][y] == <span class="string">&#x27;*&#x27;</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="comment">//检查是否入队。入队则是之前访问过的位置</span></span><br><span class="line">	<span class="keyword">if</span> (inq[x][y] == <span class="literal">true</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//表示该位置有效</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	queue&lt;node&gt;q;</span><br><span class="line">	q.<span class="built_in">push</span>(S);<span class="comment">//将起点加入到队列中</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断当前访问的位置（出队的位置）是否为终点</span></span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		node top = q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="comment">//该位置为终点，直接返回此时的深度</span></span><br><span class="line">		<span class="keyword">if</span> (top.x == T.x &amp;&amp; top.y == T.y) &#123;</span><br><span class="line">			<span class="keyword">return</span> top.step;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//检查该位置4个方向上的情况</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">			<span class="type">int</span> newX = top.x + X[i];</span><br><span class="line">			<span class="type">int</span> newY = top.y + Y[i];</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">test</span>(newX, newY)) &#123;</span><br><span class="line">				<span class="comment">//新节点，更新相关的信息</span></span><br><span class="line">				Node.x = newX, Node.y = newY;</span><br><span class="line">				Node.step = Node.step + <span class="number">1</span>;</span><br><span class="line">				q.<span class="built_in">push</span>(Node);</span><br><span class="line">				inq[newX][newY] = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//迷宫规格</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="comment">//传入迷宫信息</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="built_in">getchar</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">			maze[i][j] = <span class="built_in">getchar</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		maze[i][m + <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;S.x, &amp;S.y, &amp;T.x, &amp;T.y);</span><br><span class="line">	S.step = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">BFS</span>());</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>值得注意的一点，当将一个元素push入队的时候，其本质就是将该元素的一个副本入队，所以，队列中的元素和原数据来源是相互独立的。</p>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>二叉树可以通过递归的方式定义，也就是可以将二叉树的子树看作一个新的二叉树。注意一点，二叉树的左右节点是由严格区分的。</p>
<h3 id="二叉树的存储和操作"><a href="#二叉树的存储和操作" class="headerlink" title="二叉树的存储和操作"></a>二叉树的存储和操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树结构体的定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="keyword">typename</span> data;</span><br><span class="line">	node* lchild;</span><br><span class="line">	node* rchild;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">node* root = <span class="literal">NULL</span>;<span class="comment">//建树之前根节点不存在，将其设为NULL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//新建节点:申请空间，赋值，初始化，返回节点地址</span></span><br><span class="line"><span class="function">node* <span class="title">newNode</span><span class="params">(<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	node* Node = <span class="keyword">new</span> node;</span><br><span class="line">	Node-&gt;data = v;</span><br><span class="line">	Node-&gt;lchild = Node-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> Node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//搜索节点:检查特殊情况和满足条件的情况，然后用同样的方法检查其他的节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">search</span><span class="params">(node* root, <span class="type">int</span> x, <span class="type">int</span> newdata)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>)<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(root-&gt;data == x)root-&gt;data = newdata;</span><br><span class="line">	<span class="built_in">search</span>(root-&gt;lchild, x, newdata);</span><br><span class="line">	<span class="built_in">search</span>(root-&gt;rchild, x, newdata);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树节点的插入,注意这里输入的参数是引用型的，因为要对这个树进行修改</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(node* &amp;root, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="comment">//查找失败，这就是要插入节点的地方</span></span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		root = <span class="built_in">newNode</span>(x);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(根据条件检查检索的方向)<span class="built_in">insert</span>(root-&gt;lchild,x);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">insert</span>(root-&gt;rchild,x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树的建立</span></span><br><span class="line"><span class="function">node* <span class="title">Create</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	node* root = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">		<span class="built_in">insert</span>(root,data[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p><img src="https://img-blog.csdnimg.cn/20210401083819611.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*中序遍历（非递归）：先找到最左边的节点，在寻找的过程中将途中的节点加入到栈中，当遇到根节点的时候，</span></span><br><span class="line"><span class="comment">取出栈顶元素（这一步相当于回溯），访问其右节点，然后继续原先的循环</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrderWithoutRecursion2</span><span class="params">(BTNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//空树</span></span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">//树非空</span></span><br><span class="line">	BTNode* p = root;</span><br><span class="line">	stack&lt;BTNode*&gt; s;</span><br><span class="line">	<span class="keyword">while</span> (!s.<span class="built_in">empty</span>() || p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (p)</span><br><span class="line">		&#123;</span><br><span class="line">			s.<span class="built_in">push</span>(p);</span><br><span class="line">			p = p-&gt;lchild;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			p = s.<span class="built_in">top</span>();</span><br><span class="line">			s.<span class="built_in">pop</span>();</span><br><span class="line">			cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">4</span>) &lt;&lt; p-&gt;data;</span><br><span class="line">			p = p-&gt;rchild;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">先序遍历（非递归）：在访问头节点的同时先将右节点加入到栈中，然后再继续访问左子树。当没有左孩子的时候</span></span><br><span class="line"><span class="comment">访问右节点，表现为取出栈顶元素，进行访问</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrderWithoutRecursion</span><span class="params">(BTNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>)<span class="keyword">return</span>;</span><br><span class="line">	stack&lt;BTNode*&gt;s;</span><br><span class="line">	BTNode* p = root;</span><br><span class="line">	s.<span class="built_in">push</span>(root);</span><br><span class="line">	<span class="keyword">while</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">visit</span>(p);</span><br><span class="line">		<span class="keyword">if</span>(p-&gt;rchild)s.<span class="built_in">push</span>(p-&gt;rchild);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(p-&gt;lchild)p = p-&gt;lchild;</span><br><span class="line">		<span class="keyword">else</span>&#123;<span class="comment">//访问右子树</span></span><br><span class="line">			p = s.<span class="built_in">top</span>();</span><br><span class="line">			s.<span class="built_in">pop</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">后序遍历（非递归）：后序遍历有一个问题，需要当前访问的节点是父节点的左孩子还是右孩子，如果是左孩子，就访问</span></span><br><span class="line"><span class="comment">右孩子，否则访问头节点。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postOrderWithoutRecursion</span><span class="params">(BTNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>)<span class="keyword">return</span>;</span><br><span class="line">	stack&lt;BTNode*&gt;s;</span><br><span class="line">	BTNode* pCur, *pLastVisit;</span><br><span class="line"></span><br><span class="line">	pCur = root;</span><br><span class="line">	pLastVisit = <span class="literal">NULL</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//Find out the leftmost element of the tree.</span></span><br><span class="line">	<span class="keyword">while</span>(pCur)&#123;</span><br><span class="line">		s.<span class="built_in">push</span>(pCur);</span><br><span class="line">		pCur = pCur-&gt;lchild;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		pCur = s.<span class="built_in">top</span>();</span><br><span class="line">		s.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//访问头节点的条件：无右孩子或者是右孩子已经被访问</span></span><br><span class="line">		<span class="keyword">if</span>(pCur-&gt;rchild == <span class="literal">NULL</span> || pCur-&gt;rchild == pLastVisit)&#123;</span><br><span class="line">			<span class="built_in">visit</span>(pCur);</span><br><span class="line">			pLastVisit = pCur;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			s.<span class="built_in">push</span>(pCur);</span><br><span class="line">			pCur = pCur-&gt;rchild;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//找到右子树的最左边的节点</span></span><br><span class="line">			<span class="keyword">while</span>(pCur)&#123;</span><br><span class="line">				s.<span class="built_in">push</span>(pCur);</span><br><span class="line">				pCur = pCur-&gt;lchild;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归版</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">xOrder</span><span class="params">(node* root)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>)<span class="keyword">return</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//&#x27;* = printf(&quot;%d\n&quot;,root-&gt;data);</span></span><br><span class="line">	*<span class="comment">//前序遍历</span></span><br><span class="line">	<span class="built_in">xOrder</span>(root-&gt;lchild);</span><br><span class="line">	*<span class="comment">//中序遍历</span></span><br><span class="line">	<span class="built_in">xOrder</span>(root-&gt;rchild);</span><br><span class="line">	*<span class="comment">//后序遍历</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//层次遍历:每次完成一个节点的遍历，就需要检查其是否为叶子节点，否则加入到队列中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LayerOrder</span><span class="params">(node* root)</span></span>&#123;</span><br><span class="line">	queue&lt;node*&gt;q;</span><br><span class="line">	q.<span class="built_in">push</span>(root);</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		node* now = q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,now-&gt;data);</span><br><span class="line">		<span class="keyword">if</span>(now-&gt;lchild != <span class="literal">NULL</span>)q.<span class="built_in">push</span>(now-&gt;lchhild);</span><br><span class="line">		<span class="keyword">if</span>(now-&gt;rchild != <span class="literal">NULL</span>)q.<span class="built_in">push</span>(now-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果还想要直到当前节点所在的层数，可以在结构体中做好标记</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">	<span class="type">int</span> layer;</span><br><span class="line">	node* lchild;</span><br><span class="line">	node* rchild;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LayerOrder</span><span class="params">(node* root)</span></span>&#123;</span><br><span class="line">	queue&lt;node*&gt;<span class="number">1</span>;</span><br><span class="line">	root-&gt;layer = <span class="number">1</span>;</span><br><span class="line">	q.<span class="built_in">push</span>(root);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		node* now = q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,now-&gt;data);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//更新节点信息之后，再将节点入队</span></span><br><span class="line">		<span class="keyword">if</span>(now-&gt;lchild != <span class="literal">NULL</span>)&#123;</span><br><span class="line">			now-&gt;lchild-&gt;layer = now-&gt;layer + <span class="number">1</span>;</span><br><span class="line">			q.<span class="built_in">push</span>(now-&gt;lchild);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(now-&gt;rchild != <span class="literal">NULL</span>)&#123;</span><br><span class="line">			now-&gt;rchild-&gt;layer = now-&gt;layer + <span class="number">1</span>;</span><br><span class="line">			q.<span class="built_in">push</span>(now-&gt;rchild);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="树的静态实现-非二叉树"><a href="#树的静态实现-非二叉树" class="headerlink" title="树的静态实现(非二叉树)"></a>树的静态实现(非二叉树)</h3><p>实现静态写法是为了避免指针可能带来的错误。主要的思想就是将树的孩子节点存储在一个向量（“变长数组”）中。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="keyword">typename</span> data;</span><br><span class="line">	vector&lt;node&gt; child;<span class="comment">//??</span></span><br><span class="line">&#125;Node[maxn];</span><br><span class="line"><span class="comment">//如果不需要数据域，可以用如下方法定义</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;child[maxn];<span class="comment">//这里定义了maxn个向量</span></span><br></pre></td></tr></table></figure></p>
<h3 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先序遍历：先访问节点，之后递归地遍历其孩子节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(<span class="type">int</span> root)</span></span>&#123;</span><br><span class="line">	<span class="built_in">visit</span>(root);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; Node[root].child.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">		<span class="built_in">PreOrder</span>(Node[root].child[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//层序遍历：先访问头节点，然后将孩子节点入队，直到队列为空</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LayerOrder</span><span class="params">(<span class="type">int</span> root)</span></span>&#123;</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt;Q;</span><br><span class="line">	Q.<span class="built_in">push</span> (root);</span><br><span class="line">	<span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="type">int</span> front = Q.<span class="built_in">front</span>();</span><br><span class="line">		Q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="built_in">visit</span>(Q);</span><br><span class="line">		<span class="comment">//下面是访问该节点所有孩子节点的方法</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; Node[front].child.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">			Q.<span class="built_in">push</span>(Node[front].child[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h3><p>二叉查找树是节点按照一定规律排列的树，根节点的数据域大于或者小于左右孩子节点的数据域。同时二叉查找树还可以是一个空树。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉查找树的操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//新建一个节点：申请空间，赋值初始化，返回节点地址</span></span><br><span class="line"><span class="function">node* <span class="title">newNode</span><span class="params">(<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	node* Node = <span class="keyword">new</span> node;</span><br><span class="line">	Node-&gt;data = v;</span><br><span class="line">	Node-&gt;lchild = Node -&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> Node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找二叉查找树中数据域为x的节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">search</span> <span class="params">(node* root, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="comment">//递归出口</span></span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;search failed\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//根据当前节点值得情况，决定递归方向</span></span><br><span class="line">	<span class="keyword">if</span>(x == root-&gt;data)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,root-&gt;data);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(x &lt; root-&gt;data) <span class="built_in">search</span>(root-&gt;lchild, x);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">search</span>(root-&gt;rchild, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入一个数据域为x的新节点（注意这里的root是需要引用，后续修改）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span> <span class="params">(node* &amp;root, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="comment">//当查找失败的时候，这个地方即为节点插入的位置</span></span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		root = <span class="built_in">newNode</span>(x);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//由数据域的情况决定递归的方向</span></span><br><span class="line">	<span class="keyword">if</span>(x == root-&gt;data)<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(x &lt; root-&gt;data)<span class="built_in">insert</span>(root-&gt;lchild, x);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">insert</span>(root-&gt;rchild, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉查找树的建立</span></span><br><span class="line"><span class="function">node* <span class="title">Crate</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	node* root = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//将数组数据找到一个合适的地方插入</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)<span class="built_in">insert</span>(root,data[i]);</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉查找树的删除</span></span><br><span class="line"><span class="comment">//可以用根节点的前去或者后继来代替被删除的头节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//找到极值点的过程就是不断向左或者向右的过程，直到遇到空节点</span></span><br><span class="line"><span class="comment">//找到以root为头节点的最大全职的节点</span></span><br><span class="line"><span class="function">node* <span class="title">findMax</span><span class="params">(node* root)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(root-&gt;child != <span class="literal">NULL</span>)root = root -&gt; rchild;</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到权值最小的节点</span></span><br><span class="line"><span class="function">node* <span class="title">findMin</span><span class="params">(node* root)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(root-&gt;lchild != <span class="literal">NULL</span>)root = root-&gt;lchild;</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除节点：想用前驱后者后继节点覆盖要删除的节点，然后问题就转换成删除前驱或后继节点</span></span><br><span class="line"><span class="comment">//先找到想要删除的节点，然后判断节点的类型，然后再进行相应的递归操作</span></span><br><span class="line"><span class="comment">//删除以root为根节点的权值为x的节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteNode</span><span class="params">(node* &amp;root, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>)<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">//找到需要删除的节点</span></span><br><span class="line">	<span class="keyword">if</span>(root-&gt;data == x)&#123;</span><br><span class="line">		<span class="comment">//当需要删除的节点为叶节点，直接删除</span></span><br><span class="line">		<span class="keyword">if</span>(root-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; root-&gt;rchild == <span class="literal">NULL</span>)root = <span class="literal">NULL</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//左孩子非空，则用右孩子的极值替换该节点，然后删除该极值节点</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;lchild != <span class="literal">NULL</span>)&#123;</span><br><span class="line">			node* pre = <span class="built_in">findMax</span>(root-&gt;lchild);</span><br><span class="line">			root-&gt;data = pre-&gt;data;</span><br><span class="line">			<span class="built_in">deleteNode</span>(root-&gt;lchild,pre-&gt;data);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//右孩子非空，操作同上</span></span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			node* next = <span class="built_in">findMin</span>(root-&gt;rchild);</span><br><span class="line">			root-&gt;data = next -&gt; data;</span><br><span class="line">			<span class="built_in">deleteNode</span>(root-&gt;rchild, next-&gt;data);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="comment">//寻找需要删除的节点</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;data &gt; x)<span class="built_in">deleteNode</span>(root-&gt;lshild,x);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">deleteNode</span>(root-&gt;rchild, x);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>对于删除节点的操作，可以进行优化，主要里利用极值节点坑定没有左子树或右子树的性质，将该极值节点的子树直接连接到该极值节点的父节点上即可。<br>加入一直删除前驱或者后继，就会导致最后树变得十分不平衡，解决这个方法可以采取交替删除前驱后继或者是记录子树高度，优先在高度更高的的子树中删除节点。</p>
<h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>平衡二叉树是左右子树高度相差不超过1的二叉树。这样的结构可以保证在大多数操作下保持O(logn)的性能。因为当二叉树严重失衡时，二叉树退化成链表，此时操作的时间复杂度变为O(n)。在平衡二叉树中，右子树与左子树的高度之差称为该节点的<strong>平衡因子</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//节点结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> v, height;<span class="comment">//节点权值和子树高度</span></span><br><span class="line">	node* lchild, *rchild; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成一个新的节点</span></span><br><span class="line"><span class="function">node* <span class="title">newNode</span><span class="params">(<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	node* Node = <span class="keyword">new</span> node;<span class="comment">//申请节点空间</span></span><br><span class="line">	Node-&gt;v = v;<span class="comment">//节点权值</span></span><br><span class="line">	Node-&gt;height = <span class="number">1</span>;<span class="comment">//该节点本身的高度</span></span><br><span class="line">	Node-&gt;lchild = Node-&gt;rchild = <span class="literal">NULL</span>;<span class="comment">//初始化孩子节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取当前树的高度:从结构体变量中获取</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getHeight</span><span class="params">(node* root)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> root-&gt;height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算平衡因子:左子树高度减去右子树高度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getBalanceFactor</span><span class="params">(node* root)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">getHeight</span>(root-&gt;lchild) - <span class="built_in">getHeight</span>(root-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新当前节点的高度:孩子节点的最大高度加上节点本身</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateHeight</span><span class="params">(node* root)</span></span>&#123;</span><br><span class="line">	root-&gt;height = <span class="built_in">max</span>(<span class="built_in">getHeight</span>(root-&gt;lchild), <span class="built_in">getHeight</span>(root-&gt;rchild)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ALV的查找操作与二叉排序树的操作完全一致</span></span><br></pre></td></tr></table></figure>
<p>对于ALV的插入操作，要根据树的结构做出相应的不同的操作。（BF：Balance Factor）<br>树型| 判定条件|调整方法|<br>—|———-|————-<br>LL| BF(root) = 2;BF(root-&gt;lchild) = 1|对root进行右旋|<br>LR|BF(root) = 2;BF(root-&gt;lchild) = -1|先对root-&gt;lchild进行左旋后对root进行右旋<br>RR|BF(root) = -2;BF(root-&gt;lchild) = -1|对root进行左旋<br>RL|BF(root) = -2;BF(root-&gt;lchild) = 1|先对右子树进行右旋，再对root左旋<br>通过表格，可以总结：L代表根节点是正数，R代表孩子节点的负数。<br>下图时LL和LR型的树的调整示意图<br><img src="https://img-blog.csdnimg.cn/20210223093952989.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210223094002206.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>注意到LR型是将LR先左旋转换成LL型的二叉树然后再执行右旋的，所以LR型的二叉树的调整可以由基本的左旋右旋组合而来。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左旋:将右孩子的左孩子连接到头节点处，其原先的左孩子连接到原先的头节点的右孩子处</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">L</span><span class="params">(node*&amp; root)</span></span>&#123;</span><br><span class="line">	node* temp = root-&gt;rchild;</span><br><span class="line">	root-&gt;rchild = temp-&gt;lchild;</span><br><span class="line">	temp-&gt;lchild = root;</span><br><span class="line">	<span class="comment">//跟新调整之后的节点高度</span></span><br><span class="line">	<span class="built_in">updateHeight</span>(root);</span><br><span class="line">	<span class="built_in">uodateHeight</span>(temp);</span><br><span class="line">	root = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//右旋</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">R</span><span class="params">(node*&amp; root)</span></span>&#123;</span><br><span class="line">	node* temp = root-&gt;lchild;</span><br><span class="line">	root-&gt;lchild = temp-&gt;rchild;</span><br><span class="line">	temp-&gt;rchild = root;</span><br><span class="line">	<span class="built_in">updateHeight</span>(root);</span><br><span class="line">	<span class="built_in">uodateHeight</span>(temp);</span><br><span class="line">	root = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入节点：找到插入的位置，判断插入后树的类型，然后再做相应的操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span> <span class="params">(node*&amp;root,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		root = <span class="built_in">newNode</span>(v);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//节点小，则在左子树中插入</span></span><br><span class="line">	<span class="keyword">if</span>(v &lt; root-&gt;v)&#123;</span><br><span class="line">		<span class="built_in">insert</span>(root-&gt;lchild,v);</span><br><span class="line">		<span class="comment">//更新节点信息，</span></span><br><span class="line">		<span class="built_in">updateHeight</span>(root);</span><br><span class="line">		<span class="comment">//L</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">getBalanceFactor</span>(root) == <span class="number">2</span>)&#123;</span><br><span class="line">			<span class="comment">//LL</span></span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">getBalanceFactor</span>(root-&gt;lchild)==<span class="number">1</span>) <span class="built_in">R</span>(root);</span><br><span class="line">			<span class="comment">//LR</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">getBalanceFactor</span>(root-&gt;lchild)==<span class="number">-1</span>)&#123;</span><br><span class="line">			<span class="built_in">L</span>(root-&gt;lchild);</span><br><span class="line">			<span class="built_in">R</span>(root);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="comment">//从右子树中插入节点</span></span><br><span class="line">		<span class="built_in">insert</span>(root-&gt;rchild,v);</span><br><span class="line">		<span class="built_in">updateHeight</span>(root);</span><br><span class="line">		<span class="comment">//R</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">getBalanceFactor</span>(root) == <span class="number">-2</span>)&#123;</span><br><span class="line">			<span class="comment">//RR</span></span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">getBalanceFactor</span>(root-&gt;rchild)==<span class="number">-1</span>)<span class="built_in">L</span>(root);</span><br><span class="line">			<span class="comment">//RL</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">getBalanceFactor</span>(root-&gt;rchild) == <span class="number">1</span>)&#123;</span><br><span class="line">				<span class="built_in">R</span>(root-&gt;rchild);</span><br><span class="line">				<span class="built_in">L</span>(root);</span><br><span class="line">			&#125;<span class="comment">//else if</span></span><br><span class="line">		&#125;<span class="comment">//if</span></span><br><span class="line">	&#125;<span class="comment">//else</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//AVL树的建立</span></span><br><span class="line"><span class="function">node* <span class="title">Create</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	node* root = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)<span class="built_in">insert</span>(root,data[i]);</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><blockquote>
<p>在计算机科学中，并查集（英文：Disjoint-set data structure，直译为不交集数据结构）是一种数据结构，用于处理一些不交集（Disjoint sets，一系列没有重复元素的集合）的合并及查询问题。并查集支持如下操作：<br>查询：查询某个元素属于哪个集合，通常是返回集合内的一个“代表元素”。这个操作是为了判断两个元素是否在同一个集合之中。<br>合并：将两个集合合并为一个。<br>添加：添加一个新集合，其中有一个新元素。添加操作不如查询和合并操作重要，常常被忽略。</p>
</blockquote>
<p>以下是并查集得一些基本操作。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> father[N];</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initialSet</span><span class="params">(<span class="type">int</span> father[], <span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">		father[i] = i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找:根节点的父节点就是其本身</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findFather</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (x != father[x]) &#123;</span><br><span class="line">		x = father[x];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归版本</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findFatherRe</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//递归出口</span></span><br><span class="line">	<span class="keyword">if</span> (x == father[x])<span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">findFather</span>(father[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//并查集合并：先判断两节点是否再同一并查集中（判断根节点是否相同），然后再将其中一个根节点的父节点指向另一个根节点</span></span><br><span class="line"><span class="comment">//这样能能够保证并查集是个树型结构，不会出现环</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> faA = <span class="built_in">findFather</span>(a);</span><br><span class="line">	<span class="type">int</span> faB = <span class="built_in">findFather</span>(b);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//当二者不是统一并查集时合并</span></span><br><span class="line">	<span class="keyword">if</span> (faA != faB)&#123;</span><br><span class="line">		father[faA] = father[faB];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//路径压缩：将搜索的时间复杂度由O(n)变为O(1)，其实就是将所有节点的父节点全部指向根节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findFatherPatheShorten</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = x;<span class="comment">//找到根节点，同时保存初始节点</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//找到根节点</span></span><br><span class="line">	<span class="keyword">while</span> (x != father[x]) &#123;</span><br><span class="line">		x = father[x];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//将该节点的父节点指向根节点，并保存该节点原先的父节点的信息</span></span><br><span class="line">	<span class="keyword">while</span> (a != father[a]) &#123;</span><br><span class="line">		<span class="type">int</span> z = a;</span><br><span class="line">		a = father[a];</span><br><span class="line">		father[z] = x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归版本</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findFatherRSRec</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (v == father[v])<span class="keyword">return</span> v;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="type">int</span> F = <span class="built_in">findFather</span>(father[v]);</span><br><span class="line">		father[v] = F;</span><br><span class="line">		<span class="keyword">return</span> F;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>堆本质上就是满足父节点大于（或小于）孩子节点的二叉树。所有节点存储在一个数组当中，这样i节点的孩子节点分别为$2<em>i$和$2</em>i+1$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> heap[maxn], n = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向下调整O(logn)：从low到high。找出该节点得该子节点中最大得节点，然后于该节点进行比较，若孩子节点较大，则与孩子节点进行交换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">downAdjust</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i = low, j = i * <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">while</span> (j &lt;= high) &#123;</span><br><span class="line">		<span class="comment">//找出孩子节点中较大的</span></span><br><span class="line">		<span class="keyword">if</span> (j + <span class="number">1</span> &lt;= high &amp;&amp; heap[j + <span class="number">1</span>] &gt; heap[j]) ++j;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//与父节点进行比较</span></span><br><span class="line">		<span class="keyword">if</span> (heap[j] &gt; heap[i]) &#123;</span><br><span class="line">			<span class="built_in">swap</span>(heap[j], heap[i]);</span><br><span class="line">			i = j;</span><br><span class="line">			j = i * <span class="number">2</span>;<span class="comment">//这里只去检查被调整的元素是否满足堆的条件，因为为改动的节点应该是满足堆的要求的</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建堆O(n):从最后一个非叶节点往后进行循环，这是对原先数组进行了排序，以满足堆的要求</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createHeap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span>; i &gt;= <span class="number">1</span>; --i)<span class="built_in">downAdjust</span>(i, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除堆顶元素O(logn)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteTop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//将最后一个元素代替堆顶元素，然后减少节点数量</span></span><br><span class="line">	heap[<span class="number">1</span>] = heap[n--];</span><br><span class="line">	<span class="built_in">downAdjust</span>(<span class="number">1</span>, n);<span class="comment">//改动了这个节点就从这个节点进行调整</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向上调整：当插入一个节点的时候，这个节点被放到最后，逐个与其父节点比较，直到该节点小于父节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upAdjust</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i = high, j = i / <span class="number">2</span>;<span class="comment">//high就是最后一个节点，即插入的节点</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//父节点在范围之内</span></span><br><span class="line">	<span class="keyword">while</span> (j &gt;= low) &#123;</span><br><span class="line">		<span class="keyword">if</span> (heap[j] &lt; heap[i]) &#123;</span><br><span class="line">			<span class="built_in">swap</span>(heap[j], heap[i]);</span><br><span class="line">			i = j;</span><br><span class="line">			j = i / <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加元素，借用上面的函数:加入节点，然后进行相应的调整</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	heap[++n] = x;</span><br><span class="line">	<span class="built_in">upAdjust</span>(<span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//堆排序:将头节点与最后一个节点进行交换，然后对堆进行调整</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">createHeap</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt; <span class="number">1</span>; i--)&#123;</span><br><span class="line">		<span class="built_in">swap</span>(heap[i], heap[<span class="number">1</span>]);</span><br><span class="line">		<span class="built_in">downAdjust</span>(<span class="number">1</span>, i - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h3><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.iwiki.eu.org/wiki/File:Huffman_algorithm.gif">哈夫曼树构建过程</a><br>用语言描述就是，先将队列中权值最小的两个节点合并成新的节点，加入到队列中，然后一直按照这个规律执行，直到队列中只剩下一个节点。这个时候头节点的权值就是最短路径权值<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下是求一个实例的最短路径的权值的算法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;<span class="type">long</span> <span class="type">long</span>, vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;, greater&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> temp, x, y, ans = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;&amp;d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;temp);</span><br><span class="line">		q.<span class="built_in">push</span>(temp);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (q.<span class="built_in">size</span>()&gt;<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//获取前两个最大节点</span></span><br><span class="line">		x = q.<span class="built_in">top</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		y = q.<span class="built_in">top</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//将节点合并之后再入队</span></span><br><span class="line">		q.<span class="built_in">push</span>(x + y);</span><br><span class="line">		<span class="comment">//统计最短路径权值</span></span><br><span class="line">		ans += x + y;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>哈夫曼编码是一种用于无损数据压缩的熵编码（权编码）算法，它可以根据数据的一些特点（如出现频率）来制定相应长度的编码从而达到数据压缩的目的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/09/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/09/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Java学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-01-09 21:32:23" itemprop="dateCreated datePublished" datetime="2021-01-09T21:32:23+08:00">2021-01-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-08 19:43:03" itemprop="dateModified" datetime="2023-03-08T19:43:03+08:00">2023-03-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Java学习"><a href="#Java学习" class="headerlink" title="Java学习"></a>Java学习</h1><font color="#999AAA">学习[廖雪峰博客](https://www.liaoxuefeng.com/wiki/1252599548343744)笔记
</font>




<h2 id="基本运算符"><a href="#基本运算符" class="headerlink" title="基本运算符"></a>基本运算符</h2><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>||：短路或；&amp;&amp;：短路与（一些非法的语句会被忽略）；！：逻辑非</p>
<p>其中逻辑运算符只能操作布尔型数据。（注意一点，在Java中不能用1、0来代替True、False，因为前者是整型后者是布尔型）<br>逻辑运算与短路运算的结果是一致的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">x</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="type">boolean</span> <span class="variable">y</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="type">short</span> <span class="variable">z</span> <span class="operator">=</span> <span class="number">42</span>;</span><br><span class="line">		<span class="comment">//if(y == true)</span></span><br><span class="line">		<span class="keyword">if</span> (( z++==<span class="number">42</span> ) &amp;&amp; ( y = <span class="literal">true</span> )) z++;<span class="comment">//注意z++是先进行判断之后才自增的！！，所以本语句是可以被执行的</span></span><br><span class="line">		<span class="keyword">if</span> (( x = <span class="literal">false</span>) || (++z == <span class="number">45</span> )) z++;</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;z=&quot;</span> + z);</span><br><span class="line">        <span class="comment">//Output:46</span></span><br></pre></td></tr></table></figure></p>
<h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>左移相当于*2，但是有限度（最左边的数为1的时候，结果会变成负数）右移前右边的位根据数字的符号决定（1的话就用1来填，否则就用0来填）<br>>&gt;&gt;：无符号位移操作</p>
<blockquote>
<p>最高效的方式计算2 * 8：2&lt;&lt;3 or 8 &lt;&lt; 1</p>
</blockquote>
<p>位运算符:&amp;(and)、 |(or)、 ^(xor)、 ~(not)</p>
<h3 id="交换两变量的值"><a href="#交换两变量的值" class="headerlink" title="交换两变量的值"></a>交换两变量的值</h3><p>方式一：定义一个临时变量<br>方式二：先将两数合并，然后再分离<br>   （:可能超出存储范围；有局限性）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num1 = num1 + num2;</span><br><span class="line">num2 = num1 - num2;</span><br><span class="line">num1 = num1 - num2;</span><br></pre></td></tr></table></figure><br>方式三：（运用位运算符关系：m = k ^ n = (m ^ n) ^ n）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num1 = num1 ^ num2;</span><br><span class="line">num2 = num1 ^ num2;</span><br><span class="line">num1 = num1 ^ num2;</span><br></pre></td></tr></table></figure></p>
<h3 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h3><p>表达式1和表达式2要求是一致的，二者能够统一成一个类型（因为它的结果是会被赋值给单个变量的）</p>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>需要包含三点：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.导入对应的类（utility）</span></span><br><span class="line"><span class="keyword">import</span>  java.util.Scanner;<span class="comment">//注意最后的分号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IO</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    	<span class="comment">//2.创建scanner变量</span></span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);<span class="comment">//创建scanner传入：System.in、System.out分别代表标准输入和输出。</span></span><br><span class="line">		System.out.println(<span class="string">&quot;Input Your name: &quot;</span>);</span><br><span class="line">        <span class="comment">//3.访问输入变量中的成员</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> scanner.nextLine();<span class="comment">//传入的是字符串类型，注意这种类型转换是自动的</span></span><br><span class="line">		System.out.println(<span class="string">&quot;Input Your age: &quot;</span>);</span><br><span class="line">		<span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> scanner.nextInt();<span class="comment">//传入的是整型（注意next之后的语句）</span></span><br><span class="line">		System.out.printf(<span class="string">&quot;Hi, %s,you are %d\n&quot;</span>,name,age);</span><br></pre></td></tr></table></figure></p>
<h3 id="条件判断语句"><a href="#条件判断语句" class="headerlink" title="条件判断语句"></a>条件判断语句</h3><h4 id="判等语句”-“："><a href="#判等语句”-“：" class="headerlink" title="判等语句”==“："></a>判等语句”==“：</h4><p> 这种判断运算符可以用来判断了两个值类型的变量是否相等，但是对于引用型变量就变成判断两个变量是否指向同一个对象。要判断引用类型的变量内容是否相等需要使用<strong>equals（）方法</strong>（注意这是变量类型String下面的一种方法）<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IO</span> &#123;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;        </span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="literal">null</span>;        </span><br><span class="line">        <span class="comment">//注意当s1为null时，直接调用equals方法会导致NullPointException错误，       </span></span><br><span class="line">        <span class="comment">//为了避免这种情况，就利用短路运算，规避这种错误        </span></span><br><span class="line">        <span class="keyword">if</span> (s1 != <span class="literal">null</span> &amp;&amp; s1.equals(<span class="string">&quot;hello&quot;</span>))&#123;            </span><br><span class="line">            System.out.println((<span class="string">&quot;hello&quot;</span>));       </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意switch语句具有穿透性，所以每一项都需要以break结尾，且不能有大括号，判断语句也可以是字符串，是比较其中的内容是否相等</span></span><br><span class="line"><span class="keyword">switch</span>（option）&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">        ....</span><br><span class="line">        <span class="keyword">break</span>;   </span><br><span class="line">        </span><br><span class="line"> <span class="comment">//java12</span></span><br><span class="line"> <span class="keyword">case</span> <span class="string">&quot;***&quot;</span> -&gt; ....;<span class="comment">//当具有多条语句的时候，需要用大括号括起来，其不需要break</span></span><br><span class="line"> <span class="comment">//还可以直接返回参数</span></span><br><span class="line"> <span class="type">int</span> <span class="variable">opt</span> <span class="operator">=</span> <span class="keyword">switch</span>(fruit)&#123;......&#125;</span><br><span class="line"> <span class="keyword">yield</span> code;<span class="comment">//这个是switch语句的返回值，作为默认返回的方式</span></span><br></pre></td></tr></table></figure>
<h4 id="for-语句"><a href="#for-语句" class="headerlink" title="for 语句"></a>for 语句</h4><p> esp.（for each 循环）</p>
<h1 id="eg："><a href="#eg：" class="headerlink" title="eg："></a>eg：</h1> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] ns = &#123;...&#125;;<span class="comment">//数组初始化</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> n : ns)&#123;....&#125;<span class="comment">//数组遍历</span></span><br><span class="line"><span class="comment">//但是这种方式没有办法拿到数组的索引</span></span><br></pre></td></tr></table></figure>
<h2 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h2><h3 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h3><p>java标准库提供了Arrays.toString()，可以用来快速打印数组内容</p>
<h3 id="数组的排序"><a href="#数组的排序" class="headerlink" title="数组的排序"></a>数组的排序</h3><p>调用Java的内置排序功能</p>
<blockquote>
<p>import java.util.Arrays;<br>Arrays.sort(Arrays_name);//排序算法的调用</p>
</blockquote>
<p>注意一点，数组的第一个元素就是指向该数组的指针</p>
<h3 id="访问多维数组"><a href="#访问多维数组" class="headerlink" title="访问多维数组"></a>访问多维数组</h3><p>初始化的方式与C语言的一致，利用Java标准库输出：</p>
<blockquote>
<p>Arrays.deepToString</p>
<p>注意一点，在多维数组中，.length表示的多为数组中的数组的个数</p>
</blockquote>
<h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><p>NULL</p>
<h2 id="面对对象编程"><a href="#面对对象编程" class="headerlink" title="面对对象编程"></a>面对对象编程</h2><h3 id="面对对象基础"><a href="#面对对象基础" class="headerlink" title="面对对象基础"></a>面对对象基础</h3><p> 简单来说就是我们都是一类（class）人，但是每个我们都是不同的实例（instance），各有各的性格特点<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Class_Name</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> member_name;<span class="comment">//public表示外部可以访问;这些是类的字段（Field）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建实例</span></span><br><span class="line"><span class="type">Class_Name</span> <span class="variable">instanceName</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Class_Name</span>();</span><br><span class="line"><span class="comment">//访问实例的字段</span></span><br><span class="line">instanceName.field;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h4 id="类方法："><a href="#类方法：" class="headerlink" title="类方法："></a>类方法：</h4><h5 id="private-方法"><a href="#private-方法" class="headerlink" title="private 方法"></a>private 方法</h5><p>为了避免外部代码直接去访问field，可以用private修饰field，这样可以拒绝外部的访问。但是外部代码想要访问，就需要借助方法（method）<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;<span class="comment">//实例（instance）</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">	<span class="keyword">private</span> String nickName；</span><br><span class="line"></span><br><span class="line">	<span class="comment">//下面是private的方法</span></span><br><span class="line">	<span class="comment">//访问内部字段</span></span><br><span class="line">	<span class="keyword">public</span> String getName&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getAge</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//同时可以检查输入的值是否合法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;<span class="comment">//这里是方法参数</span></span><br><span class="line">	<span class="comment">//发现违法输入，抛出异常</span></span><br><span class="line">		<span class="keyword">if</span>(name == <span class="literal">null</span> || name.isBlank())&#123;</span><br><span class="line">			<span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;Invalid name&quot;</span>); </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="comment">//如果没有冲突，则可以忽略this，如：return name；</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//下面是可变参数的一个示例。（类型...）</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNickName</span><span class="params">(String... names)</span>&#123;<span class="comment">//参数也可以写成：String[] names</span></span><br><span class="line">		<span class="built_in">this</span>.nickName = names;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//调用方式:varianName.setNickName(&quot; *** &quot; ,&quot; **** &quot;);</span></span><br><span class="line">	<span class="comment">/*注意：前几个方法的参数是以复制后形式传入的，而这个方法的参数若是数组</span></span><br><span class="line"><span class="comment">	的话，就是以引用的方式传入的，所以在外部代码中，之前传入的数组的会导</span></span><br><span class="line"><span class="comment">	致内部数组的变化（类似于传值、传址）</span></span><br><span class="line"><span class="comment">	**引用类型参数的传递，调用放的变量，和接受方的变量，指向的是同一个对象。双方任意一方修改这个对象都会影响对方**</span></span><br><span class="line"><span class="comment">	之前的复制参数的传递方式成为参数绑定机制</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第一private相当于对变量进行了封装，而public这作为外部的接口。</span></span><br><span class="line"><span class="comment">//这里注意一下this指针的运用，用于在类内部指代内部本身。（屋子内的物品分布的地图）</span></span><br></pre></td></tr></table></figure></p>
<h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><p> <strong>之前些的这部分写得太烂了，这部分最后是重写的（我终于知道在代码中加太多注释的话，在复习的会哭的）</strong></p>
<p> 在类定义的时候定义一个构造方法，这可以在创建实例的时候顺便将字段都初始化了<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在类中，定义一个与类名相同的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ClassName</span> <span class="params">(type instanceName1, type instanceName2)</span>;<span class="comment">//参变量是需要初始化的变量</span></span><br><span class="line"><span class="comment">//定义的同时初始化</span></span><br><span class="line"><span class="type">className</span> <span class="variable">varianName</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">className</span>(initialValue1,initialValue2);</span><br><span class="line"><span class="comment">//Java的构造函数与C语言类似（几乎一致）</span></span><br><span class="line"><span class="comment">//默认构造函数</span></span><br><span class="line"><span class="keyword">public</span> ClassName</span><br><span class="line"><span class="comment">//没有初始化的字段：引用类型-&gt;null; 数值类型-&gt;默认值，int-&gt;0;boolean -&gt;false;</span></span><br><span class="line"><span class="comment">//可以在类定义当中定义多个构造方法，调用的时候会根据传入的参数的个数匹配至相应的构造方法</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ClassName</span>();<span class="comment">//这个时候就会调用默认的构造方法</span></span><br><span class="line"><span class="comment">//一种方法可以调用另一种方法，这里用到this指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在类定义的内部：</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>(name,<span class="number">18</span>);<span class="comment">//这里调用了另外一个方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&lt;hr style=” border:solid; width:100px; height:1px;” color=#000000 size=1”&gt;<br>构造方法就是为了能够在定义变量的时候方便初始化。作用就像是C++中的结构体的构造函数，但是Java中的构造方法与C++中的有一些不同。</p>
<blockquote>
<p>和普通方法相比，构造方法没有返回值（也没有void），调用构造方法，必须用new操作符。</p>
</blockquote>
<p>下面是运用实例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//默认构造函数</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用：直接初始化了成员变量</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Xiao Ming&quot;</span>, <span class="number">15</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h5 id="方法重载（Overload）（同名但拥有不同的参数类型的方法）"><a href="#方法重载（Overload）（同名但拥有不同的参数类型的方法）" class="headerlink" title="方法重载（Overload）（同名但拥有不同的参数类型的方法）"></a>方法重载（Overload）（同名但拥有不同的参数类型的方法）</h5><p>允许出现<strong>同名但拥有不同的参数类型的方法</strong>，但是这些方法的返回值应该具有相同的返回值。这样使得调用变得更加方便。注意重载的方法应该完成相似的功能。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继续之前的案例</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法重载</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">steName</span><span class="params">(String name, String familyName)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.name = name + <span class="string">&quot; &quot;</span> + familyName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>继承就是在原有的类的字段和方法上进行拓展，形成一个新的类，Java中运用关键字<strong>extends</strong>来实现继承。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;...&#125;<span class="comment">//超类（super class）、父类（parent class）、基类（base class）</span></span><br><span class="line"><span class="comment">//对原先的类进行继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">person</span>&#123;...&#125;<span class="comment">//子类（subclass）、拓展类（extended class）</span></span><br><span class="line"><span class="comment">//注意子类中不能定义父类中重名的字段！</span></span><br></pre></td></tr></table></figure></p>
<h5 id="继承树"><a href="#继承树" class="headerlink" title="继承树"></a>继承树</h5><p>这类的继承结构就像是树的结构，所有定义的类都有对应的父类，上例中，Person的父类就是Object（这个类就相当于树中的头节点，没有父类），同样与树类似，每一个类只有一个父节点（除了Object），及只能继承自一个类。</p>
<h5 id="protected（仅能被继承树中的成员所访问的变量）"><a href="#protected（仅能被继承树中的成员所访问的变量）" class="headerlink" title="protected（仅能被继承树中的成员所访问的变量）"></a>protected（仅能被继承树中的成员所访问的变量）</h5><p>父类中private的字段是没有办法被子类访问的，但是protected的字段可以被所有的子类所访问（继承树内部）。</p>
<h5 id="super-子类构造方法时使用"><a href="#super-子类构造方法时使用" class="headerlink" title="super(子类构造方法时使用)"></a>super(子类构造方法时使用)</h5><p>当在子类中引用父类的字段时，就可以用super指代（联想到this是指代自己，super是指代父类）一般情况下，super.name、this.name、name(name 为父类中的一个字段)都是一样的，编译器会自动定位字段的位置。但是在子类中需要生成构造函数的时候，情况就发生变化了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*在Java中任何类的构造方法必须是调用父类的构造方法，在没有明确调用父类的构造方法时候，</span></span><br><span class="line"><span class="comment">会默认一个super（），但是父类中并没有无参数的构造方法，这时候就会报错。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Class Student <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">	<span class="keyword">protected</span> <span class="type">int</span> score;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name,<span class="type">int</span> age,<span class="type">int</span> score)</span>&#123;</span><br><span class="line">		<span class="built_in">super</span>()；<span class="comment">//自动调用父类的构造方法,出错</span></span><br><span class="line">		<span class="comment">//这个时候只需要调用父类中已经定义的构造方法即可</span></span><br><span class="line">		<span class="built_in">this</span>.score = score;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*所以当父类没有默认的构造方法时，必须写明调用super（），以便定位到合适的构造方法中。</span></span><br><span class="line"><span class="comment">（回忆之前所的，当自己定义一个构造方法时，原有的默认构造方法就被覆盖了）</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><br>还有一点，子类是不会继承父类的任何构造方法。</p>
<h5 id="阻止继承（sealed）"><a href="#阻止继承（sealed）" class="headerlink" title="阻止继承（sealed）"></a>阻止继承（sealed）</h5><p>只要一个class没有final修饰符，任何类都可以从该类中继承。但是为了防止继承被滥用，Java15中允许使用 <strong>sealed</strong>类型，通过<strong>permits</strong>明确可以继承的子类名称<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Shape</span> <span class="keyword">permits</span> Rect, Circle&#123;...&#125;<span class="comment">//permits之后时允许继承的子类</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>sealed类在Java 15中目前是预览状态，要启用它，必须使用参数—enable-preview和—source 15</p>
</blockquote>
<h5 id="向上转型-amp-向下转型"><a href="#向上转型-amp-向下转型" class="headerlink" title="向上转型&amp;向下转型"></a>向上转型&amp;向下转型</h5><p>这种向上向下的关系是针对继承树的，总的来说，字符/方法少的不能向字符/方法多的转型，否则Java虚拟机就会报<strong>ClassCastException</strong>.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向下转型实例</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>()<span class="comment">//Person类型p1指向Students实例</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> (Student) p1;<span class="comment">//向下转型,出现错误，因为原先的类中可能不存在子类中的方法</span></span><br><span class="line"><span class="comment">//向上转型实例</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();<span class="comment">//向下转型</span></span><br></pre></td></tr></table></figure><br>为了避免在向下转型的过程中出现错误，可以用<strong>instanceof</strong>实现判断一个变量所指向的实例是否是指定类型，或者是这个类型的子类。（A is instance of ClassName?True or False?）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">	<span class="keyword">if</span>(p <span class="keyword">instanceof</span> Student)&#123;</span><br><span class="line">		<span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> (Student) p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//在java14中可以在判断语句中直接转型为制定变量（预览功能，启用需要参数）</span></span><br><span class="line">	<span class="comment">//这样写更加整洁</span></span><br><span class="line">	<span class="keyword">if</span>(p <span class="keyword">instanceof</span> Student s)&#123;</span><br><span class="line">		System.out.println(s.getname);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>最后在使用继承的时候要注意逻辑的一致性，继承的双方应该是包含和被包含的关系，而不是有交集的关系。</p>
<h5 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h5><h6 id="覆写"><a href="#覆写" class="headerlink" title="覆写"></a>覆写</h6><p>父类的方法可以被子类的完全相同的方法所覆写（修改相应方法的功能）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类的方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;  &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类对父类方法进行覆写</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">	<span class="meta">@override</span><span class="comment">//帮助检查是否正确进行了覆写（非必须）</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span> <span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;***&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载（overload）：对一个方法进行补充性修改，名称一致，但是参数、功能可以发生变化</span></span><br><span class="line"><span class="comment">//覆写(override):对一个方法的功能进行修改，相应的功能名称都应该相同</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注意一点，Java调用方法的过程中，调用的是所指向的类的对应的方法，这意味着所调用的方法与所对应的父类无关</span></span><br><span class="line"><span class="comment">这样在定义一个函数的时候，由于传入的参数类型不确定，这就导致所调用的方法也是不确定的。</span></span><br><span class="line"><span class="comment">（Java中定义的类型和所指向的类型可以是不一致的）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Run</span><span class="params">(Person p)</span>&#123;</span><br><span class="line">	<span class="comment">//这时候无法确定是Person的方法还是Student的方法</span></span><br><span class="line">	p.run();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//利用这个特点，可以通过传入不同类型的参数，以实现调用不同的功能的方法</span></span><br><span class="line"><span class="comment">//的目的,这样就实现了功能的拓展，而又不需要修改基于父类的代码</span></span><br></pre></td></tr></table></figure><br>&#8195; 所有的类都最终继承自Object，这就意味着在必要情况下可以覆写Object的方法。其有一下几个重要方法：</p>
<ol>
<li>toString():将instance输出为String</li>
<li>equals():判断两个instance是否逻辑相等</li>
<li>hashCode():计算一个instance的哈希值</li>
</ol>
<p>在子类中，想要调用父类的方法，可以用super来调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Student <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">	<span class="meta">@override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">super</span>.hello()+<span class="string">&quot;!&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//当一个方法不想让子类进行覆写的时候，在方法前加上final关键字</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">hello_1</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span>+name;</span><br><span class="line">	&#125;<span class="comment">//子类进行覆写会导致编译错误</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不希望被继承的类</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ClassName</span>&#123;...&#125;</span><br><span class="line"><span class="comment">//不希望被修改的字段,常出现在构造方法中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;***&quot;</span>;</span><br><span class="line"><span class="comment">//提一下：在方法的参数当中出现三个英文句号，代表参数个数不确定，依照输入参数的个数来确定</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">totalTax</span><span class="params">(Income... incomes)</span>&#123;...&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h5 id="抽象类-amp-接口"><a href="#抽象类-amp-接口" class="headerlink" title="抽象类&amp;接口"></a>抽象类&amp;接口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当父类方法只是定义方法签名，本身没有实际的意义，这时候应该将父类方法声明为抽象方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这样的类运行时会报错，需要将类本身也声明为抽象类型,此类方法无法被实例化（无法用于定义变量）</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="面向抽象编程"><a href="#面向抽象编程" class="headerlink" title="面向抽象编程"></a>面向抽象编程</h6><p>上层类只是定义规范，对于方法的实现并不关心，这相当于对方法的实现过程进行了封装。<br>实现方法就是用抽象类型去引用具体子类的实例。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br></pre></td></tr></table></figure></p>
<h6 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h6><p>当一个抽象类中没有字段，所有的方法都是抽象类，这个时候应该将将这个类定义为接口：<strong>Interface</strong><br>在接口中所有的方法都是默认是public abstract，所以这两个修饰符在定义方法的时候都不写出来，当一个类去实现接口的时候需要使用<strong>implements</strong>关键字。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span>&#123;...&#125;<span class="comment">//定义一个接口，接口中不能有字段</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Person</span>&#123;...&#125;<span class="comment">//实现一个接口</span></span><br><span class="line"><span class="comment">//在Java中一个类只能继承自唯一的一个类，但是可以实现多个方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Run</span>,Walk&#123;...&#125;<span class="comment">//实现两个接口</span></span><br><span class="line"><span class="comment">//一个接口还可以继承自另一个接口，这就相当于拓展了接口的方法</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Teacher</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;....&#125;</span><br></pre></td></tr></table></figure><br> 当实现一个接口的时候，需要覆写接口中所有的方法，但是可以不用覆写default方法，这实际上就是一种默认的方法功能，可以“不初始化”。<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">	<span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;...&#125;<span class="comment">//无法访问字段</span></span><br><span class="line">&#125;		</span><br></pre></td></tr></table></figure></p>
<h5 id="静态字段和静态方法"><a href="#静态字段和静态方法" class="headerlink" title="静态字段和静态方法"></a>静态字段和静态方法</h5><h6 id="静态字段"><a href="#静态字段" class="headerlink" title="静态字段"></a>静态字段</h6><p>用static修饰，独立于实例，在任何一个实例当中修改都会修改静态字段的值，这就是说所有实例中的同一个静态字段都是同一个字段（在同一个存储空间当中）。所以在访问静态字段的时候，最好是使用类名来访问：<strong>类名.静态字段</strong></p>
<h6 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h6><p>调用静态方法不需要实例变量，直接通过类名即可。</p>
<blockquote>
<p>静态方法属于类而不属于实例，所以在静态方法内部是无法访问this变量，也无法访问实例字段，只能访问静态字段</p>
<h6 id="接口的静态字段"><a href="#接口的静态字段" class="headerlink" title="接口的静态字段"></a>接口的静态字段</h6><p>接口的静态字段必须是final类型的，又因为接口的字段只能是public static final类型的，所以这样的修饰符是可以省略的。</p>
<h6 id="包"><a href="#包" class="headerlink" title="包"></a>包</h6><p>为了避免因为类名相同的而导致的冲突，在Java中定义了一种名字空间，成为包（package），一个类的完成类名是：<strong>包名.类名</strong>，没有写包名的类会使用默认包，这样容易造成名字冲突，所以建议将包名写出来。（注意，<strong>包没有父子关系</strong>，这也就是说com.apache和com.apache.abc是不同的包）</p>
<h6 id="包的作用域"><a href="#包的作用域" class="headerlink" title="包的作用域"></a>包的作用域</h6><p>位于同一个包的类可以访问包的作用域的字段和方法（允许访问package的没有public、private修饰的class、以及没有public、protected、private修饰的字段和方法。注意这里的意思是能访问，不是只能访问，public修饰的方法在同一个包情况下当然可以被访问）</p>
<h6 id="调用其他的class：import"><a href="#调用其他的class：import" class="headerlink" title="调用其他的class：import"></a>调用其他的class：import</h6><p>package_sample<br>└─ bin<br>   &#8195;&#8195;├─ hong<br>   &#8195;&#8195;│  └─ Person.class<br>  &#8195;&#8195;│  ming<br> &#8195;&#8195; │  └─ Person.class<br> &#8195;&#8195; └─ mr<br>      &#8195;&#8195;&#8195;&#8195;└─ jun<br>       &#8195;&#8195;  &#8195;&#8195;&#8195;&#8195;└─ Arrays.class</p>
</blockquote>
<p>假设一个包的结构如上图。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用方法①:直接完成写出类名</span></span><br><span class="line">mr.jun.<span class="type">Arrays</span> <span class="variable">arrays</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">mr</span>.jun.Arrays();</span><br><span class="line"><span class="comment">//调用方法②：用import语句,导入对应的包</span></span><br><span class="line"><span class="keyword">import</span> mr.jun.Arrays;<span class="comment">//导入这个包下的Arrays类</span></span><br><span class="line"><span class="keyword">import</span> mr.jun.*;<span class="comment">//导入这个包下的所有的类（不推荐，可能引起混乱）</span></span><br><span class="line"><span class="comment">//导入一个类的静态字段和静态方法</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.*;<span class="comment">//导入system类中的所有静态方法</span></span><br><span class="line">out.println(<span class="string">&quot;...&quot;</span>);<span class="comment">//可用√</span></span><br></pre></td></tr></table></figure><br>在编译器遇到一个类名称的时候，按照一下顺序查找这个类<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[是否是完整的类名]--是--&gt;B(直接根据完整类名查找这个类)</span><br><span class="line">A--否--&gt;C(查找当前package是否存在这个类名)</span><br><span class="line">C--&gt;D(查找import的包)--&gt;E(查找java.lang包)</span><br></pre></td></tr></table></figure><br>如果没有找到最后就报错。<br>在编写class 的时候，编译器会自动import两个包：导入当前包的其他class、默认：import java.lang.*.导入的包的名称不能相同，如有重名，另一个应该到写入完整的类名。为了避免冲突，要注意能和java.lang和JDK常用类的类名重名<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个语句应该就是在声明包的位置</span></span><br><span class="line"><span class="keyword">package</span> com.itranswarp.sample;</span><br><span class="line"></span><br><span class="line"><span class="comment">//导入包，写明包的具体位置</span></span><br><span class="line"><span class="keyword">import</span> com.itranswarp.world.Person;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小明&quot;</span>);</span><br><span class="line">		System.out.println(p1.hello());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h5><div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th>作用范围</th>
<th>补充</th>
</tr>
</thead>
<tbody>
<tr>
<td>public</td>
<td>只要有class的访问权限，定义位public的方法和字段就可以被访问</td>
<td>相当于一个对外的接口</td>
</tr>
<tr>
<td>private</td>
<td>无法被其他类访问，但是可以通过嵌套类（nested class）访问</td>
<td>用方法内的public方法访问private方法，使外部可以访问方法内部的private方法</td>
</tr>
<tr>
<td>protected</td>
<td>字段和方法能被子类及其子类访问</td>
<td>限制访问范围只能在继承树中才访问</td>
</tr>
<tr>
<td>package</td>
<td>同一个包内能访问对应的方法字段</td>
<td>有点像名字空间</td>
</tr>
<tr>
<td>局部变量</td>
<td>在方法内部定义的变量成为局部变量</td>
<td>在范围之外就会失效，像形参之类的</td>
</tr>
<tr>
<td>final</td>
<td>class：防止被继承<br>字段：防止被重新赋值<br>局部变量：防止重新赋值<br>方法：防止被覆写</td>
<td>就相当于静态变量</td>
</tr>
</tbody>
</table>
</div>
<p><em>注意事项：</em> 1.尽可能少地对外暴露字段和方法，也就是说要尽可能减少public地使用<br>2.将方法定义位package有利于测试，测试类和被测试类只要在同一个包中，测试代码就可以访问被测试类的权限方法<br>3.一个.java类只能有一个public类，且文件名和public类必须相同。</p>
<h5 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h5><p>在其他类中定义的类称为内部类。<br>①：Inner Class（内部类）：依托于外部类，能够访问外部类的private字段和方法。<br>创建方法：Outer.Inner inner = outer.new Inner();<br>编译后：Outer编译位Outer.class,内部类编译为Outer$Inner.class</p>
<p>②：Anonymous Class（匿名类）在其他类的内部实例化<br>创建方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;<span class="comment">//这里是定义了一个接口</span></span><br><span class="line">	<span class="comment">//方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继承自普通类</span></span><br><span class="line">HashMap&lt;String, String&gt;map2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;()&#123;&#125;;</span><br></pre></td></tr></table></figure><br>编译后：main$1.class(main是public修饰的)<br>③：Static Nested Class（静态内部类）用static修饰，无法应用Outer.this，可以访问private修饰的变量</p>
<h5 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h5><p>模块申明了依赖关系，只有声明依赖关系之后才能将需要的类导入<br>(While need it, learn it)</p>
<h4 id="Java核心类"><a href="#Java核心类" class="headerlink" title="Java核心类"></a>Java核心类</h4><h1 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h1><h2 id="在命令行中运行Java程序"><a href="#在命令行中运行Java程序" class="headerlink" title="在命令行中运行Java程序"></a>在命令行中运行Java程序</h2><p>可以在执行语句后面加上参数列表，在程序中将会被保存至args参数列表中，用下标索引的方式可以直接访问传入的参数。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/09/%E3%80%8AComputer-Systems-A-Programmer-Perspective-3rd-ed%E3%80%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/09/%E3%80%8AComputer-Systems-A-Programmer-Perspective-3rd-ed%E3%80%8B/" class="post-title-link" itemprop="url">《Computer Systems: A Programmer Perspective 3rd ed》</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-01-09 20:45:14" itemprop="dateCreated datePublished" datetime="2021-01-09T20:45:14+08:00">2021-01-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-08 19:43:43" itemprop="dateModified" datetime="2023-03-08T19:43:43+08:00">2023-03-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第一章-A-Tour-of-Computer-Systems"><a href="#第一章-A-Tour-of-Computer-Systems" class="headerlink" title="第一章 A Tour of Computer Systems"></a>第一章 A Tour of Computer Systems</h1><p><font color="#999AAA"><br>&amp;#8195这本书的前言部分主要介绍了本书主要包含的内容（the hardware architecture, the operating system, the compiler, the network）还有一些学习的预备知识（C语言、Lunux系统）。</font></p>
<p><font color="#999AAA"><br>&amp;#8195全文展开的逻辑是介绍Hello.c文件从编写到输出主要经历了什么</font></p>
<h2 id="1-1-Information-Is-Bits-Context"><a href="#1-1-Information-Is-Bits-Context" class="headerlink" title="1.1 Information Is Bits + Context"></a>1.1 Information Is Bits + Context</h2><p><font color="#999AAA"></font>这一部分主要讲程序文件在计算机中的存贮方式<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Hello,world!\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这段代码在计算机中使用ASCII码存贮的，如下图：<br><img src="https://img-blog.csdnimg.cn/20210102154622739.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<blockquote>
<p>Most computer systems represent text characters using the ASCII standard<br>that represents each character with a unique byte-size integer value.<br>The hello.c program is stored in a file as a sequence of bytes</p>
</blockquote>
<p>注意每一行都是以换行符结束的，而换行符的ASCII码为10.<br><em>包含ASCII字符的文件为文本文件，其他的文件为二进制文件。</em><br>最后的注释部分介绍了C语言的优点，还有缺点：</p>
<blockquote>
<p>C pointers are a common source of confusion and programming errors.</p>
</blockquote>
<p>&lt;hr style=” border:solid; width:100px; height:1px;” color=#000000 size=1”&gt;</p>
<h2 id="1-2-Programs-Are-Translated-by-Other-Programs-into-Different-Forms"><a href="#1-2-Programs-Are-Translated-by-Other-Programs-into-Different-Forms" class="headerlink" title="1.2 Programs Are Translated by Other Programs into Different Forms"></a>1.2 Programs Are Translated by Other Programs into Different Forms</h2><p><img src="https://img-blog.csdnimg.cn/20210116102447818.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="一个程序文件的执行周期"><br>文件运行的时候会有四个阶段：<br>在预处理阶段，预处理器会处理带有#的语句，并将它直接插入到程序文本中。<br>编译阶段将文本文件转义成汇编语言文件，汇编语言相当于一种通用语言，能够使得不同的高级语言在同一个机器上运行。<br>汇编阶段将<em>hello.s</em>转换成机器语言，并将结果存储在<em>hello.o</em>文件当中，这时候的文件是可迁移的（relocatable object program）<br>链接阶段将程序文件中调用的一些函数方法的执行程序与主程序合并，使主程序调用的函数可以顺利运行，这时候的文件为<em>hello</em>,这时的文件已经准备好被加载入内存中，后被运行了。</p>
<h2 id="1-4-Processors-Read-and-Interpret-Instructions-Stored-in-Memory"><a href="#1-4-Processors-Read-and-Interpret-Instructions-Stored-in-Memory" class="headerlink" title="1.4 Processors Read and Interpret Instructions Stored in Memory"></a>1.4 Processors Read and Interpret Instructions Stored in Memory</h2><p><img src="https://img-blog.csdnimg.cn/20210119145938442.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>What’s happening when we entering a sequence of command.<br><img src="https://img-blog.csdnimg.cn/20210119152000654.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="1-5-Cache-Matter"><a href="#1-5-Cache-Matter" class="headerlink" title="1.5 Cache Matter"></a>1.5 Cache Matter</h2><p>Note that we spend a lot of time to move data form disk to main memory by bus. Which is so-call <em>processor-memory gap</em> .In order to improve the performance of the operations,we use a Cache Memory between Main memory and Register which will store the information which is most likely to need in the near future.It maybe small to store data but fast to fletch when we need it.</p>
<blockquote>
<p>Because of physical laws, larger storage devices are slower than smaller storage devices.</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210119152749480.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="1-6-Storage-Devices-Form-a-Hierarchy"><a href="#1-6-Storage-Devices-Form-a-Hierarchy" class="headerlink" title="1.6 Storage Devices Form a Hierarchy"></a>1.6 Storage Devices Form a Hierarchy</h2><p><img src="https://img-blog.csdnimg.cn/20210120143008803.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="1-7-The-Operating-System-Manages-the-Hardware"><a href="#1-7-The-Operating-System-Manages-the-Hardware" class="headerlink" title="1.7 The Operating System Manages the Hardware"></a>1.7 The Operating System Manages the Hardware</h2><p><img src="https://img-blog.csdnimg.cn/20210120151124190.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="1-7-1-Processes"><a href="#1-7-1-Processes" class="headerlink" title="1.7.1 Processes"></a>1.7.1 Processes</h3><p><img src="https://img-blog.csdnimg.cn/2021012015135845.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>To be continue</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><font color="#999AAA">

<p>1.英文术语：<br>interpreted language ：</p>
<blockquote>
<p>直译语言（英语：Interpreted language），又称直译式语言，是一种编程语言。这种类型的编程语言，会将代码一句一句直接运行，不需要像编译语言（Compiled language）一样，经过编译器先行编译为机器码，之后再运行。这种编程语言需要利用解释器，在运行期，动态将代码逐句直译（interpret）为机器码，或是已经预先编译为机器码的的子程序，之后再运行。<br>理论上，任何编程语言都可以是编译式，或直译式的。它们之间的区别，仅与程序的应用有关。许多编程语言同时采用编译器与解释器来实作，其中包括Lisp，Pascal，C，BASIC 与 Python。JAVA及C#采用混合方式，先将代码编译为bytecode，在运行时再进行直译。</p>
</blockquote>
<p>magnetic-disk &amp; solid state drives：磁盘和固态硬盘<br>lingking：链接器</p>
<blockquote>
<p>链接器（英语：Linker），又译为链结器、链接器，是一个进程，将一个或多个由编译器或汇编器生成的目标文档外加库链接为一个可执行文档。</p>
</blockquote>
<p>metadata：</p>
<blockquote>
<p>元数据（Metadata），又称元数据、诠释数据、中继数据元数据，为描述数据的数据（data about data），主要是描述数据属性（property）的信息，用来支持如指示保存位置、历史数据、资源寻找、文档记录等功能。元数据算是一种电子式目录，为了达到编制目录的目的，必须在描述并收藏数据的内容或特色，进而达成协助数据检索的目的。</p>
</blockquote>
<p>context exchange：</p>
<blockquote>
<p>上下文交换(英语：context switch)，又称环境切换，电脑术语，是一个保存和重建CPU的状态 (内文)，因此令多个进程(process)可以分享单一CPU资源的计算过程。要交换CPU上的进程时，必需先行保存目前进程的状态，再将欲运行的进程之状态读回CPU中。</p>
</blockquote>
<p>System Call:</p>
<blockquote>
<p>在计算机中，系统调用（英语：system call），又称为系统调用，指运行在用户空间的进程向操作系统内核请求需要更高权限运行的服务。系统调用提供用户进程与操作系统之间的接口。大多数系统交互式操作需求在内核态执行。如设备IO操作或者进程间通信。</p>
</blockquote>
</font>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/04/Bug-%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/04/Bug-%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">Bug 记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-01-04 11:49:57" itemprop="dateCreated datePublished" datetime="2021-01-04T11:49:57+08:00">2021-01-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-08 19:43:38" itemprop="dateModified" datetime="2023-03-08T19:43:38+08:00">2023-03-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Bug-笔记"><a href="#Bug-笔记" class="headerlink" title="Bug 笔记"></a>Bug 笔记</h1><h2 id="VS-2019"><a href="#VS-2019" class="headerlink" title="VS 2019"></a>VS 2019</h2><p>1.<strong>警告    C6031    返回值被忽略: “scanf”。</strong><br>主要是没有检查输入是否成功。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改：加上一个条件判断语句</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure>
<p>2.<strong>变量不明确</strong>：这多半是因为变量名或者是函数名与现有库中的变量有冲突。</p>
<p>3.<strong>E0520    应使用“{…}”初始化聚合对象</strong></p>
<p>4.<strong>C4996    ‘fopen’: This function or variable may be unsafe. Consider using fopen_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS</strong>.<br>加上下面的语句，然后在 项目-&gt;属性-&gt;C/C++-&gt;预处理器-&gt;预处理器定义中添加_CRT_SECURE_NO_WARNINGS<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br></pre></td></tr></table></figure></p>
<p>5.<strong>C++不允许使用不完整的类型说明</strong><br>不完整类型是这样一种类型，它缺乏足够的信息例如长度去描述一个完整的对象。所以一个数组没有给定长度，直接赋值就会产生这样的错误。</p>
<p>6.<strong>c++ 非静态成员引用必须与特定对象相对</strong><br>这是在调用类成员函数的时候出现的问题<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">className::<span class="built_in">funcName</span>(para) <span class="comment">// Error</span></span><br><span class="line"></span><br><span class="line">className CN;</span><br><span class="line">CN.<span class="built_in">funcName</span>(para);<span class="comment">//Pass</span></span><br></pre></td></tr></table></figure><br><img src="https://img-blog.csdnimg.cn/20210416082241282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="PAT"><a href="#PAT" class="headerlink" title="PAT"></a>PAT</h2><p>1.（当输出结果为很大的数字时出现）比较赋值的变量一定要进行初始化，因为PAT编译器不会默认初始化为0.（基本上就是一个很大的随机数）</p>
<h1 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h1><p>sudo apt-get install g++-multilib<br>遇到一种情况，就是出现缺少一些库</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/03/Wireshark-Lab-HTTP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/03/Wireshark-Lab-HTTP/" class="post-title-link" itemprop="url">Wireshark Lab: HTTP</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-01-03 08:16:33" itemprop="dateCreated datePublished" datetime="2021-01-03T08:16:33+08:00">2021-01-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-08 19:40:01" itemprop="dateModified" datetime="2023-03-08T19:40:01+08:00">2023-03-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Wireshark-Lab-HTTP"><a href="#Wireshark-Lab-HTTP" class="headerlink" title="Wireshark Lab: HTTP"></a>Wireshark Lab: HTTP</h1><h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><font color="#999AAA">

坚持型连接&非坚持型连接：是否在同一个TCP连接上完成所有的请求/应答报文的传输？Y：坚持型，N:非坚持型。

#### HTTP的非坚持型连接
现在来看看当你点击一个超链接的时候会发生什么。
1.客户机会对超链接的服务器通过80端口（TCP默认端口号）发起一个TCP连接
2.客户机通过套接字向服务器发送HTTP请求报文
3.服务器收到报文之后，从自己的内存（RAM or disk）中获取被请求的对象，并将这些对象封装至HTTP请求报文（HTLM）中，然后通过套接字发送给客户机。
4.HTTP服务器请求关闭TCP连接
5.客户机获取请求的对象，TCP连接彻底关闭。客户机从恢复报文中获取文件
6.获取其他的对象，继续循环上面的步骤

由此可见，每当一个对象被正确接收的时候，之前的建立的TCP连接都会被关闭。一般情况下，浏览器会建立5到10个并行TCP连接，这样的平行连接可以减短响应时间。

![HTLM相应时间](https://img-blog.csdnimg.cn/20210102200933336.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70#pic_center)
由上图，非坚持型下的HTLM的相应时间为：
$$
t_{total} = 2*t_{RTT} + t_{trans}
$$

#### HTTP的坚持型连接
非坚持型连接有以下几个缺点：
1.每一个请求对象都需要建立一次TCP连接，这样会导致额外的内存消耗

> For each of these connections, TCP buffers must be allocated and TCP variables must be kept in both the client and server.

2.每一个对象的递交过程会导致两个RTT的时间消耗
##### 坚持型HTTP连接的断开

在HTTP1.1中，当TCP连接建立之后，剩余的对象都通过这个TCP连接递交。当递交结束之后，当这条TCP连接在一定的时间(a configurable timeout interval)没有被使用时，这条连接会自动关闭。

> HTTP/2  builds on HTTP 1.1 by allowing multiple requests and replies to be interleaved in the same connection, and a mechanism for prioritizing HTTP message requests and replies within this connection.
（存疑）


![在这里插入图片描述](https://img-blog.csdnimg.cn/20210102184014664.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70#pic_center)

#### HTTP的报文格式
###### 请求报文
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个例子</span></span><br><span class="line"><span class="comment">//The great majority of HTTP request messages use the GET method.</span></span><br><span class="line">GET /somedir/page.html HTTP/<span class="number">1.1</span> <span class="comment">//the method field, the URL field, and the HTTP version field.</span></span><br><span class="line">Host: www.someschool.edu  <span class="comment">//对象所在的主机地址（Web代理缓存中需要）</span></span><br><span class="line">Connection: close<span class="comment">//表示非坚持型</span></span><br><span class="line">User-agent: Mozilla/<span class="number">5.0</span> <span class="comment">//浏览器的类型</span></span><br><span class="line">Accept-language: fr<span class="comment">//许多协商首部(negotiation header)中的一种</span></span><br></pre></td></tr></table></figure>
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210102204106878.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70#pic_center)
注意到上图出现的实体（Entity Body）部分，在GET方法中是空的，他在POST方法中，例如当用户提供搜索关键词的时候，POST仍然是向服务器请求获取网页，但是是网页特定的内容。
但是HTML表单（HTML form）通常用GET方法，并在URL（统一资源定位器）中加上输入的文本，就像这样：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当你在某个网站上面搜索“monkeys” 和“bananas”的时候，URL会变成下面这个样子</span></span><br><span class="line"> www.somesite.com/animalsearch?monkeys&amp;bananas</span><br></pre></td></tr></table></figure>
###### 应答报文
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个例子</span></span><br><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK<span class="comment">//the protocol version field, a status code（状态码：请求结果）, and a corresponding status message.</span></span><br><span class="line">Connection: close<span class="comment">//非坚持型</span></span><br><span class="line">Date: Tue, <span class="number">18</span> Aug <span class="number">2015</span> <span class="number">15</span>:<span class="number">44</span>:<span class="number">04</span> GMT<span class="comment">//服务器从自己的文件系统中获取被请求对象，并将它插入到回应报文中，后将它发送给客户机时的时间</span></span><br><span class="line">Server: Apache/<span class="number">2.2</span><span class="number">.3</span> (CentOS)<span class="comment">//服务器类型</span></span><br><span class="line">Last-Modified: Tue, <span class="number">18</span> Aug <span class="number">2015</span> <span class="number">15</span>:<span class="number">11</span>:<span class="number">03</span> GMT<span class="comment">// It is critical for object caching, both in the local client and in network cache servers (also known as proxy servers).</span></span><br><span class="line">Content-Length: <span class="number">6821</span><span class="comment">//被发送对象的比特数</span></span><br><span class="line">Content-Type: text/html<span class="comment">//发送主题的类型（HTML 文本）(The object type is officially indicated by the Content-Type: header and not by the file extension.)</span></span><br><span class="line">(data data data data data ...)<span class="comment">//报文核心部分（the meat of message）包含被请求的对象</span></span><br></pre></td></tr></table></figure>
报文请求结果类型：

> 
> **200 OK**: Request succeeded and the information is returned in the response.
**301 Moved Permanently**: Requested object has been permanently moved; the new URL is specified in Location : header of the response message. The client software will automatically retrieve the new URL.
**400 Bad Request**: This is a generic error code indicating that the request could not be understood by the server
**404 Not Found**: The requested document does not exist on this server.
**505 HTTP Version Not Supported**: The requested HTTP protocol version is not supported by the server.

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210102210031696.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70#pic_center)
状态行（state line）
表头行（header line）
(待续....)
</font>

<p>&lt;hr style=” border:solid; width:100px; height:1px;” color=#000000 size=1”&gt;</p>
<font color="#999AAA">

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><font color="#999AAA"><br>问题：<br>1.HTTP/2？（unsolved）</font></p>
</font>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/02/Wireshark-Lab-Getting-Started/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/02/Wireshark-Lab-Getting-Started/" class="post-title-link" itemprop="url">Wireshark Lab:Getting Started</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-01-02 16:46:57" itemprop="dateCreated datePublished" datetime="2021-01-02T16:46:57+08:00">2021-01-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-08 19:39:26" itemprop="dateModified" datetime="2023-03-08T19:39:26+08:00">2023-03-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Wireshark-Lab-Getting-Started"><a href="#Wireshark-Lab-Getting-Started" class="headerlink" title="Wireshark Lab:Getting Started"></a>Wireshark Lab:Getting Started</h1><p><font color="#999AAA">《计算机网络自顶向下方法7e》实验</font></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><font color="#999AAA">第一次实验主要就是介绍Wireshark应该怎么用，还有大致讲了Wireshark的工作原理。</font></p>
<h1 id="一、How-Wireshark-Works"><a href="#一、How-Wireshark-Works" class="headerlink" title="一、How Wireshark Works?"></a>一、How Wireshark Works?</h1><p><img src="https://img-blog.csdnimg.cn/20201231213649334.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_12,color_FFFFFF,t_70" alt><br>包嗅探器（Packet Sniffer）<br>其本身不主动运行，只是观察应用发送和接收的数据包，并保存这些数据包的一个备份。</p>
<blockquote>
<p>嗅探（Sniffers）是一种黑客的窃听手段，一般是指使用嗅探器对数据流的数据截获与封包分析（Packet analysis）。</p>
</blockquote>
<p>包捕捉器：接受数据链路层的帧，因为在这一层，数据包是最完整的（发送来的数据报没有被解封装，发送的数据报在这一层完成了所有的封装）。<br>包分析器：能够识别数据包的协议，以便将各层的协议部分从下一层的数据报中分离出来。</p>
<font color="#999AAA">



<h1 id="二、Wireshark的界面介绍"><a href="#二、Wireshark的界面介绍" class="headerlink" title="二、Wireshark的界面介绍"></a>二、Wireshark的界面介绍</h1><p><img src="https://img-blog.csdnimg.cn/20210102162028414.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h1 id="三、实验过程"><a href="#三、实验过程" class="headerlink" title="三、实验过程"></a>三、实验过程</h1><p>i）运行Wireshark，然后在浏览器中访问<a target="_blank" rel="noopener" href="http://gaia.cs.umass.edu/wireshark-labs/INTRO-wireshark-file1.html">http://gaia.cs.umass.edu/wireshark-labs/INTRO-wireshark-file1.html</a><br>ii）停止Wireshak，在过滤器中输入http。<br><img src="https://img-blog.csdnimg.cn/20210102163534330.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>在对应层可以看到对应协议的一些信息，例如在IP层可以看到数据包的发送者和接收者的IP地址。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><font color="#999AAA">How long did it take from when the HTTP GET message was sent until the HTTP<br>OK reply was received?（Unsolved）</font></p>
</font>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/31/%E3%80%8A%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%8B%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86C-C-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/31/%E3%80%8A%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%8B%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86C-C-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">《算法笔记》第一部分C/C++语言基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-31 21:30:57" itemprop="dateCreated datePublished" datetime="2020-12-31T21:30:57+08:00">2020-12-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-08 19:38:42" itemprop="dateModified" datetime="2023-03-08T19:38:42+08:00">2023-03-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="《算法笔记》的笔记"><a href="#《算法笔记》的笔记" class="headerlink" title="《算法笔记》的笔记"></a>《算法笔记》的笔记</h1><font color="#999AAA">第二章： C/C++快速入门


# 前言

<font color="#999AAA">在学习之前有一个小插曲，用vi命令打开.c文件的时候总是提示存在交换文件，这让我没有办法修改我的目标文件，经过查询相关资料，我发现只要将对应的交换文件删除就可以了，产生原因可能是因为在退出编辑模式之前退出文件了。应该是shift+double z，而不是crtl
    **具体的操作方法**：使用ls - al 命令查看文件夹目录，找到交换文件（文件后缀是.swp）然后就用 rm - 文件名 删掉相应的交换文件就可以了
    *PS：我发现当交换文件出现重名的时候，文件的拓展名会到发生变化（.swn 、.swo等）
    PPS：很久没有用我的Ubuntu了，很多的命令都忘记了，所以一些常用的命令需要在这里记下来，以便之后学习的时候复习。*
    vi/vim、cd、ls、mkdir 

</font>

<p>&lt;hr style=” border:solid; width:100px; height:1px;” color=#000000 size=1”&gt;<br>虽然之前学过C/C++但是担心自己有什么遗漏所以还是看了一遍，在这里主要记录的就是自己原先不是很熟悉的内容。</p>
<font color="#999AAA">


<h2 id="2-1-基本数据类型"><a href="#2-1-基本数据类型" class="headerlink" title="2.1 基本数据类型"></a>2.1 基本数据类型</h2><ol>
<li>cin和cout消耗的时间会比scanf和printf多得多。而且在同一个程序当中不应该同时使用cout和printf（会出现问题）</li>
<li>C++标准库中，stdio.h的推荐写法：cstdio（就是去掉后缀，然后在最前面加上c,eg:<math.h> —-&gt; \<cmath>）</cmath></math.h></li>
<li><strong>基本数据类型：</strong><br><font color="#999AAA"><br>i）整型：int  —-&gt;  32bit （10\^9以内使用）||  long long ——&gt; 64 bit(如果long long型赋大于2\^31-1的初值的时候，需要在初值后面加上LL，否则会编译错误)<br>ii)浮点型：（Mantissa：小数部分）<img src="https://img-blog.csdnimg.cn/20201231202429775.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="IEEE标准的浮点表示法"><br>由上图可以知道单精度float有效精度只有6~7位（具体原因之后补充），双精度浮点型double的有效精度为15~16位。书中的建议：（应该是单精度浮点型的精度在大多时候都不够用吧）</font></li>
</ol>
<blockquote>
<p>对于浮点型来说，只需记住一点，不要使用float，碰到浮点型的数据都应该使用double来存贮。</p>
<p><font color="#999AAA"><br>iii）字符型：字符在C语言中使用使用ASCII码统一编码的。（需要记住一点小写字母比大写字母的ASCII码值大32，0的ASCII码为48）<br>（还要记住几个常用的转义字符：\n代表换行,\0代表空字符，其ASCII码为0，\t代表Tab键）<br>这一部分总结来说就是%c会将整型数字转化成相应ASCII码所对应的值。<br>对于字符串型可以转化成字符数组，但是不能赋值给字符变量</font></p>
</blockquote>
<p>3.<strong>强制类型转换</strong></p>
<p><font color="#999AAA">格式：（新类型名）变量名</font></p>
<blockquote>
<p>如果在计算过程中需要类型转换，那么就不能等它算完再在赋值的时候转换</p>
</blockquote>
<p><strong>4.符号常量和const常量</strong></p>
<p><font color="#999AAA"><br>这是定义常量的两种方式（更加推荐后者）<br>格式：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> 标识符 常量<span class="comment">//注意这里最后是没有分号的</span></span></span><br><span class="line"><span class="type">const</span> 数据类型 变量 = 常量；</span><br></pre></td></tr></table></figure><br>宏定义（Macro definition）的陷阱：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAL(x) (x * 2 + 1)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">CAL</span> (a + <span class="number">1</span>));</span><br><span class="line">	<span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：4</span></span><br><span class="line"><span class="comment">//因为宏定义只会将数据原封不动地带进去，实际上的运算过程为：a+1*2+1.</span></span><br><span class="line"><span class="comment">//所以在用宏定义的时候应该将变量全部用括号括起来</span></span><br></pre></td></tr></table></figure><br><strong>5.运算符</strong></font></p>
<p><font color="#999AAA"><br>i）算数运算符没有幂次运算符，<strong>^代表的是位异或</strong>（位运算符可以用来定义无穷大的数）<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实际上就是整型的上限</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = (<span class="number">1</span> &lt;&lt; <span class="number">30</span>) <span class="number">-1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3fffffff</span>;</span><br></pre></td></tr></table></figure><br>位运算符的使用技巧：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.判断两个数字是否异号，利用补码编码的符号位进行异或运算（同0异1）</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">-1</span>, j = <span class="number">1</span>;</span><br><span class="line">(i ^ j &lt; <span class="number">0</span>) = <span class="literal">true</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//2.将编码最后一个1转换成0，可用于求解统计二进制编码中1的个数和判断一个数是不是2的指数</span></span><br><span class="line"><span class="comment">//这个数减去一之后，会向从右开始的第一个数借一位，这使得这一位变成0，然后与运算，</span></span><br><span class="line"><span class="comment">//将不相同的位全部变成0，这样就去掉了最右边的哪一个1</span></span><br><span class="line">n &amp; (n<span class="number">-1</span>);<span class="comment">//可以用于统计1的个数，或者进行相应的运算</span></span><br><span class="line"><span class="comment">//统计一个数的二进制数中1的个数(汉明权重)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="type">uint32_t</span> n)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">		n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">		res++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断一个数是否为2的指数：注意2的指数有一个特点，在二进制编码中只能有一个1</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n &lt;= <span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> (n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p>
<p><font color="#999AAA"><br>ii）条件运算符<br>格式：A ? B : C;</font></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用条件运算符+宏定义判断大小的结构</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br></pre></td></tr></table></figure>
<h2 id="2-2-顺序结构"><a href="#2-2-顺序结构" class="headerlink" title="2.2 顺序结构"></a>2.2 顺序结构</h2><h3 id="2-2-1-赋值语句"><a href="#2-2-1-赋值语句" class="headerlink" title="2.2.1 赋值语句"></a>2.2.1 赋值语句</h3><p>而如果要给多个变量赋<strong>同一个值</strong>，可以使用连续等号的方法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">n = m = <span class="number">5</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-2-2-输入-输出语句（scanf-printf）"><a href="#2-2-2-输入-输出语句（scanf-printf）" class="headerlink" title="2.2.2 输入/输出语句（scanf/printf）"></a>2.2.2 输入/输出语句（scanf/printf）</h3><p>1.scanf函数<br><img src="https://img-blog.csdnimg.cn/20210102212212410.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>注意到字符串类型不需要使用取址运算符，因为字符串类型相当于一个数组，数组名称代表第一个元素的地址。<br>另外，除了%c 外， scanf 对其他格式符（如%d）的输入是以空白符（即空格、 Tab ）为结束判断标志的<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a, a1;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;a1);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>, a, a1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//input:1 2  output:1 2</span></span><br></pre></td></tr></table></figure><br>但是对于%c</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a; <span class="type">char</span> c, str[<span class="number">10</span>];</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%c%s&quot;</span>, &amp;a, &amp;c,str);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;a=%d, c=%c,str=%s&quot;</span>, a, c, str);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//Input:1 2 3</span></span><br><span class="line">	<span class="comment">//Output:a = 1, c=, str = 2</span></span><br><span class="line">	<span class="comment">//可见空格也被当成一个字符了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>scanf()的返回值：<br>输入数字，匹配%d,配置b的值成功，scanf返回成功配置数量1；<br>输入字母，不匹配%d,配置b的值失败，scanf返回成功配置数量0；<br>输入Ctrl+Z，scanf返回-1；</p>
<p>2.printf函数<br><img src="https://img-blog.csdnimg.cn/20210102212936302.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>这里注意一点：在scanf中double的格式符为%lf，而在printf中格式符为%f</strong></p>
<p>接下来介绍三种使用的输出格式：（m为一个具体的数字）</p>
<ol>
<li><strong>%md</strong>  可以使不足 位的 int 型变量以m位进行右对齐输出，其中高位用空格补齐。如果变量本身超过m位，则保持原样。</li>
<li><strong>%0md</strong> 和上面的类似，只不过是用0而不是空格</li>
<li><strong>%.mf</strong>  让浮点数保留m位小数输出，采用”四舍六入五成双“[4]的规则</li>
</ol>
<h3 id="2-2-3-getchar-amp-putchar"><a href="#2-2-3-getchar-amp-putchar" class="headerlink" title="2.2.3 getchar &amp; putchar"></a>2.2.3 getchar &amp; putchar</h3><p>获取和输出一个字符，注意getchar（）是可以识别换行的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">char</span> c1, c2, c3;</span><br><span class="line">	c1 = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line">	c2 = <span class="built_in">getchar</span>();</span><br><span class="line">	c3 = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="built_in">putchar</span>(c1);</span><br><span class="line">	<span class="built_in">putchar</span>(c2);</span><br><span class="line">	<span class="built_in">putchar</span>(c3);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Input:ab(&lt;Enter&gt;)c</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">a</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">c</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2-2-5-typedef"><a href="#2-2-5-typedef" class="headerlink" title="2.2.5 typedef"></a>2.2.5 typedef</h3><p>可以给复杂的数据类型起一个别名<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;<span class="comment">//之后就可以用LL代替long long了</span></span><br></pre></td></tr></table></figure></p>
<h3 id="2-2-6-常用的math函数"><a href="#2-2-6-常用的math函数" class="headerlink" title="2.2.6 常用的math函数"></a>2.2.6 常用的math函数</h3><p>需要#include<math.h></math.h></p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只能是括号中的类型（？）</span></span><br><span class="line"><span class="number">1.</span> fabs（<span class="type">double</span> x）————（<span class="type">float</span> absolute value）给<span class="type">double</span>型变量取绝对值</span><br><span class="line"><span class="number">2.</span> <span class="built_in">floor</span>(<span class="type">double</span> x) &amp; <span class="built_in">ceil</span>(<span class="type">double</span> x) ————（地板和天花板）向下和向上取整</span><br><span class="line"><span class="number">3.</span> <span class="built_in">pow</span>(<span class="type">double</span> r, <span class="type">double</span> p)————（幂函数：power function）返回  r^p</span><br><span class="line"><span class="number">4.</span> <span class="built_in">sqrt</span>(<span class="type">double</span> x) ————（Arithmetic square root）返回算数平方根</span><br><span class="line"><span class="number">5.</span> log（<span class="type">double</span> x） ————（Natural logarithm） 返回以自然对数为底数的对数值</span><br><span class="line"><span class="number">6.</span> <span class="built_in">sin</span>(<span class="type">double</span> x) 、<span class="built_in">cos</span>(<span class="type">double</span> x)、<span class="built_in">tan</span>(<span class="type">double</span> x) ————可以用来精确定义pi的值：acos（<span class="number">-1.0</span>）</span><br><span class="line"><span class="number">7.</span> <span class="built_in">asin</span>(<span class="type">double</span> x) 、<span class="built_in">acos</span>(<span class="type">double</span> x)、<span class="built_in">atan</span>(<span class="type">double</span> x) ————反三角函数</span><br><span class="line"><span class="number">8.</span> <span class="built_in">round</span>(<span class="type">double</span> x) ————（round：用整数表示的, 取整数的, 整数的）四舍五入取整</span><br></pre></td></tr></table></figure>
<p>C语言中没有对任意底数求对数的函数，因此必须使用换底公式来将不是以自然对数为底的对数转换为以e为底的对数，即 </p>
<script type="math/tex; mode=display">log_ab = log_eb/log_ea</script><p>注意：pow()可能导致错误的情况：</p>
<ol>
<li>如果==底数 x 为负数并且指数 y 不是整数==，将会导致 domain error 错误。</li>
<li>如果<u>底数 x 和指数 y 都是0</u>，可能会导致 domain error 错误，也可能没有；这跟库的实现有关。 </li>
<li>如果<u>底数 x 是 0，指数 y是负数</u>，可能会导致 domain error 或 pole error 错误，也可能没有；这跟库的实现有关。 </li>
<li>如果<u>返回值ret 太大或者太小</u>，将会导致 range error 错误。</li>
</ol>
<p>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/yuanbo_shaw/article/details/79511132">https://blog.csdn.net/yuanbo_shaw/article/details/79511132</a></p>
<h2 id="2-3-选择结构"><a href="#2-3-选择结构" class="headerlink" title="2.3 选择结构"></a>2.3 选择结构</h2><p>因为这部分的内容比较熟悉，就跳过了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">	<span class="keyword">case</span> 表达式<span class="number">1</span>：<span class="comment">//相当于switch中的语句的结构，如果匹配，则执行之后的语句</span></span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> 表达式<span class="number">2</span>：</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	.........</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		....</span><br><span class="line"><span class="comment">//注意每个case语句之后是没有大括号的！</span></span><br><span class="line"><span class="comment">//break是用来结束当前switch语句的</span></span><br></pre></td></tr></table></figure>
<p>对于for语句，在C语言中是不允许定义变量的，但是在C++中可以（将代码文件保存为.cpp的格式即可）</p>
<h2 id="2-5-数组"><a href="#2-5-数组" class="headerlink" title="2.5 数组"></a>2.5 数组</h2><h3 id="2-5-1-一维数组"><a href="#2-5-1-一维数组" class="headerlink" title="2.5.1 一维数组"></a>2.5.1 一维数组</h3><ol>
<li>数组的大小必须是整型常量，不能是变量。但是可以自己申请空间以定义数组<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C</span></span><br><span class="line"><span class="type">int</span>* a = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>)*n);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"><span class="comment">//C++</span></span><br><span class="line"><span class="type">int</span>* a = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line"><span class="keyword">delete</span>[] a;</span><br><span class="line"><span class="comment">//释放内存~~~</span></span><br></pre></td></tr></table></figure></li>
<li>当数组没有被初始化值的时候，一般默认是赋值为0，但是有时候有可能被赋值为很大的随机数</li>
<li>给数组赋值的方法：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//这种方法只能用于将数组初始化为0</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123;<span class="number">-1</span>&#125;;<span class="comment">//-1 0 0 0 0  0 0....(测试环境VS2019)</span></span><br><span class="line"><span class="built_in">fill</span> (a, a + <span class="number">10</span>, <span class="number">-1</span>);<span class="comment">//初始化为-1，需要函数头algorithm和using namespace std;</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123;&#125;;<span class="comment">//初始化为0</span></span><br></pre></td></tr></table></figure>
<h3 id="2-5-2-冒泡排序"><a href="#2-5-2-冒泡排序" class="headerlink" title="2.5.2 冒泡排序"></a>2.5.2 冒泡排序</h3><p>本质上就是通过不断地交换减少数组中的逆序数对。在一遍遍历过程中，不断将较大的元素与相邻的元素进行交换。而最大的元素因为总是会比之后的元素更大，所以会被移到最后。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> sorted = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">while</span>(!sorted)&#123;</span><br><span class="line">		sorted = <span class="literal">true</span>;<span class="comment">//优化</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;=n;++i)&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i<span class="number">-1</span>] &gt; a[i])&#123;</span><br><span class="line">				<span class="type">int</span> temp = a[i<span class="number">-1</span>];</span><br><span class="line">				a[i<span class="number">-1</span>] = a[i];</span><br><span class="line">				a[i] = temp;</span><br><span class="line">				sorted = <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-5-3-二维数组"><a href="#2-5-3-二维数组" class="headerlink" title="2.5.3 二维数组"></a>2.5.3 二维数组</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二维数组想要作为参数传入函数中，需要确定二维数组的大小（至少是第二维需要确定）</span></span><br><span class="line"><span class="comment">//二维数组的赋值方式</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">5</span>][<span class="number">6</span>] = &#123;&#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">8</span>,<span class="number">4</span>&#125;,&#123;&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;&#125;;<span class="comment">//剩余部分将会被赋值为0</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：当数组大小较大时（$10^6$数量级），需要将其定义在主函数外面，否则会使程序异常退出。</strong></p>
<p><font color="#999AAA">因为在函数内部申请的局部变量来自于系统栈，允许的空间较小；函数外部申请的全局变量来自静态存储区，允许申请的空间大。[6]</font></p>
<h3 id="2-5-4-memset函数"><a href="#2-5-4-memset函数" class="headerlink" title="2.5.4 memset函数"></a>2.5.4 memset函数</h3><p>menset函数可以给数组中的每一个函数赋值，但是menset使用的是<strong>按字节赋值的</strong>，这就是说一个整型变量的四个字节都会被赋相同的值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//memset（数组名，赋值，sizeof（数组名））；</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> A[<span class="number">5</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">	<span class="built_in">memset</span>(a, <span class="number">1</span>, <span class="built_in">sizeof</span>(A));</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：16843009        16843009        16843009        16843009        16843009[5]</span></span><br><span class="line"><span class="comment">//赋值为0或者-1（0的二进制补码为全0，-1的二进制补码为全1）</span></span><br><span class="line"><span class="comment">//还可以用fill函数对数组进行赋值，但是执行速度较差。</span></span><br></pre></td></tr></table></figure>
<p>这里每个字节的意思是每个字节都设为1，注意不要与每个位赋值弄混淆。因为int是8字节所以，调用menset之后，数组中存储的数字为：0000 0001 0000 0001 0000 0001 0000 0001.（1字节为8位）</p>
<h3 id="2-5-5-字符数组"><a href="#2-5-5-字符数组" class="headerlink" title="2.5.5 字符数组"></a>2.5.5 字符数组</h3><p>输入：（scanf）<br>%c:输入单个字符（<strong>能识别空格与换行并将其输入</strong>）<br>%s:输入字符串并保存在字符数组中（以空格或者换行作为结束标志）<br>（gets）输入一行字符串，以\n作为结束标识。<br>（getchar）获取输入额一个字符<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str2 [<span class="number">5</span>][<span class="number">10</span>];<span class="comment">//定义</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)&#123;</span><br><span class="line">	<span class="built_in">gets</span>(str2 [i]);<span class="comment">//运用这种方法将将输入的第一行赋值给数组的一整列</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出格式类似，运用的函数为puts（与gets类似）</span></span><br></pre></td></tr></table></figure><br>注意：字符串是以‘\0’（ASCII 为 0）作为结尾的，所以存储的长度应该比实际存储长度大一。==还有当用gets或者scanf函数的输入时，会自动在字符串尾部加上‘\0’==，但是当用getchar函数（getchar每次只获取一个字符，所以’\0’作为单独字符需要调用额外的getchar函数）时，一定要在每个字符串后面加上‘否则会出现乱码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">15</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">	str[i] = <span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span>(str);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//Input:T^T</span></span><br><span class="line"><span class="comment">//Output:T^T烫烫烫烫烫烫烫烫烫烫坍G醶?烫烫哎^v€麧</span></span><br><span class="line"><span class="comment">//应该是程序不知道什么地方是结束</span></span><br></pre></td></tr></table></figure></p>
<h3 id="2-5-6-string-h头文件"><a href="#2-5-6-string-h头文件" class="headerlink" title="2.5.6 string.h头文件"></a>2.5.6 string.h头文件</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line">...</span><br><span class="line"><span class="type">char</span> str1[<span class="number">10</span>], str2[<span class="number">10</span>];<span class="comment">//代表字符数组</span></span><br><span class="line"><span class="built_in">strlen</span>(str1)；<span class="comment">//得到第一个&#x27;\0&#x27;之前的字符个数</span></span><br><span class="line"><span class="built_in">strcmp</span>(str1,str2)；<span class="comment">//按照字典序比较（&lt;:返回负整数；=：返回0；&gt;：返回正整数）</span></span><br><span class="line"><span class="built_in">strcpy</span>(tr1,str2);<span class="comment">//str2复制给str1，包含&#x27;\0&#x27;</span></span><br><span class="line"><span class="built_in">strcat</span>(str1,str2);<span class="comment">//(concatenate：把事物连接起来)str2接到str1后面</span></span><br></pre></td></tr></table></figure>
<h3 id="2-5-7-sscanf-amp-sprintf"><a href="#2-5-7-sscanf-amp-sprintf" class="headerlink" title="2.5.7 sscanf &amp; sprintf"></a>2.5.7 sscanf &amp; sprintf</h3><p>（都在stdio.h中）（<font color="#999AAA">补充）</font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个函数的主要用途就是将字符数组的内容转化成整型，放到整型变量中</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> str[<span class="number">100</span>] = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="built_in">sscanf</span>(str, <span class="string">&quot;%d&quot;</span>, &amp;n);<span class="comment">//相当于将str作为输入对象（类似于scanf的屏幕输入）</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, n);</span><br><span class="line"></span><br><span class="line"><span class="comment">//就像printf一样，只不过是将其打印到了一个字符串数组中去了</span></span><br><span class="line"><span class="type">double</span> db = <span class="number">3.1415</span>;</span><br><span class="line"><span class="type">int</span> n1 = <span class="number">12</span>;</span><br><span class="line"><span class="type">char</span> str1[<span class="number">100</span>], str2[<span class="number">100</span>] = <span class="string">&quot;good&quot;</span>;</span><br><span class="line"><span class="built_in">sprintf</span>(str1, <span class="string">&quot;%d:%.2f,%s&quot;</span>, n1, db, str2);<span class="comment">//将这些元素输出给str1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;str1 = %s\n&quot;</span>, str1);</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//    123</span></span><br><span class="line"><span class="comment">//    str1 = 12:3.14,good</span></span><br></pre></td></tr></table></figure>
<h2 id="2-6-函数"><a href="#2-6-函数" class="headerlink" title="2.6 函数"></a>2.6 函数</h2><p><font color="#999AAA">函数这部分也比较熟悉所以大部分省略了</font></p>
<p>1.数组可以作为参数，但是不允许作为返回类型出现</p>
<h2 id="2-7-指针"><a href="#2-7-指针" class="headerlink" title="2.7 指针"></a>2.7 指针</h2><p><img src="https://img-blog.csdnimg.cn/20210104124454965.png#pic_center" alt="在这里插入图片描述"></p>
<blockquote>
<p>指针（英语：Pointer），是编程语言中的一类数据类型及其对象或变量，用来表示或存储一个存储器地址，这个地址的值直接指向（points to）存在该地址的对象的值。</p>
</blockquote>
<p>相关的操作有：<br>&amp; ——取此变量的地址<br>* ———取该地址对应的值<br>指针变量的运算：加（减）代表的是指针指向前一个（后一个）存储块。看下面这个例子<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* x, <span class="type">int</span> y</span><br><span class="line">...</span><br><span class="line">x = &amp;y + <span class="number">3</span>    <span class="comment">//结果是x存储的地址是y的地址+12</span></span><br><span class="line"><span class="comment">//因为一个int类型占4个字节，所以这样总的来说就是向前移动了12个字节</span></span><br></pre></td></tr></table></figure></p>
<p> <strong>在函数中</strong>，想要修改传入的值，就需要传入该变量的地址（传址访问），包括要修改指针变量也是需要将指针变量所对应的地址传进去。<br> <strong>注意：常量是不能被使用取址运算符</strong>。因为引用的对象必须是可以修改的左值，也就是说放常量被引用的时候，它并不能被修改，所以索性就不能被引用了。<br> <strong>在数组中</strong>，一下两种检索方式是等价的<br> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&amp; big_array[ <span class="number">0</span> ] + <span class="function">i * <span class="title">sizeof</span><span class="params">( big_array[ <span class="number">0</span> ])</span></span>;<span class="comment">//对地址直接修改</span></span><br><span class="line">&amp;big_array[ i ] = big_array + i;<span class="comment">//通过指针运算</span></span><br></pre></td></tr></table></figure><br>（以下来自于《C程序语言设计2e》）</p>
<h3 id="Pointers-and-Arrays"><a href="#Pointers-and-Arrays" class="headerlink" title="Pointers and Arrays"></a>Pointers and Arrays</h3><p>注意事项：<br>1.(<em>ip)++这里的括号是必要的，因为单元运算符像\</em>、++结合，是从右向左运算的。（一个准则，当你遇到不熟悉的运算符的时候，将所有可能出错的地方全部加括号）</p>
<p>2.在传参的时候，想要修改传入参数，需要传入参数的地址，例如swap(&amp;a,&amp;b)；</p>
<p>3.int a[num],这是在申请大小为num的数组，索引范围为0 ~ num-1<br><img src="https://img-blog.csdnimg.cn/20210222070754753.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="指针和数组索引"></p>
<h2 id="2-8-结构体（struct）的使用"><a href="#2-8-结构体（struct）的使用" class="headerlink" title="2.8 结构体（struct）的使用"></a>2.8 结构体（struct）的使用</h2><h3 id="2-8-1-结构体的定义方式以及访问方式"><a href="#2-8-1-结构体的定义方式以及访问方式" class="headerlink" title="2.8.1 结构体的定义方式以及访问方式"></a>2.8.1 结构体的定义方式以及访问方式</h3><p><strong>注意在结构体内不能用定义的结构体定义变量，但是可以定义指针类型。</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结构体的定义方式</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">structname</span>&#123;</span><br><span class="line">	<span class="type">int</span> a;<span class="comment">//成员变量</span></span><br><span class="line">	structname b;<span class="comment">//不能定义自己本身（会引起循环定义的问题）</span></span><br><span class="line">	structname* c;<span class="comment">//可以定义自身类型的指针变量</span></span><br><span class="line">&#125;A;<span class="comment">//结构体变量，相当于 structname A；</span></span><br></pre></td></tr></table></figure><br>结构体内元素的访问方式：<br>点运算符：”.“非指针变量的访问方式；<br>指针运算符：”-&gt;“指针变量的访问方式。</p>
<h3 id="2-8-3-结构体初始化"><a href="#2-8-3-结构体初始化" class="headerlink" title="2.8.3 结构体初始化"></a>2.8.3 结构体初始化</h3><p>构造函数是用来初始化结构体的一种函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认情况下构造函数是不显示的</span></span><br><span class="line"><span class="comment">//但是想要自己重新定义构造函数，就不能不经初始化就定义结构体变量</span></span><br><span class="line"><span class="comment">//想要同时实现二者，需要像以下这样定义构造函数</span></span><br><span class="line"><span class="comment">//只要参数个数和类型不完全相同，就可以定义多个构造函数，以适应不同环境下的初始化</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">studentInfo</span>&#123;</span><br><span class="line">	<span class="type">int</span> id;<span class="type">char</span> gender;</span><br><span class="line">	<span class="built_in">studentInfo</span>()&#123;&#125;;<span class="comment">//默认的构造函数</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">studentInfo</span>(<span class="type">char</span> _gender)&#123;<span class="comment">//这里的变量名不能和外部的一样</span></span><br><span class="line">		gender = _gender;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">studentInfo</span>(<span class="type">int</span> _id, <span class="type">char</span> _gender)&#123;</span><br><span class="line">	id = _id;</span><br><span class="line">	gender = _gender;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//初始化方式</span></span><br><span class="line">studentInfo A;</span><br><span class="line">A = <span class="built_in">studentInfo</span>(<span class="number">2021</span>,<span class="string">&quot;girl&quot;</span>);<span class="comment">//调用构造函数初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//C++的另一种构造函数的方式</span></span><br><span class="line"><span class="built_in">studentInfo</span>(<span class="type">int</span> _id, <span class="type">char</span> _gender):<span class="built_in">id</span>(_id),<span class="built_in">gender</span>(_gender)&#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-9-补充内容"><a href="#2-9-补充内容" class="headerlink" title="2.9 补充内容"></a>2.9 补充内容</h2><h3 id="2-9-1-cin-与-cout"><a href="#2-9-1-cin-与-cout" class="headerlink" title="2.9.1 cin 与 cout"></a>2.9.1 cin 与 cout</h3><p>这两个输入输出函数虽然简洁（不用定义类型之类的）但是面对大量数据的时候，效率较低。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&quot;&gt;&gt;&quot;可以看成数据流的方向</span></span><br><span class="line"><span class="comment">//多变量输入</span></span><br><span class="line">cin &gt;&gt; n &gt;&gt; db &gt;&gt; c &gt;&gt; str;</span><br><span class="line"><span class="comment">//多变量输出</span></span><br><span class="line">cout &lt;&lt; n &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; db &lt;&lt; endl;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="2-9-2-浮点数比较"><a href="#2-9-2-浮点数比较" class="headerlink" title="2.9.2 浮点数比较"></a>2.9.2 浮点数比较</h3><p>由于在计算机中采用有限位的二进制编码，因此浮点数在计算机中的存储并不总是精确的[8]。<br>在经过大量运算之后，浮点数的精度可能会发生变化，这就给比较操作（&gt;、&lt;、=）<br>产生了干扰。所以，我们定义一个极小数eps（通常取$10^{-8}$）,只要比较数落在特定的区间内（$\pm esp$）即可。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用宏定义等于</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> esp = <span class="number">1e-8</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Equ(a,b) ((fabs((a)-(b)) &lt; (esp)))</span></span><br></pre></td></tr></table></figure><br>其他的比较运算符的所在区间如下图：<br><img src="https://img-blog.csdnimg.cn/20210105125223616.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>还有几点需要注意：</p>
<ol>
<li>经过大量的运算之后，一个变量存储的0可能是一个很小的负数，这时候使用sqrt函数就会报错，这时候就应该运用esp使变量保证在定义域内（*）</li>
<li>某些编译环境中，可能会输出-0.00.这是能将此输出放到字符串中，与“-0.00”比较，如果一致，那就加上esp修正这个值。</li>
</ol>
<h2 id="2-10-黑盒测试"><a href="#2-10-黑盒测试" class="headerlink" title="2.10 黑盒测试"></a>2.10 黑盒测试</h2><h1 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h1><h2 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h2><p>在定义数组之前，若数组大小未知，则需要对数组的空间进行申请<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一维数组</span></span><br><span class="line"><span class="comment">//动态分配，数组长度为m</span></span><br><span class="line"><span class="type">int</span> *array = <span class="keyword">new</span> <span class="type">int</span> [m];</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放内存</span></span><br><span class="line"><span class="keyword">delete</span>[] array; </span><br><span class="line"></span><br><span class="line"><span class="comment">//定义结构体动态数组并初始化</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Mystruct</span>&#123;</span><br><span class="line">	<span class="type">int</span> a, b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Mystruct* structs = <span class="keyword">new</span> Mystruct[<span class="number">100</span>];</span><br><span class="line">	Mystruct initializer = &#123;<span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">	<span class="built_in">fill</span>(structs, structs + <span class="number">100</span>,initializer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="C语言的共生体"><a href="#C语言的共生体" class="headerlink" title="C语言的共生体"></a>C语言的共生体</h2><p>参考：<a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-unions.html">https://www.runoob.com/cprogramming/c-unions.html</a><br>共生体是一种能在相同的内存位置存储不同的数据类型的一种特殊的数据类型。在共生体中能定义很多的不同的成员变量，但是任何时候只能有一个成员带有值。这样做可以节省空间，可以应用于变量不会同时使用的情况。</p>
<blockquote>
<p>通信中的数据包会用到共用体:因为不知道对方会发一个什么包过来，用共用体的话就很简单了，定义几种格式的包，收到包之后就可以直接根据包的格式取出数据。</p>
</blockquote>
<h3 id="定义方式"><a href="#定义方式" class="headerlink" title="定义方式"></a>定义方式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> [<span class="keyword">union</span> <span class="title class_">tag</span>]</span><br><span class="line">&#123;</span><br><span class="line">	member def;</span><br><span class="line">	menber def;</span><br><span class="line">	....</span><br><span class="line">&#125;[<span class="function"><span class="keyword">union</span> <span class="title">variable</span><span class="params">(s)</span>]</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例:成员变量可以是自定义的结构类型</span></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">Data</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">float</span> f;</span><br><span class="line">	<span class="type">char</span> str[<span class="number">20</span>];</span><br><span class="line">&#125;data;</span><br></pre></td></tr></table></figure>
<p>共用体占用的内存应足够存储最大数据类型成员。</p>
<h3 id="访问共生体成员"><a href="#访问共生体成员" class="headerlink" title="访问共生体成员"></a>访问共生体成员</h3><p>想要访问共生体成员需要使用点运算符。但是因为共生体所有的成员共用一个空间，所以在同一时间只能有一个成员变量能够拥有完整的赋值。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据损坏</span></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">Data</span> data;</span><br><span class="line"><span class="comment">//这样只有data.str能够拥有完成的数据</span></span><br><span class="line">data.i = <span class="number">10</span>;<span class="comment">//在后续的赋值过程中对应的内存被占用</span></span><br><span class="line">data.f = <span class="number">220.5</span>;</span><br><span class="line"><span class="built_in">strcopy</span>(data.str, <span class="string">&quot;Union&quot;</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>判断机器是大端机还是小端机<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line">data=<span class="number">0x01020304</span>;</span><br><span class="line"><span class="keyword">if</span>(str==<span class="number">0x01</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;此机器是大端！&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(str==<span class="number">0x04</span>)&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;此机器是小端！&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    cout &lt;&lt;<span class="string">&quot; 暂无法判断此机器类型！&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="C-位域"><a href="#C-位域" class="headerlink" title="C 位域"></a>C 位域</h2><p>C语言提供了一种更好的利用内存空间的方式。这种方式可以告诉编译器你只用这些字节<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> withValidated : <span class="number">1</span>;<span class="comment">//只用一位来存储该变量</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> heightValidated : <span class="number">1</span>;<span class="comment">//后面的数字表示数据占用的空间的大小</span></span><br><span class="line">&#125;status;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> age : <span class="number">3</span>;</span><br><span class="line">&#125;Age;</span><br><span class="line">Age,age = <span class="number">7</span>;<span class="comment">//能够表示的最大值</span></span><br><span class="line">Age.age = <span class="number">8</span>;<span class="comment">//输出的时候为0，溢出</span></span><br></pre></td></tr></table></figure></p>
<h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p>定义格式<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">name</span> &#123;eleName1, eleName2,....&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">DAY</span></span><br><span class="line">&#123;</span><br><span class="line">	MON = <span class="number">1</span>,TUE,WED,THU,FRI,SAT,SUN</span><br><span class="line">&#125;day;<span class="comment">//1,2,3,4,5,6,7</span></span><br><span class="line"><span class="comment">//enum DAY day;</span></span><br><span class="line"></span><br><span class="line">day = WED;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,day);<span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">seasons</span>&#123;</span><br><span class="line">	spring, summer = <span class="number">3</span>, autumn, winter;</span><br><span class="line">&#125;;<span class="comment">//0，3，4，5</span></span><br></pre></td></tr></table></figure></p>
<h2 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h2><blockquote>
<p>在面向对象编程中，友元函数（friend function）是一个指定类（class）的“朋友”，该函数被允许访问该类中private、protected、public的资料成员。普通的函数并不能访问这些资料，然而宣告一个函数成为一个类的友元函数则被允许访问这些资料。<br>友元函数的宣告可以放在类声明的任何地方，不受访问限定关键字private、protected、public的限制。一个相似的概念是友谊类。<br>友谊关键字应该谨慎使用。如果一个拥有private或者protected成员的类，宣告过多的友元函数，可能会降低封装性的价值，也可能对整个设计框架产生影响。</p>
</blockquote>
<p>友元函数在类内部定义，可以在类外部定义。定义时在前面加上一个<code>friend</code>关键字<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">double</span> width;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">double</span> length;</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">printWidth</span><span class="params">(Box box)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printWidth</span><span class="params">(Box box)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; box.width &lt;&lt; endl;<span class="comment">//访问私密成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><blockquote>
<p>C++ 允许在同一作用域中的某个函数和运算符指定多个定义，分别称为函数重载和运算符重载。</p>
</blockquote>
<p>重载函数应该有不同的输入参数，这样能够编译器会根据不同的输入参数确定函数的定义，这个过程叫做<code>重载决策</code></p>
<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">printData</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;整数为: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">double</span>  f)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;浮点数为: &quot;</span> &lt;&lt; f &lt;&lt; endl;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">char</span> c[])</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;字符串为: &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><blockquote>
<p>重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将两个Box类相加</span></span><br><span class="line">Box <span class="keyword">operator</span>+(<span class="type">const</span> Box&amp;, <span class="type">const</span> Box&amp;);</span><br><span class="line">Box box1, box2, box3;</span><br><span class="line">....</span><br><span class="line">box3 = box1 + box2;</span><br></pre></td></tr></table></figure>
<h2 id="文件（C-PrimerPlus）"><a href="#文件（C-PrimerPlus）" class="headerlink" title="文件（C++PrimerPlus）"></a>文件（C++PrimerPlus）</h2><p>文件本身就是一连串的存储在设备当中的字节。</p>
<h3 id="文件输入和输出"><a href="#文件输入和输出" class="headerlink" title="文件输入和输出"></a>文件输入和输出</h3><p>文件输出流的类包含在文件头fstream（fstream.h）中。下面是写入文件的步骤：</p>
<ol>
<li>创建一个ofstream对象</li>
<li>将这个对象链接到特定的文件</li>
<li>用输入输出流控制命令，对文件中的字节进行操作</li>
</ol>
<p>打开一个文件可以用open()方法<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建文件对象</span></span><br><span class="line">ofstream fout;</span><br><span class="line"><span class="comment">//将文件对象与特定文件相互链接</span></span><br><span class="line">fout.<span class="built_in">open</span>(<span class="string">&quot;jar.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者在定义对象的时候初始化链接</span></span><br><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">&quot;jar.txt&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure><br>文件对象在输入或者输出的时候，会对每一个文件对象设立一个缓冲区，这个缓冲区存储输入的字节，当缓冲区满了以后，再将其中的内容转换到文件中。这种以缓冲区为单位一块块地传输字节，极大地提升了文件处理的速度。<br>读取文件中的内容<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ch;</span><br><span class="line">fin &gt;&gt; ch;</span><br><span class="line"><span class="type">char</span> buffer[<span class="number">80</span>];</span><br><span class="line">fin.<span class="built_in">getline</span>(buffer,<span class="number">80</span>);<span class="comment">//getline在string函数头中</span></span><br><span class="line">string line;</span><br><span class="line"><span class="built_in">getline</span>(fin, line);</span><br></pre></td></tr></table></figure><br>可以用close方法，断开文件对象与文件的链接，这样能够保证文件缓冲区就会被刷新，这样保证了文件会被实时更新。<br>下面是对文件的输入操作的实例。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fileio17_16</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string filename;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Enter name for new file: &quot;</span>;</span><br><span class="line">	cin &gt;&gt; filename;</span><br><span class="line"></span><br><span class="line">	<span class="function">ofstream <span class="title">fout</span><span class="params">(filename.c_str())</span></span>;<span class="comment">//将C++的string类型转换成C语言的char数组，返回一个数组指针</span></span><br><span class="line"></span><br><span class="line">	fout &lt;&lt; <span class="string">&quot;For your eyes only!\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Enter your secret number:&quot;</span>;</span><br><span class="line">	<span class="type">float</span> secret;</span><br><span class="line">	cin &gt;&gt; secret;</span><br><span class="line">	fout &lt;&lt; <span class="string">&quot;Your secret number is &quot;</span> &lt;&lt; secret &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	fout.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">	<span class="function">ifstream <span class="title">fin</span><span class="params">(filename.c_str())</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Here are the contents of &quot;</span> &lt;&lt; filename &lt;&lt; <span class="string">&quot;:\n&quot;</span>;</span><br><span class="line">	<span class="type">char</span> ch;</span><br><span class="line">	<span class="keyword">while</span> (fin.<span class="built_in">get</span>(ch))</span><br><span class="line">		cout &lt;&lt; ch;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Done\n&quot;</span>;</span><br><span class="line">	fin.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//return 0;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="总结（主要记录遇到的问题）"><a href="#总结（主要记录遇到的问题）" class="headerlink" title="总结（主要记录遇到的问题）"></a>总结（主要记录遇到的问题）</h1><font color="#999AAA">

<p>1.想直接赋值字符串而不是字符(Solved)</p>
<blockquote>
<p>字符串常量可以作为初值赋给字符型数组，并用%s输出<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="type">char</span> strl[<span class="number">25</span>] = <span class="string">&quot;cser&quot;</span>;</span><br><span class="line">&gt;<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, strl);</span><br><span class="line">&gt;<span class="comment">//对于字符串型可以转化成字符数组，但是不能赋值给字符变量</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>2.用VS2019编译sanf无法通过，出现C4996错误。(Solved)</p>
<blockquote>
<p>在 Visual Studio 中关闭项目的警告：打开项目的 “属性页” 对话框。 选择 “配置属性” “ &gt; c/c + + &gt; 高级” 属性页。编辑 “禁用特定警告” 属性以添加 4996 。 选择 “确定” 以应用所做的更改。</p>
<p>3.浮点型的有效精度（？）<br>4.“四舍六入五成双”规则？<br>5.menset按字节赋值？<br>6.系统栈&amp;静态存储区？<br>7.正则表达式？<br>8.浮点数不总是精确的详细原因</p>
</blockquote>
</font></font></font>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">39</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
