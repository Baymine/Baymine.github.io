<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"baymine.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://baymine.github.io/page/5/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://baymine.github.io/page/5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://baymine.github.io/2021/01/02/Wireshark-Lab-Getting-Started/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/02/Wireshark-Lab-Getting-Started/" class="post-title-link" itemprop="url">Wireshark Lab:Getting Started</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-01-02 16:46:57" itemprop="dateCreated datePublished" datetime="2021-01-02T16:46:57+08:00">2021-01-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-08 19:39:26" itemprop="dateModified" datetime="2023-03-08T19:39:26+08:00">2023-03-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Wireshark-Lab-Getting-Started"><a href="#Wireshark-Lab-Getting-Started" class="headerlink" title="Wireshark Lab:Getting Started"></a>Wireshark Lab:Getting Started</h1><p><font color="#999AAA">《计算机网络自顶向下方法7e》实验</font></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><font color="#999AAA">第一次实验主要就是介绍Wireshark应该怎么用，还有大致讲了Wireshark的工作原理。</font></p>
<h1 id="一、How-Wireshark-Works"><a href="#一、How-Wireshark-Works" class="headerlink" title="一、How Wireshark Works?"></a>一、How Wireshark Works?</h1><p><img src="https://img-blog.csdnimg.cn/20201231213649334.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_12,color_FFFFFF,t_70" alt><br>包嗅探器（Packet Sniffer）<br>其本身不主动运行，只是观察应用发送和接收的数据包，并保存这些数据包的一个备份。</p>
<blockquote>
<p>嗅探（Sniffers）是一种黑客的窃听手段，一般是指使用嗅探器对数据流的数据截获与封包分析（Packet analysis）。</p>
</blockquote>
<p>包捕捉器：接受数据链路层的帧，因为在这一层，数据包是最完整的（发送来的数据报没有被解封装，发送的数据报在这一层完成了所有的封装）。<br>包分析器：能够识别数据包的协议，以便将各层的协议部分从下一层的数据报中分离出来。</p>
<font color="#999AAA">



<h1 id="二、Wireshark的界面介绍"><a href="#二、Wireshark的界面介绍" class="headerlink" title="二、Wireshark的界面介绍"></a>二、Wireshark的界面介绍</h1><p><img src="https://img-blog.csdnimg.cn/20210102162028414.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h1 id="三、实验过程"><a href="#三、实验过程" class="headerlink" title="三、实验过程"></a>三、实验过程</h1><p>i）运行Wireshark，然后在浏览器中访问<a target="_blank" rel="noopener" href="http://gaia.cs.umass.edu/wireshark-labs/INTRO-wireshark-file1.html">http://gaia.cs.umass.edu/wireshark-labs/INTRO-wireshark-file1.html</a><br>ii）停止Wireshak，在过滤器中输入http。<br><img src="https://img-blog.csdnimg.cn/20210102163534330.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>在对应层可以看到对应协议的一些信息，例如在IP层可以看到数据包的发送者和接收者的IP地址。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><font color="#999AAA">How long did it take from when the HTTP GET message was sent until the HTTP<br>OK reply was received?（Unsolved）</font></p>
</font>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://baymine.github.io/2020/12/31/%E3%80%8A%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%8B%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86C-C-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/31/%E3%80%8A%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%8B%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86C-C-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">《算法笔记》第一部分C/C++语言基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-31 21:30:57" itemprop="dateCreated datePublished" datetime="2020-12-31T21:30:57+08:00">2020-12-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-08 19:38:42" itemprop="dateModified" datetime="2023-03-08T19:38:42+08:00">2023-03-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="《算法笔记》的笔记"><a href="#《算法笔记》的笔记" class="headerlink" title="《算法笔记》的笔记"></a>《算法笔记》的笔记</h1><font color="#999AAA">第二章： C/C++快速入门


# 前言

<font color="#999AAA">在学习之前有一个小插曲，用vi命令打开.c文件的时候总是提示存在交换文件，这让我没有办法修改我的目标文件，经过查询相关资料，我发现只要将对应的交换文件删除就可以了，产生原因可能是因为在退出编辑模式之前退出文件了。应该是shift+double z，而不是crtl
    **具体的操作方法**：使用ls - al 命令查看文件夹目录，找到交换文件（文件后缀是.swp）然后就用 rm - 文件名 删掉相应的交换文件就可以了
    *PS：我发现当交换文件出现重名的时候，文件的拓展名会到发生变化（.swn 、.swo等）
    PPS：很久没有用我的Ubuntu了，很多的命令都忘记了，所以一些常用的命令需要在这里记下来，以便之后学习的时候复习。*
    vi/vim、cd、ls、mkdir 

</font>

<p>&lt;hr style=” border:solid; width:100px; height:1px;” color=#000000 size=1”&gt;<br>虽然之前学过C/C++但是担心自己有什么遗漏所以还是看了一遍，在这里主要记录的就是自己原先不是很熟悉的内容。</p>
<font color="#999AAA">


<h2 id="2-1-基本数据类型"><a href="#2-1-基本数据类型" class="headerlink" title="2.1 基本数据类型"></a>2.1 基本数据类型</h2><ol>
<li>cin和cout消耗的时间会比scanf和printf多得多。而且在同一个程序当中不应该同时使用cout和printf（会出现问题）</li>
<li>C++标准库中，stdio.h的推荐写法：cstdio（就是去掉后缀，然后在最前面加上c,eg:<math.h> —-&gt; \<cmath>）</cmath></math.h></li>
<li><strong>基本数据类型：</strong><br><font color="#999AAA"><br>i）整型：int  —-&gt;  32bit （10\^9以内使用）||  long long ——&gt; 64 bit(如果long long型赋大于2\^31-1的初值的时候，需要在初值后面加上LL，否则会编译错误)<br>ii)浮点型：（Mantissa：小数部分）<img src="https://img-blog.csdnimg.cn/20201231202429775.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="IEEE标准的浮点表示法"><br>由上图可以知道单精度float有效精度只有6~7位（具体原因之后补充），双精度浮点型double的有效精度为15~16位。书中的建议：（应该是单精度浮点型的精度在大多时候都不够用吧）</font></li>
</ol>
<blockquote>
<p>对于浮点型来说，只需记住一点，不要使用float，碰到浮点型的数据都应该使用double来存贮。</p>
<p><font color="#999AAA"><br>iii）字符型：字符在C语言中使用使用ASCII码统一编码的。（需要记住一点小写字母比大写字母的ASCII码值大32，0的ASCII码为48）<br>（还要记住几个常用的转义字符：\n代表换行,\0代表空字符，其ASCII码为0，\t代表Tab键）<br>这一部分总结来说就是%c会将整型数字转化成相应ASCII码所对应的值。<br>对于字符串型可以转化成字符数组，但是不能赋值给字符变量</font></p>
</blockquote>
<p>3.<strong>强制类型转换</strong></p>
<p><font color="#999AAA">格式：（新类型名）变量名</font></p>
<blockquote>
<p>如果在计算过程中需要类型转换，那么就不能等它算完再在赋值的时候转换</p>
</blockquote>
<p><strong>4.符号常量和const常量</strong></p>
<p><font color="#999AAA"><br>这是定义常量的两种方式（更加推荐后者）<br>格式：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> 标识符 常量<span class="comment">//注意这里最后是没有分号的</span></span></span><br><span class="line"><span class="type">const</span> 数据类型 变量 = 常量；</span><br></pre></td></tr></table></figure><br>宏定义（Macro definition）的陷阱：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAL(x) (x * 2 + 1)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>{</span><br><span class="line">	<span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="built_in">CAL</span> (a + <span class="number">1</span>));</span><br><span class="line">	<span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//输出：4</span></span><br><span class="line"><span class="comment">//因为宏定义只会将数据原封不动地带进去，实际上的运算过程为：a+1*2+1.</span></span><br><span class="line"><span class="comment">//所以在用宏定义的时候应该将变量全部用括号括起来</span></span><br></pre></td></tr></table></figure><br><strong>5.运算符</strong></font></p>
<p><font color="#999AAA"><br>i）算数运算符没有幂次运算符，<strong>^代表的是位异或</strong>（位运算符可以用来定义无穷大的数）<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实际上就是整型的上限</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = (<span class="number">1</span> &lt;&lt; <span class="number">30</span>) <span class="number">-1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3fffffff</span>;</span><br></pre></td></tr></table></figure><br>位运算符的使用技巧：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.判断两个数字是否异号，利用补码编码的符号位进行异或运算（同0异1）</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">-1</span>, j = <span class="number">1</span>;</span><br><span class="line">(i ^ j &lt; <span class="number">0</span>) = <span class="literal">true</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//2.将编码最后一个1转换成0，可用于求解统计二进制编码中1的个数和判断一个数是不是2的指数</span></span><br><span class="line"><span class="comment">//这个数减去一之后，会向从右开始的第一个数借一位，这使得这一位变成0，然后与运算，</span></span><br><span class="line"><span class="comment">//将不相同的位全部变成0，这样就去掉了最右边的哪一个1</span></span><br><span class="line">n &amp; (n<span class="number">-1</span>);<span class="comment">//可以用于统计1的个数，或者进行相应的运算</span></span><br><span class="line"><span class="comment">//统计一个数的二进制数中1的个数(汉明权重)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="type">uint32_t</span> n)</span></span>{</span><br><span class="line">	<span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(n != <span class="number">0</span>){</span><br><span class="line">		n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">		res++;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="comment">//判断一个数是否为2的指数：注意2的指数有一个特点，在二进制编码中只能有一个1</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="type">int</span> n)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(n &lt;= <span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> (n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></font></p>
<p><font color="#999AAA"><br>ii）条件运算符<br>格式：A ? B : C;</font></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用条件运算符+宏定义判断大小的结构</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br></pre></td></tr></table></figure>
<h2 id="2-2-顺序结构"><a href="#2-2-顺序结构" class="headerlink" title="2.2 顺序结构"></a>2.2 顺序结构</h2><h3 id="2-2-1-赋值语句"><a href="#2-2-1-赋值语句" class="headerlink" title="2.2.1 赋值语句"></a>2.2.1 赋值语句</h3><p>而如果要给多个变量赋<strong>同一个值</strong>，可以使用连续等号的方法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">n = m = <span class="number">5</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-2-2-输入-输出语句（scanf-printf）"><a href="#2-2-2-输入-输出语句（scanf-printf）" class="headerlink" title="2.2.2 输入/输出语句（scanf/printf）"></a>2.2.2 输入/输出语句（scanf/printf）</h3><p>1.scanf函数<br><img src="https://img-blog.csdnimg.cn/20210102212212410.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>注意到字符串类型不需要使用取址运算符，因为字符串类型相当于一个数组，数组名称代表第一个元素的地址。<br>另外，除了%c 外， scanf 对其他格式符（如%d）的输入是以空白符（即空格、 Tab ）为结束判断标志的<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">(<span class="type">void</span>)</span></span>{</span><br><span class="line">	<span class="type">int</span> a, a1;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;a1);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d %d"</span>, a, a1);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//input:1 2  output:1 2</span></span><br></pre></td></tr></table></figure><br>但是对于%c</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>{</span><br><span class="line">	<span class="type">int</span> a; <span class="type">char</span> c, str[<span class="number">10</span>];</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%c%s"</span>, &amp;a, &amp;c,str);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"a=%d, c=%c,str=%s"</span>, a, c, str);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//Input:1 2 3</span></span><br><span class="line">	<span class="comment">//Output:a = 1, c=, str = 2</span></span><br><span class="line">	<span class="comment">//可见空格也被当成一个字符了</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>scanf()的返回值：<br>输入数字，匹配%d,配置b的值成功，scanf返回成功配置数量1；<br>输入字母，不匹配%d,配置b的值失败，scanf返回成功配置数量0；<br>输入Ctrl+Z，scanf返回-1；</p>
<p>2.printf函数<br><img src="https://img-blog.csdnimg.cn/20210102212936302.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>这里注意一点：在scanf中double的格式符为%lf，而在printf中格式符为%f</strong></p>
<p>接下来介绍三种使用的输出格式：（m为一个具体的数字）</p>
<ol>
<li><strong>%md</strong>  可以使不足 位的 int 型变量以m位进行右对齐输出，其中高位用空格补齐。如果变量本身超过m位，则保持原样。</li>
<li><strong>%0md</strong> 和上面的类似，只不过是用0而不是空格</li>
<li><strong>%.mf</strong>  让浮点数保留m位小数输出，采用”四舍六入五成双“[4]的规则</li>
</ol>
<h3 id="2-2-3-getchar-amp-putchar"><a href="#2-2-3-getchar-amp-putchar" class="headerlink" title="2.2.3 getchar & putchar"></a>2.2.3 getchar &amp; putchar</h3><p>获取和输出一个字符，注意getchar（）是可以识别换行的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>{</span><br><span class="line">	<span class="type">char</span> c1, c2, c3;</span><br><span class="line">	c1 = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line">	c2 = <span class="built_in">getchar</span>();</span><br><span class="line">	c3 = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="built_in">putchar</span>(c1);</span><br><span class="line">	<span class="built_in">putchar</span>(c2);</span><br><span class="line">	<span class="built_in">putchar</span>(c3);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//Input:ab(&lt;Enter&gt;)c</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">a</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">c</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2-2-5-typedef"><a href="#2-2-5-typedef" class="headerlink" title="2.2.5 typedef"></a>2.2.5 typedef</h3><p>可以给复杂的数据类型起一个别名<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;<span class="comment">//之后就可以用LL代替long long了</span></span><br></pre></td></tr></table></figure></p>
<h3 id="2-2-6-常用的math函数"><a href="#2-2-6-常用的math函数" class="headerlink" title="2.2.6 常用的math函数"></a>2.2.6 常用的math函数</h3><p>需要#include<math.h></math.h></p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只能是括号中的类型（？）</span></span><br><span class="line"><span class="number">1.</span> fabs（<span class="type">double</span> x）————（<span class="type">float</span> absolute value）给<span class="type">double</span>型变量取绝对值</span><br><span class="line"><span class="number">2.</span> <span class="built_in">floor</span>(<span class="type">double</span> x) &amp; <span class="built_in">ceil</span>(<span class="type">double</span> x) ————（地板和天花板）向下和向上取整</span><br><span class="line"><span class="number">3.</span> <span class="built_in">pow</span>(<span class="type">double</span> r, <span class="type">double</span> p)————（幂函数：power function）返回  r^p</span><br><span class="line"><span class="number">4.</span> <span class="built_in">sqrt</span>(<span class="type">double</span> x) ————（Arithmetic square root）返回算数平方根</span><br><span class="line"><span class="number">5.</span> log（<span class="type">double</span> x） ————（Natural logarithm） 返回以自然对数为底数的对数值</span><br><span class="line"><span class="number">6.</span> <span class="built_in">sin</span>(<span class="type">double</span> x) 、<span class="built_in">cos</span>(<span class="type">double</span> x)、<span class="built_in">tan</span>(<span class="type">double</span> x) ————可以用来精确定义pi的值：acos（<span class="number">-1.0</span>）</span><br><span class="line"><span class="number">7.</span> <span class="built_in">asin</span>(<span class="type">double</span> x) 、<span class="built_in">acos</span>(<span class="type">double</span> x)、<span class="built_in">atan</span>(<span class="type">double</span> x) ————反三角函数</span><br><span class="line"><span class="number">8.</span> <span class="built_in">round</span>(<span class="type">double</span> x) ————（round：用整数表示的, 取整数的, 整数的）四舍五入取整</span><br></pre></td></tr></table></figure>
<p>C语言中没有对任意底数求对数的函数，因此必须使用换底公式来将不是以自然对数为底的对数转换为以e为底的对数，即 </p>
<script type="math/tex; mode=display">log_ab = log_eb/log_ea</script><p>注意：pow()可能导致错误的情况：</p>
<ol>
<li>如果==底数 x 为负数并且指数 y 不是整数==，将会导致 domain error 错误。</li>
<li>如果<u>底数 x 和指数 y 都是0</u>，可能会导致 domain error 错误，也可能没有；这跟库的实现有关。 </li>
<li>如果<u>底数 x 是 0，指数 y是负数</u>，可能会导致 domain error 或 pole error 错误，也可能没有；这跟库的实现有关。 </li>
<li>如果<u>返回值ret 太大或者太小</u>，将会导致 range error 错误。</li>
</ol>
<p>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/yuanbo_shaw/article/details/79511132">https://blog.csdn.net/yuanbo_shaw/article/details/79511132</a></p>
<h2 id="2-3-选择结构"><a href="#2-3-选择结构" class="headerlink" title="2.3 选择结构"></a>2.3 选择结构</h2><p>因为这部分的内容比较熟悉，就跳过了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式){</span><br><span class="line">	<span class="keyword">case</span> 表达式<span class="number">1</span>：<span class="comment">//相当于switch中的语句的结构，如果匹配，则执行之后的语句</span></span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> 表达式<span class="number">2</span>：</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	.........</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		....</span><br><span class="line"><span class="comment">//注意每个case语句之后是没有大括号的！</span></span><br><span class="line"><span class="comment">//break是用来结束当前switch语句的</span></span><br></pre></td></tr></table></figure>
<p>对于for语句，在C语言中是不允许定义变量的，但是在C++中可以（将代码文件保存为.cpp的格式即可）</p>
<h2 id="2-5-数组"><a href="#2-5-数组" class="headerlink" title="2.5 数组"></a>2.5 数组</h2><h3 id="2-5-1-一维数组"><a href="#2-5-1-一维数组" class="headerlink" title="2.5.1 一维数组"></a>2.5.1 一维数组</h3><ol>
<li>数组的大小必须是整型常量，不能是变量。但是可以自己申请空间以定义数组<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C</span></span><br><span class="line"><span class="type">int</span>* a = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>)*n);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"><span class="comment">//C++</span></span><br><span class="line"><span class="type">int</span>* a = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line"><span class="keyword">delete</span>[] a;</span><br><span class="line"><span class="comment">//释放内存~~~</span></span><br></pre></td></tr></table></figure></li>
<li>当数组没有被初始化值的时候，一般默认是赋值为0，但是有时候有可能被赋值为很大的随机数</li>
<li>给数组赋值的方法：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = {<span class="number">0</span>};<span class="comment">//这种方法只能用于将数组初始化为0</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = {<span class="number">-1</span>};<span class="comment">//-1 0 0 0 0  0 0....(测试环境VS2019)</span></span><br><span class="line"><span class="built_in">fill</span> (a, a + <span class="number">10</span>, <span class="number">-1</span>);<span class="comment">//初始化为-1，需要函数头algorithm和using namespace std;</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = {};<span class="comment">//初始化为0</span></span><br></pre></td></tr></table></figure>
<h3 id="2-5-2-冒泡排序"><a href="#2-5-2-冒泡排序" class="headerlink" title="2.5.2 冒泡排序"></a>2.5.2 冒泡排序</h3><p>本质上就是通过不断地交换减少数组中的逆序数对。在一遍遍历过程中，不断将较大的元素与相邻的元素进行交换。而最大的元素因为总是会比之后的元素更大，所以会被移到最后。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n)</span></span>{</span><br><span class="line">	<span class="type">int</span> sorted = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">while</span>(!sorted){</span><br><span class="line">		sorted = <span class="literal">true</span>;<span class="comment">//优化</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;=n;++i){</span><br><span class="line">			<span class="keyword">if</span>(a[i<span class="number">-1</span>] &gt; a[i]){</span><br><span class="line">				<span class="type">int</span> temp = a[i<span class="number">-1</span>];</span><br><span class="line">				a[i<span class="number">-1</span>] = a[i];</span><br><span class="line">				a[i] = temp;</span><br><span class="line">				sorted = <span class="literal">false</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<h3 id="2-5-3-二维数组"><a href="#2-5-3-二维数组" class="headerlink" title="2.5.3 二维数组"></a>2.5.3 二维数组</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二维数组想要作为参数传入函数中，需要确定二维数组的大小（至少是第二维需要确定）</span></span><br><span class="line"><span class="comment">//二维数组的赋值方式</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">5</span>][<span class="number">6</span>] = {{<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>},{<span class="number">8</span>,<span class="number">4</span>},{},{<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>}};<span class="comment">//剩余部分将会被赋值为0</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：当数组大小较大时（<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex;" xmlns="http://www.w3.org/2000/svg" width="3.25ex" height="2.005ex" role="img" focusable="false" viewbox="0 -864 1436.6 886"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"/></g><g data-mml-node="mn" transform="translate(1033,393.1) scale(0.707)"><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z"/></g></g></g></g></svg></mjx-container>数量级），需要将其定义在主函数外面，否则会使程序异常退出。</strong></p>
<p><font color="#999AAA">因为在函数内部申请的局部变量来自于系统栈，允许的空间较小；函数外部申请的全局变量来自静态存储区，允许申请的空间大。[6]</font></p>
<h3 id="2-5-4-memset函数"><a href="#2-5-4-memset函数" class="headerlink" title="2.5.4 memset函数"></a>2.5.4 memset函数</h3><p>menset函数可以给数组中的每一个函数赋值，但是menset使用的是<strong>按字节赋值的</strong>，这就是说一个整型变量的四个字节都会被赋相同的值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//memset（数组名，赋值，sizeof（数组名））；</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>{</span><br><span class="line">	<span class="type">int</span> A[<span class="number">5</span>] = { <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> };</span><br><span class="line">	<span class="built_in">memset</span>(a, <span class="number">1</span>, <span class="built_in">sizeof</span>(A));</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) {</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\t"</span>, a[i]);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="comment">//输出：16843009        16843009        16843009        16843009        16843009[5]</span></span><br><span class="line"><span class="comment">//赋值为0或者-1（0的二进制补码为全0，-1的二进制补码为全1）</span></span><br><span class="line"><span class="comment">//还可以用fill函数对数组进行赋值，但是执行速度较差。</span></span><br></pre></td></tr></table></figure>
<p>这里每个字节的意思是每个字节都设为1，注意不要与每个位赋值弄混淆。因为int是8字节所以，调用menset之后，数组中存储的数字为：0000 0001 0000 0001 0000 0001 0000 0001.（1字节为8位）</p>
<h3 id="2-5-5-字符数组"><a href="#2-5-5-字符数组" class="headerlink" title="2.5.5 字符数组"></a>2.5.5 字符数组</h3><p>输入：（scanf）<br>%c:输入单个字符（<strong>能识别空格与换行并将其输入</strong>）<br>%s:输入字符串并保存在字符数组中（以空格或者换行作为结束标志）<br>（gets）输入一行字符串，以\n作为结束标识。<br>（getchar）获取输入额一个字符<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str2 [<span class="number">5</span>][<span class="number">10</span>];<span class="comment">//定义</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i){</span><br><span class="line">	<span class="built_in">gets</span>(str2 [i]);<span class="comment">//运用这种方法将将输入的第一行赋值给数组的一整列</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">//输出格式类似，运用的函数为puts（与gets类似）</span></span><br></pre></td></tr></table></figure><br>注意：字符串是以‘\0’（ASCII 为 0）作为结尾的，所以存储的长度应该比实际存储长度大一。==还有当用gets或者scanf函数的输入时，会自动在字符串尾部加上‘\0’==，但是当用getchar函数（getchar每次只获取一个字符，所以’\0’作为单独字符需要调用额外的getchar函数）时，一定要在每个字符串后面加上‘否则会出现乱码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">15</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) {</span><br><span class="line">	str[i] = <span class="built_in">getchar</span>();</span><br><span class="line">}</span><br><span class="line"><span class="built_in">puts</span>(str);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//Input:T^T</span></span><br><span class="line"><span class="comment">//Output:T^T烫烫烫烫烫烫烫烫烫烫坍G醶?烫烫哎^v€麧</span></span><br><span class="line"><span class="comment">//应该是程序不知道什么地方是结束</span></span><br></pre></td></tr></table></figure></p>
<h3 id="2-5-6-string-h头文件"><a href="#2-5-6-string-h头文件" class="headerlink" title="2.5.6 string.h头文件"></a>2.5.6 string.h头文件</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line">...</span><br><span class="line"><span class="type">char</span> str1[<span class="number">10</span>], str2[<span class="number">10</span>];<span class="comment">//代表字符数组</span></span><br><span class="line"><span class="built_in">strlen</span>(str1)；<span class="comment">//得到第一个'\0'之前的字符个数</span></span><br><span class="line"><span class="built_in">strcmp</span>(str1,str2)；<span class="comment">//按照字典序比较（&lt;:返回负整数；=：返回0；&gt;：返回正整数）</span></span><br><span class="line"><span class="built_in">strcpy</span>(tr1,str2);<span class="comment">//str2复制给str1，包含'\0'</span></span><br><span class="line"><span class="built_in">strcat</span>(str1,str2);<span class="comment">//(concatenate：把事物连接起来)str2接到str1后面</span></span><br></pre></td></tr></table></figure>
<h3 id="2-5-7-sscanf-amp-sprintf"><a href="#2-5-7-sscanf-amp-sprintf" class="headerlink" title="2.5.7 sscanf & sprintf"></a>2.5.7 sscanf &amp; sprintf</h3><p>（都在stdio.h中）（<font color="#999AAA">补充）</font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个函数的主要用途就是将字符数组的内容转化成整型，放到整型变量中</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> str[<span class="number">100</span>] = <span class="string">"123"</span>;</span><br><span class="line"><span class="built_in">sscanf</span>(str, <span class="string">"%d"</span>, &amp;n);<span class="comment">//相当于将str作为输入对象（类似于scanf的屏幕输入）</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, n);</span><br><span class="line"></span><br><span class="line"><span class="comment">//就像printf一样，只不过是将其打印到了一个字符串数组中去了</span></span><br><span class="line"><span class="type">double</span> db = <span class="number">3.1415</span>;</span><br><span class="line"><span class="type">int</span> n1 = <span class="number">12</span>;</span><br><span class="line"><span class="type">char</span> str1[<span class="number">100</span>], str2[<span class="number">100</span>] = <span class="string">"good"</span>;</span><br><span class="line"><span class="built_in">sprintf</span>(str1, <span class="string">"%d:%.2f,%s"</span>, n1, db, str2);<span class="comment">//将这些元素输出给str1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"str1 = %s\n"</span>, str1);</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//    123</span></span><br><span class="line"><span class="comment">//    str1 = 12:3.14,good</span></span><br></pre></td></tr></table></figure>
<h2 id="2-6-函数"><a href="#2-6-函数" class="headerlink" title="2.6 函数"></a>2.6 函数</h2><p><font color="#999AAA">函数这部分也比较熟悉所以大部分省略了</font></p>
<p>1.数组可以作为参数，但是不允许作为返回类型出现</p>
<h2 id="2-7-指针"><a href="#2-7-指针" class="headerlink" title="2.7 指针"></a>2.7 指针</h2><p><img src="https://img-blog.csdnimg.cn/20210104124454965.png#pic_center" alt="在这里插入图片描述"></p>
<blockquote>
<p>指针（英语：Pointer），是编程语言中的一类数据类型及其对象或变量，用来表示或存储一个存储器地址，这个地址的值直接指向（points to）存在该地址的对象的值。</p>
</blockquote>
<p>相关的操作有：<br>&amp; ——取此变量的地址<br>* ———取该地址对应的值<br>指针变量的运算：加（减）代表的是指针指向前一个（后一个）存储块。看下面这个例子<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* x, <span class="type">int</span> y</span><br><span class="line">...</span><br><span class="line">x = &amp;y + <span class="number">3</span>    <span class="comment">//结果是x存储的地址是y的地址+12</span></span><br><span class="line"><span class="comment">//因为一个int类型占4个字节，所以这样总的来说就是向前移动了12个字节</span></span><br></pre></td></tr></table></figure></p>
<p> <strong>在函数中</strong>，想要修改传入的值，就需要传入该变量的地址（传址访问），包括要修改指针变量也是需要将指针变量所对应的地址传进去。<br> <strong>注意：常量是不能被使用取址运算符</strong>。因为引用的对象必须是可以修改的左值，也就是说放常量被引用的时候，它并不能被修改，所以索性就不能被引用了。<br> <strong>在数组中</strong>，一下两种检索方式是等价的<br> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&amp; big_array[ <span class="number">0</span> ] + <span class="function">i * <span class="title">sizeof</span><span class="params">( big_array[ <span class="number">0</span> ])</span></span>;<span class="comment">//对地址直接修改</span></span><br><span class="line">&amp;big_array[ i ] = big_array + i;<span class="comment">//通过指针运算</span></span><br></pre></td></tr></table></figure><br>（以下来自于《C程序语言设计2e》）</p>
<h3 id="Pointers-and-Arrays"><a href="#Pointers-and-Arrays" class="headerlink" title="Pointers and Arrays"></a>Pointers and Arrays</h3><p>注意事项：<br>1.(<em>ip)++这里的括号是必要的，因为单元运算符像\</em>、++结合，是从右向左运算的。（一个准则，当你遇到不熟悉的运算符的时候，将所有可能出错的地方全部加括号）</p>
<p>2.在传参的时候，想要修改传入参数，需要传入参数的地址，例如swap(&amp;a,&amp;b)；</p>
<p>3.int a[num],这是在申请大小为num的数组，索引范围为0 ~ num-1<br><img src="https://img-blog.csdnimg.cn/20210222070754753.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="指针和数组索引"></p>
<h2 id="2-8-结构体（struct）的使用"><a href="#2-8-结构体（struct）的使用" class="headerlink" title="2.8 结构体（struct）的使用"></a>2.8 结构体（struct）的使用</h2><h3 id="2-8-1-结构体的定义方式以及访问方式"><a href="#2-8-1-结构体的定义方式以及访问方式" class="headerlink" title="2.8.1 结构体的定义方式以及访问方式"></a>2.8.1 结构体的定义方式以及访问方式</h3><p><strong>注意在结构体内不能用定义的结构体定义变量，但是可以定义指针类型。</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结构体的定义方式</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">structname</span>{</span><br><span class="line">	<span class="type">int</span> a;<span class="comment">//成员变量</span></span><br><span class="line">	structname b;<span class="comment">//不能定义自己本身（会引起循环定义的问题）</span></span><br><span class="line">	structname* c;<span class="comment">//可以定义自身类型的指针变量</span></span><br><span class="line">}A;<span class="comment">//结构体变量，相当于 structname A；</span></span><br></pre></td></tr></table></figure><br>结构体内元素的访问方式：<br>点运算符：”.“非指针变量的访问方式；<br>指针运算符：”-&gt;“指针变量的访问方式。</p>
<h3 id="2-8-3-结构体初始化"><a href="#2-8-3-结构体初始化" class="headerlink" title="2.8.3 结构体初始化"></a>2.8.3 结构体初始化</h3><p>构造函数是用来初始化结构体的一种函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认情况下构造函数是不显示的</span></span><br><span class="line"><span class="comment">//但是想要自己重新定义构造函数，就不能不经初始化就定义结构体变量</span></span><br><span class="line"><span class="comment">//想要同时实现二者，需要像以下这样定义构造函数</span></span><br><span class="line"><span class="comment">//只要参数个数和类型不完全相同，就可以定义多个构造函数，以适应不同环境下的初始化</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">studentInfo</span>{</span><br><span class="line">	<span class="type">int</span> id;<span class="type">char</span> gender;</span><br><span class="line">	<span class="built_in">studentInfo</span>(){};<span class="comment">//默认的构造函数</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">studentInfo</span>(<span class="type">char</span> _gender){<span class="comment">//这里的变量名不能和外部的一样</span></span><br><span class="line">		gender = _gender;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">studentInfo</span>(<span class="type">int</span> _id, <span class="type">char</span> _gender){</span><br><span class="line">	id = _id;</span><br><span class="line">	gender = _gender;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"><span class="comment">//初始化方式</span></span><br><span class="line">studentInfo A;</span><br><span class="line">A = <span class="built_in">studentInfo</span>(<span class="number">2021</span>,<span class="string">"girl"</span>);<span class="comment">//调用构造函数初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//C++的另一种构造函数的方式</span></span><br><span class="line"><span class="built_in">studentInfo</span>(<span class="type">int</span> _id, <span class="type">char</span> _gender):<span class="built_in">id</span>(_id),<span class="built_in">gender</span>(_gender){};</span><br></pre></td></tr></table></figure></p>
<h2 id="2-9-补充内容"><a href="#2-9-补充内容" class="headerlink" title="2.9 补充内容"></a>2.9 补充内容</h2><h3 id="2-9-1-cin-与-cout"><a href="#2-9-1-cin-与-cout" class="headerlink" title="2.9.1 cin 与 cout"></a>2.9.1 cin 与 cout</h3><p>这两个输入输出函数虽然简洁（不用定义类型之类的）但是面对大量数据的时候，效率较低。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//"&gt;&gt;"可以看成数据流的方向</span></span><br><span class="line"><span class="comment">//多变量输入</span></span><br><span class="line">cin &gt;&gt; n &gt;&gt; db &gt;&gt; c &gt;&gt; str;</span><br><span class="line"><span class="comment">//多变量输出</span></span><br><span class="line">cout &lt;&lt; n &lt;&lt; <span class="string">"\n"</span> &lt;&lt; db &lt;&lt; endl;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="2-9-2-浮点数比较"><a href="#2-9-2-浮点数比较" class="headerlink" title="2.9.2 浮点数比较"></a>2.9.2 浮点数比较</h3><p>由于在计算机中采用有限位的二进制编码，因此浮点数在计算机中的存储并不总是精确的[8]。<br>在经过大量运算之后，浮点数的精度可能会发生变化，这就给比较操作（&gt;、&lt;、=）<br>产生了干扰。所以，我们定义一个极小数eps（通常取<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex;" xmlns="http://www.w3.org/2000/svg" width="4.495ex" height="2.005ex" role="img" focusable="false" viewbox="0 -864 1986.7 886"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"/></g><g data-mml-node="TeXAtom" transform="translate(1033,393.1) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mo"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(778,0)"><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z"/></g></g></g></g></g></svg></mjx-container>）,只要比较数落在特定的区间内（<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex;" xmlns="http://www.w3.org/2000/svg" width="5.014ex" height="1.946ex" role="img" focusable="false" viewbox="0 -666 2216 860"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="B1" d="M56 320T56 333T70 353H369V502Q369 651 371 655Q376 666 388 666Q402 666 405 654T409 596V500V353H707Q722 345 722 333Q722 320 707 313H409V40H707Q722 32 722 20T707 0H70Q56 7 56 20T70 40H369V313H70Q56 320 56 333Z"/></g><g data-mml-node="mi" transform="translate(778,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g><g data-mml-node="mi" transform="translate(1244,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/></g><g data-mml-node="mi" transform="translate(1713,0)"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/></g></g></g></svg></mjx-container>）即可。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用宏定义等于</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> esp = <span class="number">1e-8</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Equ(a,b) ((fabs((a)-(b)) &lt; (esp)))</span></span><br></pre></td></tr></table></figure><br>其他的比较运算符的所在区间如下图：<br><img src="https://img-blog.csdnimg.cn/20210105125223616.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>还有几点需要注意：</p>
<ol>
<li>经过大量的运算之后，一个变量存储的0可能是一个很小的负数，这时候使用sqrt函数就会报错，这时候就应该运用esp使变量保证在定义域内（*）</li>
<li>某些编译环境中，可能会输出-0.00.这是能将此输出放到字符串中，与“-0.00”比较，如果一致，那就加上esp修正这个值。</li>
</ol>
<h2 id="2-10-黑盒测试"><a href="#2-10-黑盒测试" class="headerlink" title="2.10 黑盒测试"></a>2.10 黑盒测试</h2><h1 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h1><h2 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h2><p>在定义数组之前，若数组大小未知，则需要对数组的空间进行申请<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一维数组</span></span><br><span class="line"><span class="comment">//动态分配，数组长度为m</span></span><br><span class="line"><span class="type">int</span> *array = <span class="keyword">new</span> <span class="type">int</span> [m];</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放内存</span></span><br><span class="line"><span class="keyword">delete</span>[] array; </span><br><span class="line"></span><br><span class="line"><span class="comment">//定义结构体动态数组并初始化</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Mystruct</span>{</span><br><span class="line">	<span class="type">int</span> a, b;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	Mystruct* structs = <span class="keyword">new</span> Mystruct[<span class="number">100</span>];</span><br><span class="line">	Mystruct initializer = {<span class="number">20</span>, <span class="number">30</span>};</span><br><span class="line">	<span class="built_in">fill</span>(structs, structs + <span class="number">100</span>,initializer);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="C语言的共生体"><a href="#C语言的共生体" class="headerlink" title="C语言的共生体"></a>C语言的共生体</h2><p>参考：<a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-unions.html">https://www.runoob.com/cprogramming/c-unions.html</a><br>共生体是一种能在相同的内存位置存储不同的数据类型的一种特殊的数据类型。在共生体中能定义很多的不同的成员变量，但是任何时候只能有一个成员带有值。这样做可以节省空间，可以应用于变量不会同时使用的情况。</p>
<blockquote>
<p>通信中的数据包会用到共用体:因为不知道对方会发一个什么包过来，用共用体的话就很简单了，定义几种格式的包，收到包之后就可以直接根据包的格式取出数据。</p>
</blockquote>
<h3 id="定义方式"><a href="#定义方式" class="headerlink" title="定义方式"></a>定义方式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> [<span class="keyword">union</span> <span class="title class_">tag</span>]</span><br><span class="line">{</span><br><span class="line">	member def;</span><br><span class="line">	menber def;</span><br><span class="line">	....</span><br><span class="line">}[<span class="function"><span class="keyword">union</span> <span class="title">variable</span><span class="params">(s)</span>]</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例:成员变量可以是自定义的结构类型</span></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">Data</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">float</span> f;</span><br><span class="line">	<span class="type">char</span> str[<span class="number">20</span>];</span><br><span class="line">}data;</span><br></pre></td></tr></table></figure>
<p>共用体占用的内存应足够存储最大数据类型成员。</p>
<h3 id="访问共生体成员"><a href="#访问共生体成员" class="headerlink" title="访问共生体成员"></a>访问共生体成员</h3><p>想要访问共生体成员需要使用点运算符。但是因为共生体所有的成员共用一个空间，所以在同一时间只能有一个成员变量能够拥有完整的赋值。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据损坏</span></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">Data</span> data;</span><br><span class="line"><span class="comment">//这样只有data.str能够拥有完成的数据</span></span><br><span class="line">data.i = <span class="number">10</span>;<span class="comment">//在后续的赋值过程中对应的内存被占用</span></span><br><span class="line">data.f = <span class="number">220.5</span>;</span><br><span class="line"><span class="built_in">strcopy</span>(data.str, <span class="string">"Union"</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>判断机器是大端机还是小端机<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">char</span> str;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">};</span><br><span class="line">data=<span class="number">0x01020304</span>;</span><br><span class="line"><span class="keyword">if</span>(str==<span class="number">0x01</span>)</span><br><span class="line">{</span><br><span class="line">    cout&lt;&lt; <span class="string">"此机器是大端！"</span>&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(str==<span class="number">0x04</span>){</span><br><span class="line">    cout&lt;&lt;<span class="string">"此机器是小端！"</span>&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span>{</span><br><span class="line">    cout &lt;&lt;<span class="string">" 暂无法判断此机器类型！"</span>&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<h2 id="C-位域"><a href="#C-位域" class="headerlink" title="C 位域"></a>C 位域</h2><p>C语言提供了一种更好的利用内存空间的方式。这种方式可以告诉编译器你只用这些字节<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> withValidated : <span class="number">1</span>;<span class="comment">//只用一位来存储该变量</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> heightValidated : <span class="number">1</span>;<span class="comment">//后面的数字表示数据占用的空间的大小</span></span><br><span class="line">}status;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> age : <span class="number">3</span>;</span><br><span class="line">}Age;</span><br><span class="line">Age,age = <span class="number">7</span>;<span class="comment">//能够表示的最大值</span></span><br><span class="line">Age.age = <span class="number">8</span>;<span class="comment">//输出的时候为0，溢出</span></span><br></pre></td></tr></table></figure></p>
<h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p>定义格式<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">name</span> {eleName1, eleName2,....};</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">DAY</span></span><br><span class="line">{</span><br><span class="line">	MON = <span class="number">1</span>,TUE,WED,THU,FRI,SAT,SUN</span><br><span class="line">}day;<span class="comment">//1,2,3,4,5,6,7</span></span><br><span class="line"><span class="comment">//enum DAY day;</span></span><br><span class="line"></span><br><span class="line">day = WED;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,day);<span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">seasons</span>{</span><br><span class="line">	spring, summer = <span class="number">3</span>, autumn, winter;</span><br><span class="line">};<span class="comment">//0，3，4，5</span></span><br></pre></td></tr></table></figure></p>
<h2 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h2><blockquote>
<p>在面向对象编程中，友元函数（friend function）是一个指定类（class）的“朋友”，该函数被允许访问该类中private、protected、public的资料成员。普通的函数并不能访问这些资料，然而宣告一个函数成为一个类的友元函数则被允许访问这些资料。<br>友元函数的宣告可以放在类声明的任何地方，不受访问限定关键字private、protected、public的限制。一个相似的概念是友谊类。<br>友谊关键字应该谨慎使用。如果一个拥有private或者protected成员的类，宣告过多的友元函数，可能会降低封装性的价值，也可能对整个设计框架产生影响。</p>
</blockquote>
<p>友元函数在类内部定义，可以在类外部定义。定义时在前面加上一个<code>friend</code>关键字<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">double</span> width;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">double</span> length;</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">printWidth</span><span class="params">(Box box)</span></span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printWidth</span><span class="params">(Box box)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	cout &lt;&lt; box.width &lt;&lt; endl;<span class="comment">//访问私密成员</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><blockquote>
<p>C++ 允许在同一作用域中的某个函数和运算符指定多个定义，分别称为函数重载和运算符重载。</p>
</blockquote>
<p>重载函数应该有不同的输入参数，这样能够编译器会根据不同的输入参数确定函数的定义，这个过程叫做<code>重载决策</code></p>
<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">printData</span></span><br><span class="line">{</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> i)</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"整数为: "</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">      }</span><br><span class="line"> </span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">double</span>  f)</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"浮点数为: "</span> &lt;&lt; f &lt;&lt; endl;</span><br><span class="line">      }</span><br><span class="line"> </span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">char</span> c[])</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"字符串为: "</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">      }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><blockquote>
<p>重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将两个Box类相加</span></span><br><span class="line">Box <span class="keyword">operator</span>+(<span class="type">const</span> Box&amp;, <span class="type">const</span> Box&amp;);</span><br><span class="line">Box box1, box2, box3;</span><br><span class="line">....</span><br><span class="line">box3 = box1 + box2;</span><br></pre></td></tr></table></figure>
<h2 id="文件（C-PrimerPlus）"><a href="#文件（C-PrimerPlus）" class="headerlink" title="文件（C++PrimerPlus）"></a>文件（C++PrimerPlus）</h2><p>文件本身就是一连串的存储在设备当中的字节。</p>
<h3 id="文件输入和输出"><a href="#文件输入和输出" class="headerlink" title="文件输入和输出"></a>文件输入和输出</h3><p>文件输出流的类包含在文件头fstream（fstream.h）中。下面是写入文件的步骤：</p>
<ol>
<li>创建一个ofstream对象</li>
<li>将这个对象链接到特定的文件</li>
<li>用输入输出流控制命令，对文件中的字节进行操作</li>
</ol>
<p>打开一个文件可以用open()方法<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建文件对象</span></span><br><span class="line">ofstream fout;</span><br><span class="line"><span class="comment">//将文件对象与特定文件相互链接</span></span><br><span class="line">fout.<span class="built_in">open</span>(<span class="string">"jar.txt"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者在定义对象的时候初始化链接</span></span><br><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"jar.txt"</span>)</span></span>;</span><br></pre></td></tr></table></figure><br>文件对象在输入或者输出的时候，会对每一个文件对象设立一个缓冲区，这个缓冲区存储输入的字节，当缓冲区满了以后，再将其中的内容转换到文件中。这种以缓冲区为单位一块块地传输字节，极大地提升了文件处理的速度。<br>读取文件中的内容<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ch;</span><br><span class="line">fin &gt;&gt; ch;</span><br><span class="line"><span class="type">char</span> buffer[<span class="number">80</span>];</span><br><span class="line">fin.<span class="built_in">getline</span>(buffer,<span class="number">80</span>);<span class="comment">//getline在string函数头中</span></span><br><span class="line">string line;</span><br><span class="line"><span class="built_in">getline</span>(fin, line);</span><br></pre></td></tr></table></figure><br>可以用close方法，断开文件对象与文件的链接，这样能够保证文件缓冲区就会被刷新，这样保证了文件会被实时更新。<br>下面是对文件的输入操作的实例。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fileio17_16</span><span class="params">()</span> </span>{</span><br><span class="line">	string filename;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"Enter name for new file: "</span>;</span><br><span class="line">	cin &gt;&gt; filename;</span><br><span class="line"></span><br><span class="line">	<span class="function">ofstream <span class="title">fout</span><span class="params">(filename.c_str())</span></span>;<span class="comment">//将C++的string类型转换成C语言的char数组，返回一个数组指针</span></span><br><span class="line"></span><br><span class="line">	fout &lt;&lt; <span class="string">"For your eyes only!\n"</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">"Enter your secret number:"</span>;</span><br><span class="line">	<span class="type">float</span> secret;</span><br><span class="line">	cin &gt;&gt; secret;</span><br><span class="line">	fout &lt;&lt; <span class="string">"Your secret number is "</span> &lt;&lt; secret &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	fout.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">	<span class="function">ifstream <span class="title">fin</span><span class="params">(filename.c_str())</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">"Here are the contents of "</span> &lt;&lt; filename &lt;&lt; <span class="string">":\n"</span>;</span><br><span class="line">	<span class="type">char</span> ch;</span><br><span class="line">	<span class="keyword">while</span> (fin.<span class="built_in">get</span>(ch))</span><br><span class="line">		cout &lt;&lt; ch;</span><br><span class="line">	cout &lt;&lt; <span class="string">"Done\n"</span>;</span><br><span class="line">	fin.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//return 0;</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<h1 id="总结（主要记录遇到的问题）"><a href="#总结（主要记录遇到的问题）" class="headerlink" title="总结（主要记录遇到的问题）"></a>总结（主要记录遇到的问题）</h1><font color="#999AAA">

<p>1.想直接赋值字符串而不是字符(Solved)</p>
<blockquote>
<p>字符串常量可以作为初值赋给字符型数组，并用%s输出<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="type">char</span> strl[<span class="number">25</span>] = <span class="string">"cser"</span>;</span><br><span class="line">&gt;<span class="built_in">printf</span>(<span class="string">"%s"</span>, strl);</span><br><span class="line">&gt;<span class="comment">//对于字符串型可以转化成字符数组，但是不能赋值给字符变量</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>2.用VS2019编译sanf无法通过，出现C4996错误。(Solved)</p>
<blockquote>
<p>在 Visual Studio 中关闭项目的警告：打开项目的 “属性页” 对话框。 选择 “配置属性” “ &gt; c/c + + &gt; 高级” 属性页。编辑 “禁用特定警告” 属性以添加 4996 。 选择 “确定” 以应用所做的更改。</p>
<p>3.浮点型的有效精度（？）<br>4.“四舍六入五成双”规则？<br>5.menset按字节赋值？<br>6.系统栈&amp;静态存储区？<br>7.正则表达式？<br>8.浮点数不总是精确的详细原因</p>
</blockquote>
</font></font></font>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">42</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
