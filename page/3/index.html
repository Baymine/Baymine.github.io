<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/14/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6%EF%BC%9A%EF%BC%88%E5%85%AD%EF%BC%89%E8%BF%9E%E7%BB%AD%E4%BC%98%E5%8C%96-Continuous-Optimization/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/14/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6%EF%BC%9A%EF%BC%88%E5%85%AD%EF%BC%89%E8%BF%9E%E7%BB%AD%E4%BC%98%E5%8C%96-Continuous-Optimization/" class="post-title-link" itemprop="url">机器学习中的数学：（六）连续优化(Continuous Optimization)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-05-14 10:40:52" itemprop="dateCreated datePublished" datetime="2021-05-14T10:40:52+08:00">2021-05-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-08 19:53:58" itemprop="dateModified" datetime="2023-03-08T19:53:58+08:00">2023-03-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>@[toc]<br><img src="https://img-blog.csdnimg.cn/20210511103327500.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在本节中，主要讨论连续优化的两个主要分支：<strong>约束优化</strong>（constrained optimization）、<strong>无约束优化</strong>（unconstrained optimization）。在求解一个线性方程的最优问题的时候，可以对方程进行求导，让后让求导得到的式子赋值为0，接触的结果就是<strong>驻点</strong>（Stationary points），想要知道这个驻点是极大值还是极小值，需要看在该点的二阶导数的的值的情况。由于五次方及以上的高次方程没有代数解（Abel–Ruffini theorem），所以在一些情况下无法求解出求导式子的解析解，这时候我们可以设置一个初始点，为了求解极小值，只需要让点顺着梯度的反方向运动即可，但是这有可能无法得到全局最优解，而是得到一个局部最优解。<br><img src="https://img-blog.csdnimg.cn/20210511105611284.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="梯度下降法（Optimization-Using-Gradient-Descent）"><a href="#梯度下降法（Optimization-Using-Gradient-Descent）" class="headerlink" title="梯度下降法（Optimization Using Gradient Descent）"></a>梯度下降法（Optimization Using Gradient Descent）</h1><p>梯度下降法是一种一阶优化算法，算法会不断更新参数的值，每一步的变化方向都是梯度的反方向（梯度方向的变化率最大。）<br>梯度下降的目标是：</p>
<script type="math/tex; mode=display">\min_xf(x)</script><p>其中，$f：\mathbb R^d \rightarrow \mathbb R$被称为<strong>目标函数</strong>（objective function）。在等高线图中，$f(x)$的变化方向与等高线相互垂直。</p>
<p>下面考虑多元方程$f(\boldsymbol x)$的优化问题。<br>$f(\boldsymbol x)$下降最快的方向就是梯度的反方向$-((\nabla f)(x_0))^\top$,所以：</p>
<script type="math/tex; mode=display">\boldsymbol{x}_{1}=\boldsymbol{x}_{0}-\gamma\left((\nabla f)\left(\boldsymbol{x}_{0}\right)\right)^{\top}</script><p>如果步长（step-size）$\gamma \ge 0$,则$f(x_1)\le f(x_0)$<br><img src="https://img-blog.csdnimg.cn/20210511154900473.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="步长-学习率（Step-size）"><a href="#步长-学习率（Step-size）" class="headerlink" title="步长/学习率（Step-size）"></a>步长/学习率（Step-size）</h2><p>梯度实际上只给出了变化的方向，但是变化的大小是由学习率和当前梯度的绝对值决定的。梯度的绝对值由函数决定，学习率就成为了能够人为控制的变量。假如学习率过小，则取得最优解的耗时会很长，反之可能会在最优解两端左右震荡，也会可能会花费很多的时间求得最优解，在极端情况下还可能会发散。<br>有一种称为<strong>自适应梯度法</strong>（Adaptive gradient methods）能够在每次迭代的时候更新学习率，以保证代价函数能够“平滑”地移动到最优解点。下面是几个经验性的结论：</p>
<ol>
<li>每一次迭代代价函数都应该减少，否则减小学习率并撤回当前操作。</li>
<li>当函数值接近最优解点的时候，函数的梯度减少，这个时候应该适当地增大学习率，以加快收敛速度。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20210511204854318.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我们可以使用梯度下降法求解线性方程：<br>求解一个线性方程$\boldsymbol A\boldsymbol x=\boldsymbol b$就是求解$\boldsymbol A\boldsymbol x-\boldsymbol b=\boldsymbol0$,近似地等价于求解当平方误差最小时，x的取值：（这里使用欧几里得范数）</p>
<script type="math/tex; mode=display">\min_x \|Ax-b\|^2=(Ax-b)^\top(Ax-b）</script><p>对上式对x进行求导：</p>
<script type="math/tex; mode=display">\nabla_x=2(Ax-b)^\top A</script><p>这时可以使用梯度下降法求解出x的值。<br>在求解线性方程的时候，梯度下降法的收敛速度由<strong>条件数</strong>（condition number）决定，即$\kappa = \frac{\sigma(A)<em>{max}}{\sigma(B)</em>{min}}$,条件数在本质上就是最大弯曲方向与最小弯曲方向的比率（在等高线图上）<br><strong>预处理子</strong>（preconditioner）<br>在求解$Ax-b=0$之前，先进行$P^{-1}(Ax-b) = 0$，使得$P^{-1}A$有一个更好的条件数，其中$P$称为<strong>预处理子</strong>。实际上就是对数量级进行匹配，使得等高线图上的图像更加均匀，这样能够加快收敛的速度。</p>
<h2 id="带动量项的梯度下降（Gradient-Descent-With-Momentum）"><a href="#带动量项的梯度下降（Gradient-Descent-With-Momentum）" class="headerlink" title="带动量项的梯度下降（Gradient Descent With Momentum）"></a>带动量项的梯度下降（Gradient Descent With Momentum）</h2><p>当函数数量级不是很匹配的时候（表现在等高线图上就是一个狭长的圆），这时候，在执行梯度下降算法的时候，可能会出现在最优解两端不断震荡的现象，为了改善这种情况，可以给梯度下降赋予一些记忆，这个记忆就是动量项，记录先前一次迭代发生的变化。</p>
<script type="math/tex; mode=display">
\begin{aligned}
\boldsymbol{x}_{i+1} &=\boldsymbol{x}_{i}-\gamma_{i}\left((\nabla f)\left(\boldsymbol{x}_{i}\right)\right)^{\top}+\alpha \Delta \boldsymbol{x}_{i} \\
\Delta \boldsymbol{x}_{i} &=\boldsymbol{x}_{i}-\boldsymbol{x}_{i-1}=\alpha \Delta \boldsymbol{x}_{i-1}-\gamma_{i-1}\left((\nabla f)\left(\boldsymbol{x}_{i-1}\right)\right)^{\top}
,\alpha\in[0,1]\end{aligned}</script><blockquote>
<p>the momentum term is useful since it averages out different noisy estimates of the gradient</p>
</blockquote>
<h2 id="随机梯度下降法（Stochastic-Gradient-Descent）"><a href="#随机梯度下降法（Stochastic-Gradient-Descent）" class="headerlink" title="随机梯度下降法（Stochastic Gradient Descent）"></a>随机梯度下降法（Stochastic Gradient Descent）</h2><p>由于在计算梯度的时候需要消耗很多的时间，所以可以考虑求解一个近似解即可并非需要求出精确解。<br>在运行梯度下降的时候，我们需要求解出所有代价函数最小时，所对应的参数的值：</p>
<script type="math/tex; mode=display">L(\boldsymbol\theta)=\sum^N_{n=1}L_n(\boldsymbol \theta)</script><p>我们还可以使用负对数似然的形式表示代价函数：</p>
<script type="math/tex; mode=display">L(\boldsymbol \theta)=-\sum_{n=1}^N\log p(y_n|\boldsymbol x_n,\boldsymbol \theta)</script><p>其中$x_n\in \mathbb R^{D}$为训练数据，$y_n$为训练目标，$\boldsymbol\theta$为回归模型的参数。<br>我们原先提到的梯度下降是批优化算法，也就是在更新的时候需要用到所有的训练数据。</p>
<script type="math/tex; mode=display">\boldsymbol \theta_{i+1}=\boldsymbol\theta_i-\gamma_i(\nabla L(\boldsymbol\theta_i))^{\top}=\boldsymbol\theta_i-\gamma_i\sum^N_{n=1}(\nabla L_n(\boldsymbol \theta_i))^\top</script><p>当需要训练大量数据或是对应的方程无法简单地表示出来的时候，利用上式进行梯度下降将会消耗大量的计算资源。<br>其实，我们并不一定需要使用所有的数据，我们可以使用其中的一部分数据进行训练，这种梯度下降法被称为<strong>小批量梯度下降法</strong>（mini-batch gradient descent）当样品的数量越多，所得到的梯度结果也就越接近真实值，但是也会消耗更多的计算资源。<br><img src="https://img-blog.csdnimg.cn/20210512152938563.png" alt="在这里插入图片描述"><br>如果我们能够保持每次的数据小批量，那么数据噪音也许会帮助梯度下降算法跳出局部最优解。</p>
<blockquote>
<p>在机器学习中有广泛应用，需要进行补充</p>
</blockquote>
<h2 id="约束优化和拉格朗格日乘数（Constrained-Optimization-and-Lagrange-Multipliers）"><a href="#约束优化和拉格朗格日乘数（Constrained-Optimization-and-Lagrange-Multipliers）" class="headerlink" title="约束优化和拉格朗格日乘数（Constrained Optimization and Lagrange Multipliers）"></a>约束优化和拉格朗格日乘数（Constrained Optimization and Lagrange Multipliers）</h2><p><img src="https://img-blog.csdnimg.cn/20210513100139619.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>约束优化问题可以表示为：</p>
<script type="math/tex; mode=display">\min_x f(x),s.t \ g_i(x)\le0 \ \ i = 1,\cdots,m</script><p>也可以使用<strong>指示函数</strong>（indicator function）指示函数可以表示一个元素是否在设定的集合内，用$\boldsymbol 1$表示：</p>
<script type="math/tex; mode=display">J(x)=f(x)+\sum^m_{i=1}\boldsymbol 1(g_i(x))</script><p>其中$\boldsymbol 1$是<strong>无限阶跃函数</strong>（infinite step function）：</p>
<script type="math/tex; mode=display">\boldsymbol 1(z)=\left\{\begin{aligned} &0\quad if\ z\le0 \\ &\infin \quad otherwise\end{aligned}\right.</script><p>也就是当取值在约束范围之外时，会有一个无穷大的惩罚。<br><strong>拉格朗日算子</strong></p>
<script type="math/tex; mode=display">
\begin{aligned}
\mathfrak{L}(\boldsymbol{x}, \boldsymbol{\lambda}) &=f(\boldsymbol{x})+\sum_{i=1}^{m} \lambda_{i} g_{i}(\boldsymbol{x}) 
&=f(\boldsymbol{x})+\boldsymbol{\lambda}^{\top} \boldsymbol{g}(\boldsymbol{x})
\end{aligned}</script><p>其中$\boldsymbol\lambda$为<strong>拉格朗日乘子</strong>（Lagrange multiplier）</p>
<p><strong>拉格朗日对偶</strong>（Lagrangian duality）<br>在优化问题中，对偶是将一个变量（原始变量，primal variables）装换成另一种变量（对偶变量，dual variables）x<img src="https://img-blog.csdnimg.cn/20210512154945578.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>对偶问题是看待一个优化问题的两个角度。对偶问题的解是原始问题的一个下界。</p>
</blockquote>
<p>原始问题（primal problem）：</p>
<script type="math/tex; mode=display">\min_x f(x), s.t. \quad g_i(x)\le 0\quad i = 1\cdots,m</script><p>对应的对偶问题（Lagrangian Dual Problem）:（将原始的问题转化成拉格朗日算子表示的式子）</p>
<script type="math/tex; mode=display">\max_{\lambda\in\mathbb R^m}\mathfrak D(\lambda),\quad s.t.\ \lambda\ge 0</script><p>这里$\lambda$为对偶变量（dual variable），$\mathfrak D = \min\limits_{x\in \mathbb R^d}\mathfrak L(x,\lambda)$</p>
<blockquote>
<p>这里需要补充几点知识：<br> 1.<strong>极大极小不等式</strong>（minimax inequality）<br>对于任意一个有两个参数的函数$\varphi(\boldsymbol x, \boldsymbol y)$有：</p>
<script type="math/tex; mode=display">\max _{\boldsymbol{y}} \min _{\boldsymbol{x}} \varphi(\boldsymbol{x}, \boldsymbol{y}) \leqslant \min _{\boldsymbol{x}} \max _{\boldsymbol{y}} \varphi(\boldsymbol{x}, \boldsymbol{y})</script><p>2.<strong>弱对偶</strong>（weak duality）<br>原始变量$\ge$对偶变量（duality gap$\ge 0$）</p>
<p>下面的内容需要想想为什么？（为什么是下界，二者的关系是什么？）</p>
</blockquote>
<p>当$\lambda\ge0$时，$\mathfrak L(x,\lambda)$是代价函数$J(x)$的下界。所以：</p>
<script type="math/tex; mode=display">J(x)=\max_{\lambda\ge0}\mathfrak L(x,\lambda)</script><p>同时我们原先先要解决的问题是找到J(x)最小时的参数的值所以：</p>
<script type="math/tex; mode=display">\min_{x\in\mathbb R^d}\max_{\lambda\ge0}\mathfrak L(x,\lambda)</script><p>再利用之前的极大极小不等式:</p>
<script type="math/tex; mode=display">\min _{x \in \mathbb{R}^{d}} \max _{\boldsymbol{\lambda} \geqslant 0} \mathfrak{L}(\boldsymbol{x}, \boldsymbol{\lambda}) \geqslant \max _{\boldsymbol{\lambda} \geqslant 0} \min _{\boldsymbol{x} \in \mathbb{R}^{d}} \mathfrak{L}(\boldsymbol{x}, \boldsymbol{\lambda}) .</script><p>这也是弱对偶。这时候将问题转化成了$\min\limits_{\boldsymbol x\in\mathbb{R}^{d}} \mathfrak{L}(\boldsymbol{x}, \boldsymbol{\lambda})$,一个无约束的问题。</p>
<blockquote>
<p><strong>等式约束</strong>（Equality Constraints）：</p>
<script type="math/tex; mode=display">
\begin{array}{rl}
\min _{\boldsymbol{x}} & f(\boldsymbol{x}) \\
\text { subject to } & g_{i}(\boldsymbol{x}) \leqslant 0 \quad \text { for all } \quad i=1, \ldots, m \\
& h_{j}(\boldsymbol{x})=0 \quad \text { for all } \quad j=1, \ldots, n .
\end{array}</script><p>其中的等式可以用两个不等式表示，然后就可以继续使用拉格朗日乘子了。（有一些需要补充）</p>
</blockquote>
<h1 id="凸优化（Convex-Optimization）"><a href="#凸优化（Convex-Optimization）" class="headerlink" title="凸优化（Convex Optimization）"></a>凸优化（Convex Optimization）</h1><blockquote>
<p>注意一点：国内外对凹凸函数的定义有时相反</p>
</blockquote>
<p>当一个优化问题的目标函数为凸函数，约束条件为凸集时，称这种问题为<strong>凸优化问题</strong><br><strong>强对偶</strong>（strong duality）：原始问题和对偶问题的最优化结果是一致的。<br><strong>凸集</strong>:<br>对于一个凸集（convex set）$\mathcal C$,如果任意的$x,y\in \mathcal C$和任意的标量$\theta(0\le \theta\le 1)$有：</p>
<script type="math/tex; mode=display">\theta x+(1-\theta)y\in \mathcal C</script><p>其实凸集就是凸函数上方形成的一个区域中的集合，如下图。</p>
<p><img src="https://img-blog.csdnimg.cn/20210512204554354.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>凸函数</strong>：<br>对于一个函数$f:\mathbb R^D\rightarrow\mathbb R$的定义域是一个凸集，那么如果这个函数是凸函数，则对于定义域内的所有的点$x、y$和标量$\theta(0\le\theta\le1)$有：（Jensen’s inequality）</p>
<script type="math/tex; mode=display">f(\theta x+(1-\theta)y)\le\theta f(x)+(1-\theta)f(y)</script><p>判断一个函数是否为凸函数，可以使用函数的梯度：</p>
<script type="math/tex; mode=display">f(y)\ge f(x)+\nabla_xf(x)^\top(y-x)</script><p>如果该函数二阶可导，则只要这个函数的海森矩阵是半正定的</p>
<h2 id="线性规划（Linear-Programming）"><a href="#线性规划（Linear-Programming）" class="headerlink" title="线性规划（Linear Programming）"></a>线性规划（Linear Programming）</h2><p>目标函数和约束函数都是线性方程的优化问题</p>
<script type="math/tex; mode=display">\min_{x\in\mathbb R^d}c^\top x,\ s.t.\ Ax\le b</script><p>其中：$A\in\mathbb R^{m\times d}\ 、b\in\mathbb R^m$这里包含d个变量和m个线性约束条件。<br>对应的拉格朗日式为：</p>
<script type="math/tex; mode=display">\mathfrak{L}(\boldsymbol{x}, \boldsymbol{\lambda})=\boldsymbol{c}^{\top} \boldsymbol{x}+\boldsymbol{\lambda}^{\top}(\boldsymbol{A} \boldsymbol{x})</script><p>将上式对x进行求导,并设为0，得：</p>
<script type="math/tex; mode=display">c+A^\top \lambda=0</script><p>所以对偶问题为：</p>
<script type="math/tex; mode=display">\max_{\lambda\in\mathbb R^m}-b^\top\lambda,\ \ s.t.\ c+A^\top\lambda=0, \lambda\ge 0</script><h2 id="二次规划问题（Quadratic-Programming）"><a href="#二次规划问题（Quadratic-Programming）" class="headerlink" title="二次规划问题（Quadratic Programming）"></a>二次规划问题（Quadratic Programming）</h2><script type="math/tex; mode=display">\min _{x\in \mathbb R^d}\frac{1}{2}x^\top Qx+c^\top\ \ s.t.\ Ax\le b</script><p>其中：$A\in \mathbb R^{m\times d},b\in\mathbb R^m,C\in \mathbb R^d$,其中$Q\in \mathbb R^{d\times d}$是一个正定矩阵，目标函数是凸函数（convex)。这种问题被称为二次规划问题。</p>
<p>利用拉格朗日乘子：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\mathfrak{L}(\boldsymbol{x}, \boldsymbol{\lambda}) &=\frac{1}{2} \boldsymbol{x}^{\top} \boldsymbol{Q} \boldsymbol{x}+\boldsymbol{c}^{\top} \boldsymbol{x}+\boldsymbol{\lambda}^{\top}(\boldsymbol{A} \boldsymbol{x}-\boldsymbol{b}) \\
&=\frac{1}{2} \boldsymbol{x}^{\top} \boldsymbol{Q} \boldsymbol{x}+\left(\boldsymbol{c}+\boldsymbol{A}^{\top} \boldsymbol{\lambda}\right)^{\top} \boldsymbol{x}-\boldsymbol{\lambda}^{\top} \boldsymbol{b}
\end{aligned}</script><p>对上式进行整理之后，对x进行求导得：</p>
<script type="math/tex; mode=display">Qx+(c+A^\top\lambda)=0</script><p>假设矩阵Q是可逆得：</p>
<script type="math/tex; mode=display">x= -Q^{-1}(c+A^\top\lambda)</script><p>将上面二式联立可以得到拉格朗日对偶：</p>
<script type="math/tex; mode=display">\mathfrak D(\lambda)=-\frac12(c+A^\top\lambda)^\top Q^{-1}(c+A^\top\lambda)-\lambda^\top b</script><p>对偶优化问题的解可以由下解得：</p>
<script type="math/tex; mode=display">\max_{\lambda\in\mathbb R^m}-\frac 12(c+A^\top\lambda)^\top Q^{-1}(c+A^\top\lambda)-\lambda^\top b,\ \ s.t. \lambda\ge 0</script><h2 id="Legendre-Fenchel变换和凸共轭-Legendre-Fenchel-Transform-and-Convex-Conjugate"><a href="#Legendre-Fenchel变换和凸共轭-Legendre-Fenchel-Transform-and-Convex-Conjugate" class="headerlink" title="Legendre-Fenchel变换和凸共轭(Legendre-Fenchel Transform and Convex Conjugate)"></a>Legendre-Fenchel变换和凸共轭(Legendre-Fenchel Transform and Convex Conjugate)</h2><p><strong>支撑超平面</strong>（supporting hyperplane）：<br>我们可以用一个支撑超平面来表示一个凸函数或者凸集，如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20210513105325318.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>凸共轭</strong><br>这也被称为Legendre-Fenchel变换<br><img src="https://img-blog.csdnimg.cn/20210514103705668.png" alt="在这里插入图片描述"><br>其中，$\sup$: supremum 上确界</p>
<p>A <strong>legendre transformation</strong> is a way of transforming a function of some variable into another function of another variable without losing any information.<br><img src="https://img-blog.csdnimg.cn/2021051316160014.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>上下确界</strong>：（子集中最大和最小的元素）<br><img src="https://img-blog.csdnimg.cn/20210513163634121.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210513163729844.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>这部分需要补充</p>
</blockquote>
<h1 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h1><h2 id="Legendre-Transform"><a href="#Legendre-Transform" class="headerlink" title="Legendre Transform"></a>Legendre Transform</h2><p>Sometime it’s much more easier to work with $f(s)$ instead of $f(x)$</p>
<script type="math/tex; mode=display">f(x)\rightarrow f(s),\quad f(s) = \frac{df(x)}{dx}</script><p><img src="https://img-blog.csdnimg.cn/20210514144200287.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Now we want a function which is changing with s, the function$f^<em>(s)$ is changing with $s$.And $f^</em>$actually equal to $-b$<br>And if we use the transformation again, we will regain the original function:</p>
<script type="math/tex; mode=display">\begin{aligned}f^{**}(x) & =x^\top s-f^*(s)\\
&=x^\top s-(s^\top x - f(x))\\
& =f(x) 
\end{aligned}</script><p>Why using it we can solve the optimistics problems pretty fast:</p>
<script type="math/tex; mode=display">f^*(0)=0^\top x_{\min}-f(x_{\min})\\f(x_{\min})=-f^*(0)</script>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6%EF%BC%9A%EF%BC%88%E4%BA%94%EF%BC%89%E6%A6%82%E7%8E%87%E4%B8%8E%E5%88%86%E5%B8%83-Probability-and-Distributions/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6%EF%BC%9A%EF%BC%88%E4%BA%94%EF%BC%89%E6%A6%82%E7%8E%87%E4%B8%8E%E5%88%86%E5%B8%83-Probability-and-Distributions/" class="post-title-link" itemprop="url">机器学习中的数学：（五）概率与分布(Probability and Distributions)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-05-11 10:17:57" itemprop="dateCreated datePublished" datetime="2021-05-11T10:17:57+08:00">2021-05-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-08 19:52:08" itemprop="dateModified" datetime="2023-03-08T19:52:08+08:00">2023-03-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="https://img-blog.csdnimg.cn/20210430095419335.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="概率空间的构造（Construction-of-a-Probability-Space）"><a href="#概率空间的构造（Construction-of-a-Probability-Space）" class="headerlink" title="概率空间的构造（Construction of a Probability Space）"></a>概率空间的构造（Construction of a Probability Space）</h1><h2 id="哲学问题（Philosophical-Issues）"><a href="#哲学问题（Philosophical-Issues）" class="headerlink" title="哲学问题（Philosophical Issues）"></a>哲学问题（Philosophical Issues）</h2><p>这部分是对概率的一个解释。概率论是推理系统的一个基础，个人理解就是推理实际上就是找到对某件事情的可能性最大的结果。这里引入了一个<strong>合理性</strong>（plausibility），并用数学标准描述出来了。</p>
<p>在机器学习中，对概率的解释有两种，一种是<strong>贝叶斯式</strong>（the Bayesian）还有一种是<strong>频率论</strong>（Frequentist）前者用概率描述事物的不确定性，后者用在特定时间段中发生特定事情的频率。</p>
<h2 id="概率和随机变量（Probability-and-Random-Variables）"><a href="#概率和随机变量（Probability-and-Random-Variables）" class="headerlink" title="概率和随机变量（Probability and Random Variables）"></a>概率和随机变量（Probability and Random Variables）</h2><p><strong>几个概念</strong>：<br><strong>样品空间$\Omega$</strong>（sample space）：一个实验可能出现的所有的结果的集合。<br><strong>事件空间$\mathcal A$</strong>(event space):样品空间的一个子集<br><strong>概率P</strong>（probability）：$P(A)$,一个事件$A\in \mathcal A$发生的概率。<br><strong>目标空间$\mathcal T$</strong>（target space）和<strong>随机变量$X$</strong>(random variable)：为了找到样品空间中我们关注的量，用一个函数$X: \Omega \rightarrow \mathcal{T}$， 其中,$X$称为<strong>随机变量</strong>。(对，随机变量实际上是一个函数)</p>
<blockquote>
<p>One way to understand the transformation of probability from events in $\Omega$ via the random variable X is to associate it with the probability of the pre-image of S<br>对于一个随机变量$X:\Omega\rightarrow\mathcal T$和目标空间的一个子集$S\subseteq\mathcal T$,则$X^{-1}(S)$为$S$经过$X$变换的原象（pre-image），也就是$\Omega$中的$X^{-1}(S)$经过$X$的变换之后得到$S$，所以有：</p>
<script type="math/tex; mode=display">P_X(S) = P(X\in S)=P(X^{-1}(S))=P(\{\ \omega\in\Omega:X(\omega)\in S \})</script><p>这里称$P_X$或者$P\circ X^{-1}$为随机变量$X$的<strong>分布</strong>（distribution）或者（law？）<br><img src="https://img-blog.csdnimg.cn/20210603100643197.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>个人理解，随机变量实际上就是对样品空间的某些特性的量化描述，例如，对于一个抛两个硬币的实验，在样品空间中，一次实验正面出现的次数可以为0、1、2，可以将这些数字对应到事件上去，这就是随机变量。</p>
</blockquote>
<h2 id="统计（Statistics）"><a href="#统计（Statistics）" class="headerlink" title="统计（Statistics）"></a>统计（Statistics）</h2><p>统计和概率往往是一起出现的，但是二者的侧重点不太一样，前者是关注找出能解释观察到的现象的内在过程。后者可以认为是一些过程的模型，其中的不确定性事件被随机变量存储下来，然后用概率的一些规律去弄清楚发生了什么。</p>
<h1 id="离散概率和连续概率（Discrete-and-Continuous-Probabilities）"><a href="#离散概率和连续概率（Discrete-and-Continuous-Probabilities）" class="headerlink" title="离散概率和连续概率（Discrete and Continuous Probabilities）"></a>离散概率和连续概率（Discrete and Continuous Probabilities）</h1><p>离散型概率和连续型概率的区别就是前者的目标空间是离散的，后者是连续的。也就是前者的随机变量是由一个个数组成，后者则是一个连续的区间。</p>
<h2 id="离散型概率（Discrete-Probabilities）"><a href="#离散型概率（Discrete-Probabilities）" class="headerlink" title="离散型概率（Discrete Probabilities）"></a>离散型概率（Discrete Probabilities）</h2><p><img src="https://img-blog.csdnimg.cn/20210503091939476.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>由上图可以得到几个概念：<br><strong>联合概率（joint probability）</strong>：两个事件的交集</p>
<script type="math/tex; mode=display">P(X =x_i, Y = y_i)=\frac {n_{ij}}{N}</script><p>也可以写成$p(x,y)$</p>
<p><strong>边际概率（marginal probability）</strong>：$P(X=x_i)=\frac {x_i}{N}$<br><strong>条件概率（conditional probability）</strong>：当一个事件发生时另一个事件发生的概率</p>
<script type="math/tex; mode=display">P(X=x_{i}|Y=y_{ij})=\frac {n_{ij}}{r_j}</script><h2 id="连续性概率（Continuous-Probabilities）"><a href="#连续性概率（Continuous-Probabilities）" class="headerlink" title="连续性概率（Continuous Probabilities）"></a>连续性概率（Continuous Probabilities）</h2><blockquote>
<p>没弄懂。<br><img src="https://img-blog.csdnimg.cn/20210503122706103.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>还有之后提到的，在连续空间中两个反直觉的问题：<br>1.$\mathcal A$ needs to be restricted to behave well under set complements, set intersections,and set unions<br>2.测量集合的大小。量度（measure）、集的势（cardinality）：集合中的元素的个数，当两个集合中的元素个数相等的时候，称为<strong>等势</strong><br>Sets that behave well under set operations and additionally have a topology are called a <strong>Borel $\sigma$-algebra</strong></p>
</blockquote>
<p><strong>概率密度函数</strong><br><img src="https://img-blog.csdnimg.cn/20210503123709953.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>用概率密度函数可以求解在给定区间当中的概率：</p>
<script type="math/tex; mode=display">P(a\le X\le)=\int^a_bf(x)dx</script><p>注意一点，一个点在连续函数中出现的概率为0，即在上式$a=b$时.</p>
<p><strong>累积分布函数</strong><br><img src="https://img-blog.csdnimg.cn/20210503124057824.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>即：</p>
<script type="math/tex; mode=display">F_X(x)=\int^{x_1}_{-\infin}\dots\int^{x_D}_{-\infin}f(z_1,\dots,z_D)dz_1\dots dz_D</script><h1 id="加法法则、乘法法则和贝叶斯定理（Sum-Rule-Product-Rule-and-Bayes’-Theorem）"><a href="#加法法则、乘法法则和贝叶斯定理（Sum-Rule-Product-Rule-and-Bayes’-Theorem）" class="headerlink" title="加法法则、乘法法则和贝叶斯定理（Sum Rule, Product Rule, and Bayes’ Theorem）"></a>加法法则、乘法法则和贝叶斯定理（Sum Rule, Product Rule, and Bayes’ Theorem）</h1><p><strong>加法法则</strong>：</p>
<script type="math/tex; mode=display">p(\boldsymbol{x})=\left\{\begin{array}{ll}\sum\limits_{\boldsymbol{y} \in \mathcal{Y}} p(\boldsymbol{x}, \boldsymbol{y}) & \text { if } \boldsymbol{y} \text { is discrete } \\ \\ \int_{\mathcal{Y}} p(\boldsymbol{x}, \boldsymbol{y}) \mathrm{d} \boldsymbol{y} & \text { if } \boldsymbol{y} \text { is continuous }\end{array}\right.</script><p>推广至多变量：<br>设$\boldsymbol x=[x_1,x_2,\dots,x_D]^\top$:</p>
<script type="math/tex; mode=display">p(x_i)=\int p(x_1,\dots,x_D)d\boldsymbol x_{\backslash i}</script><p>其中，$\boldsymbol x_{\backslash i}$,表示除了$i$以外的所有的元素。</p>
<p><strong>乘法法则</strong></p>
<script type="math/tex; mode=display">p(x,y) = p(y|x)p(x)\\ p(y,x)=p(x|y)p(y)</script><p>由于随机变量的顺序无关紧要，所以上面两个式子是等价的。</p>
<p><strong>贝叶斯公式</strong><br>这个公式可以由乘法法则推出。（也被称为<strong>概率逆</strong>（probabilistic inverse））<br><img src="https://img-blog.csdnimg.cn/20210504101801292.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>the posterior distribution is the quantity of interest as it <strong>encapsulates all available information from the prior and the data.</strong></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210504102446691.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>从上图中理解，最终的后验概率就是浅蓝色部分占蓝色部分的比例。<br>$p(x)$称为<strong>先验概率</strong>，描述的是一些已知事件发生的概率，之后的$p(y|x)$是在这些已知事件中y发生的概率称为<strong>似然概率</strong>，最后是y事件在整体中发生的概率。</p>
<blockquote>
<p>举一个例子，想要知道一群人当中脾气好的女生有多少，首先，女生在人群中比例可以看成先验概率$p(girl)$，而女生中脾气好的人数比例可以看成似然概率$p(good_temper|girl)$，所以$p(girl|good_temper)$的意思就是脾气好的人中女生的比例,但是男生中也有脾气好的，所以用女生脾气好的人数，除以所有脾气好的人数就是想要求得概率了。</p>
<p>似然函数(likelihood function):在该数据下，数据拟合的好坏,也就是在当前参数的情况下对真是数据的匹配情况。具体来说就是在给的那个参数的情况下，取得预期值的概率的大小，即$p(x|\theta)$</p>
</blockquote>
<p><strong>边际似然（marginal likelihood/evidence）</strong></p>
<script type="math/tex; mode=display">p(\boldsymbol y):= \int p(\boldsymbol y|\boldsymbol x)p(\boldsymbol x)d \boldsymbol x=\mathbb E_X[p(\boldsymbol y|\boldsymbol x)]</script><p>由上式可知，边际似然是与x相互独立的，这也被称为期望似然概率。</p>
<h1 id="摘要统计和独立性（Summary-Statistics-and-Independence）"><a href="#摘要统计和独立性（Summary-Statistics-and-Independence）" class="headerlink" title="摘要统计和独立性（Summary Statistics and Independence）"></a>摘要统计和独立性（Summary Statistics and Independence）</h1><blockquote>
<p>摘要统计:In descriptive statistics, summary statistics are used to summarize a set of observations, in order to communicate the largest amount of information as simply as possible<br>实际上就是用一种尽可能简洁得方式概括数据的信息。</p>
</blockquote>
<h2 id="均值和协方差（Means-and-Covariances）"><a href="#均值和协方差（Means-and-Covariances）" class="headerlink" title="均值和协方差（Means and Covariances）"></a>均值和协方差（Means and Covariances）</h2><p><strong>数学期望</strong>（Expected Value）</p>
<script type="math/tex; mode=display">g:\mathbb R\rightarrow\mathbb R,\quad X \sim p(x) \\ \\ \mathbb E_X[g(x)]=\left\{\begin{array}{ll}\int_\mathcal Xg(x)p(x)dx,\quad continuous\\ \\ \sum\limits_{x\in\mathcal X}g(x)p(x),\quad discrete\end{array}\right.</script><p>注意这个式子中是函数值乘以对应的概率值，所以最终得到的是映射值得概率均值。对于由有限个一维随机变量组成得数组：</p>
<script type="math/tex; mode=display">\mathbb{E}_{X}[g(\boldsymbol{x})]=\left[\begin{array}{c}\mathbb{E}_{X_{1}}\left[g\left(x_{1}\right)\right] \\ \vdots \\ \mathbb{E}_{X_{D}}\left[g\left(x_{D}\right)\right]\end{array}\right] \in \mathbb{R}^{D}</script><p>数学期望满足线性算子的性质：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\mathbb{E}_{X}[f(\boldsymbol{x})] &=\int f(\boldsymbol{x}) p(\boldsymbol{x}) \mathrm{d} \boldsymbol{x} \\
&=\int[a g(\boldsymbol{x})+b h(\boldsymbol{x})] p(\boldsymbol{x}) \mathrm{d} \boldsymbol{x} \\
&=a \int g(\boldsymbol{x}) p(\boldsymbol{x}) \mathrm{d} x+b \int h(\boldsymbol{x}) p(\boldsymbol{x}) \mathrm{d} \boldsymbol{x} \\
&=a \mathbb{E}_{X}[g(\boldsymbol{x})]+b \mathbb{E}_{X}[h(\boldsymbol{x})]
\end{aligned}</script><p><strong>均值</strong>（Mean）<br>均值是描述映射前的数据的情况。<br>对于一个随机变量$X$,其中$x\in \mathbb R^D$<br>所以：</p>
<script type="math/tex; mode=display">\mathbb E_X[\boldsymbol x]=\begin{bmatrix} \mathbb E_{X_1}[x_1]\\\vdots\\ \mathbb E_{X_D}[x_D]\end{bmatrix}\in R^D</script><script type="math/tex; mode=display">
\mathbb{E}_{X_{d}}\left[x_{d}\right]:=\left\{\begin{array}{ll}
\int_{\mathcal{X}} x_{d} p\left(x_{d}\right) \mathrm{d} x_{d} & \text { if } X \text { is a continuous random variable } \\
\sum_{x_{i} \in \mathcal{X}} x_{i} p\left(x_{d}=x_{i}\right) & \text { if } X \text { is a discrete random variable }
\end{array}\right.</script><p><strong>中位数</strong>（median）<br>一组数据中大于一遍数据而小于另一边数据的数字。中位数能够有效地应对异常值。<br><strong>众数</strong>（mode）<br>一组数据中出现次数最多的数字。在连续随机变量中，众数是概率密度最大的数。</p>
<blockquote>
<p>上面两种数字对于高维的数据的处理时比较麻烦? 在高维数据中，各个维度的数值大小判断准则不统一。</p>
</blockquote>
<p><strong>协方差</strong>（Covariance）：<br>协方差描述两个随机变量之间的相互关系（衡量两个随机变量的联合变化程度）。<br>单变量：</p>
<script type="math/tex; mode=display">X,Y\in \mathbb R</script><script type="math/tex; mode=display">\operatorname {Cov}_{X,Y}[x,y]:=\mathbb E_{X,Y}[(x-\mathbb E_X[x])(y-\mathbb E_Y[y])]</script><p>利用线性性质，可以将上式化简为：</p>
<script type="math/tex; mode=display">Cov[x,y]=\mathbb E[xy]-\mathbb E[x]\mathbb E[y]</script><p>随机变量与自己本身的协方差称为<strong>方差</strong>(variance)，即$Cov[x,x]$,表示为$\mathbb V_X[x]$,方差的开根之后的值称为<strong>标准偏差</strong>(standard deviation)，表示为$\sigma (x)$<br>多变量：<br><img src="https://img-blog.csdnimg.cn/20210504140000942.png" alt="在这里插入图片描述"><br>多变量方差：<br><img src="https://img-blog.csdnimg.cn/20210504140614642.png" alt="在这里插入图片描述"><br>设随机变量$X$有$x\in \mathbb R^D$, 均值向量$\mu\in \mathbb R^D$:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\mathbb{V}_{X}[\boldsymbol{x}] &=\operatorname{Cov}_{X}[\boldsymbol{x}, \boldsymbol{x}] \\
&=\mathbb{E}_{X}\left[(\boldsymbol{x}-\boldsymbol{\mu})(\boldsymbol{x}-\boldsymbol{\mu})^{\top}\right]=\mathbb{E}_{X}\left[\boldsymbol{x} \boldsymbol{x}^{\top}\right]-\mathbb{E}_{X}[\boldsymbol{x}] \mathbb{E}_{X}[\boldsymbol{x}]^{\top} \\
&=\left[\begin{array}{cccc}
\operatorname{Cov}\left[x_{1}, x_{1}\right] & \operatorname{Cov}\left[x_{1}, x_{2}\right] & \ldots & \operatorname{Cov}\left[x_{1}, x_{D}\right] \\
\operatorname{Cov}\left[x_{2}, x_{1}\right] & \operatorname{Cov}\left[x_{2}, x_{2}\right] & \ldots & \operatorname{Cov}\left[x_{2}, x_{D}\right] \\
\vdots & \vdots & \ddots & \vdots \\
\operatorname{Cov}\left[x_{D}, x_{1}\right] & \ldots & \ldots & \operatorname{Cov}\left[x_{D}, x_{D}\right]
\end{array}\right]
\end{aligned}</script><p>上式中的矩阵称为<strong>协方差矩阵</strong>（covariance matrix），是一个对称半正定的矩阵。它描述了数据的分散情况。对角线元素为<strong>方差</strong>，非对角线元素为<strong>互协方差</strong>（cross-covariance）</p>
<p><strong>相关性</strong>（Correlation）<br>相关性描述两个随机变量之间的关系。</p>
<script type="math/tex; mode=display">\operatorname{corr}[x, y]=\frac{\operatorname{Cov}[x, y]}{\sqrt{\mathbb{V}[x] \mathbb{V}[y]}} \in[-1,1] .</script><p>相关性矩阵就是标准化的随机变量（standardized random variables），即$x/\sigma(x)$</p>
<blockquote>
<p>If the greater values of one variable mainly correspond with the greater values of the other variable, and the same holds for the lesser values (that is, the variables tend to show similar behavior), the covariance is positive.</p>
</blockquote>
<p><strong>正相关与负相关</strong><br><img src="https://img-blog.csdnimg.cn/20210504141614657.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="样本均值和样本方差（Empirical-Means-and-Covariances）"><a href="#样本均值和样本方差（Empirical-Means-and-Covariances）" class="headerlink" title="样本均值和样本方差（Empirical Means and Covariances）"></a>样本均值和样本方差（Empirical Means and Covariances）</h2><p>就是将原先的数据中拿出一部分的数据作为样本，所得出的均值和方差。之前提到的均值是<strong>全平均值</strong>（population mean），方差也一样。<br><img src="https://img-blog.csdnimg.cn/20210504205458237.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="方差的三种表达式（Three-Expressions-for-the-Variance）"><a href="#方差的三种表达式（Three-Expressions-for-the-Variance）" class="headerlink" title="方差的三种表达式（Three Expressions for the Variance）"></a>方差的三种表达式（Three Expressions for the Variance）</h2><p>方差的定义式，但是因为需要求均值，又要将样本数逐一进行运算，所以需要将数据遍历两遍。</p>
<script type="math/tex; mode=display">\mathbb{V}_{X}[x]:=\mathbb{E}_{X}\left[(x-\mu)^{2}\right]</script><p>对原始式进行整理得到下式，这个式子称为<strong>变量的原始分数形式</strong>（raw-score formula for variance），虽然这样可以避免对数据进行两次的遍历，但是这在数值上是不稳定的（numerically unstable）。（？精度上的损失？）</p>
<script type="math/tex; mode=display">\mathbb{V}_{X}[x]=\mathbb{E}_{X}\left[x^{2}\right]-\left(\mathbb{E}_{X}[x]\right)^{2}</script><p>方差还可以理解成数据中的所有数字与其他所有的数字之间的差距的均值。</p>
<script type="math/tex; mode=display">\frac{1}{N^{2}} \sum_{i, j=1}^{N}\left(x_{i}-x_{j}\right)^{2}=2\left[\frac{1}{N} \sum_{i=1}^{N} x_{i}^{2}-\left(\frac{1}{N} \sum_{i=1}^{N} x_{i}\right)^{2}\right]</script><blockquote>
<p>there is an equivalence between the pairwise distances and the distances from the center of the set of points</p>
</blockquote>
<h2 id="随机变量的加法运算和变换（Sums-and-Transformations-of-Random-Variables）"><a href="#随机变量的加法运算和变换（Sums-and-Transformations-of-Random-Variables）" class="headerlink" title="随机变量的加法运算和变换（Sums and Transformations of Random Variables）"></a>随机变量的加法运算和变换（Sums and Transformations of Random Variables）</h2><p><img src="https://img-blog.csdnimg.cn/20210504210352549.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>对于一个仿射变换$\boldsymbol y=\boldsymbol A x+\boldsymbol b$有：<br><img src="https://img-blog.csdnimg.cn/20210504210531613.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2021050421054520.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="统计独立性-Statistical-Independence"><a href="#统计独立性-Statistical-Independence" class="headerlink" title="统计独立性(Statistical Independence)"></a>统计独立性(Statistical Independence)</h2><p><img src="https://img-blog.csdnimg.cn/20210504210704491.png" alt="在这里插入图片描述"><br>当两个随机变量相互独立的时候，有以下性质。注意最后一个，当两个随机变量相互独立的时候，相关性等于0，但是相关性等于0的时候，不能说明两个随机变量相互独立，因为独立性是描述随机变量之间的线性独立，假设随机变量之间的关系不是线性的，那么相关性为0时，不能说这两个随机变量是相互独立的。</p>
<p>两随机变量相互独立时的一些性质：</p>
<script type="math/tex; mode=display">\begin{aligned}&p(\boldsymbol{y} \mid \boldsymbol{x})=p(\boldsymbol{y})\\&p(\boldsymbol{x} \mid \boldsymbol{y})=p(\boldsymbol{x}) \\ &\mathbb{V}_{X, Y}[\boldsymbol{x}+\boldsymbol{y}]=\mathbb{V}_{X}[\boldsymbol{x}]+\mathbb{V}_{Y}[\boldsymbol{y}]\\ &\operatorname{Cov}_{X, Y}[\boldsymbol{x}, \boldsymbol{y}]=\mathbf{0}\end{aligned}</script><p><strong>独立均匀分布</strong>（independent and identically distributed (i.i.d.)）<br>变量之间相互独立，而且来自于同一个分布中。<br><strong>条件独立</strong>（conditional independence）<br><img src="https://img-blog.csdnimg.cn/20210504211427767.png" alt="在这里插入图片描述"><br>表示为$X \perp!!! \perp Y \mid Z$</p>
<script type="math/tex; mode=display">p(x,y)=p(y|x)p(x)\\ p(x,y|z)=p(x|z)p(y|z),\quad z\in \mathcal Z</script><p>利用第一个式子将第二个式子的左边展开，得到：</p>
<script type="math/tex; mode=display">p(\boldsymbol x, \boldsymbol y|z)=p(\boldsymbol x|\boldsymbol y,z)p(\boldsymbol y|z)</script><p>与原始比较可以得到：</p>
<script type="math/tex; mode=display">p(x|y,z)=p(x|z)</script><p>这样可以得到条件独立的另一个定义，也就是我们知道y这个结论，对最终的结果没有影响。原式可以理解为在z的条件下，两个随机变量相互独立。统计独立可以看成条件独立的一个特例：$X \perp!!! \perp Y \mid \not!0$</p>
<h2 id="随机变量的内积（Inner-Products-of-Random-Variables）"><a href="#随机变量的内积（Inner-Products-of-Random-Variables）" class="headerlink" title="随机变量的内积（Inner Products of Random Variables）"></a>随机变量的内积（Inner Products of Random Variables）</h2><p>两个相互独立的随机变量$X,Y$,有以下性质：($\operatorname {Cov}[x,y]=0$)</p>
<script type="math/tex; mode=display">\mathbb V(x+y)=\mathbb V(x)+\mathbb V(y)</script><p>由于方差是立方项，所以上式可以联想到勾股定理（the Pythagorean theorem）。<br>（每一个随机变量都可以看成一个向量空间中的向量）假设对于随机变量之间的内积的定义如下：</p>
<script type="math/tex; mode=display"><X,Y> :=\operatorname{Cov}[x,y]</script><p>根据这个定义可以得到随机变量的长度：</p>
<script type="math/tex; mode=display">\| X\| = \sqrt{\operatorname{Cov}[x,x]}=\sqrt{\mathbb V[x]}=\sigma[x]</script><p>这里可以看到，随机变量“越长”，所对应的数据就越分散。<br>还可以根据两向量的角度的定义得到：</p>
<script type="math/tex; mode=display">\cos \theta=\frac{\langle X, Y\rangle}{\|X\|\|Y\|}=\frac{\operatorname{Cov}[x, y]}{\sqrt{\mathbb{V}[x] \mathbb{V}[y]}}</script><p>可以看到两个随机变量的“夹角”的余弦值就是相关性（$\operatorname{corr}[x, y]=\frac{\operatorname{Cov}[x, y]}{\sqrt{\mathbb{V}[x] \mathbb{V}[y]}} \in[-1,1] .$）<br>所以，当两个随机变量相会垂直的时候，也就是$X\perp Y$时，$\langle X,Y\rangle=0$这时候二者的夹角为90°，对应的余弦值为0，也就是说这两个随机变量时不相关的。</p>
<blockquote>
<p>之后提到用用欧几里得距离去比较两个随机变量的分布并不是最好的方式，这里提到了一个领域<strong>信息几何</strong>（information geometry）一个新名词<strong>廖</strong>（manifold），这部分没有弄得很清楚，留到后续再进行深入学习</p>
</blockquote>
<h1 id="高斯分布（Gaussian-Distribution）"><a href="#高斯分布（Gaussian-Distribution）" class="headerlink" title="高斯分布（Gaussian Distribution）"></a>高斯分布（Gaussian Distribution）</h1><p>一维随机变量的高斯分布：</p>
<script type="math/tex; mode=display">p\left(x \mid \mu, \sigma^{2}\right)=\frac{1}{\sqrt{2 \pi \sigma^{2}}} \exp \left(-\frac{(x-\mu)^{2}}{2 \sigma^{2}}\right)</script><p>其中，$\mu$代表均值，$\sigma$代表随机变量得方差。<br>对于多元正态分布：（multivariate Gaussian distribution）（$\mu$为均值向量，$\Sigma$为协方差矩阵）</p>
<script type="math/tex; mode=display">p(\boldsymbol{x} \mid \boldsymbol{\mu}, \boldsymbol{\Sigma})=(2 \pi)^{-\frac{D}{2}}|\boldsymbol{\Sigma}|^{-\frac{1}{2}} \exp \left(-\frac{1}{2}(\boldsymbol{x}-\boldsymbol{\mu})^{\top} \boldsymbol{\Sigma}^{-1}(\boldsymbol{x}-\boldsymbol{\mu})\right)</script><p>其中，$x\in\mathbb R^D,p(x)=\mathcal N(x|\mu,\Sigma) \ or \ X \sim\mathcal N(\mu,\Sigma)$<br>在图像中表示为：<br><img src="https://img-blog.csdnimg.cn/20210506154612837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>当$\mu=0,\Sigma=I$时，将这种分布称为<strong>标准正态分布</strong>（standard normal distribution.）</p>
<h2 id="高斯分布的边际分布和条件分布仍旧是高斯分布（Marginals-and-Conditionals-of-Gaussians-are-Gaussians）"><a href="#高斯分布的边际分布和条件分布仍旧是高斯分布（Marginals-and-Conditionals-of-Gaussians-are-Gaussians）" class="headerlink" title="高斯分布的边际分布和条件分布仍旧是高斯分布（Marginals and Conditionals of Gaussians are Gaussians）"></a>高斯分布的边际分布和条件分布仍旧是高斯分布（Marginals and Conditionals of Gaussians are Gaussians）</h2><p>假设$X、Y$是多维随机变量，则有：</p>
<script type="math/tex; mode=display">p(\boldsymbol{x}, \boldsymbol{y})=\mathcal{N}\left(\left[\begin{array}{l}\boldsymbol{\mu}_{x} \\ \boldsymbol{\mu}_{y}\end{array}\right],\left[\begin{array}{ll}\boldsymbol{\Sigma}_{x x} & \boldsymbol{\Sigma}_{x y} \\ \boldsymbol{\Sigma}_{y x} & \boldsymbol{\Sigma}_{y y}\end{array}\right]\right)</script><p><img src="https://img-blog.csdnimg.cn/20210506161213884.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>$X、Y$的条件分布也是高斯分布：</p>
<script type="math/tex; mode=display">
\begin{aligned}
p(\boldsymbol{x} \mid \boldsymbol{y}) &=\mathcal{N}\left(\boldsymbol{\mu}_{x \mid y}, \boldsymbol{\Sigma}_{x \mid y}\right) \\
\boldsymbol{\mu}_{x \mid y} &=\boldsymbol{\mu}_{x}+\boldsymbol{\Sigma}_{x y} \boldsymbol{\Sigma}_{y y}^{-1}\left(\boldsymbol{y}-\boldsymbol{\mu}_{y}\right) \\
\boldsymbol{\Sigma}_{x \mid y} &=\Sigma_{x x}-\boldsymbol{\Sigma}_{x y} \boldsymbol{\Sigma}_{y y}^{-1} \Sigma_{y x}
\end{aligned}</script><p><img src="https://img-blog.csdnimg.cn/20210506161230791.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这是$x_2=-1$是的条件分布。</p>
<p>边际分布：</p>
<script type="math/tex; mode=display">p(\boldsymbol{x})=\int p(\boldsymbol{x}, \boldsymbol{y}) \mathrm{d} \boldsymbol{y}=\mathcal{N}\left(\boldsymbol{x} \mid \boldsymbol{\mu}_{x}, \boldsymbol{\Sigma}_{x x}\right)</script><p><img src="https://img-blog.csdnimg.cn/20210506161330927.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="高斯密度函数的乘积（Product-of-Gaussian-Densities）"><a href="#高斯密度函数的乘积（Product-of-Gaussian-Densities）" class="headerlink" title="高斯密度函数的乘积（Product of Gaussian Densities）"></a>高斯密度函数的乘积（Product of Gaussian Densities）</h2><p>对于两个高斯函数$\mathcal N(x|a,A),\mathcal N(x|b,B)$二者的乘积为：$c\mathcal N(x|c,C)$,其中：</p>
<script type="math/tex; mode=display">
\begin{aligned}
C &=\left(A^{-1}+B^{-1}\right)^{-1} \\
c &=C\left(A^{-1} a+B^{-1} b\right) \\
c &=(2 \pi)^{-\frac{D}{2}}|A+B|^{-\frac{1}{2}} \exp \left(-\frac{1}{2}(a-b)^{\top}(A+B)^{-1}(a-b)\right)
\end{aligned}</script><p>比例常数c也可以写成：</p>
<script type="math/tex; mode=display">c=\mathcal N(a|b,A+B)=\mathcal N(b|a,A+B)</script><h2 id="和运算和线性变换（Sums-and-Linear-Transformations）"><a href="#和运算和线性变换（Sums-and-Linear-Transformations）" class="headerlink" title="和运算和线性变换（Sums and Linear Transformations）"></a>和运算和线性变换（Sums and Linear Transformations）</h2><p>当两个相互独立的且满足高斯分布的随机变量相加所得到的随机变量也满足高斯分布：</p>
<script type="math/tex; mode=display">p(x+y)=\mathcal N(\mu_x+\mu_y,\Sigma_x+\Sigma_y)</script><p>$x+y$的均值和协方差可以通过之前提到的和运算的性质得到（$\mathbb E(x+y)=\mathbb E(x)+\mathbb E(y), etc$）</p>
<blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210506211126726.png" alt="在这里插入图片描述"></p>
</blockquote>
<p>可以利用加权和来定义一个满足高斯分布的随机变量（或者是将一个高斯随机变量分解成两个不同的满足高斯分布的随机变量）;</p>
<script type="math/tex; mode=display">p(x)=\alpha p_1(x)+(1-\alpha)p_2(x), \ 1\gt\alpha\gt0,(\mu_1,\sigma^2_1)\ne (\mu_2,\sigma_2^2)</script><p>其期望值和方差可以表示为：</p>
<script type="math/tex; mode=display">\mathbb{E}[x]=\alpha \mu_{1}+(1-\alpha) \mu_{2}</script><script type="math/tex; mode=display">\mathbb{V}[x]=\left[\alpha \sigma_{1}^{2}+(1-\alpha) \sigma_{2}^{2}\right]+\left(\left[\alpha \mu_{1}^{2}+(1-\alpha) \mu_{2}^{2}\right]-\left[\alpha \mu_{1}+(1-\alpha) \mu_{2}\right]^{2}\right)</script><blockquote>
<p>原书p202有上面两个公式的推导过程，主要就是利用写出对应的定义式，也就是积分的形式，然后再利用积分的性质进行变换。对于方差公式的推导，可以利用方差与期望值之间的关系式。</p>
</blockquote>
<p><strong>总方差定律</strong>（law of total variance）</p>
<script type="math/tex; mode=display">\mathbb V_X[x]=\mathbb E_Y[\mathbb V_X[x|y]]+\mathbb V_Y[\mathbb E_X[x|y]]</script><p>对一个满足高斯分布的随机变量进行线性变换，即对$X$进行线性变换$Ax$,可以得到一个均值为0，方差为$AA^\top$的高斯变量。而对一个高斯随机变量加上一个常数向量，高斯随机变量的均值会发生变化，但是方差会不发生变化。所以，对一个高斯变量进行线性变换或者是仿射变换都不会改变这个变量的分布。</p>
<p>假设随机变量Y为X经过线性变换之后的随机变量，即$Ax = y$,所以有：</p>
<script type="math/tex; mode=display">\mathbb E[y]=\mathbb E[Ax]=A\mathbb E[x]=A\mu</script><script type="math/tex; mode=display">\mathbb V[y]=\mathbb V[Ax]=A\mathbb V[x]A^\top=A\Sigma A^\top</script><p>所以随机变量Y可以写成：</p>
<script type="math/tex; mode=display">p(y) = \mathbb N(y|A\mu, A\Sigma A^\top)</script><p>假设一个随机变量的均值是另一个随机变量经过线性变换之后得到的。假设变换矩阵$\boldsymbol A\in\mathbb R^{M\times N}, M\ge N$高斯随机变量$Y$有$y\in\mathbb R^M$，其均值为$\boldsymbol A\boldsymbol x$，可以表示为：</p>
<script type="math/tex; mode=display">p(\boldsymbol y)=\mathcal N(y|\boldsymbol A\boldsymbol x,\Sigma)</script><p>当我们想要求$p(\boldsymbol x)$的概率分布时，可以由$X、Y$的关系得到$x=A^{-1}y$,但是当A不可逆时，这时候需要用到伪逆，所以有：</p>
<script type="math/tex; mode=display">x = (AA^\top)^{-1}A^\top y</script><p>所以随机变量$X$的分布为：</p>
<script type="math/tex; mode=display">p(\boldsymbol{x})=\mathcal{N}\left(\boldsymbol{x} \mid\left(\boldsymbol{A}^{\top} \boldsymbol{A}\right)^{-1} \boldsymbol{A}^{\top} \boldsymbol{y},\left(\boldsymbol{A}^{\top} \boldsymbol{A}\right)^{-1} \boldsymbol{A}^{\top} \boldsymbol{\Sigma} \boldsymbol{A}\left(\boldsymbol{A}^{\top} \boldsymbol{A}\right)^{-1}\right)</script><h2 id="从多元高斯分布中取样（Sampling-from-Multivariate-Gaussian-Distributions）"><a href="#从多元高斯分布中取样（Sampling-from-Multivariate-Gaussian-Distributions）" class="headerlink" title="从多元高斯分布中取样（Sampling from Multivariate Gaussian Distributions）"></a>从多元高斯分布中取样（Sampling from Multivariate Gaussian Distributions）</h2><blockquote>
<p>取样步骤：<br>In the case of a multivariate Gaussian, this process consists of three stages:<br><strong>first</strong>, we need a source of pseudo-random numbers that provide a uniform sample in the interval [0,1];<br><strong>second</strong>, we use a non-linear transformation such as the Box-Muller transform (Devroye, 1986) to obtain a sample from a univariate Gaussian;<br>and <strong>third</strong>, we collate a vector of these samples to obtain a sample from a multivariate standard normal $\mathcal N(0,I)$</p>
</blockquote>
<p>想要从多维高斯分布$\mathcal N(\mu,\Sigma)$中取样，可以利用高斯随机变量线性变换的性质：<br>假设：$x\sim \mathcal N(0,I)$，所以$y=Ax+\mu，where\ AA^\top=\Sigma.$<br>所以$y\sim\mathcal N(\mu,\Sigma)$。<br>其中一种选取A矩阵的方法是使用Cholesky decomposition将协方差矩阵进行拆分。（但是需要矩阵是对称且正定的）</p>
<h2 id="共轭及指数族（Conjugacy-and-the-Exponential-Family）"><a href="#共轭及指数族（Conjugacy-and-the-Exponential-Family）" class="headerlink" title="共轭及指数族（Conjugacy and the Exponential Family）"></a>共轭及指数族（Conjugacy and the Exponential Family）</h2><blockquote>
<p>对概率分布的目标：<br><img src="https://img-blog.csdnimg.cn/20210507153156614.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>指数族的优点：<br>provides the right balance of generality while retaining favorable computation and inference properties</p>
</blockquote>
<h3 id="伯努利分布（Bernoulli-distribution）"><a href="#伯努利分布（Bernoulli-distribution）" class="headerlink" title="伯努利分布（Bernoulli distribution）"></a>伯努利分布（Bernoulli distribution）</h3><p>一次伯努利试验的结果的概率：<br>对于一个二元随机变量$X$有$x\in{0,1}$,伯努利分布是由一个连续的参数$\mu\in[0,1]$控制，可以表示为$\operatorname{Ber}(\mu)$:</p>
<script type="math/tex; mode=display">\begin{aligned} &p(x|\mu)=\mu^x(1-\mu)^{1-x},\quad x\in\{0,1\}\\
&\mathbb E[x] = \mu,\\ &\mathbb V[x]=\mu(1-\mu)\end{aligned}</script><h3 id="二项式分布（Binomial-Distribution）"><a href="#二项式分布（Binomial-Distribution）" class="headerlink" title="二项式分布（Binomial Distribution）"></a>二项式分布（Binomial Distribution）</h3><p>多个伯努利实验的概率分布称为二项式分布：$\operatorname{Bin}(N,\mu)$（简单来说第一个参数就是实验次数，第二个参数就是成功概率）</p>
<script type="math/tex; mode=display">\begin{aligned} p(m \mid N, \mu) &=\left(\begin{array}{l}N \\ m\end{array}\right) \mu^{m}(1-\mu)^{N-m} \\ \mathbb{E}[m] &=N \mu \\ \mathbb{V}[m] &=N \mu(1-\mu) \end{aligned}</script><h3 id="贝塔分布（Beta-Distribution）"><a href="#贝塔分布（Beta-Distribution）" class="headerlink" title="贝塔分布（Beta Distribution）"></a>贝塔分布（Beta Distribution）</h3><p>$\operatorname{Beta}(\alpha, \beta)$:</p>
<script type="math/tex; mode=display">p(\mu|\alpha,\beta) = \frac{\Gamma(\alpha+\beta)}{\Gamma(\alpha)\Gamma(\beta)}\mu^{\alpha-1}(1-\mu)^{\beta-1}</script><script type="math/tex; mode=display">\mathbb E[\mu] = \frac{\alpha}{\alpha+\beta},\quad \mathbb V[\mu] = \frac{\alpha \beta}{(\alpha+\beta)^2(\alpha+\beta+1)}</script><p>其中$\Gamma(\cdot)$定义为：</p>
<script type="math/tex; mode=display">\begin{aligned}&\Gamma(t):=\int^\infin_0x^{t-1}\operatorname{exp}(-x)dx,\quad t\gt0 \\ &\Gamma(t+1)=t\Gamma(t)\end{aligned}</script><p>贝塔函数在不同参数下的图像：<br><img src="https://img-blog.csdnimg.cn/20210508155710268.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>贝塔分布在不同参数下的一些特性：<br><img src="https://img-blog.csdnimg.cn/20210508155742699.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="共轭（Conjugacy）"><a href="#共轭（Conjugacy）" class="headerlink" title="共轭（Conjugacy）"></a>共轭（Conjugacy）</h2><p><strong>先验分布</strong>(Prior distribution)<br>先验分布就是你在取得实验观测值以前对一个参数概率分布的 主观判断</p>
<blockquote>
<p>比如说你在抛硬币之前，你会认为取得正面的结果的 概率为为0.5<br>当我们假设实验结果的分布满足均匀分布，这时候称为<strong>无信息先验</strong>(noninformative prior) 也就是说（继续上面的例子）你抛的硬币是不均匀的，所以，取得正面的概率为$0\sim 1$上的均匀分布，也就是说什么可能都有。随着实验的进行，这样的分布会根据实验结果被不断矫正。<br><img src="https://img-blog.csdnimg.cn/20210509104732714.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210509104742674.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这样的概率分布也不会排除一些极端的结果的出现的概率。</p>
</blockquote>
<p><strong>共轭先验</strong>（Conjugacy Prior）<br><img src="https://img-blog.csdnimg.cn/202105081602298.png" alt="在这里插入图片描述"><br>也就是对于一个似然函数的先验分布假设成某种分布，然后利用贝叶斯公式计算出对应的后验分布，有时候得到的结果的形式是一致的。</p>
<p>假设一个二项式分布$x\sim\operatorname{Bin}(N, \mu)$:</p>
<script type="math/tex; mode=display">p(x|N,\mu)=\begin{pmatrix}N\\ x \end{pmatrix}\mu^x(1-\mu)^{N-x},\quad x=0,1,\dots,N</script><p>它的参数$\mu$满足$\mu \sim\operatorname{Beta}(\alpha,\beta)$:</p>
<script type="math/tex; mode=display">p(\mu|\alpha,\beta) = \frac{\Gamma(\alpha+\beta)}{\Gamma(\alpha)\Gamma(\beta)}\mu^{\alpha-1}(1-\mu)^{\beta-1}</script><p>假设在x=h时：</p>
<script type="math/tex; mode=display">\begin{aligned}p(\mu|x=h,N,\alpha,\beta)&\propto p(x|N,\mu)p(\mu|\alpha,\beta)\\ &\propto\mu^h(1-\mu)^{(N-h)}\mu^{\alpha-1}(1-\mu)^{\beta-1}\\ &= \mu^{h+\alpha-1}(1-\mu)^{(N-h)+\beta-1} \\ &\propto \operatorname{Beta}(h+\alpha,N-h+\beta)\end{aligned}</script><p>所以，可以注意到这里的先验概率分布与后验概率分布的形式是一致的。</p>
<blockquote>
<p><strong>似然函数</strong>（Likelihood Function）:$f(x|\theta)$说明我们观测的数据$x$是在参数$\theta$下得来的。</p>
</blockquote>
<p>由于利用贝叶斯公式计算后验概率分布的时候，需要用到边际分布概率，如果随机变量是连续的，那么就会需要使用积分，这会导致很多不必要的计算。有了先验共轭，我们就 不用计算复杂的含有积分的贝叶斯公式 便可得到后验分布。<br>以下是常见的似然函数的先验共轭：<br><img src="https://img-blog.csdnimg.cn/20210509154352999.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="充分统计量（Sufficient-Statistics）"><a href="#充分统计量（Sufficient-Statistics）" class="headerlink" title="充分统计量（Sufficient Statistics）"></a>充分统计量（Sufficient Statistics）</h2><blockquote>
<p>充分统计量：(一个通俗的比喻解释)<br>假设你辛辛苦苦收集的500个数据全都写在了一张纸上，这些数据是给你写论文用的，非常重要。突然有一天你的狗把你这张写满数据的纸吃掉了，这个时候假如你的数据满足正态分布，且你已经提前把这些数据的均值和方差记录在另外一张纸上了，那你的狗也没坏了什么大事——因为这两个充分统计量包含了这500个数据的所有有用信息。<br><strong>sufficient statistics</strong>: the idea that there are statistics that will <strong>contain all available information that can be inferred from data</strong> corresponding to the distribution under consideration. In other words, <strong>sufficient statistics carry all the information needed to make inference about the population</strong>, that is, they are the statistics that are sufficient to represent the distribution.(像是原先的数据中的一个子集，而这个子集可以代表所有的数据，也就是去除了一些冗余的数据)</p>
</blockquote>
<p>如果向量$\phi(x)$包含$\theta_0$的所有的信息，那么将$\phi(x)$称为<strong>充分统计量</strong></p>
<p>接下来是充分统计的严格定义：<br><img src="https://img-blog.csdnimg.cn/20210509155659498.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>也就是说一个概率密度函数可以被分解为独立于参数$\theta$的部分和虽然依赖于$\theta$但仅仅是依附于$\phi(x)$的（？）</p>
<blockquote>
<p>The more interesting case is that p(x | θ) is dependent only on φ(x) and not x itself. In this case, φ(x) is a sufficient statistic for θ.</p>
<p>Explain this<br><img src="https://img-blog.csdnimg.cn/20210509160841758.png" alt="在这里插入图片描述"></p>
</blockquote>
<p>所以我们可以使用一部分数据去估计样品分布的参数。</p>
<h2 id="指数族（Exponential-Family）"><a href="#指数族（Exponential-Family）" class="headerlink" title="指数族（Exponential Family）"></a>指数族（Exponential Family）</h2><p>对分布的三种可能的抽象：<br>1.已知分布类型和对应的参数<br>2.已知类型，需要根据数据确定此分布类型的参数值。<br>3.考虑这种分布的族。<br><strong>指数族</strong>：<br><img src="https://img-blog.csdnimg.cn/20210510141147420.png" alt="在这里插入图片描述"><br>这里的内积可以是任何类型的内积。但在本节当中只考虑点积。其中的$A(\boldsymbol \theta)$被称为<strong>对数分割函数</strong>（log-partition function）是一个归一化常数，能保证分布汇总成或者积分成1.<br>为了更好地理解指数族，我们可以将原先的定义式写成：</p>
<script type="math/tex; mode=display">p(\boldsymbol x|\boldsymbol\theta)\propto\operatorname{exp}(\boldsymbol\theta^\top\phi(\boldsymbol x))</script><p>这里的参数$\theta$被称为<strong>特征参数</strong>或<strong>自然参数</strong>（natural parameters）</p>
<blockquote>
<p>之后给出了几个例子，但是我还是没有形成深刻的理解（待补充）</p>
</blockquote>
<p>指数族能够很方便地找出分布的共轭对（conjugate pairs）<br>对于一个随机变量$X$属于指数族，所以有：</p>
<script type="math/tex; mode=display">p(\boldsymbol{x} \mid \boldsymbol{\theta})=h(\boldsymbol{x}) \exp (\langle\boldsymbol{\theta}, \boldsymbol{\phi}(\boldsymbol{x})\rangle-A(\boldsymbol{\theta}))</script><p>对于所有的指数族成员都能找到一个先验共轭</p>
<script type="math/tex; mode=display">p(\boldsymbol{\theta} \mid \gamma)=h_{c}(\boldsymbol{\theta}) \exp \left(\left\langle\left[\begin{array}{l}\gamma_{1} \\ \gamma_{2}\end{array}\right],\left[\begin{array}{c}\boldsymbol{\theta} \\ -A(\boldsymbol{\theta})\end{array}\right]\right\rangle-A_{c}(\boldsymbol{\gamma})\right)</script><p>其中,$\gamma=\begin{bmatrix}\gamma_1\ \gamma_2\end{bmatrix}$,其维度为$\operatorname{dim}(\theta)+1$。充分统计量的共轭先验为$\begin{bmatrix}\theta\-A(\theta)\end{bmatrix}$<br>这是指数族成员的共轭先验的一般形式，可以通过这个一般形式得到指数族成员的共轭先验。</p>
<h1 id="变量变换和逆变换（Change-of-Variables-Inverse-Transform）"><a href="#变量变换和逆变换（Change-of-Variables-Inverse-Transform）" class="headerlink" title="变量变换和逆变换（Change of Variables/Inverse Transform）"></a>变量变换和逆变换（Change of Variables/Inverse Transform）</h1><p>在本节当中，我们主要讨论当一个随机变量发生变换之后的分布情况。书中主要介绍了两种方法，一种是直接使用定义，另一种是使用<strong>换元法/变数法</strong>（change-of-variable approach）</p>
<blockquote>
<p>$X、Y$表示随机变量，$x、y$表示随机变量在目标空间$\mathcal T$中的取值。</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210510150955972.png" alt="在这里插入图片描述"><br>假设两个随机变量$X、Y$满足关系$y = U(X)$,根据定义可以得到$Y=y$的概率分布：</p>
<script type="math/tex; mode=display">P(Y=y) = P(U(X)=y)=P(X=U^{-1}(y))</script><h2 id="分布函数法（Distribution-Function-Technique）"><a href="#分布函数法（Distribution-Function-Technique）" class="headerlink" title="分布函数法（Distribution Function Technique）"></a>分布函数法（Distribution Function Technique）</h2><p>这里是使用累积分布函数，因为累积分布函数的对变量的偏导就是概率密度函数，所以在运算的过程中可以直接将两个随机变量之间的关系带入即可。<br><img src="https://img-blog.csdnimg.cn/2021051015160139.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>假设两个随机变量$Y:=U(X),X$的分布情况已知:</p>
<script type="math/tex; mode=display">F_Y(y) = P(Y\le y)=P(U(X)\le y)=P(X\le U^{-1}(y))=F_X(U^{-1}(y))</script><script type="math/tex; mode=display">f(y)=\frac{d}{dy}F_Y(y)</script><p><strong>概率积分变换</strong>（probability integral transform）<br><img src="https://img-blog.csdnimg.cn/20210510153852298.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>需要补充</p>
</blockquote>
<p>通过这个变换，我们可以先从均匀分布中抽样，然后对抽样样品做对应的变换之后得到目标分布中的抽样结果。同样也可以用于假设性检验，检查样品是否来源于某一种分布当中。</p>
<h2 id="换元（Change-of-Variables）"><a href="#换元（Change-of-Variables）" class="headerlink" title="换元（Change of Variables）"></a>换元（Change of Variables）</h2><script type="math/tex; mode=display">\int f(g(x))g'(x)dx=\int f(u)du, \quad u=g(x)</script><p>假设一个随机变量$X:x\in [a,b]$和可逆函数$U$,可以得到：$Y=U(X)$,由概率密度函数的定义：</p>
<script type="math/tex; mode=display">F_Y(y)=P(Y\le y)=P(U(X)\le y)</script><p>因为一个可逆函数在一个区间内严格单调，且如果原函数单调递增则反函数也会是单调递增的，所以：</p>
<script type="math/tex; mode=display">P(U(X)\le y)=P(U^{-1}(U(X))\le U^{-1}(y))=P(X\le U^{-1}(y))=\int^{U^{-1}(y)}_af(x)dx</script><p>所以可以得到随机变量Y的累积概率函数：</p>
<script type="math/tex; mode=display">F_Y(y)=\int^{U^{-1}(y)}_af(x)dx</script><p>因为概率密度函数可以通过累积概率函数求导得到，即：</p>
<script type="math/tex; mode=display">f(y) = \frac{d}{dy}F_y(y)=\frac{d}{dy}\int^{U^{-1}(y)}_af(x)dx</script><p>又因为：</p>
<script type="math/tex; mode=display">\int f\left(U^{-1}(y)\right) U^{-1^{\prime}}(y) \mathrm{d} y=\int f(x) \mathrm{d} x \quad where \quad x=U^{-1}(y)</script><p>将上面二式联立：</p>
<script type="math/tex; mode=display">f(y)=\frac{\mathrm{d}}{\mathrm{d} y} \int_{a}^{U^{-1}(y)} f_{x}\left(U^{-1}(y)\right) U^{-1^{\prime}}(y) \mathrm{d} y</script><p>注意到$f_x(U^{-1}(y))$不是y的函数，所以可以将上式的积分为：</p>
<script type="math/tex; mode=display">f(y)=f_{x}\left(U^{-1}(y)\right) \cdot\left(\frac{\mathrm{d}}{\mathrm{d} y} U^{-1}(y)\right)</script><p>为了让U为增函数和减函数的时候保持形式一致，可以将上式写成下面的形式：</p>
<script type="math/tex; mode=display">f(y)=f_{x}\left(U^{-1}(y)\right) \cdot\left|\frac{\mathrm{d}}{\mathrm{d} y} U^{-1}(y)\right|</script><p>上面这种方法称为<strong>换元法</strong>（change-of-variable technique）<br>其中，$|\frac{d}{dy}U^{-1}(y)|$描述了经过变换U之后的体积变化。</p>
<p>对于多元随机变量的也是类似的，但是由于绝对值不能用于多元方程，但是我们可以使用雅可比行列式代替原先的绝对值。由于雅可比矩阵是一个偏导矩阵，且其行列式的值不为0，所以雅可比矩阵的逆是存在的。<br><img src="https://img-blog.csdnimg.cn/20210511101438167.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/29/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6%EF%BC%9A%EF%BC%88%E5%9B%9B%EF%BC%89%E7%9F%A2%E9%87%8F%E7%A7%AF%E5%88%86-Vector-Calculus/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/29/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6%EF%BC%9A%EF%BC%88%E5%9B%9B%EF%BC%89%E7%9F%A2%E9%87%8F%E7%A7%AF%E5%88%86-Vector-Calculus/" class="post-title-link" itemprop="url">机器学习中的数学：（四）矢量积分(Vector Calculus)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-29 12:23:32" itemprop="dateCreated datePublished" datetime="2021-04-29T12:23:32+08:00">2021-04-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-08 19:51:32" itemprop="dateModified" datetime="2023-03-08T19:51:32+08:00">2023-03-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="https://img-blog.csdnimg.cn/20210426135218277.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="单变量微分（Differentiation-of-Univariate-Functions）"><a href="#单变量微分（Differentiation-of-Univariate-Functions）" class="headerlink" title="单变量微分（Differentiation of Univariate Functions）"></a>单变量微分（Differentiation of Univariate Functions）</h1><p><strong>定义：差商形式</strong><br><img src="https://img-blog.csdnimg.cn/20210426135329872.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210426135407699.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>正式定义</strong>：<br>割线在极限情况下变成切线<br><img src="https://img-blog.csdnimg.cn/20210426135447455.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>多项式导数的推导：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac{\mathrm{d} f}{\mathrm{~d} x} &=\lim _{h \rightarrow 0} \frac{f(x+h)-f(x)}{h}\\
&=\lim _{h \rightarrow 0} \frac{(x+h)^{n}-x^{n}}{h} \\
&=\lim _{h \rightarrow 0} \frac{\sum_{i=0}^{n}\left(\begin{array}{l}
n \\
i
\end{array}\right) x^{n-i} h^{i}-x^{n}}{h} .
\end{aligned}</script><p>由于$x^n=\left(\begin{array}{l}n \ 0 \end{array}\right)x^{n-0}h^0$所以：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac{\mathrm{d} f}{\mathrm{~d} x} &=\lim _{h \rightarrow 0} \frac{\sum_{i=1}^{n}\left(\begin{array}{l}
n \\
i
\end{array}\right) x^{n-i} h^{i}}{h} \\
&=\lim _{h \rightarrow 0} \sum_{i=1}^{n}\left(\begin{array}{c}
n \\
i
\end{array}\right) x^{n-i} h^{i-1} \\
&=\lim _{h \rightarrow 0}\left(\begin{array}{l}
n \\
1
\end{array}\right) x^{n-1}+\underbrace{\sum_{i=2}^{n}\left(\begin{array}{l}
n \\
i
\end{array}\right) x^{n-i} h^{i-1}}_{\rightarrow 0 \text { as } h \rightarrow 0} \\
&=\frac{n !}{1 !(n-1) !} x^{n-1}=n x^{n-1} .
\end{aligned}</script><p>其中的$\left(\begin{array}{l}<br>n \<br>i<br>\end{array}\right)$是组合数$C^i_n$</p>
</blockquote>
<h2 id="泰勒级数"><a href="#泰勒级数" class="headerlink" title="泰勒级数"></a>泰勒级数</h2><p><strong>泰勒多项式</strong>：<br><img src="https://img-blog.csdnimg.cn/20210426142816300.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>对于$f\in\mathcal C^{\infty}, f:\mathbb R \rightarrow \mathcal R,f$在$x_0$的泰勒级数为:($f\in\mathcal C^{\infty}$表示$f$无穷多项都是是连续可微的，？)<br><img src="https://img-blog.csdnimg.cn/20210427101504784.png" alt="在这里插入图片描述"><br>当$x_0=0$时.称为<strong>麦克劳林级数(Maclaurin series)</strong><br>泰勒多项式表示对函数的一种近似,多项式的项越多,与原先的函数就越接近.下图中，$T_i$表示$f$的$i$项展开。<br><img src="https://img-blog.csdnimg.cn/2021042710221633.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>三角函数的泰勒展开：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\cos (x) &=\sum_{k=0}^{\infty}(-1)^{k} \frac{1}{(2 k) !} x^{2 k}, \\
\sin (x) &=\sum_{k=0}^{\infty}(-1)^{k} \frac{1}{(2 k+1) !} x^{2 k+1} .
\end{aligned}</script></blockquote>
<p>泰勒级数实际上是一种特殊的幂级数：</p>
<script type="math/tex; mode=display">f(x)=\sum^\infty_{k=0}a_k(x-c)^k,\quad 幂级数</script><p>一些求导法则：<br><img src="https://img-blog.csdnimg.cn/20210427102600815.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="偏导数和梯度（Partial-Differentiation-and-Gradients）"><a href="#偏导数和梯度（Partial-Differentiation-and-Gradients）" class="headerlink" title="偏导数和梯度（Partial Differentiation and Gradients）"></a>偏导数和梯度（Partial Differentiation and Gradients）</h1><p>偏导数定义：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac{\partial f}{\partial x_{1}} &=\lim _{h \rightarrow 0} \frac{f\left(x_{1}+h, x_{2}, \ldots, x_{n}\right)-f(x)}{h} \\
& \vdots \\
\frac{\partial f}{\partial x_{n}} &=\lim _{h \rightarrow 0} \frac{f\left(x_{1}, \ldots, x_{n-1}, x_{n}+h\right)-f(\boldsymbol{x})}{h}
\end{aligned}</script><p>可以将函数对所有变量的偏导数写成一个行向量：</p>
<script type="math/tex; mode=display">
\nabla_{\boldsymbol{x}} f=\operatorname{grad} f=\frac{\mathrm{d} f}{\mathrm{~d} \boldsymbol{x}}=\left[\begin{array}{llll}
\frac{\partial f(\boldsymbol{x})}{\partial x_{1}} & \frac{\partial f(\boldsymbol{x})}{\partial x_{2}} & \cdots & \frac{\partial f(\boldsymbol{x})}{\partial x_{n}}
\end{array}\right] \in \mathbb{R}^{1 \times n}</script><p>这个式子被称为$f$的<strong>梯度</strong>或者<strong>雅可比矩阵</strong>（Jacobian）。<br>对于一个多变量函数的偏导数（$f=(x_1,x_2),x_1=x_1(s，t),x_2=x_2(s,t)$）可以写成矩阵乘法的形式：</p>
<script type="math/tex; mode=display">
\frac{\mathrm{d} f}{\mathrm{~d}(s, t)}=\frac{\partial f}{\partial \boldsymbol{x}} \frac{\partial \boldsymbol{x}}{\partial(s, t)}=\underbrace{\left[\frac{\partial f}{\partial x_{1}} \quad \frac{\partial f}{\partial x_{2}}\right]}_{=\frac{\partial f}{\partial \boldsymbol{x}}} \underbrace{\left[\begin{array}{cc}
\frac{\partial x_{1}}{\partial s} & \frac{\partial x_{1}}{\partial t} \\
\frac{\partial x_{2}}{\partial s} & \frac{\partial x_{2}}{\partial t}
\end{array}\right]}_{=\frac{\partial \boldsymbol{x}}{\partial(s, t)}} .</script><blockquote>
<p>为了检验梯度计算结果的正确行，可以采用<strong>梯度验证</strong>（Gradient checking）的方式进行检验：<br>这里用到了<strong>有限差分法</strong>（Finite difference method，FDM）：FDM are one of the most common approaches to the numerical solution of PDE（partial differential equations）, along with finite element methods.<br>就是将连续函数离散化。</p>
<blockquote>
<p>FDM的基本原理就是利用一个很小的数$\epsilon(10^{-4})$，判断自变量在这个范围中变化时对应的函数值的变化情况是否与梯度相似。</p>
<script type="math/tex; mode=display">\frac{d}{d\theta}J(\theta)\approx \frac{J(\theta + \epsilon)-J(\theta-\epsilon)}{2\epsilon}, \quad \epsilon\rightarrow 0</script></blockquote>
</blockquote>
<h1 id="向量值函数的梯度（Gradients-of-Vector-Valued-Functions）"><a href="#向量值函数的梯度（Gradients-of-Vector-Valued-Functions）" class="headerlink" title="向量值函数的梯度（Gradients of Vector-Valued Functions）"></a>向量值函数的梯度（Gradients of Vector-Valued Functions）</h1><p><img src="https://img-blog.csdnimg.cn/20210427133447332.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这样，$\boldsymbol f$就将原先的$\boldsymbol x \in \mathbb R^n$映射成$\mathbb R^m$,对于每一个$\boldsymbol f_i：\mathbb R^n\rightarrow\mathbb R$,也就是将原先的n维自变量映射成了一个实数。<br>所以：</p>
<script type="math/tex; mode=display">\frac{\partial\boldsymbol f(x)}{\partial x_i}=\left[\begin{array}{cc}\frac{\partial f_1(x)}{\partial x_i}\\\vdots\\ \frac{\partial f_m(x)}{\partial x_i} \end{array}\right]\in \mathbb R^m</script><p>而一个函数对一个列向量的映射，也就是之前提到梯度，可以写成：</p>
<script type="math/tex; mode=display">
\nabla_{\boldsymbol{x}} f=\operatorname{grad} f=\frac{\mathrm{d} f}{\mathrm{~d} \boldsymbol{x}}=\left[\begin{array}{llll}
\frac{\partial f(\boldsymbol{x})}{\partial x_{1}} & \frac{\partial f(\boldsymbol{x})}{\partial x_{2}} & \cdots & \frac{\partial f(\boldsymbol{x})}{\partial x_{n}}
\end{array}\right] \in \mathbb{R}^{1 \times n}</script><p>代入上式，得到向量值方程的一阶偏导数：</p>
<script type="math/tex; mode=display">
\begin{aligned}
J &=\nabla_{x} f=\frac{\mathrm{d} f(x)}{\mathrm{d} x}=\left[\begin{array}{ccc}
\frac{\partial f(x)}{\partial x_{1}} & \cdots & \frac{\partial f(x)}{\partial x_{n}}
\end{array}\right] \\
&=\left[\begin{array}{ccc}
\frac{\partial f_{1}(x)}{\partial x_{1}} & \cdots & \frac{\partial f_{1}(x)}{\partial x_{n}} \\
\vdots & & \vdots \\
\frac{\partial f_{m}(x)}{\partial x_{1}} & \cdots & \frac{\partial f_{m}(x)}{\partial x_{n}}
\end{array}\right] \\
x &=\left[\begin{array}{c}
x_{1} \\
\vdots \\
x_{n}
\end{array}\right], \quad J(i, j)=\frac{\partial f_{i}}{\partial x_{j}} .
\end{aligned}</script><p>$\boldsymbol f:\mathbb R^n\rightarrow\mathbb R^m$的一阶偏导数称为<strong>雅可比矩阵</strong>。<br>雅可比矩阵用于求解映射之后图形的<strong>比例因子</strong>（scaling factor）<br><img src="https://img-blog.csdnimg.cn/20210427140052382.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>想要找到比例因子，可以找出对应的变换矩阵，这个矩阵的行列式的绝对值就是面积变化的比例。但是这个适用于线性变换，当面对非线性变换的时候，需要采取另一种策略。<br>想要知道当$x$变化的时候$f(x)$的变化情况，我们可以使用偏导数得到变化信息。所以，雅可比矩阵可以表示相对应的变换矩阵。</p>
<blockquote>
<p>非线性的情况时，采用逼近的方式获得比例因子<br><img src="https://img-blog.csdnimg.cn/20210427195823520.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</blockquote>
<p>向量和对应的映射所处的维度与偏导数的关系：<br><img src="https://img-blog.csdnimg.cn/20210427200004258.png" alt="在这里插入图片描述"></p>
<h1 id="矩阵梯度（Gradients-of-Matrices）"><a href="#矩阵梯度（Gradients-of-Matrices）" class="headerlink" title="矩阵梯度（Gradients of Matrices）"></a>矩阵梯度（Gradients of Matrices）</h1><p>矩阵的梯度的结果可能得到一个高维的矩阵，这种矩阵称为<strong>张量</strong>（Tensor）<br>两种计算矩阵梯度的方法：<br>一种是直接计算，最后将结果拼装起来，另一种是将矩阵变成一个向量，</p>
<p><img src="https://img-blog.csdnimg.cn/20210427202543293.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210427204602190.png" alt="在这里插入图片描述"></p>
<script type="math/tex; mode=display">\frac{d\boldsymbol K}{d\boldsymbol R}\in \mathbb R^{(N\times N)\times(M\times N)}</script><script type="math/tex; mode=display">\frac {d K_{pq}}{d\boldsymbol R}\in \mathbb R^{1\times(M\times N)}</script><script type="math/tex; mode=display">K_{pq}=r_p^\top r_q=\sum^M_{m=1}\boldsymbol R_{mq}\boldsymbol R_{mp}</script><script type="math/tex; mode=display">\frac{\partial \boldsymbol K_{pq}}{\partial \boldsymbol R_{ij}}=\sum_{m=1}^M\frac{\partial}{\partial R_{ij}}R_{mp}R_{mq}=\partial_{pqij},\partial_{}
\partial_{p q i j}=\left\{\begin{array}{ll}
R_{i q} & \text { if } j=p, p \neq q \\
R_{i p} & \text { if } j=q, p \neq q \\
2 R_{i q} & \text { if } j=p, p=q \\
0 & \text { otherwise }
\end{array} .\right.</script></blockquote>
<h1 id="计算梯度时有用的恒等式（Useful-Identities-for-Computing-Gradients）"><a href="#计算梯度时有用的恒等式（Useful-Identities-for-Computing-Gradients）" class="headerlink" title="计算梯度时有用的恒等式（Useful Identities for Computing Gradients）"></a>计算梯度时有用的恒等式（Useful Identities for Computing Gradients）</h1><script type="math/tex; mode=display">
\begin{aligned}
&\frac{\partial}{\partial \boldsymbol{X}} \boldsymbol{f} (\boldsymbol{X})^{\top}=\left(\frac{\partial \boldsymbol{f}(\boldsymbol{X})}{\partial \boldsymbol{X}}\right)^{\top}\\
&\frac{\partial}{\partial \boldsymbol{X}} \operatorname{tr}(\boldsymbol{f}(\boldsymbol{X}))=\operatorname{tr}\left(\frac{\partial \boldsymbol{f}(\boldsymbol{X})}{\partial \boldsymbol{X}}\right)\\
&\frac{\partial}{\partial \boldsymbol{X}} \operatorname{det}(\boldsymbol{f}(\boldsymbol{X}))=\operatorname{det}(\boldsymbol{f}(\boldsymbol{X})) \operatorname{tr}\left(\boldsymbol{f}(\boldsymbol{X})^{-1} \frac{\partial \boldsymbol{f}(\boldsymbol{X})}{\partial \boldsymbol{X}}\right)\\
&\frac{\partial}{\partial \boldsymbol{X}} \boldsymbol{f}(\boldsymbol{X})^{-1}=-\boldsymbol{f}(\boldsymbol{X})^{-1} \frac{\partial \boldsymbol{f}(\boldsymbol{X})}{\partial \boldsymbol{X}} \boldsymbol{f}(\boldsymbol{X})^{-1}\\
&\frac{\partial \boldsymbol{a}^{\top} \boldsymbol{X}^{-1} \boldsymbol{b}}{\partial \boldsymbol{X}}=-\left(\boldsymbol{X}^{-1}\right)^{\top} \boldsymbol{a} b^{\top}\left(\boldsymbol{X}^{-1}\right)^{\top}\\
&\frac{\partial \boldsymbol{x}^{\top} \boldsymbol{a}}{\partial \boldsymbol{x}}=\boldsymbol{a}^{\top}\\
&\frac{\partial \boldsymbol{a}^{\top} \boldsymbol{x}}{\partial \boldsymbol{x}}=\boldsymbol{a}^{\top}\\
&\frac{\partial \boldsymbol{a}^{\top} \boldsymbol{X} \boldsymbol{b}}{\partial \boldsymbol{X}}=\boldsymbol{a} \boldsymbol{b}^{\top}\\
&\frac{\partial \boldsymbol{x}^{\top} \boldsymbol{B} \boldsymbol{x}}{\partial \boldsymbol{x}}=\boldsymbol{x}^{\top}\left(\boldsymbol{B}+\boldsymbol{B}^{\top}\right)\\
&\frac{\partial}{\partial s}(x-A s)^{\top} W(x-A s)=-2(x-A s)^{\top} W A \quad \text { for symmetric } W\\
&(5.108)
\end{aligned}</script><blockquote>
<p>计算$\frac{\partial x^\top Bx}{\partial x}=x^\top(B+B^\top)$:</p>
</blockquote>
<h1 id="反向传播和自动微分（Backpropagation-and-Automatic-Differentiation）"><a href="#反向传播和自动微分（Backpropagation-and-Automatic-Differentiation）" class="headerlink" title="反向传播和自动微分（Backpropagation and Automatic Differentiation）"></a>反向传播和自动微分（Backpropagation and Automatic Differentiation）</h1><p>为了计算损失函数（Loss Function）的最小值，这时候需要对损失函数对其所有的参数求偏导，也就是求出损失函数的梯度。但是用传统的链式法则会使得中间步骤十分繁琐，所以有了<strong>反向传播算法</strong>（Backpropagation Algorithm)可以有效地解决损失函数的梯度的问题，并且运算速度与传统的链式法则的计算方式相同。</p>
<h2 id="深度网络的梯度（Gradients-in-a-Deep-Network）"><a href="#深度网络的梯度（Gradients-in-a-Deep-Network）" class="headerlink" title="深度网络的梯度（Gradients in a Deep Network）"></a>深度网络的梯度（Gradients in a Deep Network）</h2><p>在深度学习中，一个函数通常是由许多的函数复合而成的。</p>
<script type="math/tex; mode=display">\boldsymbol{y}=\left(f_{K} \circ f_{K-1} \circ \cdots \circ f_{1}\right)(\boldsymbol{x})=f_{K}\left(f_{K-1}\left(\cdots\left(f_{1}(\boldsymbol{x})\right) \cdots\right)\right)</script><p>后一层神经元会使用前一层神经元的输出值作为该层的输入值，所以有：$f<em>i(x</em>{i-1})=\sigma(\boldsymbol A<em>{i-1}x</em>{i-1}+b<em>{i-1}),\quad \sigma$ 为激活函数.$x</em>{i-1}$是第i层的输出值。</p>
<p><img src="https://img-blog.csdnimg.cn/20210428141227595.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>为了训练这个神经网络，我们需要求解出损失函数梯度。<br>假设：</p>
<script type="math/tex; mode=display">f_{0}:=x \\ f_{i}:=\sigma_{i}\left(A_{i-1} f_{i-1}+b_{i-1}\right), \quad i=1, \ldots, K</script><p>损失函数为：</p>
<script type="math/tex; mode=display">L(\theta)=\|y-f_K(\theta,x)\|^2,\quad \theta=\{\boldsymbol A_0,\boldsymbol b_0,\dots, \boldsymbol A_{K-1},\boldsymbol b_{K-1}\}</script><p>要求解这个函数的最小值，我们需要对损失函数求偏导。</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac{\partial L}{\partial \boldsymbol{\theta}_{K-1}} &=\frac{\partial L}{\partial \boldsymbol{f}_{K}} \frac{\partial \boldsymbol{f}_{K}}{\partial \boldsymbol{\theta}_{K-1}} \\
\frac{\partial L}{\partial \boldsymbol{\theta}_{K-2}} &=\frac{\partial L}{\partial \boldsymbol{f}_{K}}\frac{\partial f_{K}}{\partial f_{K-1}} \frac{\partial \boldsymbol{f}_{K-1}}{\partial \boldsymbol{\theta}_{K-2}}\\
\frac{\partial L}{\partial \boldsymbol{\theta}_{K-3}} &=\frac{\partial L}{\partial \boldsymbol{f}_{K}} \frac{\partial f_{K}}{\partial f_{K-1}} \frac{\partial \boldsymbol{f}_{K-1}}{\partial f_{K-2}} \frac{\partial \boldsymbol{f}_{K-2}}{\partial \boldsymbol{\theta}_{K-3}} \\
\frac{\partial L}{\partial \boldsymbol{\theta}_{i}} &=\frac{\partial L}{\partial \boldsymbol{f}_{K}} \frac{\partial f_{K}}{\partial f_{K-1}} \cdots \frac{\partial f_{i+2}}{\partial f_{i+1}} \frac{\partial \boldsymbol{f}_{i+1}}{\partial \boldsymbol{\theta}_{i}}
\end{aligned}</script><p>这样看来，当我们需要计算$\frac{\partial L}{\partial\boldsymbol \theta<em>i}$时，我们可以利用之前的$\frac{\partial L}{\partial\boldsymbol \theta</em>{i+1}}$简化计算。</p>
<script type="math/tex; mode=display">\frac{\partial L}{\partial \boldsymbol\theta_i}=\frac{\partial L}{\partial \boldsymbol\theta_{i+1}}\frac{\partial \boldsymbol f_{i+1}}{\partial \boldsymbol\theta_i}</script><p><img src="https://img-blog.csdnimg.cn/20210428143935866.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="自动微分（Automatic-Differentiation）"><a href="#自动微分（Automatic-Differentiation）" class="headerlink" title="自动微分（Automatic Differentiation）"></a>自动微分（Automatic Differentiation）</h2><p>反向传播算法实际上时自动微分中的一个特例。自动微分类似计算的时候用的还原法，将这些中间步骤用一个变量表示出来：</p>
<script type="math/tex; mode=display">y=f(g(h(x)))=f(g(h(w_0)))=f(g(w_1))=f(w_2)=w_3</script><p>原始的链式法则：</p>
<script type="math/tex; mode=display">\frac {dy}{dx}=\frac{dy}{dw_2}\frac{dw_2}{dw_1}\frac{dw_1}{dx}=\frac{df(w_2)}{dw_2}\frac{dg(w_1)}{dw_1}\frac{dh(w_0)}{dx}</script><p>自动微分有两种模式：<strong>向前模式</strong>（forward mode）和<strong>向后模式</strong>（reverse mode）<br>向前模式就是从内层函数到外层函数逐步进行求导，向后模式则是相反。</p>
<p>使用计算图（computational graphs），每个节点代表一个计算过程中的中间变量。<br>例如：$f(x)=\sqrt{x^{2}+\exp \left(x^{2}\right)}+\cos \left(x^{2}+\exp \left(x^{2}\right)\right)$用计算图可以表示为：<br><img src="https://img-blog.csdnimg.cn/20210428212906625.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>可以描述为：</p>
<script type="math/tex; mode=display">For\ \ i=d+1,\dots, D :\quad x_i=g_i(x_{pa(x_i)})</script><p>其中，$x_{Pa(x_i)}$表示节点$x_i$的父节点。$g_i(\cdot)$表示节点对应的计算函数。</p>
<blockquote>
<p>这部分没什么弄懂，后续继续补充。<br>计算图的那个部分。<br>利用上面的关系可以得出：</p>
<script type="math/tex; mode=display">\frac{df}{dx_i}=\sum_{j:i\in Pa(j)}\frac{df}{dx_i}\frac{dx_j}{dx_i}=\sum_{j:i\in Pa(j)}\frac{df}{dx_j}\frac{dg_i}{dx_i}</script><p>这实际上就是利用链式法则求解出对中间变量的微分。对最后一个中间变量的微分为1</p>
<p>符号微分（Symbolic differentiation）之所以复杂是因为在运算过程中并没有中间变量，所以想要直接编码解决难度较大</p>
</blockquote>
<h1 id="高阶偏导数（Higher-Order-Derivatives）"><a href="#高阶偏导数（Higher-Order-Derivatives）" class="headerlink" title="高阶偏导数（Higher-Order Derivatives）"></a>高阶偏导数（Higher-Order Derivatives）</h1><p>当我们想要用牛顿法进行优化的时候，二阶偏导数就不得不被使用了。<br>有一个符号需要注意：<br>$\frac {\partial^2 f}{\partial x\partial y}$这个意思时先对y求导，然后再对x求导。<br><strong>海森矩阵</strong>（Hessian Matrix）<br>海森矩阵存储函数的二阶偏导数。</p>
<script type="math/tex; mode=display">\nabla^2_{x,y}f(x,y)=\boldsymbol{H}=\left[\begin{array}{cc}\frac{\partial^{2} f}{\partial x^{2}} & \frac{\partial^{2} f}{\partial x \partial y} \\ \frac{\partial^{2} f}{\partial x \partial y} & \frac{\partial^{2} f}{\partial y^{2}}\end{array}\right]</script><p>表示函数在$(x,y)$处的曲率</p>
<h1 id="线性化和多元泰勒级数（Linearization-and-Multivariate-Taylor-Series）"><a href="#线性化和多元泰勒级数（Linearization-and-Multivariate-Taylor-Series）" class="headerlink" title="线性化和多元泰勒级数（Linearization and Multivariate Taylor Series）"></a>线性化和多元泰勒级数（Linearization and Multivariate Taylor Series）</h1><p>假设一个函数：</p>
<script type="math/tex; mode=display">\begin{aligned} f: \mathbb{R}^{D} & \rightarrow \mathbb{R} \\ \quad \boldsymbol{x} & \mapsto f(\boldsymbol{x}), \quad \boldsymbol{x} \in \mathbb{R}^{D} \end{aligned}</script><p>在$x_0$处光滑，设$\delta := x-x_0$,所以：</p>
<script type="math/tex; mode=display">f(x)=\sum^\infty_{k=0}\frac{D^k_\boldsymbol xf(x_0)}{k!}\delta^k</script><p>为$f(x)$在$x<em>0$处的多元泰勒公式。其中,$D^k</em>\boldsymbol xf(x<em>0)$，表示$f(x)$对x的k阶偏导。$D^k</em>\boldsymbol xf(x_0)$和$\delta^k$都是k阶张量，其中：</p>
<script type="math/tex; mode=display">
\boldsymbol{\delta}^{k} \in \mathbb{R} \overbrace{D \times D \times \ldots \times D}^{k \text { times }}</script><script type="math/tex; mode=display">\boldsymbol{\delta}^{3}:=\boldsymbol{\delta} \otimes \boldsymbol{\delta} \otimes \boldsymbol{\delta}, \quad \boldsymbol{\delta}^{3}[i, j, k]=\delta[i] \delta[j] \delta[k]</script><p>所以，（第一个中括号是前面偏导向量的索引）</p>
<script type="math/tex; mode=display">D_{\boldsymbol{x}}^{k} f\left(\boldsymbol{x}_{0}\right) \boldsymbol{\delta}^{k}=\sum_{i_{1}=1}^{D} \cdots \sum_{i_{k}=1}^{D} D_{\boldsymbol{x}}^{k} f\left(\boldsymbol{x}_{0}\right)\left[i_{1}, \ldots, i_{k}\right] \delta\left[i_{1}\right] \cdots \delta\left[i_{k}\right]</script><p>下面是上式的前三项：</p>
<script type="math/tex; mode=display">
\begin{array}{l}
k=0, \ldots, 3 \text { and } \delta:=x-x_{0}: \\
k=0: D_{\boldsymbol{x}}^{0} f\left(\boldsymbol{x}_{0}\right) \boldsymbol{\delta}^{0}=f\left(\boldsymbol{x}_{0}\right) \in \mathbb{R} \\
k=1: D_{\boldsymbol{x}}^{1} f\left(\boldsymbol{x}_{0}\right) \boldsymbol{\delta}^{1}=\underbrace{\nabla_{\boldsymbol{x}} f\left(\boldsymbol{x}_{0}\right)}_{1 \times D} \underbrace{\delta}_{D \times 1}=\sum_{i=1}^{D} \nabla_{\boldsymbol{x}} f\left(\boldsymbol{x}_{0}\right)[i] \delta[i] \in \mathbb{R} \\
k=2: D_{\boldsymbol{x}}^{2} f\left(\boldsymbol{x}_{0}\right) \boldsymbol{\delta}^{2}=\operatorname{tr}(\underbrace{\boldsymbol{H}\left(\boldsymbol{x}_{0}\right)}_{D \times D} \underbrace{\delta}_{D \times 1} \underbrace{\delta^{\top}}_{1 \times D})=\delta^{\top} \boldsymbol{H}\left(\boldsymbol{x}_{0}\right) \boldsymbol{\delta} \\
=\sum_{i=1}^{D} \sum_{j=1}^{D} H[i, j] \delta[i] \delta[j] \in \mathbb{R} \\
k=3: D_{\boldsymbol{x}}^{3} f\left(\boldsymbol{x}_{0}\right) \boldsymbol{\delta}^{3}=\sum_{i=1}^{D} \sum_{j=1}^{D} \sum_{k=1}^{D} D_{x}^{3} f\left(\boldsymbol{x}_{0}\right)[i, j, k] \delta[i] \delta[j] \delta[k] \in \mathbb{R}
\end{array}</script><p>其中$\boldsymbol H(x_0)$表示在$x_0$处的海森矩阵。</p>
<blockquote>
<p>证明？</p>
<script type="math/tex; mode=display">k=2: D_{\boldsymbol{x}}^{2} f\left(\boldsymbol{x}_{0}\right) \boldsymbol{\delta}^{2}=\operatorname{tr}(\underbrace{\boldsymbol{H}\left(\boldsymbol{x}_{0}\right)}_{D \times D} \underbrace{\delta}_{D \times 1} \underbrace{\delta^{\top}}_{1 \times D})=\delta^{\top} \boldsymbol{H}\left(\boldsymbol{x}_{0}\right) \boldsymbol{\delta} \\
=\sum_{i=1}^{D} \sum_{j=1}^{D} H[i, j] \delta[i] \delta[j] \in \mathbb{R}</script></blockquote>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="反向传播（推导）"><a href="#反向传播（推导）" class="headerlink" title="反向传播（推导）"></a>反向传播（推导）</h2><p>我们想要求的是对损失函数对参数的求导的结果：</p>
<script type="math/tex; mode=display">\frac{dL}{dv_i},i\ge N-M+1</script><p>利用链式法则：</p>
<script type="math/tex; mode=display">\frac{dL}{dv_i}=\sum_{j:i\in Pa(j)}\frac{dL}{dv_i}\frac{dv_i}{dv_j}</script><p>回想我们计算激活值的方法：</p>
<script type="math/tex; mode=display">v_i=\sigma_i(w_i\cdot v_{Pa(i)})</script><p>所以我们可以计算：</p>
<script type="math/tex; mode=display">\frac{dv_i}{dv_j}=\sigma_i'(\boldsymbol w_i\cdot \boldsymbol v_{Pa(i)})w_{iq},Pa(i)_q=j</script><p>举个例子，假设$Pa(i)=(2,7,9)$,则激活值为：</p>
<script type="math/tex; mode=display">v_i=\sigma_i(\boldsymbol w_i\cdot \boldsymbol v_{(2,7,9)})</script><p>展开即为下面这些式子：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac{d v_{i}}{d v_{2}} &=\sigma_{i}^{\prime}\left(\mathbf{w}_{i} \cdot \mathbf{v}_{(2,7,9)}\right) w_{i 1} \\
\frac{d v_{i}}{d v_{7}} &=\sigma_{i}^{\prime}\left(\mathbf{w}_{i} \cdot \mathbf{v}_{(2,7,9)}\right) w_{i 2} \\
\frac{d v_{i}}{d v_{9}} &=\sigma_{i}^{\prime}\left(\mathbf{w}_{i} \cdot \mathbf{v}_{(2,7,9)}\right) w_{i 3} .
\end{aligned}</script><p>我们用$v<em>i’=\sigma’_i(\boldsymbol w_i\cdot \boldsymbol v</em>{Pa(i)})$带入到原先的式子中：</p>
<script type="math/tex; mode=display">\frac{dv_i}{dv_j}=v_i'w_{iq},Pa(i)_q=j</script><p>对应的向量形式为：</p>
<script type="math/tex; mode=display">\frac{dv_i}{d\mathbf v_{Pa(i)}}= v'_i\mathbf w_i</script><p>于是我们可以很容易得到：(带入已知式)</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac{d L}{d \mathbf{w}_{i}} &=\frac{d L}{d v_{i}} \frac{d v_{i}}{d \mathbf{w}_{i}} \\
&=\frac{d L}{d v_{i}} \sigma_{i}^{\prime}\left(\mathbf{w} \cdot \mathbf{v}_{\mathrm{Pa}(i)}\right) \mathbf{v}_{\mathrm{Pa}(i)} \\
&=\frac{d L}{d v_{i}} v_{i}^{\prime} \mathbf{v}_{\mathrm{Pa}(i)}
\end{aligned}</script>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6%EF%BC%9A%EF%BC%88%E4%B8%89%EF%BC%89%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3-Matrix-Decompositions/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6%EF%BC%9A%EF%BC%88%E4%B8%89%EF%BC%89%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3-Matrix-Decompositions/" class="post-title-link" itemprop="url">机器学习中的数学：（三）矩阵分解(Matrix Decompositions)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-26 10:32:53" itemprop="dateCreated datePublished" datetime="2021-04-26T10:32:53+08:00">2021-04-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-08 19:50:17" itemprop="dateModified" datetime="2023-03-08T19:50:17+08:00">2023-03-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>@[toc]<br>矩阵分解可以用于压缩矩阵，以尽可能少的空间存储一个矩阵，同时损失尽可能少的信息。同时对数据进行降维还可以减少发生<strong>维度灾难</strong>的发生。</p>
<blockquote>
<p><strong>维数灾难</strong>： 当数据维度提升的时候，因为空间体积提升过快，因而可用数据变得很稀疏。然而在高维空间中，所有的数据都很稀疏，从很多角度看都不相似，因而平常使用的数据组织策略变得极其低效。<br><br><br>在机器学习问题中，需要在高维特征空间（每个特征都能够取一系列可能值）的有限数据样本中学习一种“自然状态”（可能是无穷分布），要求有相当数量的训练数据含有一些样本组合。<u>给定固定数量的训练样本，其预测能力随着维度的增加而减小</u>，这就是所谓的Hughes影响或Hughes现象（以Gordon F. Hughes命名）。<br>        ———Wiki<br>个人理解：随着维度的升高数据之间的距离加大，这导致数据组合而成的用于最终判断的特征难以被发现</p>
<h1 id="行列式与迹（Determinant-and-Trace）"><a href="#行列式与迹（Determinant-and-Trace）" class="headerlink" title="行列式与迹（Determinant and Trace）"></a>行列式与迹（Determinant and Trace）</h1><h2 id="行列式（Dterminant）"><a href="#行列式（Dterminant）" class="headerlink" title="行列式（Dterminant）"></a>行列式（Dterminant）</h2><p>行列式可以看成将一个方阵映射成一个实数。（只有方阵才有行列式）<br>可以将行列式用于判断一个方阵是否可逆：<br><img src="https://img-blog.csdnimg.cn/20210422212906189.png" alt="在这里插入图片描述"></p>
</blockquote>
<p>对于上/下三角矩阵的行列式的值为:</p>
<script type="math/tex; mode=display">\operatorname{det}(\boldsymbol{T})=\prod_{i=1}^{n} T_{i i}</script><p>对于n阶行列的计算，可以使用<strong>拉普拉斯展开</strong>(Laplace Expansion)<br><img src="https://img-blog.csdnimg.cn/20210422213649972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210422213733943.png" alt="在这里插入图片描述"></p>
<p>行列式的几何含义就是带有符号的多边形的体积，这个多边形是由行列式所对应的列向量通过平移之后组成的.注意到当至少其中的两个向量重合的时候，也就是这两个向量线性相关的时候，他们组成的几何体的体积为0，所以这时候他们组成的方阵的行列式为0.<br><img src="https://img-blog.csdnimg.cn/20210422213432734.png" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20210422213436294.png" alt="在这里插入图片描述"><br>行列式的一些性质：<br><img src="https://img-blog.csdnimg.cn/20210422213814612.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt><br><img src="https://img-blog.csdnimg.cn/20210422213949173.png" alt="在这里插入图片描述"></p>
<h2 id="迹-Trace"><a href="#迹-Trace" class="headerlink" title="迹(Trace)"></a>迹(Trace)</h2><p>假设$f(x)=\prod^k_{i=1}(x-\lambda_i)^{d_i}$是矩阵A的特征多项式，那么A的迹为：</p>
<script type="math/tex; mode=display">\operatorname{tr}(\boldsymbol A)=\sum^k_{i=1}d_i\lambda_i</script><p>对于一个方阵的迹就是它所有对角线元素的和：</p>
<script type="math/tex; mode=display">tr(\bold A):=\sum\limits_{i=1}^na_{ii}</script><p>迹的一些性质：<br><img src="https://img-blog.csdnimg.cn/20210422214211626.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210422214251939.png" alt="在这里插入图片描述"><br>假设$\bold B、\bold A$是向量空间U的两个基向量，所以一定存在一个向量$\bold S$,使得$\bold B=\bold S^{-1}\bold A\bold S$:</p>
<script type="math/tex; mode=display">\operatorname{tr}(\boldsymbol{B})=\operatorname{tr}\left(\boldsymbol{S}^{-1} \boldsymbol{A} \boldsymbol{S}\right) \stackrel{(4.19)}{=} \operatorname{tr}\left(\boldsymbol{A} \boldsymbol{S} \boldsymbol{S}^{-1}\right)=\operatorname{tr}(\boldsymbol{A})</script><p><strong>特征多项式</strong>：<br><img src="https://img-blog.csdnimg.cn/2021042221461996.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>其中：</p>
<script type="math/tex; mode=display">c_0=det(\bold A) \\ c_{n-1}=(-1)^{n-1}tr(\bold A)</script><p>特征多项式可以用于求解特征值和特征向量。</p>
<h1 id="特征值与特征向量"><a href="#特征值与特征向量" class="headerlink" title="特征值与特征向量"></a>特征值与特征向量</h1><p><img src="https://img-blog.csdnimg.cn/20210423102704877.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210423102727720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>特征向量不是唯一的，与特征向量共线的所有向量都是这个矩阵的特征向量。<br>共线与共向：<br><img src="https://img-blog.csdnimg.cn/20210423102845808.png" alt="在这里插入图片描述"><br>特征值是矩阵特征多项式的一个根。<br><strong>代数重度</strong>（algebraic multiplicity）：该特征是特征向量的几重根。<br><strong>特征空间</strong>：特征值对应的特征向量组成的向量空间就是特征空间<br><img src="https://img-blog.csdnimg.cn/20210423103140423.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>有疑问<br><img src="https://img-blog.csdnimg.cn/20210423103537224.png" alt="在这里插入图片描述"><br>特征向量所张成的空间就是特征向量通过线性映射之后得到的。而特征向量所对应的特征值的正负对应着特征向量的指向的方向</p>
</blockquote>
<p>特征值的几个非常有用的性质：<br>1.矩阵和他的转置的特征值一样，但是特征向量不一定一样<br>2.观察特征方程$(\bold A-\lambda\bold I)\bold x=\bold 0$,这说明$(\bold A-\lambda\bold I)$对应着核空间<br><img src="https://img-blog.csdnimg.cn/20210423103825435.png" alt="在这里插入图片描述"></p>
<p>3.相似矩阵（$\widetilde A=S^{-1}AS$）的特征值保持一致，说明特征值是与基向量无关的（拥有这种性质的还有迹和行列式）<br>4.正定矩阵拥有正的实特征值。</p>
<p><strong>几何重度</strong>（Geometric Multiplicity，特征空间的维度）：<br>$\lambda$对应的线性无关的特征向量的个数。<br><img src="https://img-blog.csdnimg.cn/20210423104316545.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>为什么？<br><img src="https://img-blog.csdnimg.cn/20210423104418946.png" alt="在这里插入图片描述"></p>
</blockquote>
<p><strong>二维空间中的几何直观理解</strong>：<br>对于特征方程（$\bold A\bold x=\lambda\bold x$），等式右边是对向量x的一个变换（变换矩阵为A），右边为对x的一个伸展，二者相等，说明在经历过变换之后，x向量只是简单地发生了范数地增长，并没有离开原先地向量空间。而这个变换之后不离开原先向量空间的向量称为<strong>特征向量</strong>。特征向量组成的向量空间，称为<strong>特征空间</strong>，在特征空间中的所有向量经过变换之后也不会离开原先的张成空间。向量延展的倍数为变换矩阵的<strong>特征值</strong><br><img src="https://img-blog.csdnimg.cn/20210423133916529.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>特征向量与特征值的求解过程：<br>由特征方程得到：$(\bold A-\lambda I)\bold v=\bold 0$当$\vec \bold v$为零向量的时候，等式成立，但是我们想要一个非零向量，所以原来的式子的含义就变成，将一个向量压缩成一个零向量，这就是说在经过变换之后原先的向量发生了降维，这就是说$\bold A-\lambda I$不是满秩的，就好像是一个三维体经过变换之后变成了二维，这时候变换之后的几何体的体积变成了0，也就是相对应的行列式变成了0，所以$|\bold A-\lambda I|=0、det(\bold A-\lambda I)=0$<br><img src="https://img-blog.csdnimg.cn/20210423133912252.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>下图是不同类型的线性映射时候特征值和行列式的情况：<br>其中<br>$\bold A_1=\begin{bmatrix}\frac1 2\quad 0\ 0 \quad 2\end{bmatrix}\<br>\bold A_2=\begin{bmatrix}1 \quad\frac 12\ 0 \quad 1\end{bmatrix}\<br>\bold A_3=\begin{bmatrix}\cos(\frac\pi6)\quad -\sin(\frac\pi6)\ \sin(\frac\pi6) \quad \cos(\frac\pi6)\end{bmatrix}=\frac12\begin{bmatrix} \sqrt 3\quad-1\1\quad\sqrt 3\end{bmatrix}\<br>\bold A_4=\begin{bmatrix}1\quad\quad -1\ -1 \quad\quad 1\end{bmatrix}$<br><img src="https://img-blog.csdnimg.cn/20210423134928849.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>为什么最后一个的行列式的值发生了变化？</p>
</blockquote>
<p>每一个特征空间在变换中对应着唯一一个特征值（倍数），所以当倍数（特征值）全部都是不同的时候，说明有所有的特征向量都是线性无关的。<br><img src="https://img-blog.csdnimg.cn/20210423141732757.png" alt="在这里插入图片描述"><br><strong>亏损矩阵</strong><br><img src="https://img-blog.csdnimg.cn/20210423142205462.png" alt="在这里插入图片描述"><br>对于一个非亏损矩阵（$\in \mathbb R^{n\times n}$）不一定需要n个不同的特征值，但是一定需要n个特征向量组成$\mathbb R^{n\times n}$的基。（注意到不同的向量在变换的时候延伸的倍数是可以一样的，所以会有一个特征值对应几个特征向量的情况）</p>
<p><img src="https://img-blog.csdnimg.cn/20210423142559266.png" alt="在这里插入图片描述"><br><strong>谱定律</strong>：<br><img src="https://img-blog.csdnimg.cn/20210423201349436.png" alt="在这里插入图片描述"><br>这说明一个对称矩阵可以进行特征分解,也就是说能够找到特征向量对应的规范正交基，使得$\bold A=\bold P\bold D\bold P^{-1}$其中D为对角矩阵，P由特征向量组成。</p>
<p><strong>行列式与迹的意义</strong>：分别与面积（体积）和周长相关<br><img src="https://img-blog.csdnimg.cn/20210423201949444.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210423202001438.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="柯列斯基分解（Cholesky-Decomposition）"><a href="#柯列斯基分解（Cholesky-Decomposition）" class="headerlink" title="柯列斯基分解（Cholesky Decomposition）"></a>柯列斯基分解（Cholesky Decomposition）</h1><p><img src="https://img-blog.csdnimg.cn/20210423202734362.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>计算方式：<br><img src="https://img-blog.csdnimg.cn/20210423202908551.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</blockquote>
<p>这在深度学习中有很多的应用，同时还可以用于计算行列式（上下三角矩阵的行列式非常好计算）</p>
<h1 id="特征分解和对角化"><a href="#特征分解和对角化" class="headerlink" title="特征分解和对角化"></a>特征分解和对角化</h1><p>可对角化的条件：<br><img src="https://img-blog.csdnimg.cn/20210423203839482.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210423204815898.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这需要P矩阵是满秩的<br><strong>特征分解</strong><br><img src="https://img-blog.csdnimg.cn/20210423205113416.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这实际上就是A与D相似。P由A的特征向量组成，D由A的特征值组成（对角矩阵）</p>
<blockquote>
<p>如何理解相似矩阵？<br>如何理解谱定理？<img src="https://img-blog.csdnimg.cn/20210424105653896.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2021042410570861.png" alt="在这里插入图片描述"></p>
<h2 id="矩阵分解的几何直观理解"><a href="#矩阵分解的几何直观理解" class="headerlink" title="矩阵分解的几何直观理解"></a>矩阵分解的几何直观理解</h2></blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210424121857566.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>各部分对应的变换还是不是很清楚。<br>特征值分解可以这样理解，首先先进行一次基变换，将正交基变换至由特征向量组成的向量空间中，然后进行延展（这就是变换矩阵A对应在特征向量中的变换Ax=$\lambda x$）,最后将向量空间复原到原先的向量空间中。</p>
</blockquote>
<p>对待方程$\bold A=\bold P^{-1}\bold D\bold P$,可以这样想，单位矩阵经过A矩阵变换之后等价于$\bold P^{-1}\bold D\bold P$三个矩阵变化之后的结果。<br>将一个矩阵分解之后，可以很方便地计算矩阵地行列式和n次方。</p>
<script type="math/tex; mode=display">det(\bold A)=det(\bold P\bold D\bold P^{-1})=det(\bold P)*det(\bold D)*det(\bold P^{-1})=\prod_id_{ii}</script><h1 id="奇异值分解（Singular-Value-Decomposition，SVD）"><a href="#奇异值分解（Singular-Value-Decomposition，SVD）" class="headerlink" title="奇异值分解（Singular Value Decomposition，SVD）"></a>奇异值分解（Singular Value Decomposition，SVD）</h1><p>相对于特征值分解，奇异值分解使用范围更广，它不要求分解的矩阵是方阵。<br><img src="https://img-blog.csdnimg.cn/20210424135923640.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>$\mathbb u_i$称为左奇异向量；$\mathbb v_j$称为右奇异向量。</p>
<p>$\Sigma$矩阵起到拓展维度的作用，所以：<br><img src="https://img-blog.csdnimg.cn/20210424140128695.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="SVD的几何直观解释"><a href="#SVD的几何直观解释" class="headerlink" title="SVD的几何直观解释"></a>SVD的几何直观解释</h2><p><img src="https://img-blog.csdnimg.cn/20210424140421187.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>奇异值分解其实和特征值分解类似，只是在延伸的时候加了一些东西，这是因为矩阵为非方阵的时候，这样的变换会使向量发生维度的变化，所以$\Sigma$矩阵在不是方阵的情况下，不仅仅使向量进行相对应的变换，还将维度进行了提升。</p>
</blockquote>
<p>$V^T$起到旋转的作用，$\Sigma$起到拓展上域（codomain，到达域）维度的作用，最后U帮助向量升维。</p>
<blockquote>
<p>上域<br><img src="https://img-blog.csdnimg.cn/20210424140700348.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</blockquote>
<p>一个变换实例：<br><img src="https://img-blog.csdnimg.cn/2021042414101820.png" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210424140923239.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="求解矩阵的SVD"><a href="#求解矩阵的SVD" class="headerlink" title="求解矩阵的SVD"></a>求解矩阵的SVD</h2><p>对于一个对称正定矩阵（SPD矩阵）有:$S=S^T=PDP^{T}$<br><img src="https://img-blog.csdnimg.cn/20210425131251977.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>所以一个SDP矩阵的SVD就是它的特征值分解。</p>
<p>计算一个矩阵$\bold A\in \mathbb R^{m\times n}$,等价于求解上域（codomain）$\mathbb R^m$和定义域（domain）$\mathbb R^n$的规范正交基</p>
<blockquote>
<p>What’s the graphic intuitions?And why?</p>
</blockquote>
<p><strong>求解右奇异向量</strong></p>
<blockquote>
<p>由谱定理得知，对称矩阵的特征向量组成规范正交基，也就是说对称矩阵能够相似对角化。而我们可以通过$AA^T$的方式得到一个半正定的对称矩阵。</p>
</blockquote>
<script type="math/tex; mode=display">\boldsymbol{A}^{\top} \boldsymbol{A}=\boldsymbol{P} \boldsymbol{D} \boldsymbol{P}^{\top}=\boldsymbol{P}\left[\begin{array}{ccc}\lambda_{1} & \cdots & 0 \\ \vdots & \ddots & \vdots \\ 0 & \cdots & \lambda_{n}\end{array}\right] \boldsymbol{P}^{\top}</script><p>将SVD带入：</p>
<script type="math/tex; mode=display">\boldsymbol{A}^{\top} \boldsymbol{A}=\left(\boldsymbol{U} \boldsymbol{\Sigma} \boldsymbol{V}^{\top}\right)^{\top}\left(\boldsymbol{U} \boldsymbol{\Sigma} \boldsymbol{V}^{\top}\right)=\boldsymbol{V} \boldsymbol{\Sigma}^{\top} \boldsymbol{U}^{\top} \boldsymbol{U} \boldsymbol{\Sigma} \boldsymbol{V}^{\top}</script><p>由于$\boldsymbol U$是正交矩阵，所以$\boldsymbol U\boldsymbol U^\top=\boldsymbol I$:</p>
<script type="math/tex; mode=display">\boldsymbol{A}^{\top} \boldsymbol{A}=\boldsymbol{V} \boldsymbol{\Sigma}^{\top} \boldsymbol{\Sigma} \boldsymbol{V}^{\top}=\boldsymbol{V}\left[\begin{array}{ccc}\sigma_{1}^{2} & 0 & 0 \\ 0 & \ddots & 0 \\ 0 & 0 & \sigma_{n}^{2}\end{array}\right] \boldsymbol{V}^{\top}</script><p>由此可以得出，A的SVD的奇异值就是$AA^\top$的特征值的开根号的结果。其特征矩阵就是右奇异矩阵。</p>
<p>对于<strong>左奇异矩阵</strong>采取相似的方式：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\boldsymbol{A} \boldsymbol{A}^{\top} &=\left(\boldsymbol{U} \boldsymbol{\Sigma} \boldsymbol{V}^{\top}\right)\left(\boldsymbol{U} \boldsymbol{\Sigma} \boldsymbol{V}^{\top}\right)^{\top}=\boldsymbol{U} \boldsymbol{\Sigma} \boldsymbol{V}^{\top} \boldsymbol{V} \boldsymbol{\Sigma}^{\top} \boldsymbol{U}^{\top}\\ 
&=\boldsymbol{U}\left[\begin{array}{ccc}
\sigma_{1}^{2} & 0 & 0 \\
0 & \ddots & 0 \\
0 & 0 & \sigma_{m}^{2}
\end{array}\right] \boldsymbol{U}^{\top} .
\end{aligned}</script><p>现在<strong>将左右奇异矩阵</strong>联系起来：<br>由于$\boldsymbol U$中的向量$\mathcal v<em>i$在经过A矩阵变换之后仍旧是正交向量，因为，$$\left(\boldsymbol{A} \boldsymbol{v}</em>{i}\right)^{\top}\left(\boldsymbol{A} \boldsymbol{v}<em>{j}\right)=\boldsymbol{v}</em>{i}^{\top}\left(\boldsymbol{A}^{\top} \boldsymbol{A}\right) \boldsymbol{v}<em>{j}=\boldsymbol{v}</em>{i}^{\top}\left(\lambda<em>{j} \boldsymbol{v}</em>{j}\right)=\lambda<em>{j} \boldsymbol{v}</em>{i}^{\top} \boldsymbol{v}_{j}=0，\quad i\ne j$$<br>单位化右奇异向量的像域：</p>
<script type="math/tex; mode=display">\boldsymbol{u}_{i}:=\frac{\boldsymbol{A} \boldsymbol{v}_{i}}{\left\|\boldsymbol{A} \boldsymbol{v}_{i}\right\|}=\frac{1}{\sqrt{\lambda_{i}}} \boldsymbol{A} \boldsymbol{v}_{i}=\frac{1}{\sigma_{i}} \boldsymbol{A} \boldsymbol{v}_{i}</script><blockquote>
<p>二者的关系？</p>
</blockquote>
<p>由上得到奇异方程：</p>
<script type="math/tex; mode=display">\boldsymbol A\boldsymbol v_i=\sigma_i\boldsymbol u_i,\quad i=1,\dots,r</script><p>于是有：</p>
<script type="math/tex; mode=display">\boldsymbol A\boldsymbol V=\Sigma\boldsymbol U</script><p>移项得：</p>
<script type="math/tex; mode=display">\boldsymbol A=\boldsymbol U\Sigma\boldsymbol V^\top</script><p>这就是矩阵A的SVD。</p>
<h1 id="矩阵逼近（Matrix-Approximation）"><a href="#矩阵逼近（Matrix-Approximation）" class="headerlink" title="矩阵逼近（Matrix Approximation）"></a>矩阵逼近（Matrix Approximation）</h1><p><strong>外积</strong>：<br><img src="https://img-blog.csdnimg.cn/20210426100532232.png" alt="在这里插入图片描述"><br>与内积不同，当两个向量相乘的时候，外积得到的是一个矩阵。有之前的SVD分解式，可以得到下式：</p>
<script type="math/tex; mode=display">\boldsymbol{A}=\sum_{i=1}^{r} \sigma_{i} \boldsymbol{u}_{i} \boldsymbol{v}_{i}^{\top}=\sum_{i=1}^{r} \sigma_{i} \boldsymbol{A}_{i}</script><p>但是加入我们不讲所有的外积都加上的话，得到一个秩为$k(k&lt;r)$的矩阵，这个称为<strong>k秩逼近</strong>（rank-k approximation）</p>
<script type="math/tex; mode=display">\widehat{\boldsymbol{A}}(k):=\sum_{i=1}^{k} \sigma_{i} \boldsymbol{u}_{i} \boldsymbol{v}_{i}^{\top}=\sum_{i=1}^{k} \sigma_{i} \boldsymbol{A}_{i}</script><p><strong>谱模</strong>（spectral norm）<br><img src="https://img-blog.csdnimg.cn/20210426101036527.png" alt="在这里插入图片描述"><br>谱模表示，一个向量在经历矩阵A的变换之后最长可以变成多长（下标2代表的是欧几里得空间）。可以证明，<u>矩阵A的谱模就是它的最大的奇异值</u></p>
<p><strong>埃卡特-杨定理</strong><br><img src="https://img-blog.csdnimg.cn/20210426101250788.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这个定理量化了矩阵近似会造成的误差。</p>
<blockquote>
<p>证明过程？</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="https://img-blog.csdnimg.cn/20210426103210671.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/25/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/25/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">论文笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-25 15:06:35" itemprop="dateCreated datePublished" datetime="2021-04-25T15:06:35+08:00">2021-04-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-08 19:54:59" itemprop="dateModified" datetime="2023-03-08T19:54:59+08:00">2023-03-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>@[toc]</p>
<h1 id="Multi-band-weighted-lp-norm-minimization-for-image-denois"><a href="#Multi-band-weighted-lp-norm-minimization-for-image-denois" class="headerlink" title="Multi-band weighted lp norm minimization for image denois"></a>Multi-band weighted lp norm minimization for image denois</h1><h2 id="内容学习"><a href="#内容学习" class="headerlink" title="内容学习"></a>内容学习</h2><h3 id="Low-rank-matrix-approximation-LRMA"><a href="#Low-rank-matrix-approximation-LRMA" class="headerlink" title="Low rank matrix approximation (LRMA)"></a>Low rank matrix approximation (LRMA)</h3><h3 id="谱模"><a href="#谱模" class="headerlink" title="谱模"></a>谱模</h3><p>（Spectral Norm，矩阵的模）：</p>
<script type="math/tex; mode=display">\|A\|_{2}=\sqrt{\lambda_{\max }\left(A^{*} A\right)}=\sigma_{\max }(A)</script><p>范数的下标表示这个模是在欧几里得空间下的。实际上就是说A的谱模就是A的最大奇异值。<br><strong>矩阵的低秩近似</strong>：<br>浅显地理解就是舍弃掉矩阵中地一些行、列，而造成最小的损失。<br><strong>Schatten norms</strong>：</p>
<blockquote>
<p>其实这个p值代表的是这个范数所在的空间，当p=2时，即为欧几里得空间。</p>
</blockquote>
<p>Schatten p-norm ：（$A\subseteq\mathbb R^{m\times n}$）</p>
<script type="math/tex; mode=display">\|A\|_{p}=\left(\sum_{i=1}^{\min \{m, n\}} \sigma_{i}^{p}(A)\right)^{\frac{1}{p}}</script><p>当p=2时：Frobenius norm<br>当p=1时：nuclear norm，定义为$\downarrow$</p>
<script type="math/tex; mode=display">\|A\|_{*}=\operatorname{trace}\left(\sqrt{A^{*} A}\right)=\sum_{i=1}^{\min \{m, n\}} \sigma_{i}(A)</script><p>当p=$\infin$时：Frobenius norm</p>
<blockquote>
<p>文中提到了核范数最小化来求解矩阵的低秩逼近，但是容易产生一个问题：”this is likely to overshrink the rank components due to having the same threshold.”<br>所以现在有一个问题，就是如何使用范数最小化来求解矩阵的低秩逼近？</p>
<p>一个运算符号：arg min在这里表示当这个运算符后面的式子取得最小值的时候，X的值。<br><img src="https://img-blog.csdnimg.cn/20210426163948627.png" alt="在这里插入图片描述"></p>
<p>复习一下范数：<br>范数实际上就是将一个实数或者虚数向量空间映射到一个非负实数的函数。表现起来像是距离。</p>
<h3 id="软阈值函数（Soft-threshold-Function）"><a href="#软阈值函数（Soft-threshold-Function）" class="headerlink" title="软阈值函数（Soft-threshold Function）"></a>软阈值函数（Soft-threshold Function）</h3><script type="math/tex; mode=display">
\operatorname{soft}(x, T)=\left\{\begin{array}{cc}
x+T & x \leq-T \\
0 & |x| \leq T \\
x-T & x \geq T
\end{array}\right.</script><p><img src="https://img-blog.csdnimg.cn/20210430161914591.png" alt="在这里插入图片描述"></p>
</blockquote>
<p>软阈值函数可以用于求解优化问题：</p>
<script type="math/tex; mode=display">\argmin_x \|\boldsymbol X-\boldsymbol B\|^2_F+\lambda\|\boldsymbol X\|_*</script><p>此问题最终解的形式就是软阈值函数。</p>
<h3 id="加性高斯白噪声（additive-white-Gaussian-noise）"><a href="#加性高斯白噪声（additive-white-Gaussian-noise）" class="headerlink" title="加性高斯白噪声（additive white Gaussian noise）"></a>加性高斯白噪声（additive white Gaussian noise）</h3><p>一种用于模拟自然噪音的模型。</p>
<p>Additive white Gaussian noise (AWGN) is a basic noise model used in information theory to <u>mimic the effect of many random processes that occur in nature.</u> The modifiers denote specific characteristics:</p>
<p><strong>Additive</strong> because it is added to any noise that might be intrinsic to the information system.<br><strong>White</strong> refers to the idea that it has uniform power across the frequency band for the information system. It is an analogy to the color white which has <u>uniform emissions at all frequencies</u> in the visible spectrum.<br><strong>Gaussian</strong> because it has a normal distribution(正态分布) in the time domain with an average time domain value of zero.</p>
<blockquote>
<p>时域（Time domain）:描述数学函数或物理信号对时间的关系.<br>就是描述函数随时间变化的情况。</p>
</blockquote>
<h3 id="正则化（regularization）"><a href="#正则化（regularization）" class="headerlink" title="正则化（regularization）"></a>正则化（regularization）</h3><p>正则化是为了防止问题过拟合，在拟合方程中加上一些惩罚项，以减少拟合的参数。</p>
<blockquote>
<p>regularization is the process of adding information in order to solve an ill-posed problem or to prevent overfitting.<br>The regularization term, or penalty, imposes a cost on the optimization function to make the optimal solution unique.</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210426154729328.png" alt="在这里插入图片描述"><br>一个正则式往往加到代价函数中：</p>
<script type="math/tex; mode=display">\min_f \sum^n_{i=1}V(f(x_i),y_i)+\lambda R(f)</script><p>其中，V为代价函数，表示预测值$f(x_i)$与$y_i$之间的差距，$\lambda$是一个控制正则式权重的项。$R(f)$为对f函数复杂程度的惩罚函数。</p>
<h3 id="拉格朗日乘数（Lagrange-multiplier）"><a href="#拉格朗日乘数（Lagrange-multiplier）" class="headerlink" title="拉格朗日乘数（Lagrange multiplier）"></a>拉格朗日乘数（Lagrange multiplier）</h3><p>拉格朗日乘数是一种用于求解线性约束问题中的极大值或者极小值的策略。主要思想就是将一个约束问题转化成一个非约束问题。大致可以描述为：<br><img src="https://img-blog.csdnimg.cn/20210430165406723.png" alt="在这里插入图片描述"><br>一个函数$f(x)$在线性约束$g(x) = 0$下的最优问题，这样可以得到<strong>拉格朗日函数</strong>(Lagrangian Function):</p>
<script type="math/tex; mode=display">\mathcal L(x,\lambda)=f(x)-\lambda g(x)</script><h1 id="Optimization-by-Simulated-Annealing"><a href="#Optimization-by-Simulated-Annealing" class="headerlink" title="Optimization by Simulated Annealing"></a>Optimization by Simulated Annealing</h1><h2 id="Metropolis-algorithm"><a href="#Metropolis-algorithm" class="headerlink" title="Metropolis algorithm"></a>Metropolis algorithm</h2><h3 id="Markvo-Chain"><a href="#Markvo-Chain" class="headerlink" title="Markvo Chain"></a>Markvo Chain</h3><p>A <strong>Markov chain</strong> is a stochastic model describing a sequence of possible events in which the probability of each event <u>depends only on the state attained in the previous event</u>.<br>概率的<strong>无记忆性</strong>（memorylessness）：<br>In other words, conditional on the present state of the system, its future and past states are independent.<br><img src="https://img-blog.csdnimg.cn/2021051309204215.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<script type="math/tex; mode=display">\Pr(X_{n+1}=x\mid X_{1}=x_{1},X_{2}=x_{2},\ldots ,X_{n}=x_{n})=\Pr(X_{n+1}=x\mid X_{n}=x_{n})</script><h2 id="Travelling-salesman-problem"><a href="#Travelling-salesman-problem" class="headerlink" title="Travelling salesman problem"></a>Travelling salesman problem</h2><blockquote>
<p>Given a list of cities and the distances between each pair of cities, what is the shortest possible route that visits each city exactly once and returns to the origin city?”</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210513093036114.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="Heuristic-computer-science"><a href="#Heuristic-computer-science" class="headerlink" title="Heuristic (computer science)"></a>Heuristic (computer science)</h2><p>In mathematical optimization and computer science, heuristic (from Greek εὑρίσκω “I find, discover”) is a technique designed for <u>solving a problem more quickly when classic methods are too slow</u>, or for <u>finding an approximate solution</u> when classic methods fail to find any exact solution. </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6%EF%BC%9A%EF%BC%88%E4%BA%8C%EF%BC%89%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6%EF%BC%9A%EF%BC%88%E4%BA%8C%EF%BC%89%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/" class="post-title-link" itemprop="url">机器学习中的数学：（二）解析几何</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-22 15:17:46" itemprop="dateCreated datePublished" datetime="2021-04-22T15:17:46+08:00">2021-04-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-08 19:49:30" itemprop="dateModified" datetime="2023-03-08T19:49:30+08:00">2023-03-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="解析几何-Analytic-Geometry"><a href="#解析几何-Analytic-Geometry" class="headerlink" title="解析几何(Analytic Geometry)"></a>解析几何(Analytic Geometry)</h1><p>这章将从几何的角度理解之前提及的一些概念。</p>
<h2 id="范数-Norm"><a href="#范数-Norm" class="headerlink" title="范数(Norm)"></a>范数(Norm)</h2><p>范数实际上就是向量的一个长度<br><img src="https://img-blog.csdnimg.cn/20210419083819764.png" alt="在这里插入图片描述"><br>范数有以下性质：<br><img src="https://img-blog.csdnimg.cn/20210419083913865.png" alt="在这里插入图片描述"></p>
<ul>
<li>第一个绝对齐次（？）实际上数量积不就是对向量长度的一个延伸，所以，缩放的量可以提出来。</li>
<li>第二个三角不等式，因为两个向量和这两个向量的向量和会形成一个三角形，三角形有一个性质就是两边之和大于等于第三边</li>
<li>最后一个是因为长度是非负的</li>
</ul>
<p>下面是两种不同的范数，这种区别是对距离的定于不同导致的。</p>
<h3 id="曼哈顿范数（Manhattan-Norm）"><a href="#曼哈顿范数（Manhattan-Norm）" class="headerlink" title="曼哈顿范数（Manhattan Norm）"></a>曼哈顿范数（Manhattan Norm）</h3><p><img src="https://img-blog.csdnimg.cn/20210419084501411.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>由上图可以了解到曼哈顿距离和欧几里得距离的区别，这样曼哈顿距离就是对应的向量（坐标）所有元素的绝对值之和。其实就是点在水平和竖直方向的位移总和。($x_i$表示向量的元素，$|\cdot|$表示绝对值)<br><img src="https://img-blog.csdnimg.cn/20210419084753190.png" alt="在这里插入图片描述"><br>表示方式：$\ell_1$</p>
<h3 id="欧几里得范数（Euclidean-Norm）"><a href="#欧几里得范数（Euclidean-Norm）" class="headerlink" title="欧几里得范数（Euclidean Norm）"></a>欧几里得范数（Euclidean Norm）</h3><p>这个使用的就是直观的“直线距离”：<br><img src="https://img-blog.csdnimg.cn/20210419090116185.png" alt="在这里插入图片描述"><br>表示方式：$\ell_2$</p>
<p>曼哈顿范数（左）和欧几里得范数（右）的实例：<br><img src="https://img-blog.csdnimg.cn/20210419092014679.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="内积（Inner-Product）"><a href="#内积（Inner-Product）" class="headerlink" title="内积（Inner Product）"></a>内积（Inner Product）</h2><p>内积可以理解为，两个向量在同一向量空间（转换后）下的长度的乘积。<br><code>点积</code>：两维度相同的向量相乘最后得到一个实数。</p>
<script type="math/tex; mode=display">x^\top y = \sum_{i=1}^{n}x_iy_i</script><p>点积的几何含义：<br><img src="https://img-blog.csdnimg.cn/20210419123348905.png?x-oss-process=imag,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>所以从图像上看，可以得到部分点积的性质：当两向量相反的时候，点积为负数；当两向量垂直的时候，点积为0（在另一个向量的投影的长度为0）。当两向量方向相同的时候，点积为正。<br>内积的齐次性和对称性：两个向量哪个投影至哪个其实并没有什么区别，所以，二者乘积的顺序是无关紧要的。</p>
<blockquote>
<p>点积为什么是这样计算的？<br><img src="https://img-blog.csdnimg.cn/20210419124954776.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2021041913015911.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</blockquote>
<h3 id="广义内积"><a href="#广义内积" class="headerlink" title="广义内积"></a>广义内积</h3><p><code>双线性映射</code>（bilinear mapping）<br><img src="https://img-blog.csdnimg.cn/20210419092253723.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>当映射的参数顺序交换后，映射结果保持一致，这种性质称为<code>对称</code>(symmetric).当映射结果不会小于0， 这种性质称为<code>正定</code>（positive definite）<br><img src="https://img-blog.csdnimg.cn/20210419093426481.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这样，内积的广义定义就是一个正定、对称的双线性映射。<br><img src="https://img-blog.csdnimg.cn/20210419093519239.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>内积空间是不是就是向量空间中两两通过运算之后得到一个实数的向量组成的空间？理解一下上图最后一句化的含义。<br><img src="https://img-blog.csdnimg.cn/20210419105239390.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</blockquote>
<h3 id="对称正定矩阵（Symmetric-Positive-Definite-Matrices）"><a href="#对称正定矩阵（Symmetric-Positive-Definite-Matrices）" class="headerlink" title="对称正定矩阵（Symmetric, Positive Definite Matrices）"></a>对称正定矩阵（Symmetric, Positive Definite Matrices）</h3><p><img src="https://img-blog.csdnimg.cn/20210419131322340.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>由于内积是正定的，所以有上式可以得出：</p>
<script type="math/tex; mode=display">\forall x \in V \backslash \{0\}:x^T\bold Ax > 0</script><p>$x$是任意的非零向量。<br>对于一个满足上式的对称矩阵，称为<strong>正定矩阵</strong></p>
<script type="math/tex; mode=display">\forall x \in V \backslash \{0\}:x^T\bold Ax \ge 0</script><p>满足上式的对称矩阵称为<strong>半正定矩阵</strong></p>
<p>可以使用一个正定矩阵定义一个内积：<br><img src="https://img-blog.csdnimg.cn/20210419132359212.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210419133148481.png" alt="在这里插入图片描述"><br>因为矩阵$\bold A$正定，所以$\bold x^T \bold A \bold x&gt;0$。这一就是说，$\bold A\bold x\ne 0$所以A的零空间只能是$\bold 0$。同时，对角线的元素都大于0，原因如下：<br><img src="https://img-blog.csdnimg.cn/20210419133529785.png" alt="在这里插入图片描述"></p>
<h2 id="长度与距离（Lengths-and-Distances）"><a href="#长度与距离（Lengths-and-Distances）" class="headerlink" title="长度与距离（Lengths and Distances）"></a>长度与距离（Lengths and Distances）</h2><p>内积和范数之间的关系十分紧密。这样理解，（在欧氏几何内）内积其实就是一个向量在另一个向量上投影之后，得到的向量，这两个向量的长度的乘积就是内积。范数简单来说就是向量的长度。所以，两个相同的向量的内积就是这个向量的范数的平方。</p>
<script type="math/tex; mode=display">\|x\| := \sqrt {\langle x, x\rangle}</script><p><strong>柯西-施瓦茨不等式</strong>（Cauchy-Schwarz Inequality）：<br><img src="https://img-blog.csdnimg.cn/20210419202022580.png" alt="在这里插入图片描述"><br>对于这个公式用图形非常好理解：不等式左边是投影之后的两向量的乘积（见之前点积部分介绍的投影），而右边是两向量没有经过投影的长度乘积。而只有两向量相等的时候，一个向量投影到另一个向量不会损失长度，这时候不等式取得等号，否则投影之后的向量长度都会变小。<br>在欧几里得空间中有特例：<br><img src="https://img-blog.csdnimg.cn/20210419202410822.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>距离和度规</strong>（Distance and Metric）：<br><strong>距离</strong>的定义：<br><img src="https://img-blog.csdnimg.cn/20210419202803485.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>度规</strong>的定义：<br>在数学中，度量（度规）或距离函数是个函数，定义了集合内每一对元素之间的距离。<br><img src="https://img-blog.csdnimg.cn/20210419202929939.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>度规和内积有类似的性质，但是他们在某方面又是不同的。当两个向量越接近的时候，内积越大，而度规越小。</p>
<h2 id="夹角与正交性-Angles-and-Orthogonality"><a href="#夹角与正交性-Angles-and-Orthogonality" class="headerlink" title="夹角与正交性(Angles and Orthogonality)"></a>夹角与正交性(Angles and Orthogonality)</h2><p>内积可以用于定义<strong>两向量的夹角</strong>：<br>由之前提到的的柯西-施瓦茨不等式：<script type="math/tex">|\langle\boldsymbol{x}, \boldsymbol{y}\rangle| \leqslant\|\boldsymbol{x}\|\|\boldsymbol{y}\|</script>可以得到：</p>
<script type="math/tex; mode=display">-1 \leqslant \frac{\langle\boldsymbol{x}, \boldsymbol{y}\rangle}{\|\boldsymbol{x}\|\|\boldsymbol{y}\|} \leqslant 1</script><p><img src="https://img-blog.csdnimg.cn/20210420164254641.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210420164311265.png" alt="在这里插入图片描述">在这个范围内，余弦函数的单调的。$\omega$用来表示两个向量的相近程度。<br>内积更重要的是可以为定义<strong>两向量的正交性</strong>:<br><img src="https://img-blog.csdnimg.cn/20210420165005906.png" alt="在这里插入图片描述"><br>两向量正交实际上就是他们之间的夹角为$90\degree$,这时候的余弦值为0，由</p>
<script type="math/tex; mode=display">\cos \omega=\frac{\langle\boldsymbol{x}, \boldsymbol{y}\rangle}{\|\boldsymbol{x}\|\|\boldsymbol{y}\|}</script><p>因为$|\bold x|$和$|\bold y|$都是正定的，所以当$\cos \omega = 0$是，$\langle \bold x, \bold y \rangle$等于0.当x、y的范数（长度）为1时，称为<strong>规范化正交</strong>(orthonormal).当一个向量是$\bold 0$时，它与所有的向量都正交。<br>正交依赖于内积，所以在不同的内积的情况下，正交性可能不同。</p>
<p><strong>正交矩阵</strong><br><img src="https://img-blog.csdnimg.cn/20210420165940150.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>转置矩阵的变换关系？</p>
</blockquote>
<script type="math/tex; mode=display">\|A x\|^{\top}=(A x)^{\top}(A x)=x^{\top} A^{\top} A x=x^{\top} \boldsymbol{I} x=x^{\top} x=\|x\|^{2}</script><script type="math/tex; mode=display">\cos \omega=\frac{(\boldsymbol{A} \boldsymbol{x})^{\top}(\boldsymbol{A} \boldsymbol{y})}{\|\boldsymbol{A} \boldsymbol{x}\|\|\boldsymbol{A} \boldsymbol{y}\|}=\frac{\boldsymbol{x}^{\top} \boldsymbol{A}^{\top} \boldsymbol{A} \boldsymbol{y}}{\sqrt{\boldsymbol{x}^{\top} \boldsymbol{A}^{\top} \boldsymbol{A} \boldsymbol{x} \boldsymbol{y}^{\top} \boldsymbol{A}^{\top} \boldsymbol{A} \boldsymbol{y}}}=\frac{\boldsymbol{x}^{\top} \boldsymbol{y}}{\|\boldsymbol{x}\|\|\boldsymbol{y}\|}</script><p>由上可知，向量在经过正交变换之后，他们之间的夹角和长度都没有发生变化，实际上，正交变换就是将向量进行旋转操作。</p>
<h3 id="规范正交基（Orthonormal-Basis）"><a href="#规范正交基（Orthonormal-Basis）" class="headerlink" title="规范正交基（Orthonormal Basis）"></a>规范正交基（Orthonormal Basis）</h3><p><img src="https://img-blog.csdnimg.cn/2021042017035145.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>一对规范正交基满足两个条件，<del>二者之间的夹角和他们各自的长度。</del> 规范（长度为1）且正交（两对基相互垂直）</p>
<blockquote>
<p><strong>格拉姆-施密特正交化 Gram–Schmidt process</strong><br>这里时利用高斯消元法来取得正交规范正交基<img src="https://img-blog.csdnimg.cn/20210420171209130.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="正交补（Orthogonal-Complement）"><a href="#正交补（Orthogonal-Complement）" class="headerlink" title="正交补（Orthogonal Complement）"></a>正交补（Orthogonal Complement）</h3><p><img src="https://img-blog.csdnimg.cn/20210420213004774.png" alt="在这里插入图片描述"><br>一个向量空间的两个子空间，这两个子空间的维度之和等于原先的向量空间的维度，准确来说，一个子空间占领原空间的部分维度，另一个子空间占领剩余的维度，二者在维度上没有关系。<br>一个实例<br><img src="https://img-blog.csdnimg.cn/20210420213347790.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</blockquote>
<p>这样，原先向量空间中的任意向量，都可以用这个子空间的有序基以及其正交补的有序基表示出来（分解）：</p>
<script type="math/tex; mode=display">\boldsymbol{x}=\sum_{m=1}^{M} \lambda_{m} \boldsymbol{b}_{m}+\sum_{j=1}^{D-M} \psi_{j} \boldsymbol{b}_{j}^{\perp}, \quad \lambda_{m}, \psi_{j} \in \mathbb{R}</script><p>其中，$\boldsymbol x$是原先的向量空间的一个向量，$\bold b$是原先空间的一个子空间的有序基，$\bold b^{\perp}$是这个子空间的正交补的有序基。<br><img src="https://img-blog.csdnimg.cn/20210420213930621.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="函数的内积"><a href="#函数的内积" class="headerlink" title="函数的内积"></a>函数的内积</h2><p>有之前的点积：</p>
<script type="math/tex; mode=display">x^Ty = \sum_{i = 1}^nx_iy_i</script><p>当向量的维度有无限维时，可以将这个利用定积分的定义，写成积分形式。</p>
<script type="math/tex; mode=display">\int_{a}^{b}f(x) = \lim_{\lambda \rarr 0}\sum_{i=1}^nf(\xi_i)\Delta x_i,\quad \lambda = max\{\Delta x_1,\Delta x_2,...,\Delta x_n\}</script><p>从而：<br><img src="https://img-blog.csdnimg.cn/20210420220554149.png" alt="在这里插入图片描述"></p>
<p>当两个函数在一定区间上的定积分为0时，说这两个函数时正交函数。</p>
<blockquote>
<p>所有的正交函数够成的一个子空间<img src="https://img-blog.csdnimg.cn/2021042022121317.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>想要正确理解这个无穷维向量的内积，需要将积分延伸到希尔伯特空间（Hilbert space）中。</p>
</blockquote>
<h2 id="正交投影（Orthogonal-Projections）"><a href="#正交投影（Orthogonal-Projections）" class="headerlink" title="正交投影（Orthogonal Projections）"></a>正交投影（Orthogonal Projections）</h2><p>在机器学习中，由于研究对象通常由多标签组成的，所以就不得不使用高维矩阵，但是实际上，大多数的信息仅仅存储在少部分的标签中，所以，当需要对矩阵进行可视化或者数据压缩的时候，为了减少造成的信息损失，可以使用正交投影，这样压缩之后的数据损失最小。<br>下面是对投影的定义：<br><img src="https://img-blog.csdnimg.cn/20210421103057918.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>$\pi^2 = \pi \circ \pi = \pi$怎么理解？<br><del>应该是对一个向量进行两次投影的与进行一次投影的效果是一致的。</del> 假设一个向量被正交投影到向量空间V中，然后再被正交投影到W中，那么这个向量可以直接利用一次正交变换投影到W中.<br>类似于$A\perp B, B\perp C\Rightarrow A\perp C$<br><img src="https://img-blog.csdnimg.cn/20210421213521182.png" alt="在这里插入图片描述"></p>
</blockquote>
<p>投影本质上就是一种对向量的变换，所以可以用矩阵来描述，所以投影操作对应的矩阵就是<strong>投影矩阵</strong>（projection matrices，$\bold P<em>{\pi}^2 = \bold P</em>{\pi}$）</p>
<h3 id="正交投影到一维子空间"><a href="#正交投影到一维子空间" class="headerlink" title="正交投影到一维子空间"></a>正交投影到一维子空间</h3><p>可以通过以下三步求解投影矩阵：<br><img src="https://img-blog.csdnimg.cn/20210421214613478.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>1.找到坐标$\lambda$:</strong></p>
<script type="math/tex; mode=display">\left\langle\boldsymbol{x}-\pi_{U}(\boldsymbol{x}), \boldsymbol{b}\right\rangle=0 \stackrel{\pi_{U}(\boldsymbol{x})=\lambda \boldsymbol{b}}{\Longleftrightarrow}\langle\boldsymbol{x}-\lambda \boldsymbol{b}, \boldsymbol{b}\rangle=0$$注意到$\boldsymbol{x}-\pi_{U}(\boldsymbol{x})$是向量及其投影向量做差之后得到的向量，所以与投影到的向量正交。因为投影之后的向量属于向量空间U，所以可以用U中的有序基线性$\bold b$表示。
$$\langle\boldsymbol{x}, \boldsymbol{b}\rangle-\lambda\langle\boldsymbol{b}, \boldsymbol{b}\rangle=0 \Longleftrightarrow \lambda=\frac{\langle\boldsymbol{x}, \boldsymbol{b}\rangle}{\langle\boldsymbol{b}, \boldsymbol{b}\rangle}=\frac{\langle\boldsymbol{b}, \boldsymbol{x}\rangle}{\|\boldsymbol{b}\|^{2}} .</script><p>这里是利用了内积的双线性的性质，将原先的式子进行了拆分，最后的等式是利用了内积的对称性。之后分离出$\lambda$，任务完成。</p>
<script type="math/tex; mode=display">\lambda=\frac{\boldsymbol{b}^{\top} \boldsymbol{x}}{\boldsymbol{b}^{\top} \boldsymbol{b}}=\frac{\boldsymbol{b}^{\top} \boldsymbol{x}}{\|\boldsymbol{b}\|^{2}}</script><p>（这里探究当内积为点积的情况）</p>
<p><strong>2.找到投影点（投影后的向量）：</strong></p>
<script type="math/tex; mode=display">\pi_{U}(\boldsymbol{x})=\lambda \boldsymbol{b}=\frac{\langle\boldsymbol{x}, \boldsymbol{b}\rangle}{\|\boldsymbol{b}\|^{2}} \boldsymbol{b}=\frac{\boldsymbol{b}^{\top} \boldsymbol{x}}{\|\boldsymbol{b}\|^{2}} \boldsymbol{b}</script><p>将之前的结果带入式中，最后的等式为当内积为点积的时候成立。</p>
<script type="math/tex; mode=display">\left\|\pi_{U}(\boldsymbol{x})\right\| \stackrel{(3.42)}{=} \frac{\left|\boldsymbol{b}^{\top} \boldsymbol{x}\right|}{\|\boldsymbol{b}\|^{2}}\|\boldsymbol{b}\| \stackrel{(3.25)}{=}|\cos \omega|\|\boldsymbol{x}\|\|\boldsymbol{b}\| \frac{\|\boldsymbol{b}\|}{\|\boldsymbol{b}\|^{2}}=|\cos \omega|\|\boldsymbol{x}\| .</script><p>点积为内积的情况下,同时，联立了$\cos \omega=\frac{\langle\boldsymbol{x}, \boldsymbol{y}\rangle}{|\boldsymbol{x}||\boldsymbol{y}|}$</p>
<p><strong>3.找到投影矩阵</strong></p>
<script type="math/tex; mode=display">\pi_{U}(\boldsymbol{x})=\lambda \boldsymbol{b}=\boldsymbol{b} \lambda=\boldsymbol{b} \frac{\boldsymbol{b}^{\top} \boldsymbol{x}}{\|\boldsymbol{b}\|^{2}}=\frac{\boldsymbol{b} \boldsymbol{b}^{\top}}{\|\boldsymbol{b}\|^{2}} \boldsymbol{x}</script><p>于是：</p>
<script type="math/tex; mode=display">\bold P_\pi = \frac{\bold b\bold b^T}{\|\bold b\|^2}</script><p>这样看投影矩阵就是一个对称矩阵。</p>
<h3 id="正交投影到一般的子空间"><a href="#正交投影到一般的子空间" class="headerlink" title="正交投影到一般的子空间"></a>正交投影到一般的子空间</h3><p>假设一个子空间$U \subseteq \mathbb R^n, \quad dim(U)\ge1$,因为投影的向量属于U，所以，这个投影向量可以用U的有序基表示出来：</p>
<script type="math/tex; mode=display">\bold \pi_U(\bold x) =\sum\limits_{i=1}^m\lambda_i\bold b_i</script><p><strong>1.找出投影的坐标</strong>$\lambda_1,\lambda_2…,\lambda_n$:</p>
<script type="math/tex; mode=display">\bold\pi_U(\bold x) = \sum\limits_{i=1}^m\lambda_i\bold b_i = \bold B\bold\lambda\\\bold B=[\bold b_1,...,\bold b_m]\in\mathbb R^{n\times m},\quad\lambda=[\lambda_1,...,\lambda_m]^T\in\mathbb R^m</script><p>假设内积为点乘：</p>
<script type="math/tex; mode=display">\left\langle\boldsymbol{b}_{1}, \boldsymbol{x}-\pi_{U}(\boldsymbol{x})\right\rangle=\boldsymbol{b}_{1}^{\top}\left(\boldsymbol{x}-\pi_{U}(\boldsymbol{x})\right)=0\\\vdots\\\left\langle\boldsymbol{b}_{m}, \boldsymbol{x}-\pi_{U}(\boldsymbol{x})\right\rangle=\boldsymbol{b}_{m}^{\top}\left(\boldsymbol{x}-\pi_{U}(\boldsymbol{x})\right)=0</script><p>由$\bold\pi_U = \bold B\bold\lambda$,带入到上式中：</p>
<script type="math/tex; mode=display">\bold b^T_1(\bold x - \bold B\bold\lambda)=0\\\vdots\\\bold b^T_m(\bold x-\bold B\lambda)=0</script><p>转换成矩阵形式：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\left[\begin{array}{c}
b_{1}^{\top} \\
\vdots \\
b_{m}^{\top}
\end{array}\right][x-B \lambda]=0 & \Longleftrightarrow B^{\top}(x-B \lambda)=0 
& \Longleftrightarrow B^{\top} B \lambda=B^{\top} x .
\end{aligned}</script><p>因为$\bold B$是U的有序基，所以他是可逆的，所以可以得到：</p>
<script type="math/tex; mode=display">\lambda=(\bold B^T\bold B)^{-1}\bold B^T\bold x</script><p>其中：$(\bold B^T\bold B)^{-1}\bold B^T$称为伪逆，可以用于计算非方阵矩阵。<br><strong>2.找到投影向量：</strong><br>由$\pi_U = \bold B\lambda$,带入上式：</p>
<script type="math/tex; mode=display">\pi_U(x) = \bold B(\bold B^T\bold B)^{-1}\bold B^T\bold x</script><p><strong>3.找到投影矩阵：</strong><br>由$\bold P_\pi \bold x=\pi_U(\bold x)$,由上式可以得出：</p>
<script type="math/tex; mode=display">\bold P_\pi=\bold B(\bold B^T\bold B)^{-1}\bold B^T</script><blockquote>
<p>原始向量与投影向量之差够成的向量的范数，称为<strong>重构误差</strong>（reconstruction error.）或者投影误差。<img src="https://img-blog.csdnimg.cn/20210422110018669.png" alt="在这里插入图片描述"></p>
</blockquote>
<p>虽然说$\pi_U(\bold x)\in \mathbb R^n$但是我们只需要用U的有序基就可以表示$\pi_U(\bold x)$</p>
<p>用正交投影可以用于求非齐次方程$\bold A\bold x=\bold b$无解的时候的近似解。当这个方程无解的时候，说明$\bold x$和$\bold b$不在同一个向量空间中，所以无法通过一些变换（$\bold A$）得到$\bold b$。这时候可以利用正交投影，将其中一个向量投影到另一个向量的向量空间中，这样可以得到一个近似解，其中的主要思想就是找到一个在A的张成空间中，与b最相近的向量。这样得到的解称为<strong>最小二乘解</strong>（least-squares solution）</p>
<h3 id="格拉姆-施密特正交化（Gram-Schmidt-Orthogonalization）"><a href="#格拉姆-施密特正交化（Gram-Schmidt-Orthogonalization）" class="headerlink" title="格拉姆-施密特正交化（Gram-Schmidt Orthogonalization）"></a>格拉姆-施密特正交化（Gram-Schmidt Orthogonalization）</h3><p><img src="https://img-blog.csdnimg.cn/20210422124223522.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>这里的目标是求出$u<em>2$，利用已知的数据$b_2,u_1$计算出$\pi</em>{span[u<em>1]}(b_2)$这样就可以利用$b_2,\pi</em>{span[u_1]}(b_2)$计算$u_2$了。</p>
</blockquote>
<p>我们可以使用向量以及其投影所在的向量空间的有序基作差，得到一个法向量。然后递归地将有序基转化成正交基。</p>
<script type="math/tex; mode=display">\bold {\mathcal u}:=\bold b_1 \\ \mathcal u_k:=\bold b_k- \pi_{span[\bold u_1,\dots,\bold u_{k-1}]}(\bold b_k),\quad k =2,\dots,n</script><p>其中，$\bold b<em>k$是之前缔造的正交向量组成的向量空间（$\bold u_1,\dots,\bold u</em>{k-1}$）</p>
<h3 id="在仿射空间中的正交投影"><a href="#在仿射空间中的正交投影" class="headerlink" title="在仿射空间中的正交投影"></a>在仿射空间中的正交投影</h3><p><img src="https://img-blog.csdnimg.cn/2021042214030141.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>先将目标向量与支撑点($\bold x_0$)相减，得到的向量就是以仿射空间为起点的，这时候，问题就转换成我们之前讨论过的问题了。<script type="math/tex">\pi_L(\bold x)=\bold x_0+\pi_U(\bold x-\bold x_0)</script><br><img src="https://img-blog.csdnimg.cn/20210422140821843.png" alt="在这里插入图片描述"></p>
<h2 id="旋转变换"><a href="#旋转变换" class="headerlink" title="旋转变换"></a>旋转变换</h2><p>旋转实际上就是一种正交变换。在文中规定当旋转角度为正数的时候，图像作逆时针旋转。<br><img src="https://img-blog.csdnimg.cn/20210422142037260.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="在二维实空间中的旋转（Rotations-in-mathbb-R-2-）"><a href="#在二维实空间中的旋转（Rotations-in-mathbb-R-2-）" class="headerlink" title="在二维实空间中的旋转（Rotations in $\mathbb R^2$）"></a>在二维实空间中的旋转（Rotations in $\mathbb R^2$）</h3><p><img src="https://img-blog.csdnimg.cn/20210422144422923.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>因为旋转之后的基向量仍然是线性无关的，所以，旋转也是一种基变换。由上可以得到旋转矩阵（旋转之后的向量）：</p>
<script type="math/tex; mode=display">\Phi\left(\boldsymbol{e}_{1}\right)=\left[\begin{array}{c}\cos \theta \\ \sin \theta\end{array}\right], \quad \Phi\left(\boldsymbol{e}_{2}\right)=\left[\begin{array}{c}-\sin \theta \\ \cos \theta\end{array}\right]</script><script type="math/tex; mode=display">\boldsymbol{R}(\theta)=\left[\begin{array}{ll}\Phi\left(\boldsymbol{e}_{1}\right) & \Phi\left(\boldsymbol{e}_{2}\right)\end{array}\right]=\left[\begin{array}{cc}\cos \theta & -\sin \theta \\ \sin \theta & \cos \theta\end{array}\right] .</script><h3 id="在三维实空间中的旋转-Rotations-in-mathbb-R-2"><a href="#在三维实空间中的旋转-Rotations-in-mathbb-R-2" class="headerlink" title="在三维实空间中的旋转(Rotations in $\mathbb R^2$)"></a>在三维实空间中的旋转(Rotations in $\mathbb R^2$)</h3><p><img src="https://img-blog.csdnimg.cn/20210422145419775.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>可以这样理解，先固定一个坐标轴，然后从上往下看去，得到这个向量在另外两个基向量所形成的向量空间中正交投影，然后再作相应的旋转操作。</p>
<p>关于$\bold e_1$的旋转操作：</p>
<script type="math/tex; mode=display">\bold R_1(\theta)=\left[\begin{array}{c}    \Phi(\bold e_1)&\Phi(\bold e_2) &\Phi(\bold e_3)   \end{array}\right]=\left[\begin{array}{c} 1&0&0 \\0&\cos\theta&-\sin\theta\\0&\sin\theta&\cos\theta       \end{array}\right]</script><p>类似的，只要固定哪个坐标轴，哪个坐标轴就是基向量。</p>
<h3 id="在-mathcal-n-维空间中的旋转"><a href="#在-mathcal-n-维空间中的旋转" class="headerlink" title="在$\mathcal n$维空间中的旋转"></a>在$\mathcal n$维空间中的旋转</h3><p><strong>吉文斯旋转</strong>（Givens Rotation）：<br><img src="https://img-blog.csdnimg.cn/20210422150526421.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>实际上就是等价于单位矩阵对应位置上变成一个正弦或者余弦值。</p>
<h3 id="旋转的特性"><a href="#旋转的特性" class="headerlink" title="旋转的特性"></a>旋转的特性</h3><p>简单来说就是变换之后向量之间的距离角度不变，三维及三维以上的旋转操作不满足交换律，二维的满足。<br><img src="https://img-blog.csdnimg.cn/20210422151402308.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6%EF%BC%9A%EF%BC%88%E4%B8%80%EF%BC%89%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6%EF%BC%9A%EF%BC%88%E4%B8%80%EF%BC%89%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/" class="post-title-link" itemprop="url">机器学习中的数学：（一）线性代数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-21 10:22:36" itemprop="dateCreated datePublished" datetime="2021-04-21T10:22:36+08:00">2021-04-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-08 19:48:46" itemprop="dateModified" datetime="2023-03-08T19:48:46+08:00">2023-03-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><font color="#999AAA">本博客是对MATHEMATICS FOR MACHINE LEARNING的学习笔记，因为是全英文的书籍，所以在每节之后都会收集一些相关的术语，然后笔记中也可能会加入一些英文。当然，作为一个个人笔记，我会加入一些自己的理解，这些理解可能会因为自己的能力有限而不够深入并且有较大的局限性，但是，我会不断复习自己的笔记，并不断更新自己的理解。这正如孔子所说的：温故而知新，可以为师矣。<br>ps:想要这本书的电子版可以私信我。<br>pps:我认为大脑能更加轻易地记忆图片，图片会比文字更好理解，所以我会尽可能的多加一些图片在笔记中。<br><img src="https://img-blog.csdnimg.cn/20210406162047999.jpg?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></font></p>
<p>&lt;hr style=” border:solid; width:100px; height:1px;” color=#000000 size=1”&gt;</p>
<p>@[toc]</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这部分讲解了书籍的组成，对书籍的各个章节做了一些简要的介绍，并探讨了书籍的学习方式。<br>总的来说，这本书分为两个部分，上半部分是将一些数学基础包含线性代数(Linear Algebra)、分析几何(Analytic Geometry)、矩阵分解(Matrix Decomposition)和概率论(Probability Theoty)，第二部分是讲解机器学习的四大支柱(pillars)技术。<br><img src="https://img-blog.csdnimg.cn/20210406170211452.jpg?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>文中提及了两种学习模式：自顶向下和自底向上。两种方法都有各自的优势和劣势。我的学习模式类似于自底向上，先完成数学理论知识的学习然后再将学过的数学知识用于机器学习理论的学习中，这个过程帮助我进一步强化学过的数学知识，就当一个复习的过程。</p>
<p>&lt;hr style=” border:solid; width:100px; height:1px;” color=#000000 size=1”&gt;</p>
<p><font color="#999AAA">一些题外话：在我接触机器学习的一些理论的时候，我发现这些理论在一定程度上与人类自己的认知过程有一定的相似之处，所以，我觉得将用这些理论去思考自己的学习过程，并且用自己的学习过程去理解这些理论都是可以帮助自己更好地提升对“学习”的理解。</font></p>
<h1 id="Linear-Algebra"><a href="#Linear-Algebra" class="headerlink" title="Linear Algebra"></a>Linear Algebra</h1><blockquote>
<p>Linear algebra is the study of vectors and certain algebra rules to manipulate vectors.</p>
</blockquote>
<p>线性代数就是向量+对向量的操作。而向量就是一个数据集，对应着具体事物的不同属性。放到空间中，向量就是方向+数量（direction and magnitude）。我们需要弄清楚的是，在不同的情形下，对向量的运算会对这些数字所对应的属性产生什么变化。例如两个向量的相加，可会将原先的向量在长度和方向上的变化。</p>
<p><div align="center"><br><img src="https://img-blog.csdnimg.cn/20210407165522874.png"></div></p>
<p><font color="#999AAA"><br>前半部分介绍线性代数的基础知识，我只记录自己不熟悉的部分和大致内容。</font></p>
<h2 id="Foundations"><a href="#Foundations" class="headerlink" title="Foundations"></a>Foundations</h2><h3 id="逆"><a href="#逆" class="headerlink" title="逆"></a>逆</h3><p> 公式法：$A^{-1} = \frac{A^*}{|A|}$<br>     解方程：$AX=I_n$ 求解   $[A|I_n] - &gt;[I_n|A^{-1}]$</p>
<h3 id="解方程"><a href="#解方程" class="headerlink" title="解方程"></a>解方程</h3><p> 通解 = 非齐次特解 + 非齐次通解<br><img src="https://img-blog.csdnimg.cn/20210410102846896.png" alt="在这里插入图片描述"><br><strong>The Minus-1 Trick</strong>（快速求解齐次方程通解）<br>在行阶梯矩阵中，添加单位行向量，非零元素对应非主元元素位置，此时原先非主元元素所在的列向量就是通解向量。<br>原矩阵：</p>
<script type="math/tex; mode=display">A=\begin{bmatrix} 1 & 3 & 0 & 0 & 3 \\ 0&0&1&0&9 \\ 0&0&0&1&-4\end{bmatrix}</script><p>增广矩阵：<br><img src="https://img-blog.csdnimg.cn/20210411130138978.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>通解：</p>
<script type="math/tex; mode=display">\left\{ x\in \mathbb R^5:x=\lambda_1\begin{bmatrix}3\\-1\\0\\0\\0\end{bmatrix}+ \lambda_2\begin{bmatrix}3\\0\\9\\-1\\-1\end{bmatrix}, \lambda_1,\lambda_2\in \mathbb R
\right\}</script><h4 id="计算线性方程-Ax-b"><a href="#计算线性方程-Ax-b" class="headerlink" title="计算线性方程$Ax = b$"></a>计算线性方程$Ax = b$</h4><p>如果A是方阵并且可逆，可以通过逆直接求出来：$x = A^{-1}b$<br>推广至一般矩阵，需要用到<strong>伪逆（Moore-Penrose pseudo-inverse）</strong>：</p>
<script type="math/tex; mode=display">Ax = b \Leftrightarrow A^TAx=A^Tb \Leftrightarrow x = (A^TA)^{-1}A^Tb</script><p>$(A^TA)^{-1}A^T$:Moore-Penrose pseudo-inverse<br>但是这方法需要大量的矩阵运算，可能会在计算精度上有损失</p>
<blockquote>
<p>这个逆是泛化的矩阵的逆，标记为$A^+$。这里是巧妙地规避了对非方阵矩阵的求逆，而不改变原先的属性。对于一个任意矩阵$A$, $(A^\top A)^{-1}A^\top=A^{-1}(A^\top)^{-1}A^\top=A^{-1}$<br>它可以用于奇异值分解。</p>
</blockquote>
<p>还可以使用<strong>高斯消元法</strong>，这个方法虽然广泛使用，但是需要立方数量级的算数运算，计算较大。</p>
<p>还有一种<strong>迭代方法</strong>（Iterative method）:</p>
<script type="math/tex; mode=display">x^{(k+1)}=Cx^{(k)}+d</script><p>在迭代的过程中，残差（residual error）：$|x^{(k+1)}-x<em>*|$,不断减小，最终向$x</em>*$收敛</p>
<h3 id="Hadamard-product"><a href="#Hadamard-product" class="headerlink" title="Hadamard product"></a>Hadamard product</h3><p>矩阵对应位置元素相乘。<br><img src="https://img-blog.csdnimg.cn/20210410101439335.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210410101504335.png" alt="在这里插入图片描述"></p>
<h3 id="向量空间（Vector-Space）"><a href="#向量空间（Vector-Space）" class="headerlink" title="向量空间（Vector Space）"></a>向量空间（Vector Space）</h3><p><del>Group: Object + Operations</del> </p>
<p><img src="https://img-blog.csdnimg.cn/20210413102520215.png" alt="在这里插入图片描述"><br>我对这个定义的理解是，<del>一个向量经过外积和向量积所能表示的所有的向量</del>一个向量经过线性组合和数乘得到的所有的向量，这些所有的向量组成的空间就是这个向量的向量空间。（张成空间：两向量的全部线性组合构成的向量空间）</p>
<blockquote>
<p>将一个向量看成向量空间中的一个点，这个点乘以所有的实数得到的所有的向量组成一条直线，这条直线就是这个向量张成的向量空间($\mathbb R$)。它与另外一个不平行的直线的所有的线性组合会得到一个平面，这就是两个向量张成的二维空间($\mathbb R^2$)</p>
<p><strong>对这个定义的理解还需要补充</strong></p>
</blockquote>
<p><strong>线性的严格定义：</strong><script type="math/tex">L(c \vec v) = cL(\vec v)\\ L(\vec v + \vec w) = L(\vec v)+L(\vec w)</script><br>将L当成一种变换，对向量进行数量积之后进行变换和变换之后对向量进行数量积的结果是一致的。<br>拥有这种性质的算子很多， 例如求导：$\frac{d}{dx}(4x^2) = 4\times \frac{d}{dx}(x^2)$</p>
<h4 id="向量子空间（Vector-subspace）"><a href="#向量子空间（Vector-subspace）" class="headerlink" title="向量子空间（Vector subspace）"></a>向量子空间（Vector subspace）</h4><p>向量子空间需要满足加法封闭性和数乘封闭性。也就是向量子空间中的向量在经过任意的数乘或线性组合之后得到的向量仍在这个子空间中。<br><img src="https://img-blog.csdnimg.cn/20210414105134656.png" alt="在这里插入图片描述"><br><del>判断是否为向量子空间，需要满足封闭性，也就是经过对应的运算之后，向量仍旧属于原先的向量空间。</del> </p>
<blockquote>
<p>例：<br><img src="https://img-blog.csdnimg.cn/20210414105953434.png" alt="the closure property is violated;"><br>the closure property is violated;因为向量空间需要满足加法封闭性，也就是说在这个空间中向量之间的运算之后的向量，需要还在这个空间中，上面这个空间显然不满足这个条件。</p>
</blockquote>
<h2 id="线性无关"><a href="#线性无关" class="headerlink" title="线性无关"></a>线性无关</h2><p>矩阵线性无关就是说每一个都是相互独立的，不能由其他向量表示出来。表现在公式上：</p>
<script type="math/tex; mode=display">\sum_{i=1}^{k} \lambda_ix_i = 0</script><p>当且仅当上式中$\lambda$为0时，成立，说明向量$x_i$线性无关。<br>空间上理解就是，每一个向量代表一个维度，少了其中一个就会导致降维,<del>这也就是秩</del>  。当有向量对维度的没有贡献的时候，就说这个向量是线性相关的。</p>
<h2 id="Basis-and-Rank"><a href="#Basis-and-Rank" class="headerlink" title="Basis and Rank"></a>Basis and Rank</h2><h3 id="Generating-set-and-basis"><a href="#Generating-set-and-basis" class="headerlink" title="Generating set and basis"></a>Generating set and basis</h3><p><strong>生成集</strong>就是能够表示向量空间的向量集合，这也就是说生成集中向量通过线性组合等方式可以表示向量空间中的所有的向量（<u>能通过数乘和线性组合表示整个向量空间的向量</u>）。而生成集所形成的向量空间称为<strong>张成空间</strong>（span）</p>
<script type="math/tex; mode=display">V = (\mathcal{V},+,\cdot ), \mathcal{A} = \{x_1,x_2,....,x_k\} \subseteq \mathcal{V}</script><p>对于任意$\mathcal{v} \in \mathcal{V}$能被$\mathcal{A}$线性表出，则称$\mathcal{A}$是$\mathcal{V}$的一个生成集。$\mathcal{A}$所能线性表示的所有向量组成的空间成为$\mathcal{A}$的张成空间，表示为$V = span[\mathcal{A}]$<br>生成集中最小的集合成为<strong>基</strong>（basis）</p>
<p>下图展示了关于这个概念的等价描述：<br><img src="https://img-blog.csdnimg.cn/20210415113357742.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>现在有一个问题，<strong>是不是任意n个n维的线性无关的向量都是n维空间的一个生成集呢？</strong><br>并不是，因为这个n个向量可能只能形成n维空间的一个子空间，并不能表示该空间当中所有的向量，所以并不是这个空间的一个生成集。</p>
<blockquote>
<p>How can you describe it in graph?存疑</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210415114048590.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>当向量组是线性无关的时候，每一个向量代表一个维度，将向量空间的维度表示为$dim(\mathcal{V})$,如果，$\mathcal{U} \subseteq \mathcal{V}$是$\mathcal{V}$的一个子空间，则有：</p>
<script type="math/tex; mode=display">dim({\mathcal{V})} \ge dim(\mathcal{U}), if\ and \ only\ if\ \mathcal{V}=\mathcal{U}\Rightarrow dim({\mathcal{V})} = dim(\mathcal{U})</script><h3 id="Rank"><a href="#Rank" class="headerlink" title="Rank"></a>Rank</h3><p>秩可以表示为向量组中线性无关的列向量的个数，也就是向量组的向量空间的维度。其他还有一些相关的性质：<br><img src="https://img-blog.csdnimg.cn/20210416103201764.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="线性映射（Linear-Mappings-vector-space-homomorphism-linear-transformation）"><a href="#线性映射（Linear-Mappings-vector-space-homomorphism-linear-transformation）" class="headerlink" title="线性映射（Linear Mappings/vector space homomorphism/ linear transformation）"></a>线性映射（Linear Mappings/vector space homomorphism/ linear transformation）</h2><p>对于向量空间$V$和$W$的线性映射$\Phi :V \rightarrow W$有如下定义:</p>
<script type="math/tex; mode=display">\forall \boldsymbol x,\boldsymbol y \in \boldsymbol V \ \forall \lambda, \psi \in \mathbb R:\boldsymbol\Phi(\lambda \boldsymbol x+\psi \boldsymbol y)=\lambda\boldsymbol\Phi(\boldsymbol x)+\psi\boldsymbol\Phi(\boldsymbol y)</script><p>这样的映射关系可以用矩阵表示：</p>
<script type="math/tex; mode=display">
\Phi{(\lambda x+\psi y)}=[\lambda\ \ \ \ \ \psi]\begin{bmatrix} \Phi_{(x)}  \\ \Phi_{(y)} \end{bmatrix}
\quad</script><p>下面是几个特殊的映射：<br><img src="https://img-blog.csdnimg.cn/20210416105124125.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><code>满射</code>就是y的所有元素都可以由x中的元素映射得来</p>
<p><strong>逆映射</strong>：对于映射$\Phi:\mathcal W \rightarrow \mathcal V$有 ：$\Phi(x) \circ \Psi = x$,则$\Psi$为$\Phi(x)$的逆映射，表示为$\Phi^{-1}(x)$</p>
<p>一些特殊的线性映射：<br><img src="https://img-blog.csdnimg.cn/20210416120627532.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="!\](https://img-blog.csdnimg.cn/20210416120533508.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70)"></p>
<blockquote>
<p><del>有疑问？需要理解一下</del><br><img src="https://img-blog.csdnimg.cn/20210416121342931.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这里是解释为什么复数可以表示维二维坐标的形式，因为我们可以使用双线性映射将二维坐标数组转化成复数空间中的加法形式(利用一个映射就可以转换了)</p>
<p><strong>同构</strong>：抓取一个数学对象最本质的信息（比如上面例子里的加法和乘法结构），而忽略其他没那么重要的信息（比如进制），然后把具有相同“本质信息”的对象视为一体。（例如一个对象中包含三个个体，那么所有包含三个个体的对象都可以说是同构的，因为他们都有3这个特征）<br><strong>同态</strong>：它是在两个本质不一定相同的数学对象之间建立联系（两不一定完全一致的对象是更大结构的一部分）</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210416130351294.png" alt="在这里插入图片描述"><br>这个定理表明拥有相同维度的向量空间在一定程度上是相同的。<br>$\mathbb{R}^{n\times m} \ \&amp; \ \ \mathbb{R^{nm}}$：一个是n×m矩阵一个是nm维度向量，二者的维度是一样的，而且他们之间能够通过一种线性映射（双映射）相互转换.</p>
<blockquote>
<p>如何在图形上理解n×m矩阵和nm维度向量是同形的？</p>
<h3 id="线性映射的矩阵表示"><a href="#线性映射的矩阵表示" class="headerlink" title="线性映射的矩阵表示"></a>线性映射的矩阵表示</h3><p>对于一个元组$\bold B = (\bold x_1,\bold x_2,…,\bold x_n)$中,各个向量的位置是不能交换的，也就是说这些向量的位置也是作为这个元组的一个信息，这样的元组称为<strong>有序基</strong>(ordered basis)</p>
</blockquote>
<p>在此书中，用$\bold B = (\bold x_1,\bold x_2,…,\bold x_n)$表示有序基； $\bold B = {\bold x_1,\bold x_2,…,\bold x_n}$表示（无序）基； $\bold B = [\bold x_1,\bold x_2,…,\bold x_n]$表示一个矩阵。</p>
<p>所以对于一个有序基$\bold B = {\bold {b_1},\bold {b_2}…\bold {b_n}} \subseteq \mathbb{R}^n$,对于$\mathbb {R}^n$中的所有向量，都可以由$\bold B$唯一线性表出。即：</p>
<script type="math/tex; mode=display">x \in \mathbb{R}^n,x = \alpha_1\bold {b_1}+\alpha_2\bold{b_2}+....+\alpha_n\bold {b_n}</script><p>$\bold\alpha$组成的向量就是向量$\bold x$在向量空间中以$\bold B$为基向量的坐标。</p>
<p>向量的坐标依赖于基向量，在不同的基向量中的坐标不同。<br><img src="https://img-blog.csdnimg.cn/20210416152551695.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>想要完成有一对基向量组成的向量空间中的向量映射到另一对基向量组成的向量空间中的向量，这可以使用一个矩阵完成，这样的矩阵被称为<strong>变换矩阵</strong>（Transformation Matrix）<br><img src="https://img-blog.csdnimg.cn/20210417102738876.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>一个向量空间中的向量可以表示为：$\bold a = x\bold {e_1} +y\bold {e_2}$表示为矩阵形式就是</p>
<script type="math/tex; mode=display">\bold a = [\bold {e_1} \ \ \bold {e_2}]\begin{bmatrix}\  x \\ y\end{bmatrix}\quad</script><p>假设$e_1、e_2$是$\mathbb{R}^2$向量空间的基向量，所以上式可以表示为：</p>
<script type="math/tex; mode=display">\bold a = \begin{bmatrix} 1 \ \ \ 0 \\ 0 \ \ \ 1\end{bmatrix} \begin{bmatrix}\  x \\ y\end{bmatrix}\quad</script><p>这一个单位矩阵也可以看成一种变换，但是是一种原封不动的变换，现在假设有一个变换矩阵$\bold b = \begin{bmatrix} 2 \  \ \ 0 \ 0 \  \ \ 1 \end{bmatrix}$。所以，$\bold a \cdot \bold b$就相当于对原先的向量空间y轴上的延伸操作。这也是一种对向量的线性变换</p>
<h3 id="基变换-Basis-Change"><a href="#基变换-Basis-Change" class="headerlink" title="基变换(Basis Change)"></a>基变换(Basis Change)</h3><p>这部分探寻向量空间发生变化之后，变换矩阵的情况。有几种情形，首先是在同一个向量空间中的基变换，这种变换也成为<strong>恒等映射</strong>（identity mapping）例如：$\Psi = id<em>V$表示在向量空间V中的恒等映射。<br>还有一种向量空间发生变化的情况。在下图中，蓝色的字母代表有序基，箭头上的希腊字母代表着对应的变换矩阵<br><img src="https://img-blog.csdnimg.cn/20210417140801630.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我们能够通过原先的变换矩阵得到$\widetilde A</em>\Phi$:</p>
<script type="math/tex; mode=display">\Phi_{\tilde C\tilde B} = \Xi_{\tilde C C}\circ \Phi_{CB}\circ\Psi_{B\tilde B} = \Xi^{-1}_{C\tilde C}\circ \Phi_{CB}\circ\Psi_{B\tilde B}</script><p>这也就是说一个基的多个变换可以等价于某一个单一的变换。</p>
<p><img src="https://img-blog.csdnimg.cn/20210417140746445.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>对上式的一个粗略的推导：<br><img src="https://img-blog.csdnimg.cn/20210417142201266.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>等价与相似：<br><img src="https://img-blog.csdnimg.cn/2021041813243031.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>正则矩阵</strong>（Regular Matrix）: 我们常见的实数矩阵和复数矩阵中，正则矩阵=可逆矩阵</p>
<h3 id="像集与核（Image-and-Kernel）"><a href="#像集与核（Image-and-Kernel）" class="headerlink" title="像集与核（Image and Kernel）"></a>像集与核（Image and Kernel）</h3><p><img src="https://img-blog.csdnimg.cn/20210418133146671.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>零空间</strong>就是一个向量空间中的向量，经过映射$\Phi$之后，变成零向量的所有向量组成的向量空间，e.g: $\bold A \bold x = 0$的解就是A的一个零空间。因为$\Phi(0_V) = \Phi(0_W)$总是成立，所以零空间不会是空的。零空间也可以用于确定列向量之间是否是线性相关的。<br>如何从映射的角度，理解这个线性相关？</p>
<p>假设存在这样的一个映射使得，$V$中的一个子空间经过线性映射之后变成了一个0空间，说明这个过程发生了降维，<strong>零空间</strong>就是在转换之后损失掉的维度，而变换矩阵所在向量空间的维度，影响变换之后的向量空间的维度，而变换矩阵的列向量就是描述这样的维度的量，所对应的就是<strong>列空间</strong></p>
</blockquote>
<p><strong>像集</strong>就是映射之后所对应的向量组成的向量空间。e.g:$\bold A \bold x = \bold b$<br><img src="https://img-blog.csdnimg.cn/20210418133852855.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>从上图知：$\Phi$的核空间是$V$的一个向量子空间，而其像域是$W$的一个向量子空间。所以，像域是$V$在映射之后在$W$的子空间，零空间是$V$中映射之后变成$W$中的零的一个向量子空间。</p>
<p><strong>列空间</strong><br>变换矩阵列向量所形成的张成空间，就是列空间<br><img src="https://img-blog.csdnimg.cn/20210418135457251.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>秩－零化度定理</strong><br><img src="https://img-blog.csdnimg.cn/20210418140518540.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>思考这个等式为什么会成立？<br><img src="https://img-blog.csdnimg.cn/20210418140707505.png" alt="在这里插入图片描述"><br>其实就是在变换过程中损失的维度和变换后的维度之和等于变换之前的向量空间的维度。而这样的损失是由于变换矩阵导致，这也就是说变换之后的维度等于变换矩阵的维度，这也就是为什么$\Phi$的像域是A的列空间了。<br>上面那个结论其实说的就是在变换之后丢失了一些维度，所以，零空间至少是一维的，在这个空间上的向量又是无限多的，所以就是有无穷解了。</p>
</blockquote>
<h2 id="仿射空间（Affine-Spaces）"><a href="#仿射空间（Affine-Spaces）" class="headerlink" title="仿射空间（Affine Spaces）"></a>仿射空间（Affine Spaces）</h2><h3 id="仿射子空间"><a href="#仿射子空间" class="headerlink" title="仿射子空间"></a>仿射子空间</h3><p><img src="https://img-blog.csdnimg.cn/20210418165641673.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>实际上就是一个不经过原点的子空间，描述为一个子空间加上一些偏置，使得这个空间不经过原点。例如。三维空间的一个仿射子空间就是一个不经过原点的点、线或者面。</p>
<blockquote>
<p>想想这段话的含义<br><img src="https://img-blog.csdnimg.cn/20210418170047681.png" alt="在这里插入图片描述"><br>想清楚仿射空间与线性非齐次方程之间的关系。</p>
</blockquote>
<p>一个实例：<br><img src="https://img-blog.csdnimg.cn/20210418170843921.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>向量可以用向量空间的有序基线性表示，同样的仿射空间中的向量可以由同样的方式表示，只需要在每个向量中加上支持点（support point）即可<br><img src="https://img-blog.csdnimg.cn/20210418171350189.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="仿射映射"><a href="#仿射映射" class="headerlink" title="仿射映射"></a>仿射映射</h3><p>与线性映射类似，仿射映射只不过是在线性映射之后加上一个偏置量（支撑点）。<br><img src="https://img-blog.csdnimg.cn/20210419080833884.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/07/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/07/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">python学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-07 19:42:19" itemprop="dateCreated datePublished" datetime="2021-04-07T19:42:19+08:00">2021-04-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-08 19:48:11" itemprop="dateModified" datetime="2023-03-08T19:48:11+08:00">2023-03-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><font color="#999AAA">因为未来研究方向的需要，现在需要我抛开挚爱的C语言学习python。整篇博客记录的学习的内容，所以会比较长。这是个人笔记，所以有些地方你可能看的不是很明白，如有什么不恰当的地方，劳烦批评指正。<br>@[toc]</font></p>
<h1 id="Python-基础"><a href="#Python-基础" class="headerlink" title="Python 基础"></a>Python 基础</h1><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;输出内容&quot;</span>， 变量) <span class="comment">#中间会出现一个空格，&quot;+&quot;用于连接两个字符串，中间没有空格</span></span><br><span class="line"><span class="built_in">input</span>(<span class="string">&quot;提示语&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="数据类型和变量"><a href="#数据类型和变量" class="headerlink" title="数据类型和变量"></a>数据类型和变量</h2><p>python在不需要提前声明变量类型，这一类的语言就是<code>动态语言</code>,反之，则为<code>动态语言</code>。<br>两种除法符号,$“ / ”$:代表的是浮点数除法，$“//“$：代表的是向下整除</p>
<h2 id="字符串和编码"><a href="#字符串和编码" class="headerlink" title="字符串和编码"></a>字符串和编码</h2><p>因为计算机只能处理数字，所有想要处理字符串，需要将对应的字符转换成数字，可以将每一个数字对应一个字符，于是就有了ASCII码（美国信息交换标准代码： American Standard Code for Information Interchange），这种编码使用一个字节，可以表示255个字符。<br>但是世界各国语言不同，需要其他的位来表示本国的语言，为了统一，于是有了万国码(Unicode)，现在最常用的是UCS-16编码，用两个字节表示一个字符。<br>但是这样会使原先一些用更少位就能存储的字符花费更多的位来存储，所以为了节约期间，出现了，可变长的编码——<code>UTF-8</code>。在编码英文字符的时候，可用更少的位存储（转换成类似ASCII）。在计算机内存中，统一使用Unicode，当存储或者转发的时候，才转换成UTF-8<br>  <img src="https://img-blog.csdnimg.cn/20210408094814411.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在python中，字符串是以<code>Unicode</code>编码的，因此可以支持多种语言。下面是几个相关的函数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>)  <span class="comment"># 65 -&gt;ASCII</span></span><br><span class="line">&gt;&gt;&gt;<span class="built_in">ord</span>(<span class="string">&#x27;中&#x27;</span>)  <span class="comment"># 20013  -&gt;Unicode</span></span><br><span class="line">&gt;&gt;&gt;<span class="built_in">chr</span>(<span class="number">66</span>)  <span class="comment"># &#x27;B&#x27;  -&gt; char</span></span><br><span class="line">&gt;&gt;&gt;<span class="string">&#x27;\u2e2d\u6587&#x27;</span>  <span class="comment"># &#x27;中文&#x27;  &lt;- Unicode (Hex)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="string">b&#x27;ABC&#x27;</span>  <span class="comment"># bytes 类型，每个字符只占一个字节</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b&#x27;ABC&#x27;</span>.decode(<span class="string">&#x27;ascii&#x27;</span>, errors = <span class="string">&#x27;ignore&#x27;</span>)  <span class="comment"># &#x27;ABC&#x27; parameter can also be &#x27;utf-8&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(<span class="string">&#x27;ABC&#x27;</span>) <span class="comment">#3  calculating how many characters in string</span></span><br></pre></td></tr></table></figure></p>
<h3 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h3><p>直接上例子,三种格式化的方式：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="string">&#x27;%s is %d years old&#x27;</span> % (<span class="string">&#x27;Tom&#x27;</span>, <span class="number">30</span>)</span><br><span class="line"><span class="comment"># Tom is 30 years old</span></span><br><span class="line"><span class="comment"># %% 表示 % 的转义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#用format语句, 占字符会用&#123;0&#125;&#123;1&#125;...表示</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&#123;0&#125; is &#123;1: .1f&#125; years old&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">30.112</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#用f-string， 这会将字符串中的变量转换成相应的值</span></span><br><span class="line">name = <span class="string">&#x27;Tom&#x27;</span></span><br><span class="line">age = <span class="string">&#x27;30&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;name&#125;</span> is <span class="subst">&#123;age&#125;</span> years old&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>占字符的常见类型<br><img src="https://img-blog.csdnimg.cn/20210409104153838.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="list-amp-tuple"><a href="#list-amp-tuple" class="headerlink" title="list &amp; tuple"></a>list &amp; tuple</h2><p>l<strong>ist</strong> 是一种有序集合，能够随时添加和删除其中的元素。与c++中的向量类似。下面是list的常用的操作：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Creating a list</span></span><br><span class="line">listName = [<span class="string">&quot;elem1&quot;</span>,elem2]</span><br><span class="line"><span class="comment">#Get length of a list</span></span><br><span class="line"><span class="built_in">len</span>(listName)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Get a element in a list by index.</span></span><br><span class="line"><span class="comment">#If the index is out of boundary you will get an error information</span></span><br><span class="line">listName[<span class="number">1</span>]  <span class="comment">#return &quot;elem1&quot;</span></span><br><span class="line">listName[-<span class="number">1</span>]  <span class="comment"># The last element</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Add an element into the end of the list</span></span><br><span class="line">listName.append(<span class="string">&quot;elem3&quot;</span>)</span><br><span class="line"><span class="comment">#Add an element to a specific index </span></span><br><span class="line">listName.insert(index,<span class="string">&quot;elem4&quot;</span>)</span><br><span class="line"><span class="comment">#Delete the last one element</span></span><br><span class="line">listName.pop()</span><br><span class="line"><span class="comment">#Specific position</span></span><br><span class="line">listName.pop(<span class="number">1</span>) <span class="comment">#The second one will be deleted</span></span><br><span class="line"><span class="comment">#change it</span></span><br><span class="line">listName[<span class="number">1</span>] = <span class="string">&quot;elem5&quot;</span> <span class="comment"># The second one will be replaced by &quot;elem5&quot;</span></span><br></pre></td></tr></table></figure><br>在list中可以是不同的类型的变量，也可以是一个其他的数组</p>
<p><strong>tuple</strong>是一种初始化之后不能修改的有序列表，成为元组。它在定义的时候与list不同的是前者使用的”()”,而后者时候的”()”<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Define</span></span><br><span class="line">t = (<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment">#Empty tuple</span></span><br><span class="line">t = ()</span><br><span class="line"></span><br><span class="line">t = (<span class="number">1</span>) <span class="comment">#The tuple&#x27;s size is 1</span></span><br><span class="line">t = (<span class="number">1</span>,)  <span class="comment">#t has only one element that is 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Changeable tuple</span></span><br><span class="line">t = (<span class="string">&quot;a&quot;</span>, [A, B])</span><br><span class="line">t[<span class="number">1</span>][<span class="number">1</span>] = A  <span class="comment">#It could be done</span></span><br></pre></td></tr></table></figure></p>
<h2 id="条件判断语句"><a href="#条件判断语句" class="headerlink" title="条件判断语句"></a>条件判断语句</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Form</span></span><br><span class="line"><span class="keyword">if</span> condition1:</span><br><span class="line">	exe1.</span><br><span class="line"><span class="keyword">elif</span> condition2:</span><br><span class="line">	exe2.</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	exe3.</span><br><span class="line"></span><br><span class="line"><span class="comment"># About input</span></span><br><span class="line">var = <span class="built_in">input</span>(<span class="string">&quot;Mention_Info&quot;</span>)  <span class="comment">#input will return str</span></span><br><span class="line">var2 = <span class="built_in">int</span> (var) <span class="comment">#Turning the str into int</span></span><br><span class="line"><span class="comment">#If you input an non-number variable you&#x27;ll get an error</span></span><br></pre></td></tr></table></figure>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p><strong>for语句</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Form</span></span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> varList:</span><br><span class="line">    exe.</span><br><span class="line"><span class="keyword">while</span> break_condition:</span><br><span class="line">    exe.</span><br><span class="line"><span class="comment"># break &amp; continue have same functions as C</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Useful function</span></span><br><span class="line"><span class="built_in">range</span>(<span class="number">5</span>) <span class="comment">#Forming an serial number for 0 to 5</span></span><br></pre></td></tr></table></figure><br>尽量减少break和continue语句的使用，这会导致代码执行的逻辑分叉过多，容易出错。</p>
<h2 id="dict-amp-set"><a href="#dict-amp-set" class="headerlink" title="dict &amp; set"></a>dict &amp; set</h2><p><strong>dict</strong>按照键-值存储， 能快速进行查找。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Form</span></span><br><span class="line">dic = &#123;key1:value1, key2:value2&#125;</span><br><span class="line">dic[key1]  <span class="comment"># Return value1</span></span><br><span class="line">dic.get(key1) <span class="comment"># Return value1</span></span><br><span class="line">dic.get(key3, -<span class="number">1</span>)  <span class="comment"># Return -1, if the -1 is None instead of -1, it will output nothing </span></span><br><span class="line"></span><br><span class="line">key2 <span class="keyword">in</span> dic  <span class="comment"># Whether the key is in the dic or not</span></span><br></pre></td></tr></table></figure></p>
<p><strong>set</strong>是一个元素不重合的有序集合，初始化之后，会自动删除重复的元素。，集合之间的逻辑运算还可以模拟集合的交集和并集。集合是不能通过下标访问的，只能进行交集等运算，想要利用下标进行访问需要将集合转换成list<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">set</span>(<span class="built_in">list</span>) <span class="comment"># Like set(range(5)) likewise:list(range(5)) it will change into a list</span></span><br><span class="line">s1 &amp; s2 <span class="comment"># 交集</span></span><br><span class="line">s1 | s2 <span class="comment"># 并集</span></span><br><span class="line">s.add(key)  <span class="comment"># Add an element</span></span><br><span class="line">s.remove(key)  <span class="comment"># Add an element</span></span><br></pre></td></tr></table></figure></p>
<p>总结一下，上面两种的结构，检索速度快，但是需要消耗大量的空间。是因为这些结构式采用哈希表实现的，也就是用键计算出对应的哈希值，这个哈希值就是值存储的位置，这也就是一个键对应一个值的原因，因为在这个位置上存储的位置式唯一的。而且这个地址只与键相关，与字典中的其他的键值无关，所以字典的检索速度不会因为字典的中的元素增多而受到影响。而list和tuple本质上就是链表，所以检索速度会受到链表中的元素的多少的影响。</p>
<p>关于<strong>不变性</strong>，这个不变性与C语言中的左值有点类似，一些不变对象进过一些操作之后变成了其他的对象，似乎是对原先的不变对象的修改，但是想象一下，你对2执行加法运算之后，得到了一个其他的结果，你能说是对数字2进行了改变吗？这时候也就是对原先的不变对象的拷贝进行的一些操作。<br>同时不变对象因为在定义之后不能被修改，所以可以同时被访问，而不需要加锁，不必担心被修改的问题。所以，<u>当一个对象可以被设计成不变对象的时候，尽量设置成不变对象。</u></p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p>注意一点，因为在定义函数的时候的没有加上大括号，所以不能借此作为函数的定界符，所以，一个函数当中的所有的语句的缩进一定要一致（DOS中使用快速双击ENTRE退出函数定义）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Form</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func_name</span>(<span class="params">parameter</span>):</span><br><span class="line">	<span class="keyword">if</span>(condition1):</span><br><span class="line">		exe.  <span class="comment"># if it&#x27;s &quot;pass&quot;, it will do nothing.</span></span><br><span class="line">		<span class="keyword">return</span> <span class="comment"># Return value</span></span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		exe_1.</span><br><span class="line">		<span class="keyword">return</span> x, y <span class="comment"># you can return muti results</span></span><br><span class="line">x, y = func_name(para.)  <span class="comment">#It actually return a tuple, and several varians can recieve the tuple	</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Import from outer file</span></span><br><span class="line"><span class="keyword">from</span> file_name <span class="keyword">import</span> func_name <span class="comment"># file_name.py</span></span><br><span class="line"><span class="comment">#return的缩进要严格对应？</span></span><br></pre></td></tr></table></figure></p>
<h2 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h2><p>python中有<strong>默认参数</strong>，但是最好是指向不变量，否则会导致意想不到的错误。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_end</span>(<span class="params">L = []</span>):</span><br><span class="line">	L.append(<span class="string">&quot;End&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> L</span><br></pre></td></tr></table></figure><br>上面这个函数，当使用默认函数的时候，L就会指向”[ ]”, 于是会返回[“End”]，当再次使用默认参数的时候，就会返回[“End”,”End”]。因为第一次使用默认参数的时候L会被初始化指向一个空list，之后若没有被重新指向一个新的list，则L指向的对象就没有改变，所以会使用原先的list作为初始化变量。正确的使用方式如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_end</span>(<span class="params">L = <span class="literal">None</span></span>):</span><br><span class="line">	<span class="keyword">if</span>(L <span class="keyword">is</span> <span class="literal">None</span>):</span><br><span class="line">		L = []</span><br><span class="line">	L.append(<span class="string">&quot;End&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> L</span><br></pre></td></tr></table></figure><br><strong>可变参数</strong><br>在函数定义的时候在参数前加上一个“ <em> ”，这样参数接收到的就是一个tuple，类似于一个指针了。当想要传入一个list或者tuple的时候，只需要把列表的名字前加上” \</em> “，当成参数传进去就可以。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Num could be several numbers or a list/array</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">*num</span>):</span><br><span class="line">	res = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> x <span class="keyword">in</span> num:</span><br><span class="line">		res = res + x</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p><strong>关键字参数</strong><br>传入参数的时候需要将对应的参数的名称加入写上，在函数中自动组装成一个字典。关键字参数在定义的时候需要在形参前面加上两个星号。在传入参数时，需要标明键和对应的值<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun_name</span>(<span class="params">para1, para2, **kw</span>):</span><br><span class="line">	<span class="built_in">print</span>(para1,para2,<span class="string">&quot;other :&quot;</span>,kw)</span><br><span class="line"></span><br><span class="line">fun_name(p1,p2,age = <span class="number">20</span>, place = <span class="string">&quot;Beijing&quot;</span>) <span class="comment"># Output like a dic</span></span><br></pre></td></tr></table></figure><br><strong>命名关键字参数</strong><br>这个限制了参数的关键参数的名字，只接受对应关键字参数。命名关键字参数之前需要用星号与位置参数隔开,这些参数必须传入参数，否则会报错。如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符<code>*</code>了：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun_name1</span>(<span class="params">para1, *para2, para3</span>):</span><br><span class="line">	exe.</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun_name</span>(<span class="params">para1, *, para2</span>):</span><br><span class="line">	exe</span><br><span class="line">fun_name(p1, para2 = p2) </span><br></pre></td></tr></table></figure></p>
<p>上诉的所有参数可以同时使用，但是顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。</p>
<h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><p>递归函数就是在定义的时候调用自身的函数，在这个函数当中维护着一个栈，所以递归的深度受到栈空间的限制。<br>有一种可以避免栈溢出的方法，就是<strong>尾递归</strong>，尾递归在返回的时候尽返回函数本身，没有其他的语句。</p>
<blockquote>
<p>尾递归调用时，如果做了优化，栈不会增长，因此，无论多少次调用也不会导致栈溢出。<br>遗憾的是，大多数编程语言没有针对尾递归做优化，Python解释器也没有做优化，所以，即使把上面的fact(n)函数改成尾递归方式，也会导致栈溢出。</p>
</blockquote>
<h1 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h1><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>切片能够使我们很方便地从其他数列当中过去一定范围的子数列。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">L = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">5</span>))</span><br><span class="line"><span class="comment">#Note that it won&#x27;t contain the last one</span></span><br><span class="line">L[<span class="number">0</span>:<span class="number">3</span>] <span class="comment"># L[0]、L[1]、L[2]</span></span><br><span class="line">L[-<span class="number">2</span>:-<span class="number">1</span>] <span class="comment"># L[-2]</span></span><br><span class="line">L[-<span class="number">2</span>:] <span class="comment">#L[-2]、L[-1]</span></span><br><span class="line">L[:] <span class="comment">#copy</span></span><br><span class="line">L[::-<span class="number">1</span>] <span class="comment"># 原矩阵的逆序矩阵</span></span><br></pre></td></tr></table></figure></p>
<h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>在python中可以使用for语句完成对数组或者是字典的遍历。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在默认情况下字典迭代的是键</span></span><br><span class="line">d = &#123;<span class="string">&quot;a&quot;</span>:<span class="number">1</span>, <span class="string">&quot;b&quot;</span>:<span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> d: <span class="comment"># Accessing keys</span></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> d.values: <span class="comment">#Accessing values</span></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> d.items(): <span class="comment">#Accessing key-value pairs</span></span><br></pre></td></tr></table></figure><br>想要判断一个对象是否是可迭代对象，可以使用collections模块的Iterable类型判断：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line"><span class="built_in">isinstance</span>(<span class="string">&quot;abc&quot;</span>, Iterable) <span class="comment">#判断str类型是否为可迭代对象</span></span><br></pre></td></tr></table></figure><br>当想要将数组的下标同时输出的时候，可以使用枚举类型<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, value <span class="keyword">in</span> <span class="built_in">enumerate</span>([<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>]):</span><br><span class="line"></span><br><span class="line"><span class="comment">#可以在循环中引入两个变量</span></span><br><span class="line"><span class="keyword">for</span> x, y <span class="keyword">in</span> [(<span class="number">1</span>,<span class="number">1</span>), (<span class="number">2</span>, <span class="number">4</span>)]:</span><br></pre></td></tr></table></figure></p>
<h2 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h2><p>可以使用range()生成一个序列，在列表中还可以加上循环语句和条件语句<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#这里的if作为一个条件筛选的作用，不能加上else</span></span><br><span class="line">[x*x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]  <span class="comment">#[0, 4, 16, 36, 64]</span></span><br><span class="line">[x*x+i <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)] <span class="comment">#这样产生的效果就是双重嵌套循环</span></span><br></pre></td></tr></table></figure></p>
<h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>生成器通过调用next()函数，根据生成器中的定义不断输出对应的生成结果。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Define a generator</span></span><br><span class="line">g = (x*x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"><span class="built_in">next</span>(g)  <span class="comment"># 0</span></span><br><span class="line"><span class="comment">#Traverse the whole </span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> g:</span><br><span class="line">	exe</span><br></pre></td></tr></table></figure><br>当生成器中没有元素的时候，再调用会报错：</p>
<blockquote>
<p>Traceback (most recent call last):<br>  File “\<stdin>“, line 1, in \<module><br>StopIteration</module></stdin></p>
</blockquote>
<p>就像是一次性的物品，使用完之后就没有了。在函数中，用关键字<code>yield</code>返回计算结果，这也就是调用next函数的时候的返回值。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params"><span class="built_in">max</span></span>):</span><br><span class="line">    n,a,b = <span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; <span class="built_in">max</span>:</span><br><span class="line">        <span class="keyword">yield</span> b  <span class="comment">#返回当前生成式的值，此时这个函数式generator</span></span><br><span class="line">        a,b = b, a+b</span><br><span class="line">        n +=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;done&#x27;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>对于可以直接作用于for语句的对象统称为可迭代对象：<code>Iterable</code>。在python中可以使用函数<code>isinstance()</code>判断一个对象是否为可迭代对象。<br>可以使用next()函数调用不断生成下一个值得对象称为迭代器:<code>Iteator</code><br>一些数据类型例如list、dict、str不是迭代器，但是可以通过函数<code>iter()</code>将他们转换成迭代器。<br>迭代器在本质上就是一个数据流，个人理解就是一个逻辑上存在的有序序列，暗示序列中的元素不是存储在某个位置，而是仅仅存在于逻辑上，想要得到他需要通过计算得出。（类似于向量空间）<br>像函数$y = f(x)$并不是存储了所有的y而是在逻辑上有这样的映射关系存在，可以说代表y这一类的数字，但是需要通过计算得到y的真正的值。</p>
<h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><blockquote>
<p>函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量</p>
</blockquote>
<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>在python中函数名就是指向实现该函数的作用的模块的变量。这也就是说可以使用其他的变量代替原先的函数的指针作用。因为是变量的缘故，函数名也可以指向新的量。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">abs</span></span><br><span class="line">f(-<span class="number">10</span>) <span class="comment"># 10</span></span><br></pre></td></tr></table></figure><br><code>高阶函数</code>就是能将其他函数作为参数的函数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x,y,f</span>):</span><br><span class="line">	<span class="keyword">return</span> f(x)+f(y)</span><br><span class="line">add(-<span class="number">5</span>,-<span class="number">6</span>,<span class="built_in">abs</span>)  <span class="comment"># 11</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>函数式编程就是指这种高度抽象的编程范式。</p>
</blockquote>
<h3 id="map-reduce"><a href="#map-reduce" class="headerlink" title="map/reduce"></a>map/reduce</h3><p><code>map()</code>接受两个参数，一个是函数名一个是可迭代的参数列表，最后返回一个迭代器，这样做可以将运算规则抽象化。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#转化成一个字符列表</span></span><br><span class="line"><span class="built_in">list</span> (<span class="built_in">map</span>(<span class="built_in">str</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数形式</span></span><br><span class="line"><span class="built_in">map</span>(func_name, list_name)</span><br></pre></td></tr></table></figure><br><code>map</code>参数中的list_name需要与Func_name函数中的参数列表一致，也可以将一个向量作为参数传入<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>(<span class="built_in">map</span>(add,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]))</span><br><span class="line"><span class="comment"># [2,4,7]</span></span><br></pre></td></tr></table></figure><br><code>reduce()</code>传入的参数与map一致，但是作用不同:<br>$reduce(f,[x_1,x_2,x_3]) = f(f(x_1,x_2),x_3)$<br>下面是一个将数字字符串类型转换成整型的实例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"></span><br><span class="line">DIGITS = &#123;<span class="string">&#x27;0&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;1&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;2&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;3&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;4&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;5&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;6&#x27;</span>: <span class="number">6</span>, <span class="string">&#x27;7&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;8&#x27;</span>: <span class="number">8</span>, <span class="string">&#x27;9&#x27;</span>: <span class="number">9</span>&#125;</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">str2int</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fn</span>(<span class="params">x,y</span>):</span><br><span class="line">        <span class="keyword">return</span> x * <span class="number">10</span> + y</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">char2num</span>(<span class="params">s</span>):</span><br><span class="line">        <span class="keyword">return</span> DIGITS[s]  <span class="comment">#字典，输入键返回对应的值</span></span><br><span class="line">    <span class="keyword">return</span> reduce(fn,<span class="built_in">map</span>(char2num,s))</span><br><span class="line">    <span class="comment">#map先将s转换成对应的数字数组，然后reduce将这个数字数组转换成对应的数字</span></span><br></pre></td></tr></table></figure><br>总的来说，二者就是将一个参数（或参数列表）按照一定的规律传入函数，然后输出对应的结果的参数列表。<br><em>简要记录一下lambda的使用方式：</em><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> 参数：操作(，范围)</span><br><span class="line">f = <span class="keyword">lambda</span> x,y : x+y</span><br><span class="line">f(<span class="number">1</span>,<span class="number">2</span>) <span class="comment"># 1+2</span></span><br></pre></td></tr></table></figure></p>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p><code>filter</code>也是一个高阶函数，也与之前的两个函数一样，传入一个函数和一个参数列表，不同的是，当参数返回false的时候，会将对应的参数列表中的参数剔除。<br>下面是一个利用筛选法求素数列表的代码实例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#利用筛选法，求出素数表</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_odd_iter</span>():</span><br><span class="line">    n = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        n = n + <span class="number">2</span></span><br><span class="line">        <span class="keyword">yield</span> n</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_not_divisible</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> x : x % n &gt; <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">primes</span>():</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    it = _odd_iter()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        n = <span class="built_in">next</span>(it)</span><br><span class="line">        <span class="keyword">yield</span> n</span><br><span class="line">        it = <span class="built_in">filter</span>(_not_divisible(n),it)</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>对于生成器的使用还是不是很熟悉。怎么理解呢？</p>
<blockquote>
<p>就像是一个映射关系，本质上它什么都不是，只是数据之间的关系，生成器只是指明了自变量与因变量之间的联系，想要得到确切的值，你得访问它。</p>
</blockquote>
</blockquote>
<h3 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h3><p><code>sorted</code>函数也是传入参数表和相应的函数，但是传入的顺序和形式与之前的有所不同。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sorted</span>(list_name, key = func_name, reverse = <span class="literal">True</span>/<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><br>参数表的比较形式是根据函数处理之后的参数表，一般按照从小到大的顺序，但是可以用<code>reverse</code>关键字，使得结果是从大到小的排序形式。</p>
<h2 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a>返回函数</h2><p>高阶函数除了可以接受函数作为参数之外，还可以将函数作为结果的返回值，返回的函数包含了当下参数的结算结果，当调用的时候，才真正计算函数的结果。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lazy_sum</span>(<span class="params">*args</span>):</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">sum</span>():</span><br><span class="line">		ax = <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> n <span class="keyword">in</span> args:</span><br><span class="line">			ax += n</span><br><span class="line">		<span class="keyword">return</span> ax</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sum</span></span><br><span class="line"></span><br><span class="line">f = lazy_sum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)   <span class="comment">#Return a function</span></span><br><span class="line">f()   <span class="comment"># Return the sumation result: 10</span></span><br></pre></td></tr></table></figure><br>在这个函数中定义的函数称为内部函数，内部函数可以使用外部函数的参数和局部变量，返回的函数包含参数和变量，这种程序结果称为<code>闭包</code>（closure）。<br>每一次的函数调用都会返回一个新的函数，这些函数调用结果互不干扰。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>在使用闭包的时候需要注意一点，返回的函数是没有被执行的，只有在调用的时候在会将这个函数执行，所以，假设内部函数中有循环，这个时候循环虽然在继续，也在正常返回函数，但是因为函数是在调用的时候才执行的，所以当所有函数在调用的时候只返回最终循环作为参数的结果。<br>例如下面这个函数返回的函数运行之后的结果都是9，因为在计算的函数的时候，只传入了循环的最后一个数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">count</span>():</span><br><span class="line">	fs[]   <span class="comment"># 用于存储返回函数</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">4</span>):</span><br><span class="line">		<span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">			<span class="keyword">return</span> i*i</span><br><span class="line">		fs.append(f)</span><br><span class="line">	<span class="keyword">return</span> fs</span><br><span class="line"></span><br><span class="line"><span class="comment">#调用</span></span><br><span class="line">f1,f2,f3 = count()</span><br></pre></td></tr></table></figure><br>所以需要记住的一点：<code>返回函数中不要有任何循环变量，或者是之后会发生变化的量</code><br>如果想要在返回函数中使用循环，可以在定义一个函数，然后再返回函数之前，这个函数就被执行了。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">count</span>():</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">		<span class="keyword">def</span> <span class="title function_">g</span>():</span><br><span class="line">			<span class="keyword">return</span> j*j</span><br><span class="line">		<span class="keyword">return</span> g</span><br><span class="line">	fs =[]</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">4</span>):</span><br><span class="line">		fs.append(f(i))  <span class="comment"># 参数传入，函数被执行</span></span><br><span class="line">	<span class="keyword">return</span> fs</span><br></pre></td></tr></table></figure></p>
<h2 id="匿名函数（lambda）"><a href="#匿名函数（lambda）" class="headerlink" title="匿名函数（lambda）"></a>匿名函数（lambda）</h2><p>想要直接传入参数的时候，不需要定义一个函数的名称，可以用相应的lambda语句代替函数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#筛选出序列中的奇数</span></span><br><span class="line">L = <span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x : x % <span class="number">2</span> == <span class="number">1</span>, <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">20</span>)))</span><br></pre></td></tr></table></figure></p>
<h2 id="修饰器"><a href="#修饰器" class="headerlink" title="修饰器"></a>修饰器</h2><p>修饰器实际上就是将原先的一个函数指向一个重新定义的函数，而原先的函数定义没有发生改变。<br>原先提到一个变量可以指向一个函数，所以可以通过变量指向调用函数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">now</span>():</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;?&quot;</span>)</span><br><span class="line">f = now</span><br><span class="line">f()  <span class="comment"># ?</span></span><br><span class="line">f.__name__  <span class="comment"># now</span></span><br></pre></td></tr></table></figure><br>下面是将now函数的重定向：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">log</span>(<span class="params">func</span>):</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kw</span>):</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&#x27;call %s():&#x27;</span> % func.__name__)</span><br><span class="line">		<span class="keyword">return</span> func(*args, **kw)</span><br><span class="line">	<span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="comment">#在函数定义处加上@和函数名</span></span><br><span class="line"><span class="meta">@log</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">now</span>():</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;?&quot;</span>)</span><br></pre></td></tr></table></figure><br>之后的语句就相当于调用了log(now),当调用的now函数的时候，会返回调用log的函数的结果。这相当于对函数做了一个重定向。</p>
<h2 id="偏导数"><a href="#偏导数" class="headerlink" title="偏导数"></a>偏导数</h2><p>创建一个新函数，可以修改原先函数的默认值。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">import</span> functools</span><br><span class="line">int2 = functools.partial(<span class="built_in">int</span>, base=<span class="number">2</span>)</span><br><span class="line"><span class="comment">#这里将函数int中的变量默认为2</span></span><br><span class="line"><span class="comment">#int函数是将一个字符串类型的变量转换成base进制的数字，base的默认值为10</span></span><br></pre></td></tr></table></figure></p>
<h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p>模块可以封装一些函数，增加代码的可读性和可维护性，而且不同模块当中的变量是可以相同的。如是模块名发生了冲突，可以将模块整合到包下面，这时候只要包名不冲突，对应的模块也就不会发生冲突。如果一个文件夹是一个包，需要在文件中包含<code>__int__.py</code><br><code>注意在创建模块的时候，不能与系统内置的模块相互冲突</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">假设一个路径：</span><br><span class="line">&gt;myPackage</span><br><span class="line">&gt;&gt;&gt;&gt;__int__.py</span><br><span class="line">&gt;&gt;&gt;&gt;abc.py</span><br><span class="line">则abc对应的模块名称为myPackage.abc</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>模块名要遵循Python变量命名规范，不要使用中文、特殊字符；</p>
</blockquote>
<h1 id="使用模块"><a href="#使用模块" class="headerlink" title="使用模块"></a>使用模块</h1><p>在python中有很多的内置模块，可以利用这些模块编写一个自己的模块。以sys为例,创建一个名为<code>hello.py</code>的模块。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3             加上这一行之后hello.py文件直接在Unix/Linux/Mac上运行</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-            表明了编码方式</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27; a test module &#x27;</span>  <span class="comment">#模块的第一个字符串会被当成文档注释</span></span><br><span class="line"></span><br><span class="line">__author__ = <span class="string">&#x27;Michael Liao&#x27;</span>      <span class="comment">#模块作者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys                      <span class="comment">#import 是执行非main函数的部分</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    args = sys.argv                      <span class="comment">#获取命令行参数，存储到一个列表当中</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(args)==<span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Hello, world!&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">len</span>(args)==<span class="number">2</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Hello, %s!&#x27;</span> % args[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Too many arguments!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:         <span class="comment">#当程序在命令行中运行的时候，会将其中的一个变量__name__赋值为__main__，</span></span><br><span class="line">                                <span class="comment"># 所以当在非命令行的模式下运行的时候，导入模块之后需要使用hello.test（）来运行程序</span></span><br><span class="line">    test()</span><br></pre></td></tr></table></figure><br>在sys.argv中会获取命令行参数，如<code>python hello.py York</code>,那么argv中的list中会存储两个量[‘hello.py’、‘York’]</p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>变量名称的作用域用<code>_</code>来表示。<code>__name__</code>表示特殊变量，有专门的用途，自己命名的时候不要使用这样的变量名称。<code>_name_</code>表示非公开的变量或者函数（虽然在python中没有一种能够完全限制private变量访问的机制，但是习惯上不应该引用这些变量或者是函数）</p>
<h1 id="面对对象编程"><a href="#面对对象编程" class="headerlink" title="面对对象编程"></a>面对对象编程</h1><p>在初始化一个对象的时候需要使用一个特殊的方法<code>__init__()</code>这类似C++中的构造器，每当一个实例被创造出来的时候，这个方法都会被调用，这个方法的第一个参数用于是<code>self</code>，表示创建的实例本身<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">	</span><br><span class="line">	def __init__(self, name, score):</span><br><span class="line">		self.name = name</span><br><span class="line">		self.score = score</span><br><span class="line"></span><br><span class="line">	#当对象当中的方法需要调用实例当中的变量或者函数的时候，需要在参数列表中加上self</span><br><span class="line">	def print_score(self):</span><br><span class="line">		print(&#x27;&#123;&#125;\&#x27;s score:&#123;&#125;&#x27;.format(self.name, self.score))</span><br><span class="line">		</span><br><span class="line">#创建一个实例</span><br><span class="line">student1 = Student(&#x27;York&#x27;, 99)</span><br></pre></td></tr></table></figure></p>
<h2 id="访问限制"><a href="#访问限制" class="headerlink" title="访问限制"></a>访问限制</h2><p>当不想让类外部访问内部变量或者函数的时候，可以在变量或者函数前面加上<code>__</code>(double),这时候就外部代码想要访问这个变量或者函数的时候就会报错</p>
<blockquote>
<p>AttributeError: ‘Student’ object has no attribute ‘__name’</p>
</blockquote>
<p>当一个变量或者是函数被声明为私有的时候，可以通过public的内部函数调用私有函数，从而达到访问的目的。当想要修改私有变量的时候，也可以通过public函数实现内外的联通。虽然直接用点运算也可以修改参数，但是使用函数的好处就是可以进行参数检查。</p>
<blockquote>
<p>不能直接访问<code>__name</code>是因为Python解释器对外把<code>__name</code>变量改成了<code>_Student__name</code>，所以，仍然可以通过<code>_Student__name</code>来访问<code>__name</code>变量<br>所以当你违反规定直接用点运算进行调用的时候，你不会得到你想要的那个变量，而是得到会给对象加上一个<code>__name</code>的变量。</p>
</blockquote>
<h2 id="继承与多态"><a href="#继承与多态" class="headerlink" title="继承与多态"></a>继承与多态</h2><blockquote>
<p>在OOP程序设计中，当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类（Subclass），而被继承的class称为基类、父类或超类（Base class、Super class）。</p>
</blockquote>
<p>注意到之前在定义类的时候，在类名之后的括号中加上了object,这表示这个类是从object这个对象中继承而来的。<br>子类中的方法可以对父类中的方法进行继承和覆写。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&#x27;Animal is running...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">	<span class="keyword">pass</span>         <span class="comment"># class Dog has a method run</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&#x27;Cat is running&#x27;</span>)   <span class="comment">#The method has been overwrite</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#We can use isinstance(instance_name, type)to check whether the instance is a certain type</span></span><br><span class="line">c = Cat() </span><br><span class="line"><span class="built_in">isinstance</span>(c,Animal)<span class="comment">#True</span></span><br><span class="line"><span class="built_in">isinstance</span>(c,Cat)<span class="comment">#Ture</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#We can use those characters </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_twice</span>(<span class="params">Animal</span>):  <span class="comment"># This parameter can be any other name</span></span><br><span class="line">	animal.run()</span><br><span class="line">	anmial.run()</span><br><span class="line"></span><br><span class="line"><span class="comment">#We can pass the parameter either the Animal or its subclass</span></span><br><span class="line"></span><br><span class="line">run_twice(c)  <span class="comment">#the run will the overwitten one  </span></span><br></pre></td></tr></table></figure></p>
<h3 id="静态语言与动态语言"><a href="#静态语言与动态语言" class="headerlink" title="静态语言与动态语言"></a>静态语言与动态语言</h3><p>在下面的这个代码中，传入的参数不一定是Animal类或者是其子类，只要是有run这种方法就行了<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def run_twice(Animal):  # This parameter can be any other name</span><br><span class="line">	animal.run()</span><br><span class="line">	anmial.run()</span><br></pre></td></tr></table></figure></p>
<h2 id="获取对象信息"><a href="#获取对象信息" class="headerlink" title="获取对象信息"></a>获取对象信息</h2><ol>
<li>用<code>type()</code>函数可以得到一个变量的类型</li>
<li>想要判断一个子类是否是继承于某一个父类，可以使用<code>isinstance(变量，类名)</code></li>
<li>使用<code>dir()</code>可以获取一个对象的所有属性</li>
<li>使用<code>hasattr(类名，&#39;属性名&#39;)</code>可以用于判断这个对象当中是否有某种属性</li>
<li><code>getattr(类名，&#39;属性名&#39;)</code>可以获取指定对象的制定属性</li>
</ol>
<blockquote>
<p>hasattr(object, name)判断一个对象里面是否有name属性或者name方法，<br>getattr(obj,name[,default)函数用于返回一个对象属性值<br>setattr(obj,name,value)函数对应函数getattr()，用于设置属性值，该属性不一定是存在的。</p>
<p><strong>Animal.run和Animal().run的区别</strong><br>永远记住，类只是一个模板，模板是不会亲自下海干活的。<br>python中如果不加括号，除了个别的，那就是个标识符（你可以理解为变量）。加了括号代表运行前面的东西，比如f就是个标识符，f（）代表运行f。<br>Animal(). run，如果Animal是个类，就代表先运行Animal这个类，记得前面章节说的，类运行变为实例，实例才能亲自下海干活。<br>Animal(). run就是这个实例里的run函数（run没加括号表示没运行run，仅仅是个函数而已），Animal(). run（）就是先运行Animal生成一个实例，然后运行这个实例里的run函数。</p>
</blockquote>
<h2 id="实例属性和类属性"><a href="#实例属性和类属性" class="headerlink" title="实例属性和类属性"></a>实例属性和类属性</h2><p>可以在类定义的时候加上一个变量，这时候这个类就与这个对象相互绑定了。当创建实例的时候，可以访问这个属性，也可以重新定义这个属性，因为实例的优先级比类的优先级要高，所以类的属性会被屏蔽，但是可以使用<code>del instanceName.attributeName</code>删除实例定义的属性。这时候再访问这个属性就是类的属性了。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">	name = &#x27;student&#x27;</span><br><span class="line">#创建实例</span><br><span class="line">s = Student()</span><br><span class="line">s.name  #访问属性</span><br><span class="line">s.name = &#x27;Joker&#x27;  #绑定实例</span><br><span class="line">del s.name        #删除原先绑定的实例</span><br><span class="line">#实例也可以绑定原先类中不存在的属性</span><br></pre></td></tr></table></figure><br><code>注意一点，self.name代表的是实例属性，Student.name类属性</code></p>
<h1 id="面对对象高级编程"><a href="#面对对象高级编程" class="headerlink" title="面对对象高级编程"></a>面对对象高级编程</h1><p><code>暂略</code></p>
<h1 id="错误、调试和测试"><a href="#错误、调试和测试" class="headerlink" title="错误、调试和测试"></a>错误、调试和测试</h1><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>当一个函数正常运行的时候会返回一个整数，当出错时会返回<code>-1</code>，但是这样十分不方便，因为要接受返回值，然后对返回值进行判断，再作为返回值，这就需要函数一层层上报，十分麻烦，所以再高级语言当中设置一套机制<code>try...except...finally...</code></p>
<h3 id="try"><a href="#try" class="headerlink" title="try"></a>try</h3><p><code>try</code>之后跟着对应的测试代码，当某语句出现错误的时候，会直接跳到<code>except</code>语句中，检查是否捕获到对应的错误信息，是则执行之后的代码，最后执行<code>finally</code>中的代码。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">	print(&#x27;try&#x27;)</span><br><span class="line">	r = 10 / 0</span><br><span class="line">	print(&#x27;result&#x27;,r)     #这一句不会被执行</span><br><span class="line">except ZeroDivisionError as e:</span><br><span class="line">	print(&#x27;except&#x27;,e)     #except: division by zero</span><br><span class="line">finally:</span><br><span class="line">	print(&#x27;Finally...&#x27;)</span><br></pre></td></tr></table></figure><br><code>ZeroDivisionError</code>之类的异常，实际上都继承自<code>BaseException</code>，所以当<code>except</code>语句后面加上<code>BaseException</code>,表示捕获所有的异常，也就是说<code>BaseException</code>的所有子类都会被捕获。</p>
<h3 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h3><blockquote>
<p>如果错误没有被捕获，它就会一直往上抛，最后被Python解释器捕获，打印一个错误信息，然后程序退出。</p>
</blockquote>
<p>其实就是当main语句中某处出现错误的时候，会返回出错的位置，如出错的位置为函数，则跳转到这个函数中，继续检查出现错误的语句，然后一步步深入，这个称为<code>异常栈</code></p>
<h3 id="记录错误"><a href="#记录错误" class="headerlink" title="记录错误"></a>记录错误</h3><p>原先的错误抛出方式会导致程序退出，但是可以使用<code>logging</code>模块，将错误记录下来，然后继续执行程序<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line">def error():</span><br><span class="line">    try:</span><br><span class="line">        result = 1/0</span><br><span class="line">        #result = int(&#x27;w&#x27;)</span><br><span class="line">        print(&#x27;Pass1&#x27;)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        logging.exception(e)</span><br><span class="line">error()</span><br><span class="line">print(&#x27;Pass2&#x27;)</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">ERROR:root:division by zero</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;ipython-input-12-21a7559c0ac6&gt;&quot;, line 4, in error</span><br><span class="line">    result = 1/0</span><br><span class="line">ZeroDivisionError: division by zero</span><br><span class="line">Pass2</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>通过配置，<code>logging</code>还可以把错误记录到日志文件里，方便事后排查。</p>
</blockquote>
<h3 id="抛出错误"><a href="#抛出错误" class="headerlink" title="抛出错误"></a>抛出错误</h3><blockquote>
<p>只有在必要的时候才定义我们自己的错误类型。如果可以选择Python已有的内置的错误类型（比如ValueError，TypeError），尽量使用Python内置的错误类型。</p>
</blockquote>
<p>可以使用<code>rise</code>来抛出异常。</p>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def dive():</span><br><span class="line">	assert a != 0, &#x27;AssertionError: The denominator is zero!&#x27;</span><br><span class="line">	....</span><br></pre></td></tr></table></figure>
<p><code>assert</code>的意思是，表达式n != 0应该是True，否则，根据程序运行的逻辑，后面的代码肯定会出错。<br>如果断言失败，assert语句本身就会抛出AssertionError：</p>
<blockquote>
<p><code>AssertionError</code>: The denominator is zero!</p>
</blockquote>
<p>当程序中包含过多的<code>assert</code>,也会导致不良的影响，在启动python解释器的时候可以加上<code>-O</code>（大写字母O）来关闭<code>assert</code>语句。</p>
<blockquote>
<p>$ python -O err.py</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/25/%E3%80%8A%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%8B%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/25/%E3%80%8A%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%8B%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" class="post-title-link" itemprop="url">《算法笔记》第十一章(动态规划)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-25 15:29:44" itemprop="dateCreated datePublished" datetime="2021-03-25T15:29:44+08:00">2021-03-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-08 19:47:18" itemprop="dateModified" datetime="2023-03-08T19:47:18+08:00">2023-03-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>@[toc]</p>
<h1 id="动态规划介绍"><a href="#动态规划介绍" class="headerlink" title="动态规划介绍"></a>动态规划介绍</h1><p><strong>动态规划（Dynamic Programming</strong>)用于解决一类最优化问题。它将一个问题划分成几个相同的子问题，通过找到子问题的全局最优解，得到整个问题的最优解。<br><br><br><strong>DP与贪心算法的主要区别是</strong>：<u>贪心算法选用的是当前步骤的最优解，但是DP采用的是当前子问题的全局最优解。</u>DP因为每一步都是当前子问题的全局最优解，所以最后的一个子问题（原问题）也是全局最优解。而贪心算法由于是局部最优解，所以只能得到一个局部最优解。<br><img src="https://img-blog.csdnimg.cn/20210317203300613.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在动态规划的一类问题中，子问题之间会出现重叠子问题，为了避免重复计算，可以用一个数组变量作为备忘录，记录当前的子问题的最优解。<br>下面是求解斐波那契数列的问题：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">F</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">F</span>(n - <span class="number">1</span>) + <span class="built_in">F</span>(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以注意到在求解最终结果之前，这个算法花费了大量的时间去计算一些重复的问题，因为$F(n-1) = F(n-2)+F(n-3)$，所以在完成第一个递归的时候，其实第二个递归式已经被计算过了，所以可以将这个结果利用起来。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN = 10</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">F</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//将数组初始化为-1.表示该结果未被计算</span></span><br><span class="line">		<span class="type">int</span>*dp = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line">		<span class="built_in">fill</span>(dp, dp + n, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (dp[n] != <span class="number">-1</span>)<span class="keyword">return</span> dp[n];</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			dp[n] = <span class="built_in">F</span>(n - <span class="number">1</span>) + <span class="built_in">F</span>(n - <span class="number">2</span>);</span><br><span class="line">			<span class="keyword">return</span> dp[n];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//当只需要第n个斐波那契数的时候，使用三个变量滚动更新即可</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">F</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//三个变量分别表示F(n-2)、F(n-1)、F(n)</span></span><br><span class="line">		<span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>, c = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++n) &#123;</span><br><span class="line">			c = a + b;</span><br><span class="line">			a = b;</span><br><span class="line">			b = c;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><br>通过记忆之前的计算结果，避免了重复子问题的求解，从而使求解的时间复杂度由原先的O($2^ { n }$)转变成O($n$)。</p>
<h2 id="递推写法"><a href="#递推写法" class="headerlink" title="递推写法"></a>递推写法</h2><p>现在看一个数塔问题，需要求解从顶层到最底层的所形成的最大的数字。如下图：<br><img src="https://img-blog.csdnimg.cn/20210317213841404.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>从最顶层开始，我们先假设下一层的各个元素到最低层所形成的最大数字都已经知道了，并且存放在一个二维数组中。在上图中，最顶层的元素到最层的所形成的最大数字可以表示为：</p>
<script type="math/tex; mode=display">dp[1][1] = max(dp[2][1],dp[2][2]) + val[1][1]</script><p><font color="#999AAA"><em>其中，dp存放各节点到最底层形成的最大数字，val存放当前节点的所存储的值。</em></font></p>
<p>同样的，每一个子问题的求解也可以用与头节点相同的方法进行求解。所以可以得到一个<strong>状态转移方程</strong>：</p>
<script type="math/tex; mode=display">dp[i][j] = max(dp[i+1][j],dp[i+1][j+1]) + val[i][j]</script><p>这样就得到了一个上下层之间的关系式。这也就是说我们可以利用下层的结果来求解上层！又注意到，最底层节点到最底层节点所能形成最大的数字就是其本身！所以通过自底向上（Bottom-up）的方法，可以逐步向上求解的最终的问题的答案！<br>这种算法的分析模式似乎就是<strong>从上往下分析最优解的结构，从下往上求解最优解</strong>。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">numTower</span><span class="params">(<span class="type">int</span> f[maxn][maxn])</span></span>&#123;</span><br><span class="line">	<span class="comment">//边界	</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n;++j)&#123;</span><br><span class="line">		dp[n][j] = f[n][j];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//向上更新各节点的最优结果</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = n <span class="number">-1</span>; i &gt;= <span class="number">1</span>; i--)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i;j++)&#123;</span><br><span class="line">			dp[i][j] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][j],dp[i + <span class="number">1</span>][j + <span class="number">1</span>]) + f[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这一类问题有一个共同点，那就是拥有<strong>最优子结构(Optimal Structure)</strong>，通过这个最优子结构可以构造出这个问题的最优解。<br>这样一个问题想要用动态规划进行求解，需要满足两个条件：<strong>拥有重叠子问题和最优子结构</strong>。前者是发挥动态规划优势条件，后者是产生状态转移方程的条件。<br><code>递归与递推</code>的写法在本质上是一致的，但是在写法上存在一些区别，<code>递归</code>是通过向下递归，一步步得到最优解的（就像是先利用还未被解出来的结果）所以是<strong>自顶向下</strong>的。而<code>递推</code>需要一步步获得子问题的最优解（就像是利用的是求解出来的结果），所以是<strong>自底向上</strong>的。</p>
<h1 id="最大连续子序列和"><a href="#最大连续子序列和" class="headerlink" title="最大连续子序列和"></a>最大连续子序列和</h1><p>问题描述：</p>
<blockquote>
<p>给定一个数字数列$A_1,A_2…,A_n$,求$i，j(1\le i\le j \le n)$，使得$A_i+….+A_j$最大，输出这个最大和</p>
</blockquote>
<h2 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h2><p>首先可以采用枚举的方式，从第一个元素开始。让$i$固定，让$j$指针向后移动，统计最大值，然后将$i$向后移动，重复上面的操作。这样枚举过程需要的时间复杂度为$O(n^2)$，加上求和过程中的复杂度为$O(n)$，总复杂度为$O(n^3)$,如果用数组记住原先的计算结果，通过推算求得子序列的和，那么总复杂度为$O(n^2)$.</p>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>将$dp[i]$作为以$A_i$结尾的、和最大的连续子序列，这样$dp[i]$的取值为：</p>
<script type="math/tex; mode=display">dp[i] = max\{A[i],dp[i-1]+A[i]\}</script><p>这也就是选择加或者不加之前元素的序列，看看哪个序列和更大。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> A[maxn], dp[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sumOfserial</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//输入</span></span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;A[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//边界</span></span><br><span class="line">	dp[<span class="number">0</span>] = A[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">//更新状态数组</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">		dp[i] = <span class="built_in">max</span>(A[i], dp[i - <span class="number">1</span>] + A[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//找到最大的结果所在的位置</span></span><br><span class="line">	<span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (dp[i] &gt; dp[k]) k = i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//输出结果</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dp[k]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="最长不下降子序列（LIS）"><a href="#最长不下降子序列（LIS）" class="headerlink" title="最长不下降子序列（LIS）"></a>最长不下降子序列（LIS）</h1><p>LIS(Longest Increasing Sequence)问题描述</p>
<blockquote>
<p>在一个数字序列中，找到一个最长的子序列（可以不连续），使得这个序列是不下降（非递减）的。</p>
</blockquote>
<h2 id="暴力求解"><a href="#暴力求解" class="headerlink" title="暴力求解"></a>暴力求解</h2><p>如果采用暴力解法，即每个元素都有两种情况，加入子序列或者是不加入子序列，将每一个元素进行枚举，找出最长的LIS，更新最大长度，但是这样的时间复杂度为O($2^n$)。</p>
<h2 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h2><p>现在尝试使用动态规划进行求解。将$dp[i]$当成以$i$结尾的LIS，将第$i$个序列元素作为$A[i]$，想要找到最长的序列，就需要遍历$i$之前的所有$dp[j]$，尝试将$A[i]$加入到这个子序列中，看是否能形成更大的LIS。所以$dp[i]$的状态转移方程为：</p>
<script type="math/tex; mode=display">dp[i] = max\{1, dp[j]+1\}\\(j = 1,2,....,i-1 \&\& A[j]<A[i])</script><p>当$A[i]$加到所有的子序列中都不能够成LIS时，那就只能$A[i]$自己形成一个子序列，所以为1。<br>整个算法时间复杂度$O(n^2)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入参数为序列以及序列元素个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LSP</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		dp[i] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (A[i] &gt;= A[j] &amp;&amp; (dp[j] + <span class="number">1</span> &gt; dp[i])) &#123;</span><br><span class="line">				dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ans = ans &gt; dp[i] ? ans : dp[i];</span><br><span class="line">		<span class="comment">//ans = max(ans, dp[i]);</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="最长公共子序列-LCS"><a href="#最长公共子序列-LCS" class="headerlink" title="最长公共子序列(LCS)"></a>最长公共子序列(LCS)</h1><p>问题描述</p>
<blockquote>
<p>给定两个字符串（或数字序列）A和B，求一个字符串，使得这个字符串是A和B的最长公共部分（子序列可以不重合）<br>例如：“sadstory”和“adminsorry”的最长公共子序列为“adsory”</p>
</blockquote>
<h2 id="暴力解法-1"><a href="#暴力解法-1" class="headerlink" title="暴力解法"></a>暴力解法</h2><p>每一个元素都有选或者不选两种选择，所以想要遍历所有的元素需要的时间复杂度为$O(2^{m+n})$,选出来的序列需要进行比较(用分别指向两个序列的指针)，这需要的时间复杂度为$O(max(m,n))$,所以总的时间复杂度为$O(2^{m+n}\times max(m,n))$</p>
<h2 id="动态规划-2"><a href="#动态规划-2" class="headerlink" title="动态规划"></a>动态规划</h2><p>首先定义dp数组，将$dp[i][j]$作为A的$(1 \sim i)$子串和B的$(1\sim j)$子串所能形成的最长的公共子串。</p>
<p><img src="https://img-blog.csdnimg.cn/20210328152444324.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>从上图可以看出，有两种情况：</p>
<script type="math/tex; mode=display">dp[i][j]=\left\{
\begin{aligned}
dp[i-1][j-1], A[i] == B[j]\\
max\{dp[i-1][j],dp[i][j-1]\}, A[i] != B[j]
\end{aligned}
\right.</script><p>同时也可以看到二维矩阵的四周就是动态规划的边界。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100</span>;</span><br><span class="line"><span class="type">char</span> A[N], B[N];<span class="comment">//两个目标字符串数组</span></span><br><span class="line"><span class="type">int</span> dp[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="comment">//Input those datas.Note that the index is starting from 1</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; ++i) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;A[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; ++i) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;B[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//Calculating the length from 1.</span></span><br><span class="line">	<span class="type">int</span> lenA = <span class="built_in">strlen</span>(A + <span class="number">1</span>);</span><br><span class="line">	<span class="type">int</span> lenB = <span class="built_in">strlen</span>(B + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Boundary</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= lenA; ++i) &#123;</span><br><span class="line">		dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= lenB; ++i) &#123;</span><br><span class="line">		dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//State Transition Equations</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= lenA; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= lenB; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (A[i] == B[j]) &#123;</span><br><span class="line">				dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Output the result</span></span><br><span class="line">	cout &lt;&lt; dp[lenA][lenB] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h1><p>运用动态规划的方法可以将原先的暴力解法的时间复杂度$O(n^3)$变成$O(n^2)$。还是像原先的一样，只要子序列是否为回文子串，需要通过判断子串两端的元素是否相同，然后再利用该子串的子串来判断整体子串是否为回文子串。用公式表示为：<br>将$dp[i][j]$定义为$S[i]$至$S[j]$是否为回文序列，是则为1，否则为0.</p>
<script type="math/tex; mode=display">dp[i][j]=\left\{
\begin{aligned}
dp[i+1][j-1],S[i] == S[j]\\
0,S[i]!=S[j]
\end{aligned}
\right.</script><p>边界：$dp[i][i] =1,dp[i][i+1] = (S[i] == S[i+1])?1:0$<br>但是直接将$i$和$j$从小到大枚举（ $i = 0,j = 1,2,3….$）会导致一些问题。因为动态规划是自底向上的，所以只有将子问题解出来，才能解决更大的子问题。但是在这个问题中，例如需要计算$dp[0][4]$的时候，会需要$dp[1][3]$的结果，但是这个问题的结果并没有求解出来。所以需要转换枚举方式。<br>注意到每次进行状态转移的时候，都是将子串的长度减少了一，所以可以考虑先将所有长度小的子串全部计算出来，然后再求长度更长的子串。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Palindrome</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line">	<span class="type">char</span> S[maxn];</span><br><span class="line">	<span class="type">int</span> dp[maxn][maxn];</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Input datas</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;S[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> len = <span class="built_in">strlen</span>(S), ans = <span class="number">1</span>;<span class="comment">//&#x27;ans&#x27;stores the length of longest subarray</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//Initializing dp array</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; maxn; ++j) &#123;</span><br><span class="line">			dp[i][j] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Set up Boundaries</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">		dp[i][i] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (i &lt; len - <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (S[i] == S[i + <span class="number">1</span>]) &#123;</span><br><span class="line">				dp[i][i + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">				ans = <span class="number">2</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//State Transition Equation</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> L = <span class="number">3</span>; L &lt;= len; L++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i + L - <span class="number">1</span> &lt; len; ++i) &#123;</span><br><span class="line">			<span class="type">int</span> j = i + L - <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (S[i] == S[j] &amp;&amp; dp[i + <span class="number">1</span>][j - <span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">				dp[i][j] = <span class="number">1</span>;</span><br><span class="line">				ans = L;<span class="comment">//Updating the length</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>To Be Continue…</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/10/%E7%AE%97%E6%B3%95%E2%9E%A1%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/10/%E7%AE%97%E6%B3%95%E2%9E%A1%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">算法➡数学问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-10 08:00:41" itemprop="dateCreated datePublished" datetime="2021-03-10T08:00:41+08:00">2021-03-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-08 19:48:51" itemprop="dateModified" datetime="2023-03-08T19:48:51+08:00">2023-03-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h1><p>8➡10:</p>
<script type="math/tex; mode=display">123_{oct} = 3 \times8^0+2\times8^1+1\times8^2 = 83_{dec}</script><p>10➡8:</p>
<script type="math/tex; mode=display">
\left.\ \begin{aligned}
83_{dec} \div 8 = 10 ······3\\
10_{dec}\div 8 = 1······2\\
1_{dec} \div8 = 0······1\\
\end{aligned}
\right\uparrow</script><p>其他的都是类似的。从低进制到高进制就按照第一种方式，否则按照第二种方式，二者实际上是一个逆过程。其他的可以先转换成十进制，然后再转换成目标进制。</p>
<h1 id="最大公约数与最小公倍数"><a href="#最大公约数与最小公倍数" class="headerlink" title="最大公约数与最小公倍数"></a>最大公约数与最小公倍数</h1><p>最大公约数可以用于分数运算的时候的化简。</p>
<h2 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h2><p>最大公约数可以利用欧几里得算法（辗转相除法）进行求解。</p>
<blockquote>
<p>设a、b均为正整数，则gcd(a,b) = gcd(b, a%b)</p>
</blockquote>
<p>有了递推式之后，还需要一个递归边界，因为0与任意数字a的最大公约数为a，所以可以利用这个作为递归的出口。<br>在这里需要a&gt;b所以应该在先判断a和b的大小。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd1</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(a &lt; b)&#123;</span><br><span class="line">		<span class="type">int</span> temp = a;</span><br><span class="line">		a = b;</span><br><span class="line">		b = temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(b == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等价形式</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(a &lt; b)&#123;</span><br><span class="line">		<span class="type">int</span> temp = a;</span><br><span class="line">		a = b;</span><br><span class="line">		b = temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> !b ? a : <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//辗转相除法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd3</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(a &lt; b)&#123;</span><br><span class="line">		<span class="type">int</span> temp = a;</span><br><span class="line">		a = b;</span><br><span class="line">		b = temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(b != <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="type">int</span> temp = a % b;</span><br><span class="line">		a = b;</span><br><span class="line">		b = temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> a;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h1 id="素数"><a href="#素数" class="headerlink" title="素数"></a>素数</h1><h2 id="判断素数"><a href="#判断素数" class="headerlink" title="判断素数"></a>判断素数</h2><p>素数的定义是除了1和本身之外不能被其他整数整除的一类数。因为假设一个数字k可以整除数字n，那么有$\frac nk \times k=n$所以这里可以得到，$\frac nk$也是可以整除n的。这也就是说这两个数一定是一个大于等于sqrt(n)，一个小于sqrt(n)的，所以只需要遍历2~sqrt(n)(范围之内的所有整数，检查是否存在能够整除目标数字的数即可)（反证法，假设该数能够整除目标数字，而能够整除目标数字的数是成对出现的）<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n &lt;= <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">else</span>&#123;<span class="comment">//这个else语句是可以不要的</span></span><br><span class="line">		<span class="type">int</span> sqr = <span class="built_in">sqrt</span>(<span class="number">1.0</span> * n);<span class="comment">//由于sqrt函数需要浮点型，所以这里乘以1.0</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= sqr; ++i)&#123;</span><br><span class="line">			<span class="keyword">if</span>(n % i == <span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="素数表的获取"><a href="#素数表的获取" class="headerlink" title="素数表的获取"></a>素数表的获取</h2><p>由于判断一个数字是否属于素数的时间复杂度为O($\sqrt{n}$),所以想要获取n个素数的时间复杂度为O(n* $\sqrt{n}$ )<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">101</span>;</span><br><span class="line"><span class="type">int</span> prime[maxn], pNum = <span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> p[maxn] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Find_Prime</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; maxn; ++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">isPrime</span>(i) == <span class="literal">true</span>)&#123;</span><br><span class="line">			prime[pNum++] = i;</span><br><span class="line">			p[i] = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>还有一种算法是欧拉筛选法，其时间复杂度为O(nlong long n)</p>
<h1 id="质因子分解"><a href="#质因子分解" class="headerlink" title="质因子分解"></a>质因子分解</h1><p> 质因子分解就是将一个非质数分解成素数的乘积，素数在乘积中可以重复出现。</p>
<blockquote>
<p>对一个正整数n 来说，如果它存在［2, n］范围内的质因子，要么这些质因子全部小于等于sqrt(n），要么只存在一个大于sqrt(n）的质因子，而其余质因子全部小于等于sqrt(n）</p>
</blockquote>
<p>算法思想：求出素数表，然后用输入的参数x与该素数取余数，直到无法被整除，换下一个素数，直到x变成0。之后按照格式进行输出。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自己写的，水平有限，后续会对此进行优化</span></span><br><span class="line"><span class="comment">//判断是否为质数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &lt; <span class="number">2</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">double</span> sq = <span class="built_in">sqrt</span>(x * <span class="number">1.0</span>);</span><br><span class="line">	<span class="type">int</span> num = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">while</span> (num &lt;= sq) &#123;</span><br><span class="line">		<span class="keyword">if</span> (x % num == <span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		num++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//质数的结构体，包含质数数字本身，以及在分解式中出现的次数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">prime</span>&#123;</span><br><span class="line">	<span class="type">int</span> data = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//质因子分解</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prime_factorization</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	prime prime_list[<span class="number">200</span>];</span><br><span class="line">	<span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> copy = x;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//考虑到输入参数本身就是质数的情况，边界设置为i&lt;=x</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">isPrime</span>(i))prime_list[index++].data = i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">		<span class="type">int</span> temp = prime_list[i].data;</span><br><span class="line">		<span class="keyword">while</span> (x % temp == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span>) &#123;</span><br><span class="line">			prime_list[i].num++;</span><br><span class="line">			x /= temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//输出</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d=&quot;</span>, copy);</span><br><span class="line">	<span class="type">bool</span> flag = <span class="literal">true</span>;<span class="comment">//标记是否为第一个数字</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= index; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; prime_list[i].num; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (flag != <span class="literal">true</span>)<span class="built_in">printf</span>(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">			<span class="comment">//printf(&quot;*&quot;);</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, prime_list[i].data);</span><br><span class="line">			flag = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//getchar();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="大数运算"><a href="#大数运算" class="headerlink" title="大数运算"></a>大数运算</h1><h2 id="大数乘法"><a href="#大数乘法" class="headerlink" title="大数乘法"></a>大数乘法</h2><p>将两个数字按照位从小到大从低位到高位依次加入到数组中。将其中的一个乘数从按位从小到大乘以另外一个数，加到数组中。每一位只加上计算结果的个位数，进位加到下一位中。最后的结果数组中可能还会有某一位超过十的数字的位，这时候就取余，调整成各位就可以了。</p>
<p><img src="https://img-blog.csdnimg.cn/20210320111018908.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初级版本，还有在后序进行改进的</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">stimuMulti</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> an, <span class="type">int</span> b[],<span class="type">int</span> bn)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//初始化结果数组</span></span><br><span class="line">		<span class="type">int</span> result[<span class="number">100</span>];</span><br><span class="line">		<span class="built_in">fill</span>(result, result + <span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//计算各位的值</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= bn; ++i) &#123;</span><br><span class="line">			<span class="type">int</span> carry = <span class="number">0</span>;<span class="comment">//进位</span></span><br><span class="line">			<span class="type">int</span> index_result = i;<span class="comment">//错位相加（开始的位置错一位）</span></span><br><span class="line">			<span class="comment">//关键部分</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= an; ++j) &#123;</span><br><span class="line">				result[index_result++] += (b[i] * a[j]) % <span class="number">10</span>;</span><br><span class="line">				carry = (a[j] * b[i]) / <span class="number">10</span>;</span><br><span class="line">				result[index_result] += carry;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//将最后一位的下一位作为结束标志</span></span><br><span class="line">			<span class="keyword">if</span> (i == bn)result[++index_result] = <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//调整，将大于十的位调整为小于十</span></span><br><span class="line">		<span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (result[i++] != <span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (result[i] &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">				<span class="type">int</span> carry = result[i] / <span class="number">10</span>;</span><br><span class="line">				result[i] %= <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">				<span class="comment">//当最后一位需要进位的时候</span></span><br><span class="line">				<span class="keyword">if</span> (result[i + <span class="number">1</span>] == <span class="number">-1</span>) &#123;</span><br><span class="line">					result[i + <span class="number">2</span>] = <span class="number">-1</span>;</span><br><span class="line">					result[i + <span class="number">1</span>]++;</span><br><span class="line">				&#125;</span><br><span class="line">				result[i + <span class="number">1</span>] += carry;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//输出</span></span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">		<span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i - <span class="number">2</span>; j &gt;= <span class="number">1</span>; --j) &#123;</span><br><span class="line">			<span class="comment">//将最高位前面的0全部忽略掉</span></span><br><span class="line">			<span class="keyword">if</span> (result[j] == <span class="number">0</span> &amp;&amp; flag == <span class="literal">false</span>) &#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			flag = <span class="literal">true</span>;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, result[j]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="literal">false</span>)<span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h1 id="几何问题"><a href="#几何问题" class="headerlink" title="几何问题"></a>几何问题</h1><h2 id="由三点的坐标求所构成的三角形的面积"><a href="#由三点的坐标求所构成的三角形的面积" class="headerlink" title="由三点的坐标求所构成的三角形的面积"></a>由三点的坐标求所构成的三角形的面积</h2><p>有几个比较常用的计算面积公式：</p>
<script type="math/tex; mode=display">S_{\Delta ABC} =  \frac 12 \vert \vec a\vert \vert \vec b\vert sin<\vec a,\vec b ></script><p>海伦公式：</p>
<script type="math/tex; mode=display">S_{\Delta ABC} = \sqrt {p(p-a)(p-b)(p-c)},其中p = \frac {a+b+c}{2}</script><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用了第一个求面积的公式</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">point</span>&#123;</span><br><span class="line">	<span class="type">double</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求两点形成的向量</span></span><br><span class="line"><span class="function">point <span class="title">decPoint</span><span class="params">(point p1, point p2)</span></span>&#123;</span><br><span class="line">	point res;</span><br><span class="line">	res.x = p1.x - p2.x;</span><br><span class="line">	res.y = p1.y - p2.y;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求两向量的叉乘</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">mutiPoint</span><span class="params">(point p1, point p2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (p1.x*p2.y - p2.x*p1.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求面积</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">areaOfThreePoint</span><span class="params">(point a, point b, point c)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">fabs</span>(<span class="built_in">multipoint</span>(<span class="built_in">decPoint</span>(B, A), <span class="built_in">decPonint</span>(C, A))/<span class="number">2.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="判断点是否在三角形内"><a href="#判断点是否在三角形内" class="headerlink" title="判断点是否在三角形内"></a>判断点是否在三角形内</h2><p>针对这个问题有几个虽然麻烦但是十分直观的做法。1.计算该点和三角形三点组成的面积之和，若于三角形面积相等，则该点在三角形内。2.计算该点与三角形所有任意两点组成的夹角之和，判断是否等于360°。<br><img src="https://img-blog.csdnimg.cn/20210320135214157.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>还有一种是利用叉乘。想要该点在三角形内，只需要该点在三条边的下面/上面。如果该点在三角形内部，那么该点与三角形三点形成的向量和三角形三条边形成的向量的叉乘的方向是一致的。叉乘的计算方式如下：</p>
<script type="math/tex; mode=display">设a(x_1,y_1),b(x_2,y_2),则\vec a×\vec b = (x_1*y_2-x_1*y_1)\vec j, \vec a×\vec b = \vert a\vert \vert b\vert*sin(\theta)</script><p><img src="https://upload.wikimedia.iwiki.eu.org/wikipedia/commons/thumb/b/b0/Cross_product_vector.svg/800px-Cross_product_vector.svg.png" width="200" height alt="向量叉乘图示" align="center"><br>（右图是两向量的叉乘的图示,图源Wikipedia)</p>
<p>所以可以借用两个向量的叉乘的正负情况，判断二者是否在同一方向上。<br><img src="https://img-blog.csdnimg.cn/20210320194633693.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>算法思想：创建一个方向函数，将三点的坐标作为参数，计算出各边的向量，然后计算出叉乘，将叉乘的结果的正负作为返回值。判断所有的叉乘结果的符号是否都相等。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//转载自牛客网https://www.nowcoder.com/questionTerminal/f9c4290baed0406cbbe2c23dd687732c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">direction</span><span class="params">(<span class="type">double</span> x1, <span class="type">double</span> y1, <span class="type">double</span> x2, <span class="type">double</span> y2, <span class="type">double</span> x3, <span class="type">double</span> y3)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    求向量V和点(x3, y3)之间的位置关系，(x1, y1)是V的起点，(x2, y2)是V的终点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//得到向量V</span></span><br><span class="line">    x2 -= x1;</span><br><span class="line">    y2 -= y1;</span><br><span class="line">    <span class="comment">//V的起点(x1, y1)与目标点(x3, y3)构成新的向量U</span></span><br><span class="line">    x3 -= x1;</span><br><span class="line">    y3 -= y1;</span><br><span class="line">    <span class="type">double</span> res = x3 * y2 - x2 * y3;<span class="comment">//求两向量U和V的外积（叉积）</span></span><br><span class="line">    <span class="keyword">if</span>(res &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//&lt;0在逆时针方向</span></span><br><span class="line">    <span class="keyword">if</span>(res == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//=0共线</span></span><br><span class="line">    <span class="keyword">if</span>(res &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//&gt;0说明点在向量顺时针方向</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> x1, y1;</span><br><span class="line">    <span class="type">double</span> x2, y2;</span><br><span class="line">    <span class="type">double</span> x3, y3;</span><br><span class="line">    cin &gt;&gt; x1 &gt;&gt; y1;</span><br><span class="line">    cin &gt;&gt; x2 &gt;&gt; y2;</span><br><span class="line">    cin &gt;&gt; x3 &gt;&gt; y3;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> x4, y4;</span><br><span class="line">    cin &gt;&gt; x4 &gt;&gt; y4;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(x1, y1)与(x2, y2)构成向量V1</span></span><br><span class="line">    <span class="comment">//(x2, y2)与(x3, y3)构成向量V2</span></span><br><span class="line">    <span class="comment">//(x3, y3)与(x1, y1)构成向量V3</span></span><br><span class="line">    <span class="type">int</span> res1 = <span class="built_in">direction</span>(x1, y1, x2, y2, x4, y4);</span><br><span class="line">    <span class="type">int</span> res2 = <span class="built_in">direction</span>(x2, y2, x3, y4, x4, y4);</span><br><span class="line">    <span class="type">int</span> res3 = <span class="built_in">direction</span>(x3, y3, x1, y1, x4, y4);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">abs</span>(res1 + res2 + res3) == <span class="number">3</span>)&#123;<span class="comment">//全-1或全1，表示点(x4, y4)同时在三个向量的同一侧</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Yes&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="集合问题"><a href="#集合问题" class="headerlink" title="集合问题"></a>集合问题</h1><h2 id="子集问题"><a href="#子集问题" class="headerlink" title="子集问题"></a>子集问题</h2><p>原文：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/qT6WgR6Qwn7ayZkI3AineA">https://mp.weixin.qq.com/s/qT6WgR6Qwn7ayZkI3AineA</a></p>
<h3 id="数学归纳法"><a href="#数学归纳法" class="headerlink" title="数学归纳法"></a>数学归纳法</h3><p>对于${1,2,3}$的子集，通过观察发现，原数组的子集跟它子集的子集是有关联的。注意到：<script type="math/tex">Subset_{\{1,2,3\}} -Subset_{\{1,2\}} = \{3\},\{1,3\},\{2,3\},\{1,2,3\}</script><br>而这个子集又是可以从${1,2}$的子集中，每一个子集加上一个元素3之后的结果。同样，${1,2}$的子集又可以通过${1}$的子集加上元素2之后得来。<br>所以，</p>
<script type="math/tex; mode=display">Subset_{\{1,2,3\}} = Subset_{\{1,2\}} + \{Subset_{\{1,2\}} append \{3\}\}\\
Subset_{\{1,2\}} = Subset_{\{1\}} + \{Subset_{\{1\}} append \{2\}\}\\
Subset_{\{1\}} = Subset_{\{\}} + \{Subset_{\{\}} append \{1\}\}</script><p>所以可以将空数组作为基元素。<br><img src="https://img-blog.csdnimg.cn/20210322082910901.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="comment">// base case，返回一个空集</span></span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> &#123;&#123;&#125;&#125;;</span><br><span class="line">    <span class="comment">// 把最后一个元素拿出来</span></span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">back</span>();</span><br><span class="line">    nums.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="comment">// 先递归算出前面元素的所有子集</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res = <span class="built_in">subsets</span>(nums);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> size = res.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="comment">// 然后在之前的结果之上追加</span></span><br><span class="line">        res.<span class="built_in">push_back</span>(res[i]);<span class="comment">//这里是将原先的数组赋值了一份过来然后再往结尾的地方加上最后一个元素</span></span><br><span class="line">        res.<span class="built_in">back</span>().<span class="built_in">push_back</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这种写法的时间复杂度和空间复杂度很大[O($n\times 2^n$)]，下面用的是回溯法去求解。</p>
<h3 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h3><p>下面是<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&amp;mid=2247485007&amp;idx=1&amp;sn=ceb42ba2f341af34953d158358c61f7c&amp;chksm=9bd7f847aca071517fe0889d2679ead78b40caf6978ebc1d3d8355d6693acc7ec3aca60823f0&amp;scene=178&amp;cur_album_id=1318883740306948097#rd">东哥</a>总结的回溯法模板：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line">def backtrack(路径, 选择列表):</span><br><span class="line">    if 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        return</span><br><span class="line">    for 选择 in 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure><br>可以发现，前半部分因为是递归的因素，所以会不断在选择列表中加入元素，当递归全部结束的时候，会不断将原先加入的元素剔除，再进行递归，这个就类似于树的深度优先遍历。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="comment">// 记录走过的路径</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; track;</span><br><span class="line">    <span class="built_in">backtrack</span>(nums, <span class="number">0</span>, track);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start, vector&lt;<span class="type">int</span>&gt;&amp; track)</span> </span>&#123;</span><br><span class="line">    res.<span class="built_in">push_back</span>(track);</span><br><span class="line">    <span class="comment">// 注意 i 从 start 开始递增</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        track.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        <span class="comment">// 回溯</span></span><br><span class="line">        <span class="built_in">backtrack</span>(nums, i + <span class="number">1</span>, track);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        track.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>将这个过程可视化：<br><img src="https://img-blog.csdnimg.cn/20210324082353329.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>由上图可以发现，每个节点都是子集，所以在继续访问节点之前，先将节点信息保存。进行回溯的条件为，判断可供选择元素的数量，体现在循环数组中，当没有元素可供选择的时候，for语句就会退出。这时候就会退出全部算法，或者是退出当前递归层。返回递归的时候，将向量中的元素弹出，并且更新选择列表（体现在递归函数的输入的参数）。注意这里的选择列表的选取方式，这里更新之后的选择列表就是当前标志指针所指的之后的所有元素。</p>
<h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><p>每次都选取一个元素，并做好标记（防止元素被重复选取），然后重新遍历一遍所有元素，与之匹配，直到数组中的数量满足要求，将结果输出。</p>
<p><img src="https://img-blog.csdnimg.cn/20210324091018987.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//处理排列的idex号位</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">generateP</span><span class="params">(<span class="type">int</span> index)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//这是递归边界，前面的元素全部排列完毕，现在是要将数组输出</span></span><br><span class="line">	<span class="keyword">if</span> (index == n + <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, p[i]);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历检查所有的元素，这里引用了外部的变量n，由主函数定义</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">1</span>; x &lt;= n; ++x) &#123;</span><br><span class="line">		<span class="comment">//哈希表是来表示索引元素是否已经加入数组了</span></span><br><span class="line">		<span class="keyword">if</span> (hashTable[x] == <span class="literal">false</span>) &#123;</span><br><span class="line">			p[index] = x;<span class="comment">//以x作为头部的时候</span></span><br><span class="line">			hashTable[x] = <span class="literal">true</span>;<span class="comment">//更新状态</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//这里是继续下一位，注意这里还没有将哈希表重置，所以原先作为首部的元素是不会再被赋值了</span></span><br><span class="line">			<span class="built_in">generateP</span>(index + <span class="number">1</span>);</span><br><span class="line">			hashTable[x] = <span class="literal">false</span>;<span class="comment">//完成递归项中的一个，重置状态</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	count++;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">39</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
