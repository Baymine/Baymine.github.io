<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
<style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/12/C-%E6%A0%87%E5%87%8611-14/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/12/C-%E6%A0%87%E5%87%8611-14/" class="post-title-link" itemprop="url">C++标准11-14</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-10-12 19:46:26" itemprop="dateCreated datePublished" datetime="2022-10-12T19:46:26+08:00">2022-10-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-10-14 16:19:20" itemprop="dateModified" datetime="2022-10-14T16:19:20+08:00">2022-10-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1-演进、环境与资源"><a href="#1-演进、环境与资源" class="headerlink" title="1.演进、环境与资源"></a>1.演进、环境与资源</h3><p>C++1.0 : C++ 98<br>C++2.0: C++11</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查看支持的版本</span></span><br><span class="line">cout &lt;&lt; __cplusplus &lt;&lt; enl;</span><br></pre></td></tr></table></figure>

<h3 id="2-Variadic-Templates-1-21"><a href="#2-Variadic-Templates-1-21" class="headerlink" title="2. Variadic Templates + 1~21"></a>2. Variadic Templates + 1~21</h3><p>数量不定的模板参数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;&#125; <span class="comment">// 处理最后的情况，没有参数被传入，这个作为函数出口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样可以传入任意个数任意类型的参数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Types&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> T&amp; firstArg, <span class="type">const</span> Types&amp;... args)</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; firstArg &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">print</span>(args...)； <span class="comment">// 传入后不断被分开（这实际上是一个包）n = (n - 1) + 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">sizeof</span>...(args); <span class="comment">// 查看包中的参数个数</span></span><br></pre></td></tr></table></figure>
<p><code>...</code>: 实际上就是一个所谓的包</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用&quot;...&quot; 实现递归继承</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Values&gt; <span class="keyword">class</span> <span class="title class_">tuple</span>; <span class="comment">// 这种数据结构可以方任意个数以及任意类型的数据</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">class</span> <span class="title class_">tuple</span>&lt;&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Head, <span class="keyword">typename</span>... Tail&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">tuple</span>&lt;Head, Tail...&gt;</span><br><span class="line">    : <span class="keyword">private</span> tuple&lt;Tail...&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> tuple&lt;Tail...&gt; inherited;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">tuple</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">tuple</span>(Head v, Tail... vtail)</span><br><span class="line">        : <span class="built_in">m_head</span>(v), <span class="built_in">inherited</span>(vtail...)&#123;&#125;  <span class="comment">// 这是个初始化列表</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获得变量类型</span></span><br><span class="line">    <span class="comment">// typename Head::type head() &#123;return m_head;&#125;  // 这样写会报错，因为像int这样的类型没有无法调用type</span></span><br><span class="line">	<span class="function"><span class="keyword">auto</span> <span class="title">head</span><span class="params">()</span>-&gt;<span class="title">decltype</span><span class="params">(m_head)</span></span>&#123;<span class="keyword">return</span> m_head;&#125;</span><br><span class="line">	<span class="comment">// 或者</span></span><br><span class="line">	<span class="comment">// Head head() &#123;return m_head; &#125;</span></span><br><span class="line">    <span class="function">inherited&amp; <span class="title">tail</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Head m_head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>谁更特化，就优先调用谁。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个版本更加特化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Types&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> T&amp; firstArg, <span class="type">const</span> Types&amp;... args)</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; firstArg &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">print</span>(args...)； <span class="comment">// 传入后不断被分开（这实际上是一个包）n = (n - 1) + 1 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与上面的函数共存的话，这个函数永远不会被调用</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Types&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printX</span><span class="params">(<span class="type">const</span> Types&amp;... args)</span></span>&#123;<span class="comment">/**********/</span>&#125;</span><br></pre></td></tr></table></figure>
<p>一些应用实例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在多个参数中找到最大值。这一点也可以通过初始化列表直接调用标准库中的max函数:max(&#123;1,3,2,5&#125;)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maximum</span><span class="params">(<span class="type">int</span> n)</span> <span class="keyword">return</span> n</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maximum</span><span class="params">(<span class="type">int</span> n, Args... args)</span> <span class="keyword">return</span> <span class="title">std::max</span><span class="params">(n, maximum(args...))</span></span>;</span><br><span class="line"><span class="comment">// 标准库中的max函数只能接收两个参数，这里这样调用就像是一个栈</span></span><br></pre></td></tr></table></figure>

<p>递归复合</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Values&gt;<span class="keyword">class</span> <span class="title class_">tup</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;<span class="keyword">class</span> <span class="title class_">tup</span>&lt;&gt;&#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Head, <span class="keyword">typename</span>... Tail&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">tup</span>&lt;Head, Tail&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> tup&lt;Tail...&gt;composited;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	composited m_tail;</span><br><span class="line">	Head m_head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">tup</span>()&#123; &#125;</span><br><span class="line">	<span class="built_in">tup</span>(Head v, Tail... vtail)</span><br><span class="line">		: <span class="built_in">m_tail</span>(vtail...), <span class="built_in">m_head</span>(v) &#123; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">Head <span class="title">head</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> m_head;&#125;</span><br><span class="line">	<span class="function">composited&amp; <span class="title">tail</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> m_tail;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p><strong>空指针</strong>： <code>nullptr</code></p>
<p>还可以用<code>0</code>或者<code>NULL</code>定义空指针.但是在传递参数的时候可能会存在歧义</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">void</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(<span class="literal">nullptr</span>); <span class="comment">// call void f(void*)</span></span><br></pre></td></tr></table></figure>

<p><strong>auto</strong>: 尽量当类型比较长或者复杂的时候才使用，或者需要写lambda的类型</p>
<h3 id="4-Uniform-Initialization"><a href="#4-Uniform-Initialization" class="headerlink" title="4.Uniform Initialization"></a>4.Uniform Initialization</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化对象的方法</span></span><br><span class="line">className c = &#123;...&#125;;</span><br><span class="line"><span class="function">className <span class="title">c</span><span class="params">(...)</span></span>;</span><br><span class="line">className c&#123;...&#125;; <span class="comment">// Uniform Initialization 直接在变量后面的大括号中写初始化的数值</span></span><br><span class="line"><span class="type">int</span> values[] &#123;...&#125;;</span><br></pre></td></tr></table></figure>
<p>当编译器遇到{}时，会创建一个 initializer_list&lt;T&gt;，然后关联到array&lt;T, n&gt;,然后由此传给构造函数（分解之后，变成构造函数接收的形式）</p>
<h3 id="4，5、Initializer-list"><a href="#4，5、Initializer-list" class="headerlink" title="4，5、Initializer_list"></a>4，5、Initializer_list</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;  <span class="comment">// 未定义</span></span><br><span class="line"><span class="type">int</span> i&#123;&#125;; <span class="comment">// 初始化为0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">P</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">P</span>(<span class="type">int</span> a, <span class="type">int</span> b)&#123;...&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">P</span>(initializer_list&lt;list&gt; initlist)&#123; ...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">P <span class="title">p</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>; </span><br><span class="line">P q&#123;<span class="number">77</span>, <span class="number">5</span>&#125;;  <span class="comment">// 如果第二个构造函数不存在，那么编译器会将这两个数拆解，找到接收对应数目的参数的构造函数</span></span><br><span class="line"></span><br><span class="line">P r&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// 如果第二个构造函数不存在，则会报错，因为不存在接收三个参数的构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以利用初始化列表和max函数在三个或以上的数据中找到最大值</span></span><br><span class="line"><span class="built_in">max</span>(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">9</span>&#125;); </span><br></pre></td></tr></table></figure>

<h3 id="7-Explicit-for-constructor-taking-more-than-one-argument"><a href="#7-Explicit-for-constructor-taking-more-than-one-argument" class="headerlink" title="7. Explicit for constructor taking more than one argument"></a>7. Explicit for constructor taking more than one argument</h3><p>这个关键字存在时，构造函数不会被隐式调用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">12</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">Complex c2 = c1 + <span class="number">5</span>; <span class="comment">// 5会被隐式地转换成complex类型，如果构造函数被加上了explicit 则会报错</span></span><br></pre></td></tr></table></figure>

<h3 id="8-range-based-for-statement"><a href="#8-range-based-for-statement" class="headerlink" title="8. range-based for statement"></a>8. range-based for statement</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个循环中会有一个赋值地动作，所以可能会出现类型转换</span></span><br><span class="line"><span class="keyword">for</span> (decl : coll) &#123;</span><br><span class="line">	statement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-x3D-default-x3D-delete"><a href="#9-x3D-default-x3D-delete" class="headerlink" title="9. &#x3D;default, &#x3D;delete"></a>9. &#x3D;default, &#x3D;delete</h3><p>只能用于构造函数和析构函数，以及赋值重载的函数中。普通的函数没有这种性质。</p>
<blockquote>
<p>什么时候需要自己定义Big-Three 呢？<br>大多数时候，当类中有指针的需要写。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Foo</span>(<span class="type">int</span> i) : _i(i) &#123; &#125;</span><br><span class="line">	<span class="built_in">Foo</span>() =<span class="keyword">default</span>;<span class="comment">// 保留默认的构造函数</span></span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Foo</span>() = <span class="keyword">delete</span>;<span class="comment">// 删除默认的析构函数</span></span><br><span class="line">	~<span class="built_in">Foo</span>(<span class="keyword">typename</span> arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-Alias-Template"><a href="#10-Alias-Template" class="headerlink" title="10.Alias Template"></a>10.Alias Template</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Vec = std::vector&lt;T, MyAlloc&lt;T&gt;&gt;;  <span class="comment">// 设置化名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意不能对别名进行特化或者偏特化</span></span><br><span class="line">Vec&lt;<span class="type">int</span>&gt; coll; <span class="comment">// 等价于 std::vector&lt;int, MyAlloc&lt;int&gt;&gt; coll; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意使用define是无法达到相同的效果的，define仅仅会将指定的内容原封不动套入</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传入任意类型的数据, 这里借助容器的萃取机来获取数值类型</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_moveable</span><span class="params">(Container c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	typerdef typername iterator_traits&lt;<span class="keyword">typename</span> Container::iterator&gt;::value_type Valtype;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">long</span> i = <span class="number">0</span>; i &lt; SIZE; ++i) c.<span class="built_in">insert</span>(c.<span class="built_in">end</span>(), <span class="built_in">Valtype</span>());</span><br><span class="line"></span><br><span class="line">	<span class="built_in">output_static_data</span>(*(c.<span class="built_in">begin</span>());</span><br><span class="line">	Container <span class="built_in">c1</span>(c);</span><br><span class="line">	Container <span class="built_in">c2</span>(std::<span class="built_in">move</span>(c));</span><br><span class="line">	c1.<span class="built_in">swap</span>(c2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-template-template-parameter"><a href="#11-template-template-parameter" class="headerlink" title="11.template template parameter"></a>11.template template parameter</h3><p>化名模板</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">template</span>&lt;<span class="keyword">class</span>&gt; <span class="keyword">class</span> <span class="title class_">Container</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XCls</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Container&lt;T&gt; c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">XCls</span>()&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">long</span> i = <span class="number">0</span>; i &lt; SIZE; ++i) c.<span class="built_in">insert</span>(c.end, <span class="built_in">T</span>());</span><br><span class="line">		<span class="built_in">output_static_data</span>(<span class="built_in">T</span>());</span><br><span class="line">		Container&lt;T&gt;<span class="built_in">c1</span>(c);</span><br><span class="line">		Container&lt;T&gt;<span class="built_in">c2</span>(std::<span class="built_in">move</span>(c));</span><br><span class="line">		c1.<span class="built_in">swap</span>(c2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 想要声明变量，你需要定义alias template</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 这个不能在function body之中声明</span></span><br><span class="line"><span class="keyword">using</span> Vec = vector&lt;T, allocator&lt;T&gt;&gt;;</span><br><span class="line"></span><br><span class="line">XCls&lt;MyString, Vec&gt;c1;</span><br></pre></td></tr></table></figure>

<h3 id="12-Type-Alias-noexcept-override-final"><a href="#12-Type-Alias-noexcept-override-final" class="headerlink" title="12.Type Alias, noexcept, override, final"></a>12.Type Alias, noexcept, override, final</h3><p><strong>Type Alias</strong>: </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> func = <span class="built_in">void</span>(*)(<span class="type">int</span>, <span class="type">int</span>);  <span class="comment">// 这时候就是一个函数指针</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">example</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>&#123;&#125;</span><br><span class="line">func fn = example;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以使用类型化名隐藏模板参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">CharT</span>&gt; <span class="keyword">using</span> mystring = std::basic_string&lt;CahrT, std::char_traits&lt;CahrT&gt;&gt;;</span><br><span class="line">mystring&lt;<span class="type">char</span>&gt;std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//放到结构体中</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Container</span>&#123;</span><br><span class="line">	<span class="keyword">using</span> value_type = T;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>noexcept</strong>:<br>不抛出异常，需要在vector的构造函数上使用，使得vector在增长的时候能够调用构造函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;  <span class="comment">// void foo() noexcept(true);</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Type&amp; x, Type&amp; y)</span> <span class="title">noexcept</span> <span class="params">(<span class="keyword">noexcept</span> (x.swap(y)))</span></span>&#123;</span><br><span class="line">	x.<span class="built_in">swap</span>(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Override</strong>:<br>覆写需要签名一致，但是如果不一致编译器不会报错，这会产生一个新的函数，加上关键字<code>override</code>会让函数抛出异常。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived2</span>:Base&#123;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vfunc</span><span class="params">(<span class="type">int</span>)</span> <span class="keyword">override</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vfunc</span><span class="params">(<span class="type">float</span>)</span> <span class="keyword">override</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>final</strong>: 无法被继承</p>
<h3 id="13-decltype"><a href="#13-decltype" class="headerlink" title="13. decltype"></a>13. decltype</h3><p>找出表达式的类型，相当于typeof。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">float</span>&gt;coll;</span><br><span class="line"><span class="keyword">decltype</span>(coll)::value_type elem;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义返回类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">decltype</span>(x+y) <span class="built_in">add</span>(T1 x, T2 y); <span class="comment">// 在C++11之前不可实现，因为对象在这个范围内还没有引入</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T1 x, T2 y)</span>-&gt;<span class="title">decltype</span><span class="params">(x+y)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="title">decltype</span><span class="params">(obj)</span>::iterator iType</span>; <span class="comment">// 等价于typedef typename T::iterator iType;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将decltype used to pass the type of a lambda</span></span><br><span class="line"><span class="keyword">auto</span> cmp = [](<span class="type">const</span> Person&amp; p1, <span class="type">const</span> Person&amp; p2)&#123;</span><br><span class="line">	<span class="keyword">return</span> p1.<span class="built_in">lastname</span>() &lt; p2.<span class="built_in">lastname</span>() || </span><br><span class="line">			(p1.<span class="built_in">lastname</span>() == p2.<span class="built_in">lastname</span>() &amp;&amp; </span><br><span class="line">			p1.<span class="built_in">firstname</span>() &lt; p2.<span class="built_in">firstname</span>());</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">std::set&lt;Person, <span class="title">decltype</span><span class="params">(cmp)</span>&gt; <span class="title">coll</span><span class="params">(cmp)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="lambdas"><a href="#lambdas" class="headerlink" title="lambdas"></a>lambdas</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [id] <span class="keyword">mutable</span> &#123; <span class="comment">// 不加mutable就没有办法修改id</span></span><br><span class="line">	std::cout &lt;&lt; id &lt;&lt; std::endl;</span><br><span class="line">	++id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价形式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Functor</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> id;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">()</span></span>&#123;</span><br><span class="line">		std::cout &lt;&lt; id &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Functor f;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法举例</span></span><br><span class="line">[x, y](<span class="type">int</span> n) &#123;<span class="keyword">return</span> x &lt; n &amp;&amp; n &lt; y; &#125;</span><br></pre></td></tr></table></figure>
<p>lambda没有默认构造函数和赋值操作。</p>
<h2 id="第二讲：标准库"><a href="#第二讲：标准库" class="headerlink" title="第二讲：标准库"></a>第二讲：标准库</h2><h3 id="23-Rvalue-refernces-and-Move-Semantics"><a href="#23-Rvalue-refernces-and-Move-Semantics" class="headerlink" title="23. Rvalue refernces and Move Semantics"></a>23. Rvalue refernces and Move Semantics</h3><ul>
<li>临时对象就是一种右值（对于自定义的类（例如string）可以，int等类型不可以）</li>
<li>右值不可以放在左边</li>
<li>右值在被使用之后，应该被销毁，因为对于它的操作实际上就是改变指针指向，原先的右值的指针会被删除，这样这个右值也需要被删除</li>
</ul>
<h3 id="24-Perfect-Forwarding（完美传递）"><a href="#24-Perfect-Forwarding（完美传递）" class="headerlink" title="24. Perfect Forwarding（完美传递）"></a>24. Perfect Forwarding（完美传递）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入左值的版本</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp; i)</span></span>&#123;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 传入右值的版本</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp;&amp; i)</span></span>&#123;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">process</span>(a); <span class="comment">// 变量被视为左值</span></span><br><span class="line"><span class="built_in">process</span>(<span class="number">1</span>); <span class="comment">// 临时对象被视为右值</span></span><br><span class="line"><span class="built_in">process</span>(<span class="built_in">move</span>(a));  <span class="comment">// 强制将a由左值转换成右值</span></span><br></pre></td></tr></table></figure>
<p>不完美传递：在参数传递过程中，参数的左值右值可能会发生变化。这个问题可以使用标准库中的forward函数避免。</p>
<h3 id="25-写一个move-aware-class"><a href="#25-写一个move-aware-class" class="headerlink" title="25. 写一个move-aware class"></a>25. 写一个move-aware class</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 复制构造 </span></span><br><span class="line"><span class="built_in">MyString</span>(<span class="type">const</span> Mystring&amp; str) : _len(str._len)&#123;</span><br><span class="line">	_init_data(str._data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// &amp;&amp;：右值引用; 这个是移动构造</span></span><br><span class="line"><span class="built_in">MyString</span>(MyString&amp;&amp; str) <span class="keyword">noexcept</span></span><br><span class="line">	: _data(str._data), _len(str._len)&#123;</span><br><span class="line">		str._len = <span class="number">0</span>;</span><br><span class="line">		str._data = <span class="literal">NULL</span>; <span class="comment">// 因为传入的如果是临时变量，这个变量的生命周期只在这个函数中，如果这个指针还是指向原先的地址，那么在这个变量生命周期结束的时候，原先地址的数据也会被删除。</span></span><br><span class="line">		<span class="comment">// 有那么一瞬间，复制对象和这个临时对象之间指向的是同一个地址</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="26-Move-aware-class-对容器的效能测试"><a href="#26-Move-aware-class-对容器的效能测试" class="headerlink" title="26.Move-aware class 对容器的效能测试"></a>26.Move-aware class 对容器的效能测试</h3><p>似乎只对vector的影响很大。（两种不同的构造函数）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">M <span class="title">c1</span><span class="params">(c)</span></span>;  <span class="comment">// 如果是vector的话，在内存拓展的时候，需要一个个调用构造函数</span></span><br><span class="line"><span class="built_in">vector</span>(<span class="type">const</span> vector&amp; __x) : _Base(....)&#123;....&#125; <span class="comment">// 调用的构造函数 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">M <span class="title">c2</span><span class="params">(std::move(c))</span></span>;  <span class="comment">// 将c当成右值(这样只是交换了指针)； 往下c就不能再用了，指针被修改了</span></span><br><span class="line"><span class="comment">// 调用的构造函数</span></span><br><span class="line"><span class="built_in">vector</span>(vector&amp;&amp; __x) <span class="keyword">noexcept</span> : _Base(std::<span class="built_in">move</span>(__x)) &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="30-Hash-function"><a href="#30-Hash-function" class="headerlink" title="30.Hash function"></a>30.Hash function</h3><ul>
<li>对于整数（数字，long也行），其哈希值就是其本身</li>
<li>对于字符串，用一个哈希函数，得到一个尽可能乱的哈希值</li>
</ul>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="动态内存（C-Primer-chapter12）"><a href="#动态内存（C-Primer-chapter12）" class="headerlink" title="动态内存（C++ Primer chapter12）"></a>动态内存（C++ Primer chapter12）</h3><ul>
<li>分配在静态或栈内存中的对象由编译器自动创建和销毁</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/12/%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%AD%E9%9B%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/12/%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%AD%E9%9B%86/" class="post-title-link" itemprop="url">面对对象的续集</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-10-12 19:45:30" itemprop="dateCreated datePublished" datetime="2022-10-12T19:45:30+08:00">2022-10-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-12-13 17:20:58" itemprop="dateModified" datetime="2022-12-13T17:20:58+08:00">2022-12-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1-主要的内容"><a href="#1-主要的内容" class="headerlink" title="1.主要的内容"></a>1.主要的内容</h3><ul>
<li>泛型编程</li>
<li>面对对象的继承关系（底层内容）</li>
<li>书籍： Effective （modern）C++<br>标准库——&gt; 如何用，如何实现</li>
</ul>
<h3 id="转换函数-conversion-function"><a href="#转换函数-conversion-function" class="headerlink" title="转换函数 conversion function"></a>转换函数 conversion function</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fraction</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Fraction</span>(<span class="type">int</span> num, <span class="type">int</span> den = <span class="number">1</span>)</span><br><span class="line">		: <span class="built_in">m_numerator</span>(num), <span class="built_in">m_denominator</span>(den) &#123; &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 转换函数</span></span><br><span class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (doubl) (m_numerator / m_denominator);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_numerator;</span><br><span class="line">	<span class="type">int</span> m_denominator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="function">Fraction <span class="title">f</span><span class="params">(<span class="number">3</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="comment">// 先检查是否重载了+，然后尝试将f转换成允许的类型（还是要检查需要的函数是否被重载）</span></span><br><span class="line"><span class="type">double</span> d = <span class="number">4</span> + f;</span><br></pre></td></tr></table></figure>

<h3 id="non-explicit-one-argument-constructor"><a href="#non-explicit-one-argument-constructor" class="headerlink" title="non-explicit-one-argument constructor"></a>non-explicit-one-argument constructor</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fraction</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Fraction</span>(<span class="type">int</span> num, <span class="type">int</span> den=<span class="number">1</span>)</span><br><span class="line">		: <span class="built_in">m_numerator</span>(num), <span class="built_in">m_denominator</span>(den)&#123; &#125;</span><br><span class="line"></span><br><span class="line">	Fraction <span class="keyword">operator</span>+(<span class="type">const</span> Fraction&amp; f)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Fraction</span>(...);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 在这里的案例中，会产生歧义，这会报错（这使得两种可以的选择）</span></span><br><span class="line">	<span class="comment">//operator double() const &#123;</span></span><br><span class="line">	<span class="comment">//	return (doubl) (m_numerator / m_denominator);%%tor / m_denominator);</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_numerator;</span><br><span class="line">	<span class="type">int</span> m_denominator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="function">Fraction <span class="title">f</span><span class="params">(<span class="number">3</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="comment">// 这里会将3转换成Fraction类型，以适应重载函数</span></span><br><span class="line"><span class="type">double</span> d = f + <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fraction</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// explicit：不会自动调用</span></span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">Fraction</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> den=<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">		: m_numerator(num), m_denominator(den)&#123;</span> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (doubl) (m_numerator / m_denominator);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	Fraction <span class="keyword">operator</span>+(<span class="type">const</span> Fraction&amp; f)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Fraction</span>(...);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_numerator;</span><br><span class="line">	<span class="type">int</span> m_denominator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="function">Fraction <span class="title">f</span><span class="params">(<span class="number">3</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="comment">// 这里3将不能转换为Fraction，会报错（double 无法转换成Fraction）</span></span><br><span class="line"><span class="type">double</span> d = f + <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<h3 id="4-pointer-like-classes"><a href="#4-pointer-like-classes" class="headerlink" title="4.pointer-like classes"></a>4.pointer-like classes</h3><p><strong>智能指针</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shared_ptr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T&amp; <span class="keyword">operator</span>*() <span class="type">const</span></span><br><span class="line">	&#123; <span class="keyword">return</span> *px; &#125;</span><br><span class="line"></span><br><span class="line">	T* <span class="keyword">operator</span>-&gt;() <span class="type">const</span></span><br><span class="line">	&#123; <span class="keyword">return</span> px; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">shared_ptr</span>(T* p) : <span class="built_in">px</span>(p)&#123; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T* px;</span><br><span class="line">	<span class="type">long</span>* pn;</span><br><span class="line">....</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">	....</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">method</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;....&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">shared_ptr&lt;Foo&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> Foo)</span></span>;</span><br><span class="line"><span class="function">Foo <span class="title">f</span><span class="params">(*sp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里比较特殊，箭头操作符在执行之后会继续对返回值执行操作</span></span><br><span class="line"><span class="comment">// 注意这里的→操作符用于获取指针，同时还用于获取指针所指向的类中的方法</span></span><br><span class="line">sp-&gt;<span class="built_in">method</span>();</span><br><span class="line"><span class="comment">// 等价</span></span><br><span class="line">px-&gt;<span class="built_in">method</span>();</span><br></pre></td></tr></table></figure>

<p><strong>迭代器</strong></p>
<h3 id="5-function-like-classes-仿函数"><a href="#5-function-like-classes-仿函数" class="headerlink" title="5.function-like classes 仿函数"></a>5.function-like classes 仿函数</h3><p>我们将任何一个能够接受”（）”（函数调用符号）的东西叫做函数或者时像函数的东西。<br>实际上，就是尝试对”（）“进行重载</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">identity</span> : <span class="keyword">public</span> unary_function &#123; <span class="comment">// 在标准库中会继承这样的base classes</span></span><br><span class="line">	<span class="function"><span class="type">const</span> T&amp;</span></span><br><span class="line"><span class="function">	<span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="6-namespace-经验谈"><a href="#6-namespace-经验谈" class="headerlink" title="6.namespace 经验谈"></a>6.namespace 经验谈</h3><p>这样在进行测试的时候可以使用重名的函数，不用去想其他的名字（Great thoughts）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------------------------</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> jj01</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">test_member_template</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123; ..... &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// --------------------------------</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> jj02</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">	<span class="keyword">using</span> Lst = list&lt;T, allocator&lt;T&gt;&gt;;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">test_template_param</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	jj01::<span class="built_in">test_member_template</span>();</span><br><span class="line">	jj02::<span class="built_in">test_template_template_param</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-成员模板"><a href="#9-成员模板" class="headerlink" title="9. 成员模板"></a>9. 成员模板</h3><p>在模板函数中，在被调用之前函数可以被编译，在传入参数之后，这个函数会被重新编译，这可能导致编译失败（不支持的类型）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pair</span> &#123;</span><br><span class="line">	<span class="keyword">typedef</span> T1 first_type;</span><br><span class="line">	<span class="keyword">typedef</span> T2 second_type;</span><br><span class="line"></span><br><span class="line">	T1 first;</span><br><span class="line">	T2 second;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">pair</span>()</span><br><span class="line">		: <span class="built_in">first</span>(<span class="built_in">T1</span>()), <span class="built_in">second</span>(<span class="built_in">T2</span>()) &#123; &#125;</span><br><span class="line">	<span class="built_in">pair</span>(<span class="type">const</span> T1&amp; a, <span class="type">const</span> T2&amp; b)</span><br><span class="line">		: <span class="built_in">first</span>(a), <span class="built_in">second</span>(b) &#123; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 成员模板（外部被确定之后，内部还是不确定的）</span></span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">U1</span>, <span class="keyword">class</span> <span class="title class_">U2</span>&gt;</span><br><span class="line">	<span class="built_in">pair</span>(<span class="type">const</span> pair&lt;U1, U2&gt;&amp; p)  <span class="comment">// 这里是要求传入的初始值需要能够转换成T类型（一次作为初始化值，是T的子类）</span></span><br><span class="line">		: <span class="built_in">first</span>(p.first), <span class="built_in">second</span>(p.second)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">pair&lt;Derived1, Derived2&gt; p;</span><br><span class="line">pair&lt;Base1, Base2&gt;<span class="built_in">p2</span>(p);</span><br><span class="line">|</span><br><span class="line">pair&lt;Base1, Base2&gt;<span class="built_in">p2</span>(<span class="built_in">pair</span>&lt;Derived1, Derived2&gt;());</span><br></pre></td></tr></table></figure>

<p>子类指针能够指向父类，但是反之不能</p>
<blockquote>
<p>鲤鱼是一种鱼类，但是鱼类不是鲤鱼</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base1* ptr = <span class="keyword">new</span> Derived1;  <span class="comment">// up-cast</span></span><br><span class="line">shared_ptr&lt;Base1&gt;<span class="built_in">sptr</span>(<span class="keyword">new</span> Derived1);  <span class="comment">// 模拟up-cast</span></span><br></pre></td></tr></table></figure>

<h3 id="10、11-模板特化"><a href="#10、11-模板特化" class="headerlink" title="10、11. 模板特化"></a>10、11. 模板特化</h3><p>泛化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">has</span> &#123; &#125;;</span><br></pre></td></tr></table></figure>

<p>特化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hash</span>&lt;<span class="type">char</span>&gt;&#123;</span><br><span class="line">	<span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">char</span> x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>偏特化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数量特化：只对其中一个参数进行特化（不完全特化）</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc=...&gt;</span><br><span class="line"><span class="keyword">class</span> vector</span><br><span class="line">&#123;</span><br><span class="line">	.....</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Alloc=....&gt;</span><br><span class="line"><span class="keyword">class</span> vector&lt;<span class="type">bool</span>, Alloc&gt;&#123; .... &#125;  <span class="comment">// 只有一个参数被指定了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 范围特化：指定特化的范围</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">class</span> C</span><br><span class="line">&#123;</span><br><span class="line">	....</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的模板变量与前面的不是同一个</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&lt;T*&gt;  <span class="comment">// 指定的是任意的指针</span></span><br><span class="line">&#123;</span><br><span class="line">	.....</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">C&lt;string&gt; obj1;</span><br><span class="line">C&lt;string*&gt; obj2;  <span class="comment">// 调用的函数不同</span></span><br></pre></td></tr></table></figure>

<h3 id="12-模板模板参数"><a href="#12-模板模板参数" class="headerlink" title="12.模板模板参数"></a>12.模板模板参数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,</span><br><span class="line">		<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">			<span class="keyword">class</span> <span class="title class_">Container</span></span><br><span class="line">		&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XCls</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Container&lt;T&gt; c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	.....</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------------------</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Lst = list&lt;T, allocator&lt;T&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------------------</span></span><br><span class="line"><span class="comment">// 这种参数能够让用户传入一个未被指定的容器</span></span><br><span class="line">XCls&lt;string, list&gt;mylst1;  <span class="comment">// 直接使用会报错</span></span><br><span class="line">XCLs&lt;string, Lst&gt; mylst2;</span><br></pre></td></tr></table></figure>

<h3 id="14-三个主题"><a href="#14-三个主题" class="headerlink" title="14.三个主题"></a>14.三个主题</h3><p>**variadic templates(C++11)**：数量不确定的模板</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 最后会仅仅传入0个参数，这时候会调用这个重载函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 实际上是一种操作符了</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> T&amp; firstArg, <span class="type">const</span> Types&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 查看包的大小： sizeof...(args)</span></span><br><span class="line">	cout &lt;&lt; firstArg &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">print</span>(args...); <span class="comment">// 递归打印其中的组合的元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">7.5</span>, <span class="string">&quot;hello&quot;</span>, <span class="built_in">bitset</span>&lt;<span class="number">16</span>&gt;(<span class="number">377</span>), <span class="number">42</span>);</span><br></pre></td></tr></table></figure>

<p><strong>auto(C++11)</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">list&lt;string&gt; c;</span><br><span class="line">...</span><br><span class="line">list&lt;string&gt;::iterator ite;</span><br><span class="line">ite = <span class="built_in">find</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), target);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用auto，仅用于类型推导</span></span><br><span class="line"><span class="keyword">auto</span> ite = <span class="built_in">find</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), target);</span><br><span class="line"><span class="comment">//但是不能用于申明变量</span></span><br><span class="line"><span class="keyword">auto</span> ite;  <span class="comment">// ×</span></span><br></pre></td></tr></table></figure>

<p><strong>ranged-base <code>for</code></strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> elem : vec) &#123; <span class="comment">// copy</span></span><br><span class="line">	.....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要修改原始数据，则需要传引用（引用就是指针）</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; elem : vec)&#123;</span><br><span class="line">	elem *= <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="15-Reference"><a href="#15-Reference" class="headerlink" title="15. Reference"></a>15. Reference</h3><p>引用类型一定要设定初值</p>
<img src="/.com//10/12/%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%AD%E9%9B%86/20220913134632.png" class>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span>* p = &amp;x;</span><br><span class="line"><span class="type">int</span>&amp; r = x; <span class="comment">// r代表x，现在r, x 都是0。 实际上就是一个别名</span></span><br><span class="line"><span class="type">int</span> x2 = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">r = x2; <span class="comment">// r不能重新代表其他实物，心啊在r, x都是5</span></span><br><span class="line"><span class="type">int</span>&amp; r2 = r;</span><br></pre></td></tr></table></figure>
<p>对象和他的reference大小相同，地址也相同（全都是假象）<br>reference通常不用与声明，而是用于参数类型和返回类型的描述 </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面两种函数不能共存.二者之间的签名一致</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">imag</span> <span class="params">(<span class="type">const</span> <span class="type">double</span>&amp; im)</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">imag</span> <span class="params">(<span class="type">const</span> <span class="type">double</span> im)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这时候的函数签名与上面不同</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">imag</span> <span class="params">(<span class="type">const</span> <span class="type">double</span>&amp; im)</span> <span class="type">const</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p><code>注意</code>: const也是签名的一部分，</p>
<h3 id="16-复合-amp-继承关系下的构造和析构"><a href="#16-复合-amp-继承关系下的构造和析构" class="headerlink" title="16. 复合&amp;继承关系下的构造和析构"></a>16. 复合&amp;继承关系下的构造和析构</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由内到外调用构造函数</span></span><br><span class="line">Derived::<span class="built_in">Derived</span>(..):<span class="built_in">Base</span>() &#123;....&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由外到内调用析构函数</span></span><br><span class="line">Derived::~<span class="built_in">Derived</span>(...)&#123;....~<span class="built_in">Base</span>()&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="关于vptr和vtbl"><a href="#关于vptr和vtbl" class="headerlink" title="关于vptr和vtbl"></a>关于vptr和vtbl</h3><blockquote>
<p>vtbl: virtual table, 为了实现C++的多态，C++使用了一种动态绑定的技术。这个技术的核心是虚函数表</p>
</blockquote>
<p>一个类占用了多少的内存，主要看类中声明的变量。继承不仅仅会<code>继承变量</code>，同时也会继承<code>父类的函数的调用权</code>，所以父类有虚函数，子类一定有。<br>当子类重载虚函数的时候，会重新申请一个函数空间，让对应的虚表中的元素指向这个空间。</p>
<img src="/.com//10/12/%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%AD%E9%9B%86/20220914135123.png" class>

<p>这里子类重载了父类的虚函数，所以在子类的虚表中，对应的虚表中的指针会指向一个新的虚函数（B::vfunc1()），所以这三次继承下来，一共会产生四个虚函数。<br>对于p的调用，用C语言写出来是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(*(p-&gt;vptr[n])(p); <span class="comment">/*或者图中下方的形式*/</span></span><br><span class="line"> <span class="comment">/*这时候，调用出来的函数是不确定的，需要根据p指向的类型进行确定，这个就是动态绑定（虚机制）*/</span></span><br></pre></td></tr></table></figure>
<p>静态绑定&amp;动态绑定<br>动态绑定的条件：</p>
<ol>
<li>通过指针调用函数</li>
<li>有一个向上的转型（子类调用，到时候会调用子类的重载函数）</li>
<li>调用的是虚函数</li>
</ol>
<h3 id="18-关于this"><a href="#18-关于this" class="headerlink" title="18.关于this"></a>18.关于this</h3><p>在C++类中，都有一个隐藏的参数<code>this</code></p>
<h3 id="19-动态绑定"><a href="#19-动态绑定" class="headerlink" title="19. 动态绑定"></a>19. 动态绑定</h3><p>关于<code>const</code>：const对象能够调用const函数，不能调用非const函数，非const对象两者都可以调用。实际上一个常量对象会被多个用户使用（指向同一个对象），当某一个用户需要修改的对象的时候，只需要将其做一份拷贝，这个过程称为Copy on Write. 所以，设置两种不同的函数，一种给常量对象调用，一种是给非常量对象调用，同时，在C++中，规定<code>常量成员函数的const和non-const版本同时存在，const对象只能调用const版本，non-const只能调用non-const版本</code>。</p>
<h3 id="22-示例"><a href="#22-示例" class="headerlink" title="22.示例"></a>22.示例</h3><p>当一个对象拥有虚函数的时候，则对应的会多出一个指针（虚指针）<br>构建对象数组的时候，每一个元素都会调用一次构造函数<br>分配数组内存的时候，会额外申请一块，用于记录数组的大小（多一个counter）</p>
<h3 id="23-重载new-amp-delete"><a href="#23-重载new-amp-delete" class="headerlink" title="23.重载new() &amp; delete()"></a>23.重载new() &amp; delete()</h3><p>前提：1.每一版本的声明都必须是独特的参数列表，参数列表的第一参数必须是<code>size_t</code>，其余参数以<code>new</code>所指定的placement arguments为初值，出现在<code>new(...)</code>小括号内的就是placement arguments。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size, <span class="type">long</span> extra)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">malloc</span>(size + extra);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/12/%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/12/%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">面对对象编程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-12 14:35:56 / Modified: 20:02:44" itemprop="dateCreated datePublished" datetime="2022-10-12T14:35:56+08:00">2022-10-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1-C-编程简介"><a href="#1-C-编程简介" class="headerlink" title="1.C++编程简介"></a>1.C++编程简介</h3><p>C++: 语言+标准库</p>
<h3 id="2-头文件与类的声明"><a href="#2-头文件与类的声明" class="headerlink" title="2. 头文件与类的声明"></a>2. 头文件与类的声明</h3><p><strong>防卫式声明</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Header file: complex.h*/</span></span><br><span class="line"><span class="meta"># <span class="keyword">ifndef</span> __COMPLEX__</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __COMPLEX__</span></span><br><span class="line">....</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>写任意一个头文件都应该加上这种防卫语句</p>
<p><strong>头文件的布局</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">ifndef</span> __headerName__</span></span><br><span class="line"># ....</span><br><span class="line"><span class="comment">// 前置声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">className</span>;</span><br><span class="line"><span class="function">type&amp; <span class="title">func</span><span class="params">(type* var1)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Name</span>&#123;</span><br><span class="line">.....</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类定义</span></span><br><span class="line">Name::function ...</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="3-构造函数"><a href="#3-构造函数" class="headerlink" title="3. 构造函数"></a>3. 构造函数</h3><p>函数可以进行重载，编译器会将函数根据函数签名和其中的参数进行编码，以此作为区分。</p>
<h3 id="4-参数传递与返回值"><a href="#4-参数传递与返回值" class="headerlink" title="4.参数传递与返回值"></a>4.参数传递与返回值</h3><p>当构造函数放在<code>private</code>区域中，外界将不能够直接创建这个类。但是在一种设计模式<code>Singleton</code>中，会将构造函数放在<code>private</code>区域中。</p>
<blockquote>
<p>单例类Singleton保证了程序中同一时刻最多存在该类的一个对象。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> A&amp; <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="built_in">setup</span>()&#123;...&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">A</span>();</span><br><span class="line">	<span class="built_in">A</span>(<span class="type">const</span> A&amp; rhs);</span><br><span class="line">	.....</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A&amp; <span class="title">A::getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">static</span> A a;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建</span></span><br><span class="line">A::<span class="built_in">getInstance</span>().<span class="built_in">setup</span>();</span><br></pre></td></tr></table></figure>

<p><strong>传递函数参数</strong><br>由于pass by value 是将变量整体进行传递，当变量比较大的时候，效率比较低，所以在传递参数的时候，应该尽量pass by reference(底层是传递指针)， 这样传递的参数可能会在函数中被修改，所以可以通过传递到const中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> className&amp;)</span></span>;  <span class="comment">// 这样传递的方式不会修改传递的值</span></span><br><span class="line"></span><br><span class="line">ostream&amp;</span><br><span class="line"><span class="keyword">operator</span> &lt;&lt; (ostream&amp; os, <span class="type">const</span> <span class="type">int</span>&amp; x)&#123;....&#125; </span><br></pre></td></tr></table></figure>
<p><strong>返回值传递</strong><br>在返回的时候也应该尽量使用pass by reference</p>
<p><strong>友元函数</strong><br>友元函数可以使用<code>private</code>中的数据。</p>
<p>相同class的各个object互为友元：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">complex</span> (<span class="type">double</span> r = <span class="number">0</span>, <span class="type">double</span> i = <span class="number">0</span>)</span><br><span class="line">		: <span class="built_in">re</span> (r), <span class="built_in">im</span> (i)</span><br><span class="line">	&#123;   &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">const</span> complex&amp; param)</span></span></span><br><span class="line"><span class="function">	</span>&#123; <span class="keyword">return</span> param.re + param.im; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">double</span> re, im;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/******************************************************************/</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">complex <span class="title">c1</span><span class="params">(<span class="number">2</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">	complex c2;</span><br><span class="line">	</span><br><span class="line">	c2.<span class="built_in">func</span>(c1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>设计类的几个要点</strong></p>
<ol>
<li>数据尽量放在<code>private</code>中</li>
<li>参数、返回值尽量pass by reference（可能）</li>
<li>需要加<code>const</code>尽量加</li>
<li>构造函数尽量使用冒号的赋值方法</li>
</ol>
<p><strong>什么时候不能返回引用</strong><br>一些参数通过一些操作之后的结果，需要在函数中申请一个空间存储这个结果，但是在函数结束的时候，这个空间就会被释放掉，这时候再返回原先这里的地址就没有意义了。（局部变量在函数结束的时候被删除）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> complex&amp;</span><br><span class="line">__doapl(complex* ths, <span class="type">const</span> complex&amp; r) <span class="comment">// 第一个参数会被改变，第二不会</span></span><br><span class="line">&#123;</span><br><span class="line">	ths-&gt;re += r.re;</span><br><span class="line">	ths-&gt;im += r.im;</span><br><span class="line">	<span class="keyword">return</span> *ths;*</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> complex&amp;</span><br><span class="line">complex::<span class="keyword">operator</span> += (<span class="type">const</span> complex&amp; r)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> __doapl (<span class="keyword">this</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-操作符重载与临时对象"><a href="#4-操作符重载与临时对象" class="headerlink" title="4. 操作符重载与临时对象"></a>4. 操作符重载与临时对象</h3><p>操作符重载中包含一个隐藏参数this（不能写出来）</p>
<img src="/.com//10/12/%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/20220831211854.png" class>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// do assinment plus(doapl)</span></span><br><span class="line"><span class="keyword">inline</span> complex&amp;  <span class="comment">// 用reference速度快 </span></span><br><span class="line">__adopl(complex* ths, <span class="type">const</span> complexr)</span><br><span class="line">&#123;</span><br><span class="line">    ths-&gt;re += r.re;</span><br><span class="line">    ths-&gt;im += r.im;</span><br><span class="line">    <span class="keyword">return</span> *ths;  <span class="comment">// 返回该地址上的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// c1 += c2 时，可以改用void接受，但是当连加出现时（c3 += c2 += c1）时，不行</span></span><br><span class="line"><span class="keyword">inline</span> complex&amp;  </span><br><span class="line">complex::<span class="keyword">operator</span> += (<span class="type">const</span> complex&amp; r)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 使用这种方法的原因是可复用性</span></span><br><span class="line">    <span class="keyword">return</span> __adopl (<span class="keyword">this</span>, r); <span class="comment">// this在参数列表中不能写出来，但是能够使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>传递者无需知道接受者是以reference形式接受<br><strong>非成员函数（无this）</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> complex <span class="comment">// 不能返回引用，因为这里返回的必定时局部对象</span></span><br><span class="line"><span class="keyword">operator</span> = (<span class="type">const</span> complex&amp; x, <span class="type">const</span> complex&amp; y)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">complex</span> ( <span class="built_in">real</span> (x) + <span class="built_in">real</span> (y) ,</span><br><span class="line">					 <span class="built_in">imag</span> (x) + <span class="built_in">imag</span> (y)) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> complex</span><br><span class="line"><span class="keyword">operator</span> + (<span class="type">const</span> complex&amp; x, <span class="type">double</span> y)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">complex</span> (<span class="built_in">real</span> (x) + y, <span class="built_in">imag</span> (x)); <span class="comment">// 临时对象（无名称，STL用得多）</span></span><br><span class="line">&#125;</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="function">complex <span class="title">c1</span><span class="params">(<span class="number">2</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">	complex c2;</span><br><span class="line"></span><br><span class="line">	complex c3 = c1 + c2;</span><br><span class="line">	complex c4 = c1 + <span class="number">4</span>;</span><br><span class="line">	complex c5 = <span class="number">4</span> + c1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这种重载函数只能写为全局函数，不能写成成员函数（cout可能不认识你的参数类型， 访问定义的类)</span></span><br><span class="line"><span class="comment">// cout的数据类型是iostream， os的状态会被改变（传入的内容改变的）</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span> <span class="comment">// 不一定放在文件开头</span></span></span><br><span class="line">ostream&amp;  <span class="comment">// cout &lt;&lt; c1;时可以使用void接收，但是cout&lt;&lt;c1&lt;&lt;c2;时，不能用void接收</span></span><br><span class="line"><span class="keyword">operator</span> &lt;&lt; (ostream&amp; os, <span class="type">const</span> complex&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> os &lt;&lt; <span class="string">&#x27;(&#x27;</span> &lt;&lt; <span class="built_in">real</span> (x) &lt;&lt; <span class="string">&#x27;,&#x27;</span> </span><br><span class="line">			  &lt;&lt; <span class="built_in">imag</span> (x) &lt;&lt; <span class="string">&#x27;)&#x27;</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传递的是double类型的时候，传值和传引用效率一样。</p>
<h3 id="7-三大函数：拷贝函数，拷贝复制，析构"><a href="#7-三大函数：拷贝函数，拷贝复制，析构" class="headerlink" title="7.三大函数：拷贝函数，拷贝复制，析构"></a>7.三大函数：拷贝函数，拷贝复制，析构</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYSTRING__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYSTRING__</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// Big Three </span></span><br><span class="line">	<span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* cstr = <span class="number">0</span>); <span class="comment">// 需要赋值，不能设置为const</span></span><br><span class="line">	<span class="comment">//如果class中带有指针， 一定不能使用默认版本（符号重载等）</span></span><br><span class="line">	<span class="built_in">String</span>(<span class="type">const</span> String&amp; str);  <span class="comment">// 拷贝构造</span></span><br><span class="line">	String&amp; <span class="keyword">operator</span>=(<span class="type">const</span> String&amp; str); <span class="comment">// 拷贝复制</span></span><br><span class="line">	~<span class="built_in">String</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">char</span>* <span class="title">get_c_str</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_data; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span>* m_data;  <span class="comment">// 指针占4byte</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span></span></span><br><span class="line"><span class="function"><span class="title">String::String</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* cstr = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(cstr) &#123;</span><br><span class="line">		m_data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(cstr) + <span class="number">1</span>];  <span class="comment">// 最后还有一个结束符号</span></span><br><span class="line">		<span class="built_in">strcpy</span>(m_data, cstr);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;  <span class="comment">// 空字符串</span></span><br><span class="line">		m_data = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">1</span>];</span><br><span class="line">		*m_data = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> </span><br><span class="line">String::~<span class="built_in">String</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">delete</span>[] m_data;  <span class="comment">// 释放申请的动态内存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝赋值：先将原先的变量中的内容删除，然后将新的内容赋值给这个变量</span></span><br><span class="line"><span class="comment">// 返回类型是考虑到了连串的赋值的情况（否则可以将void作为返回类型）</span></span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line">String&amp; String::<span class="keyword">operator</span>=(<span class="type">const</span> String&amp; str) <span class="comment">// &amp;：reference</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// &amp;： 取地址</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str) <span class="comment">// 效率高且防止赋值内容的地址被释放，这会报错！</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">// 三步</span></span><br><span class="line">	<span class="keyword">delete</span>[] m_data;</span><br><span class="line">	m_data = <span class="keyword">new</span> <span class="type">char</span>[ <span class="built_in">strlen</span>(str.m_data) + <span class="number">1</span> ];</span><br><span class="line">	<span class="built_in">strcpy</span>(m_data, str.m_data);</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="type">const</span> String&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">	os &lt;&lt; str.<span class="built_in">get_c_str</span>(); </span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="function">String <span class="title">s3</span><span class="params">(s1)</span></span>;  <span class="comment">//拷贝构造</span></span><br><span class="line">s3 = s2;  <span class="comment">// 拷贝赋值</span></span><br></pre></td></tr></table></figure>

<p><strong>当类中存在指针成员的时候，必须要有拷贝构造和拷贝赋值</strong><br>使用默认的操作会使得赋值对象和原先的对象指向相同的地址（浅拷贝），你实际上会得到一个别名（alias）。 </p>
<h3 id="8-堆，栈与内存管理"><a href="#8-堆，栈与内存管理" class="headerlink" title="8.堆，栈与内存管理"></a>8.堆，栈与内存管理</h3><p><strong>栈</strong>：存在于作用域的一类内存空间。函数本体中声明的任何变量其所使用的内存块都取自这种栈。</p>
<p><strong>堆（heap）</strong>：用操作系统分配的一种global内存变量，动态申请的变量的内存会被放到堆中。</p>
<p>stack object: 作用域结束之后会被自动清理<br>static object: 作用域结束之后依旧存在。程序结束才被删除<br>global object: 整个程序结束之后才会删除，可以看成一种static object<br>heap object: </p>
<p>如果不释放，可能导致<code>内存泄漏</code>，因为在函数中声明的指针变量在作用域结束之后就会被删除，而对应的内存块还被占用着，这时候我们就失去了对这个内存块的控制了。 </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Complex* pc = <span class="keyword">new</span> <span class="built_in">Complex</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// transformed by compiler</span></span><br><span class="line">Complex *pc;</span><br><span class="line"></span><br><span class="line"><span class="comment">// complex 中的私有变量需要的内存大小</span></span><br><span class="line"><span class="type">void</span>* mem = <span class="keyword">operator</span> <span class="built_in">new</span> ( <span class="built_in">sizeof</span>(Complex) ); <span class="comment">// allocating the memory</span></span><br><span class="line">pc = <span class="built_in">static_cast</span>&lt;Complex*&gt;(mem);  <span class="comment">// change variable type</span></span><br><span class="line">pc-&gt;Complex::<span class="built_in">Complex</span>(<span class="number">1</span>, <span class="number">2</span>);  <span class="comment">// constructor function</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Delete</span></span><br><span class="line">String* ps = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="keyword">delete</span> ps;</span><br><span class="line"><span class="comment">// equal</span></span><br><span class="line">String::~<span class="built_in">String</span>(ps);</span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(ps)</span></span>;</span><br></pre></td></tr></table></figure>

<p>为了标记占用的内存块，规定在内存块的开头和结尾加上一个cookie标记内存块的大小和状态。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String* p = <span class="keyword">new</span> String[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span>[] p; <span class="comment">// 唤起3次析构函数</span></span><br><span class="line"><span class="keyword">delete</span> p;  <span class="comment">// 只调用一次析构函数，导致除了头元素外的元素所在的空间出现内存泄漏</span></span><br></pre></td></tr></table></figure>

<h3 id="拓展补充：类模板、函数模板及其他"><a href="#拓展补充：类模板、函数模板及其他" class="headerlink" title="拓展补充：类模板、函数模板及其他"></a>拓展补充：类模板、函数模板及其他</h3><p><strong>static</strong>：<br>非<code>static</code>类中，成员函数只有一份，不同类调用的实际上是同一个成员函数，只是传入了不同的成员变量。<br>静态数据，在内存中只有一份，这意味着这个数据对所有类都是一致的。<br>静态函数，没有this 指针，所以不能处理普通数据，只能处理静态数据</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">double</span> m_rate;</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">set_rate</span><span class="params">(<span class="type">const</span> <span class="type">double</span>&amp; x)</span> </span>&#123; m_rate = x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态变量需要在类外进行初始化</span></span><br><span class="line"><span class="type">double</span> Account::m_rate = <span class="number">8.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">// 两种调用静态函数的方法</span></span><br><span class="line">	Account::<span class="built_in">set_rate</span>(<span class="number">5.0</span>);</span><br><span class="line">	</span><br><span class="line">	Account a;</span><br><span class="line">	a.<span class="built_in">set_rate</span>(<span class="number">7.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Singleton中调用静态函数的方法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> A&amp; <span class="title">getInstance</span><span class="params">( <span class="keyword">return</span> a; )</span></span>;</span><br><span class="line">	<span class="built_in">setup</span>() &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">A</span>();</span><br><span class="line">	<span class="built_in">A</span>(<span class="type">const</span> A&amp; rhs);</span><br><span class="line">	<span class="type">static</span> A a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Call</span></span><br><span class="line">A::<span class="built_in">getInstance</span>().<span class="built_in">setup</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>更好的实现方法，单例仅使用的时候才会被构建</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> A&amp; <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="built_in">setup</span>() &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">A</span>();</span><br><span class="line">	<span class="built_in">A</span>(<span class="type">const</span> A&amp; rhs);</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A&amp; <span class="title">A::getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">static</span> A a;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A::<span class="built_in">getInstance</span>().<span class="built_in">setup</span>();</span><br></pre></td></tr></table></figure>

<p><strong>进一步补充：cout</strong><br>对<code>&lt;&lt;</code>操作符进行了多种多样的重载</p>
<p><strong>类模板</strong><br>类型未指定,在定义类的时候使用。在调用的时候需要指定类型</p>
<p><strong>函数模板</strong><br>函数模板不需要指定类型，可以根据传入变量的类型进行自动推导</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span></span></span><br><span class="line"><span class="function"><span class="type">const</span> T&amp; <span class="title">min</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b &lt; a ? b : a;  <span class="comment">// 对于操作数的重载需要在类定义中定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>namespace</strong><br>避免重名函数、类冲突</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 三种打开方式</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std:cout;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; ;</span><br></pre></td></tr></table></figure>

<h3 id="11-组合与继承"><a href="#11-组合与继承" class="headerlink" title="11.组合与继承"></a>11.组合与继承</h3><p><strong>复合</strong>： 容器中包含其他类型（类似结构体）<br>设计模式：配接（adapter）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">queue</span>&#123;</span><br><span class="line">	....</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	deque&lt;T&gt; c;  <span class="comment">// 底层容器</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 所有的方法实际上都是由c中的操作函数完成的</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">empty</span>(); &#125;</span><br><span class="line">	<span class="function">size_type <span class="title">soze</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">size</span>(); &#125;</span><br><span class="line">	<span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">front</span>(); &#125;</span><br><span class="line">	<span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">back</span>(); &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span> </span>&#123; c.<span class="built_in">push_back</span>(x); &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123; c.<span class="built_in">pop_front</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>复合情况下的构造和析构</strong><br>container -&gt; component</p>
<ul>
<li>构造由内而外（内部的成分, 默认会调用默认的构造函数）</li>
<li>析构由外而内</li>
</ul>
<p><strong>委托(Delegation): composition by reference</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file String.cpp</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StringRep</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">String</span>();</span><br><span class="line">	<span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* s);</span><br><span class="line">	<span class="built_in">String</span>(<span class="type">const</span> String&amp; s);</span><br><span class="line">	String &amp;<span class="keyword">operator</span>=(<span class="type">const</span> String&amp; s);</span><br><span class="line">	~<span class="built_in">String</span>();</span><br><span class="line">	....</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 所有的实现都在这个类中 </span></span><br><span class="line">	StringRep* rep; <span class="comment">// pimpl</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Pimpl(<strong>P</strong>ointer to <strong>impl</strong>ementation) 是一种减少代码依赖和编译时间的C++编程技巧，其基本思想是将一个外部可见类(visible class)的实现细节（一般是所有私有的非虚成员）放在一个单独的实现类(implementation class)中，而在可见类中通过一个私有指针来间接访问该实现类</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&quot;String.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">namespace</span>&#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StringRep</span>&#123;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">String</span>;</span><br><span class="line">	<span class="built_in">StringRep</span>(<span class="type">const</span> <span class="type">char</span>* s);</span><br><span class="line">	~<span class="built_in">StringRep</span>();</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	<span class="type">char</span>* rep;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String::<span class="built_in">String</span>()&#123; .... &#125;</span><br></pre></td></tr></table></figure>
<p>这时候多个类实际上共享一组变量，当需要修改的时候，会单独复制一个出来 </p>
<p><strong>继承</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">_List_node_base</span></span><br><span class="line">&#123;</span><br><span class="line">	_List_node_base* _M_next;</span><br><span class="line">	_List_node_base* _M_prev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp_&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_List_node</span></span><br><span class="line">	: <span class="keyword">public</span> _List_node_base  <span class="comment">// 三种继承public、private、protected</span></span><br><span class="line">&#123;</span><br><span class="line">	_Tp _M_data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>构造和析构与复合一致（先调用父类的构造函数， 析构则是先执行子类的析构函数）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Derived::<span class="built_in">Deriveed</span>(...):<span class="built_in">Base</span>() &#123;....&#125;; </span><br><span class="line">Derived::~<span class="built_in">Derived</span>(...)&#123;... ~<span class="built_in">Base</span>() &#125;;</span><br></pre></td></tr></table></figure>
<p><code>base class的构造函数必须是虚函数，否则会出现 undefined behavior</code></p>
<h3 id="12-虚函数与多态"><a href="#12-虚函数与多态" class="headerlink" title="12.虚函数与多态"></a>12.虚函数与多态</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;  <span class="comment">// pure virtual: 必须重定义（无法事先定义的函数）</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">error</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span></span>;  <span class="comment">// impure virtual：有默认定义</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">objectID</span><span class="params">()</span> <span class="type">const</span></span>;  <span class="comment">// non-vitual：不希望重定义</span></span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>: <span class="keyword">public</span> Shape &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ellipse</span>: <span class="keyword">public</span> Shape &#123; ... &#125;;</span><br></pre></td></tr></table></figure>

<p><strong>虚函数继承</strong>: <code>Template Method</code>(模板函数法 )</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Application framework</span></span><br><span class="line">CDocument::</span><br><span class="line"><span class="built_in">OnFileOpen</span>()</span><br><span class="line">&#123;</span><br><span class="line">	....</span><br><span class="line">	<span class="built_in">Serialize</span>()  <span class="comment">// 这个函数延缓到子类中实现</span></span><br><span class="line">	.....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Application</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CMyDoc</span>:</span><br><span class="line">	<span class="keyword">public</span> CDocument</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="title">Serialize</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Call the father function by son</span></span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">	CMyDoc myDoc;</span><br><span class="line">	....</span><br><span class="line">	myDoc.<span class="built_in">OnFileOpen</span>();  </span><br><span class="line">	<span class="comment">// 实际上的调用动作</span></span><br><span class="line">	CDocument::<span class="built_in">OnFileOpen</span>(&amp;myDoc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>委托+继承</strong><br>*******************************<br><font size="5" color="red">需要补充</font><br>*******************************</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> m_value;</span><br><span class="line">	vector&lt;Observer*&gt;m_views;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 注册</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">attach</span><span class="params">(Observer* obs)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_views.<span class="built_in">push_back</span>(obs);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">set_val</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_value = value;</span><br><span class="line">		<span class="built_in">notify</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 通知更新数据</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">notify</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_views.<span class="built_in">size</span>(); ++i)</span><br><span class="line">			m_views[i]-&gt;<span class="built_in">update</span>(<span class="keyword">this</span>, m_value);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">update</span><span class="params">(Subject* sub, <span class="type">int</span> value)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="13-委托相关设计"><a href="#13-委托相关设计" class="headerlink" title="13.委托相关设计"></a>13.委托相关设计</h3><img src="/.com//10/12/%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/20220907193955.png" class>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Component</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Component</span>(<span class="type">int</span> val) &#123; value=val; &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 不能设置为纯虚函数，因为有一些子类对这个动作是没有定义的</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">add</span><span class="params">(Component*)</span> </span>&#123; &#125;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Primitive</span>: <span class="keyword">public</span> Component</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Primitive</span>(<span class="type">int</span> val): <span class="built_in">Component</span>(val) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Composite</span>: <span class="keyword">public</span> Component</span><br><span class="line">&#123;</span><br><span class="line">	vector&lt;Component*&gt;c;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Composite</span>(<span class="type">int</span> val): <span class="built_in">Component</span>(val) &#123; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">add</span> <span class="params">(Component* elem)</span></span>&#123;</span><br><span class="line">		c.<span class="built_in">push_back</span>(elem);</span><br><span class="line">	&#125;</span><br><span class="line">	....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><font color="red">为什么父类指针能够指向子类，但是子类指针指向父类可能导致不安全？</font></p>
<p><strong>委托+继承</strong><br>将新建的类与框架搭配到一起，需要创建好的类加入到框架的容器中去。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原型</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">imageType</span></span><br><span class="line">&#123;</span><br><span class="line">	LAST, SPOT</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Image</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="type">static</span> Image *<span class="title">findAndColone</span><span class="params">(imageType)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> imageType <span class="title">returnType</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> Image *<span class="title">clone</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">addPrototype</span><span class="params">(Image *image)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		_prototypes[_nextSlot++] = image;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 存放类原型</span></span><br><span class="line">	<span class="type">static</span> Image *_prototypes[<span class="number">10</span>];</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> _nextSlot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态变量需要在类外进行初始化</span></span><br><span class="line">Image *Image::_prototypes[];</span><br><span class="line"><span class="type">int</span> Imgage::_nextSlot;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过变量类型找出需要调用的原型</span></span><br><span class="line"><span class="function">Image *<span class="title">Image::findAndClone</span><span class="params">(imageType type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; _nextSlot; i++)</span><br><span class="line">		<span class="keyword">if</span>(_prototypes[i]-&gt;<span class="built_in">returnType</span>() == type)</span><br><span class="line">			<span class="keyword">return</span> _prototypes[i]-&gt;<span class="built_in">clone</span>();  <span class="comment">// 得到目标类的一个备份</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LandSatImage</span>:<span class="keyword">public</span> Image&#123;</span><br><span class="line">	<span class="comment">// 创建一个静态的自己，然后放到父类的那个容器中</span></span><br><span class="line">	<span class="comment">// 这里需要两个不同的构造函数，一个用于给父类原型时创建类用的，一个时父类在调用这个原型clone时用的，为了将这两种构造函数进行区分，他们的参数之间存在差异</span></span><br><span class="line">	....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6%EF%BC%9A%E4%BF%A1%E6%81%AF%E8%AE%BA-Information-Theory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6%EF%BC%9A%E4%BF%A1%E6%81%AF%E8%AE%BA-Information-Theory/" class="post-title-link" itemprop="url">机器学习中的数学：信息论(Information Theory)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-11 22:19:24 / Modified: 22:19:36" itemprop="dateCreated datePublished" datetime="2022-10-11T22:19:24+08:00">2022-10-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>@[toc]</p>
<blockquote>
<p>参考：<em>Dive into Deep Learning A. zhang ect</em> Chapter 18 <strong>Appendix: Mathematics for Deep Learning</strong></p>
</blockquote>
<p>利用信息论我们可以测量或者比较在不同的信号（signals）中信息。在这部分，我们主要讨论机器学习对信息论的一些概念和应用。<br>首先我们先简要描述介绍一下机器学习和信息论之间的关系。机器学习的主要的任务就是从数据中提取出有价值的信息，然后利用这些信息去做一些预测。而信息论主要研究信息的编码、解码、转换和操作（sencoding, decoding, transmitting, and manipulating information）。所以，我们可以利用信息论来讨论机器学习在训练中对信息的处理过程。</p>
<h1 id="信息（Information）"><a href="#信息（Information）" class="headerlink" title="信息（Information）"></a>信息（Information）</h1><p><strong>信息</strong>就是能够将所有事情通过一种或者是多种编码格式编码成一个特定的序列。但是怎么样编码才能正确地表述事物所具有的信息量呢？在我们描述一个事件的时候，如果这件事情是不寻常的，这时候我们需要更多的信息来描述，反之需要更少的信息。这就好比说一个普通的碗和清朝乾隆皇帝御用的碗，后者是比较少见的，需要更多的必要信息才能描述清楚它的特征。所以可以将信息表示为事件发生的抽象概率。</p>
<h1 id="自信息（Self-information）"><a href="#自信息（Self-information）" class="headerlink" title="自信息（Self-information）"></a>自信息（Self-information）</h1><p>香农（Shannon）将<strong>比特</strong>（bit）作为信息的单位，这将时间发生的概率转换成比特数。这样，对于一个长度为$n$的二进制序列所包含的信息为$n$比特。<br>假设二进制序列每一个位置为1或者0的概率相等（都为$\frac 12$）,所以对于一个事件$X$,这个事件为：一个长度为$n$二进制序列，每种序列出现的概率为$\frac{1}{2^n}$,香农定义了<strong>自信息</strong>，将事件的概率转换成了比特数：<br>$$I(x) &#x3D; -\log_2(p)$$<br>举例来说，对于一个序列“0010”的自信息为：<br>$$I(“0010”) &#x3D; -\log_2(p(“0010”))&#x3D;-\log_2(\frac{1}{2^4})&#x3D;4\ bits$$<br>* <code>在本章节中，我们省略log的下标，如无特殊说明都表示  </code> $\log_2p$</p>
<h1 id="熵（Entropy）"><a href="#熵（Entropy）" class="headerlink" title="熵（Entropy）"></a>熵（Entropy）</h1><p>自信息只能描述一个离散事件的信息，这部分介绍能够任意随机变量的描述方式。</p>
<h2 id="提出熵的动机（Motivating-Entropy）"><a href="#提出熵的动机（Motivating-Entropy）" class="headerlink" title="提出熵的动机（Motivating Entropy）"></a>提出熵的动机（Motivating Entropy）</h2><p>熵的形式受限于<strong>香农熵定理</strong>：</p>
<ol>
<li>我们通过观察随机变量得到的信息与随机变量的元素的名称无关，与发生概率为0的元素无关。</li>
<li>两个随机变量<strong>一起</strong>观测得到的信息 $\le$ 两个随机变量<strong>分开</strong>观测得到的信息。当两个随机变量相互独立的时候，取得等号。</li>
<li>通过一个确定事件所得到的信息为0</li>
</ol>
<p>我们可以将抛掷一个完全均匀的硬币所得到的信息为1比特作为基准，以消除使用不同的基本单位而导致的对同一事件的信息量上的差异。</p>
<h2 id="定义（Definition）"><a href="#定义（Definition）" class="headerlink" title="定义（Definition）"></a>定义（Definition）</h2><p>对于一个随机变量$X$, 遵循概率分布$P$,概率密度函数或概率质量函数为$p(x)$,我们利用熵来描述信息的期望值：<br>$$H(x)&#x3D;-E_{x\sim P}[\log p(x)]$$<br>具体来说：<br>$$H(X)&#x3D;\left{\begin{aligned}<br>&amp; -\sum_i p_i\log p_i, \quad p_i &#x3D; P(X_i)\quad X 是离散型随机变量 \<br>&amp; -\int_x p(x)\log p(x) dx\quad X是连续型随机变量<br>\end{aligned}<br>\right.$$<br>连续性随机变量的熵也被称为<strong>微分熵</strong>（Differential Entropy） </p>
<h2 id="解释（Interpretation）"><a href="#解释（Interpretation）" class="headerlink" title="解释（Interpretation）"></a>解释（Interpretation）</h2><p>在这一节中，主要解释两个关于上述公式的问题。</p>
<ol>
<li><p>为什么要使用负对数？<br> 首先是为什么要使用对数。这是为了保证熵对独立随机变量的可加性。对于一系列相互独立的事件发生的概率为$f_i(x)$, 那么所有事件发生的概率为 $p(X)&#x3D;\prod_if_i(x)$,使用对数可以将这个连乘转换成连加。</p>
</li>
<li><p>为什么添加负号？<br> 因为信息的定义。由于发生概率低的事件应该包含更多的信息，但是对数是一个单调递增函数，所以为了保证事件概率和对应的熵之间的反比例的关系，我们需要对对数加一个负号，让他变成单调递减函数。</p>
</li>
<li><p>为什么需要期望函数？<br> 对于一个随机变量X，它的自信息（$-\log(p)$）就是对于某个输出的不确定性的数量。但是当事件发生的概率趋向于0的时候，这种不确定性就会趋向于$+\infin$.同样的，我们可以将熵解释为观测事件X的平均不确定性。举例子来说，对于一个模型的相互独立的输出$s_1,\cdots, s_k$的对应的概率为$p_1,\cdots, p_k$， 那么这个系统的熵就是输出值的平均自信息：<br> $$H(S) &#x3D; \sum_ip_i\cdot I(s_i)&#x3D;-\sum_ip_i\cdot\log p_i$$</p>
</li>
</ol>
<h2 id="熵的性质（Properties-of-Entropy）"><a href="#熵的性质（Properties-of-Entropy）" class="headerlink" title="熵的性质（Properties of Entropy）"></a>熵的性质（Properties of Entropy）</h2><p>下面考虑随机事件$X$, 它对应的概率分布为$P$</p>
<ul>
<li>对所有离散型随机变量$X$:$H(X)\ge 0$(连续性随机变量的熵可能会是负数)</li>
<li>假设一个随机事件$X\sim P\quad(p.d.f&#x3D;p(x))$，我们想用一个新的概率分布$Q\quad(p.d.f&#x3D;q(x))$来估计$P$则有：<br>   $$H(X)&#x3D;-E_{x\sim P}[\log p(x)]\le -E_{x\sim P}[\log q(x)]$$<br>   当$P&#x3D;Q$的时候，取得等号。</li>
<li>对于一个随机变量$X\sim P$, $x$将会传递最多的信息，如果他能将这些信息均匀地分布在所有可能的结果上。具体来说，对于一个概率分布$P$的k种相互独立的输出${p_1,\cdots, p_k}$:<br> $$H(X)\le \log(k), with\ equality\ if \ and \ only \ if \ p_i&#x3D;\frac{1}{k},\forall_i$$<br> 但是如果$P$是一个连续性随机变量，那么处理过程就会很麻烦了。我们假设P在一个有限的区间内，那么，如果这个随机变量在这个区间上满足均匀分布，那么这个随机变量的熵的值将会是最大的。</li>
</ul>
<h1 id="互信息（Mutual-Information）"><a href="#互信息（Mutual-Information）" class="headerlink" title="互信息（Mutual Information）"></a>互信息（Mutual Information）</h1><p>在这部分，我们联合变量$(X,Y)$的熵。在本节中，我们使用的联合变量$(X,Y)$遵循联合概率分布$P$,概率密度函数为$P_{X,Y}(x,y)$,其中$X\sim p_X(x);\quad Y\sim p_Y(y)$</p>
<h2 id="联合熵-Joint-Entropy"><a href="#联合熵-Joint-Entropy" class="headerlink" title="联合熵(Joint Entropy)"></a>联合熵(Joint Entropy)</h2><p>联合熵与先前定义的熵的形式一致：<br>$$H(X,Y)&#x3D;-E_{(x,y)\sim P}[\log p_{X,Y}(x,y)]\tag {<em>}$$<br>具体形式为：<br>$$H(X,Y)&#x3D;\left{\begin{aligned}<br>&amp;-\sum_x\sum_yp_{X,Y}(x,y)\log p_{X,Y}(x,y),\quad 离散型\<br>&amp;-\int_{x,y}p_{X,Y}(x,y)\log p_{X,Y}(x,y)dxdy,\quad 连续型<br>\end{aligned}\right.<br>$$<br>$(</em>)$表示一对随机变量的全部的不确定性。当$X&#x3D;Y$的时候，$H(X,Y)&#x3D;H(X)&#x3D;H(Y)$,当X与Y相互独立的时候$H(X,Y)&#x3D;H(X)+H(Y)$,所以有：<br>$$H(X),H(Y)\le H(X,Y)\le H(X)+H(Y)$$</p>
<h2 id="条件熵（Conditional-Entropy）"><a href="#条件熵（Conditional-Entropy）" class="headerlink" title="条件熵（Conditional Entropy）"></a>条件熵（Conditional Entropy）</h2><p>在机器学习中，我们更多的时候，我们更关注条件上而不是联合熵。例如我们要根据图片判断图片的标签，这就可以理解为在图片像素信息条件下的对标签的信息。条件熵的定义与之前的几种熵的定义相似：<br>$$H(Y|X)&#x3D;-E_{(x,y)\sim P}[\log p(y|x)]$$<br>其中：$p(y|x)&#x3D;\frac{p_{X,Y}(x,y)}{p_X(x)}$.条件熵与熵和联合熵的关系为：<br>$$H(Y|X)&#x3D;H(X,Y)-H(X)$$<br>这样条件熵既可以理解为存在于Y中的而不存在与X中的的信息。</p>
<h2 id="互信息（Mutual-Information）-1"><a href="#互信息（Mutual-Information）-1" class="headerlink" title="互信息（Mutual Information）"></a>互信息（Mutual Information）</h2><p>上面我们讨论了联合变量之中独有的信息，现在我们讨论两个变量之间共有的信息。所以根据定义可以得到（互信息:$I(X,Y)$）<br>$$I(X,Y) &#x3D; H(X,Y)-H(Y|X)-H(X|Y)$$<br>将原先的定义式带入，整理可得：<br>$$I(X,Y)&#x3D;E_xE_y\left{<br>p_{X,Y}(x,y)\log \frac{p_{X,Y}(x,y)}{p_X(x)p_Y(y)}<br>\right}<br>$$<br>在本节中提到的定义之间的关系如下图：<br><img src="https://img-blog.csdnimg.cn/013c87570cd9401fb52ba8c3dd7d9da8.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_Q1NETiBATGVhcm5pbmdEZWVwbHk=,size_29,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="互信息的性质-Properties-of-Mutual-Information"><a href="#互信息的性质-Properties-of-Mutual-Information" class="headerlink" title="互信息的性质(Properties of Mutual Information)"></a>互信息的性质(Properties of Mutual Information)</h2><ul>
<li>对称性：$I(X,Y) &#x3D; I(Y,X)$</li>
<li>非负性：$I(X,Y)\ge 0$</li>
<li>如果两个随机变量是相互独立的，那么$I(X,Y)&#x3D;0$</li>
<li>如果X是Y的可逆函数：$I(X,Y)&#x3D;H(Y)&#x3D;H(X)$</li>
</ul>
<h2 id="点间互信息（Pointwise-Mutual-Information）"><a href="#点间互信息（Pointwise-Mutual-Information）" class="headerlink" title="点间互信息（Pointwise Mutual Information）"></a>点间互信息（Pointwise Mutual Information）</h2><p>点间互信息:$pmi(x,y)$就是互信息定义中的对数部分：<br>$$pmi(x,y) &#x3D; \log\frac{p_{X,Y}(x,y)}{p_X(x)p_Y(y)}$$<br>他描述的是两个联合事件发生的概率比分别发生的概率的具体的数值关系。</p>
<h2 id="互信息的应用（Applications-of-Mutual-Information）"><a href="#互信息的应用（Applications-of-Mutual-Information）" class="headerlink" title="互信息的应用（Applications of Mutual Information）"></a>互信息的应用（Applications of Mutual Information）</h2><p>在自认语言处理中，<strong>歧义消除</strong>（Ambiguity Resolution）是一件比较难的事情。也就是一些词在文中的含义不是很明确。例如先前出现的新闻“亚马逊起火了”，我们不知道是公司起火了，还是那个雨林起火了。这时候就产生了歧义。我们先找出一组词，这些词与亚马逊公司有较大互信息。同样找到与亚马逊雨林有较大互信息的词，然后分析这些那些在文中有更高的出现频率。利用这个，我们能够了解新闻是关于公司的还是雨林的。</p>
<h1 id="Kullback–Leibler-散度（Kullback–Leibler-Divergence）"><a href="#Kullback–Leibler-散度（Kullback–Leibler-Divergence）" class="headerlink" title="Kullback–Leibler 散度（Kullback–Leibler Divergence）"></a>Kullback–Leibler 散度（Kullback–Leibler Divergence）</h1><p>我们可以利用范数来表示任何维度两点之间的距离。现在我们想知道两个概率分布之间的距离（相似程度）。<strong>KL散度</strong>就是一种测量两种分布之间相似程度的量。</p>
<h2 id="定义（Definition）-1"><a href="#定义（Definition）-1" class="headerlink" title="定义（Definition）"></a>定义（Definition）</h2><p>对于一个随机变量$X$遵循概率分布$P$,概率密度分布为$p(x)$.我们利用另一个概率分布$Q$($p.d.f&#x3D;q(x)$),那么$P$和$Q$之间的KL散度（相对熵，Relative Entropy）定义为：<br>$$D_{KL}(P|Q)&#x3D;E_{x\sim P}[\log\frac{p(x)}{q(x)}]$$<br>可见DL散度就是在描述两个随机变量之间不确定性程度的相对关系。</p>
<h2 id="性质（Properties）"><a href="#性质（Properties）" class="headerlink" title="性质（Properties）"></a>性质（Properties）</h2><ul>
<li>非对称性：$D_{KL}(P|Q)\ne D_{KL}(Q|P)$</li>
<li>非负性：$D_{KL}(P|Q)\ge0$,当$P&#x3D;Q$时取得等号。</li>
<li>如果$p(x)&gt;0,\ q(x)&#x3D;0$则$D_{KL}(P|Q)&#x3D;\infin$</li>
<li>以下三种表达式等价：<br>  $$D_{KL}(P(X,Y)| P(X)P(Y))$$<br>  $$E_Y{D_{KL}(P(X|Y))|P(X))}$$<br>  $$E_X{D_{KL}(P(Y|X)|P(Y))}$$<blockquote>
<p>For the first term, we interpret mutual information as the KL divergence between P(X, Y ) and the product of P(X) and P(Y ), and thus is a measure of how different the joint distribution is from the distribution if they were independent. For the second term, mutual information tells us the average reduction in uncertainty about Y that results from learning the value of the $X$ʼs distribution. Similarly to the third term.</p>
</blockquote>
</li>
</ul>
<h1 id="交叉熵（Cross-Entropy）"><a href="#交叉熵（Cross-Entropy）" class="headerlink" title="交叉熵（Cross-Entropy）"></a>交叉熵（Cross-Entropy）</h1><p>对于一个二分类问题，预测值为$\hat y_i &#x3D; p_\theta(y_i|x_i)$.预测结果为1的概率为：$\pi_i&#x3D;p_\theta(y_i&#x3D;1|x_i)$所以log似然方程为：<br>$$\begin{aligned}<br>l(\theta)&amp;&#x3D;\log L(\theta)\<br>&amp;&#x3D;\log \prod^n_{i&#x3D;1}\pi_i^{y_i}(1-\pi_i)^{1-y_i}\<br>&amp;&#x3D;\sum^n_{i&#x3D;1}y_i \log(\pi_i)+(1-y_i)\log(1-\pi_i)<br>\end{aligned}<br>$$<br>我们的目标就是最大化这个似然函数，这种方法就是极大似然估计。看到式中的自然对数，我们可以联想到之前提到一些信息论的概念。这暗示我们这个函数可以从信息论的角度理解。</p>
<h2 id="正式定义（Formal-Definition）"><a href="#正式定义（Formal-Definition）" class="headerlink" title="正式定义（Formal Definition）"></a>正式定义（Formal Definition）</h2><p>我们假设有两个随机变量:$P\sim p(x);\quad Q\sim q(x)$(前者是真实值的分布，后者是预测值的分布).，我们可以通过交叉熵来描述两种分布之间的散度：<br>$$CE(P,Q)&#x3D;-E_{x\sim P}[\log (q(x))]$$<br>通过之前提到的关系式，可以将上式转化为：<br>$$CE(P,Q) &#x3D; H(P)+D_{KL}(P|Q)$$</p>
<h2 id="性质（Properties）-1"><a href="#性质（Properties）-1" class="headerlink" title="性质（Properties）"></a>性质（Properties）</h2><p>交叉熵可以用于优化问题的损失函数，以下几种说法是等价的：</p>
<ul>
<li>最大化分布对于分布P的预测概率(最大化$E_{x\sim P[\log (q(x))]}$)</li>
<li>最小化交叉熵$CE(P,Q)$</li>
<li>最小化KL散度</li>
</ul>
<p>这些性质可以从交叉熵的定义中得出。注意因为P是真实值的分布，所以$H(P)$是一个常量。</p>
<h2 id="交叉熵作为多元分类问题的目标函数（Cross-Entropy-as-An-Objective-Function-of-Multi-class-Classification）"><a href="#交叉熵作为多元分类问题的目标函数（Cross-Entropy-as-An-Objective-Function-of-Multi-class-Classification）" class="headerlink" title="交叉熵作为多元分类问题的目标函数（Cross-Entropy as An Objective Function of Multi-class Classification）"></a>交叉熵作为多元分类问题的目标函数（Cross-Entropy as An Objective Function of Multi-class Classification）</h2><p>现在考虑一个k分类问题，这个分类问题的标签用独热编码（One-hot encoding）表示$y_i&#x3D;(y_{i1},\cdots,y_{ik})$,预测标签值为：<br>$$\hat y_i&#x3D;p_\theta(y_i|x_i)&#x3D;\sum^k_{j&#x3D;1}y_{ij}p_\theta(y_{ij}|x_i)$$<br>所以交叉熵可以表示为：<br>$$CE(y,\hat y)&#x3D;-\sum^n_{i&#x3D;1}y_i\log\hat y_i&#x3D;-\sum^n_{i&#x3D;1}\sum^k_{j&#x3D;1}y_{ij}\log(y_{ij}|x_i)$$<br>另一方面，我们可以利用极大似然估计来解决这个问题。假设一个随机变量$z&#x3D;(z_1,\cdots,z_k)$满足k分类多元伯努利分布，对应的概率为$p&#x3D;(p_1,\cdots, p_k)$,也就是：<br>$$p(z)&#x3D;p(z_1,\cdots,z_k)&#x3D;Multi(p_1,\cdots,p_k),\ where\ \sum^k_{i&#x3D;1}p_i&#x3D;1$$<br>z的联合概率质量函数为:<br>$$p^z&#x3D;\prod^k_{j&#x3D;1}p^{z_j}<em>j$$<br>所以对应的log似然方程为：<br>$$l(\theta)&#x3D;\log L(\theta)&#x3D;\log\prod^n</em>{i&#x3D;1}p^{y_i}&#x3D;\log\prod^n_{i&#x3D;1}\prod_{j&#x3D;1}^{k}p^{y_{ij}}&#x3D;\sum^n_{i&#x3D;1}\sum^k_{j&#x3D;1}y_{ij}\log p_j$$<br>所以对于多分类问题最大化log似然函数等价于最小化交叉熵损失$CE(y,\hat y)$</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/11/test/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/11/test/" class="post-title-link" itemprop="url">test</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-11 21:57:22 / Modified: 22:08:23" itemprop="dateCreated datePublished" datetime="2022-10-11T21:57:22+08:00">2022-10-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这是一篇测试文章</p>
<img src="/.com//10/11/test/test.jpg" class title="图片引用方法一">

<p><img src="/.com//10/11/test/test.jpg" alt="图片引用方法二"></p>
<p>这里的图片放在<code>\source\images</code>目录下<br><img src="/./images/test.png" alt="图片引用方法三"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6-ch12%EF%BC%9A%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%E5%88%86%E7%B1%BB%EF%BC%88Classification-with-Support-Vector-Machines%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6-ch12%EF%BC%9A%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%E5%88%86%E7%B1%BB%EF%BC%88Classification-with-Support-Vector-Machines%EF%BC%89/" class="post-title-link" itemprop="url">机器学习中的数学 ch12：支持向量机分类（Classification with Support Vector Machines）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-07-25 08:25:24" itemprop="dateCreated datePublished" datetime="2021-07-25T08:25:24+08:00">2021-07-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-09 18:50:55" itemprop="dateModified" datetime="2023-03-09T18:50:55+08:00">2023-03-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>@[toc]<br>在机器学习中，有一种分类问题，这种分类问题只有两个预测结果，是或否，即：</p>
<script type="math/tex; mode=display">f:\mathbb R^D\rightarrow \{0,1\}</script><p>为了计算方便，我们使用0，1来表示两种分类的结果，这种分类问题被称为<strong>二元分类</strong>（Binary Classification）。本章节就是主要介绍用<strong>支持向量机</strong>（Support Vector Machine，SVM）来解决这种分类问题。<br>支持向量机给我们提供了一个用几何的方式的视角看待监督式机器学习。在原先的章节中，我们使用概率模型来理解机器学习问题：用极大似然估计和贝叶斯推断对模型进行优化。支持向量机利用的是另一个角度，这种角度需要大量的代数知识，如内积、投影等。另外，由于用支持向量机解的优化问题没有一个解析解，所以我们需要利用之前学到的各种的优化方法，这可以作为之前学到的知识的一种实践。<br>在支持向量机的视角下的机器学习问题与概率视角下的机器学习问题略有不同，前者的模型是由数据分布的概率视角得出的。后者是设计一个函数，然后再训练的过程中不断优化，这是基于几何理解的。<br>接下来我们将从两个视角看待SVM：几何视角和损失函数视角。同时，为了提高模型的泛化能力，线性分类子应该允许一些错误的分类。之后我们还利用拉格朗日乘子得到对偶版本的SVM，这让我们可以利用另一个角度看待SVM。我们还介绍SVM的核方法，以及解非线性核SVM的优化问题。</p>
<h1 id="分离超平面（Separating-Hyperplanes）"><a href="#分离超平面（Separating-Hyperplanes）" class="headerlink" title="分离超平面（Separating Hyperplanes）"></a>分离超平面（Separating Hyperplanes）</h1><p>对于两点的相似程度，我们可以使用内积来表示$\langle x_i,x_j\rangle$。而一个分类问题的本质就是将数据集在一个平面上表示，然后将数据所在的空间划分成两个子空间。为了方便起见，我们考虑一个简单的分类问题：</p>
<script type="math/tex; mode=display">f:\mathbb R^D\rightarrow \mathbb R, \ x\in \mathbb R^D\\ x\mapsto f(x):=\langle w,x\rangle+b</script><p>其中的参数为：$w\in\mathbb R^D,b\in \mathbb R$.我们原先提到，超平面实际上就是仿射子空间，所以我们假设一个超平面在一个二分类问题中将两类数据分离到两个子空间中：</p>
<script type="math/tex; mode=display">\{x\in\mathbb R^D:f(x)=0\}</script><p>在下图中，我们可以知道w是超平面的法向量，b是超平面的截距。<br><img src="https://img-blog.csdnimg.cn/20210720074318957.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>证明：<br>假设有两个点在超平面上$x_a,x_b$:</p>
<script type="math/tex; mode=display">f(x_a)-f(x_b)=\langle w,x_a\rangle+b-(\langle w,x_b\rangle + b)=\langle w, x_a-x_b\rangle</script><p>由于超平面的方程为$\langle w,x\rangle +b=0$,而选取的两个点在超平面上，所以$f(x_a),f(x_b)=0$,所以：</p>
<script type="math/tex; mode=display">\langle w, x_a-x_b\rangle=0</script><p>所以，w与超平面相互垂直。<br>对于一个二分类问题，数据点在超平面的上方为一类，下方为另一类，所以：</p>
<script type="math/tex; mode=display">y_n=\left\{\begin{aligned}
1,\quad\langle w,x_n\rangle+b\ge0 \\
-1\quad \langle w,x_n\rangle+b <0 
\end{aligned}\right.</script><p>上式也可以直接整理到一个式子中：$y_n(\langle w,x_n\rangle+b)\ge 0$.这就是分类问题的分类器。</p>
<h1 id="原始支持向量机（Primal-Support-Vector-Machine）"><a href="#原始支持向量机（Primal-Support-Vector-Machine）" class="headerlink" title="原始支持向量机（Primal Support Vector Machine）"></a>原始支持向量机（Primal Support Vector Machine）</h1><p>对于一个线性可分的数据集，有时候能够将两类数据分开的超平面不止一个，我们需要找到其中的较好的一个超平面，其中的一个想法就是最大化两类数据到超平面的距离，这样能够提高模型的泛化能力。（这样想，如果一个分类器离数据点很近，那么只要这个数据点有一点波动，就可能导致数据点的类别变化）</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://img-blog.csdnimg.cn/20210720104357340.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">
    Figure 12.3  Possible separating hyperplanes. There are many linear
classifiers (green lines) that separate orange crosses from blue discs.
</div>
</center>
<br>

## 间隔的概念（Concept of the Margin）
我们假设有一个样本点$x_a$是这一类数据中离超平面最近的点, 这个样本点在超平面上的正交投影为$x_a'$,如下图所示。我们可以发现$x_a$与$x_a'$之间的距离向量与$w$相互平行，所以这个距离向量可以用$r\frac{w}{\|w\|}$表示，其中的r为比例参数，然后根据向量加法：
$$x_a = x_a'+r\frac{w}{\|w\|}$$
对于r，我们还可以认为是$x_a$在$w$上的投影的坐标。
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://img-blog.csdnimg.cn/20210720103533239.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">Figure 12.4 Vector addition to express distance to hyperplane
    </div>
</center>
<br>

我们需要尽量最大化这个距离向量，所以我们假设这个距离向量的模不应该小于r(即这个数据点到其投影点的距离不应该小于$|r|$)，所以有：

$$y_n(\langle w,x_n\rangle+b)\ge r$$

由于我们并不关心$w$的大小，只需要求他的方向，所以可以假设$\|w\|=1$。将上面的条件组合成一个约束优化问题：

$$\max_{w,b,r}\underbrace{r}_{margin}\\
s.t. \quad \underbrace{y_n(\langle w, x_n\rangle+b\ge r)}_{data fitting},\ \underbrace{\|w\|=1}_{normalization},r>0
$$

这也就是说我们想最大化间隔r，同时保证数据在超平面的正确的方向。
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://img-blog.csdnimg.cn/20210720111704696.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">Figure 12.5
Derivation of the
margin: r</div>
</center>

<blockquote>
<p>when the margin is large, the “complexity” of the function class is low, and hence learning is possible</p>
</blockquote>
<h2 id="间隔的传统推导（Traditional-Derivation-of-the-Margin）"><a href="#间隔的传统推导（Traditional-Derivation-of-the-Margin）" class="headerlink" title="间隔的传统推导（Traditional Derivation of the Margin）"></a>间隔的传统推导（Traditional Derivation of the Margin）</h2><p>我们之前在推导边缘的时候，因为我们不关心$w$的大小，只关心它的方向，所以我们就假设$|w|=1$.在本节中，我们将使用不同的假设推导边缘最大化问题。假设数据集中的一类离超平面最近的点为$x_a$,距离为1,即$\langle w,x_a\rangle +b=1$， 所以我们可以重新调整超平面，使得这个点在移动后的超平面上，如图12.5. 有因为这个数据点的投影$x’_a$在超平面上，所以：</p>
<script type="math/tex; mode=display">\langle w,x_a'\rangle +b = 0</script><p>之后将$x_a = x_a’+r\frac{w}{|w|}$带入到上式：</p>
<script type="math/tex; mode=display">\langle w, x_a-r\frac{w}{\|w\|}\rangle+b=0</script><p>再根据内积的双线性的性质：</p>
<script type="math/tex; mode=display">\langle w,x_a\rangle +b-r\frac{\langle w,w\rangle}{\|w\|}=0</script><p>由于我们之前假设$\langle w,x_a\rangle +b=1$,有因为$\langle w,w\rangle=|w|^2$,全部带入上式：</p>
<script type="math/tex; mode=display">r = \frac{1}{\|w\|}</script><p>由于在计算的时候w也是未知的，所以我们并不能通过上式将r推导出来，但是我们可以将这个变量作为中间变量，所以接下来的章节我们将会使用$\frac{1}{|w|}$代替$r$.当然这个r 也可以看成数量点向超平面的投影误差。 这样我们可以发现，这个假设$r=1$与之前的假设$|w|=1$是一致的。<br>于是，我们原先的约束问题可以转换成：</p>
<script type="math/tex; mode=display">\max_{w,b}\frac{1}{\|w\|}\\
s.t. \quad y_n(\langle w,x_n\rangle+b\ge1) \quad for \ all \quad n=1,\cdots,N</script><p>为了计算方便，我们将上式中的求最大值转换成求最小值：</p>
<script type="math/tex; mode=display">\min_{w,b}\frac12{\|w\|}^2\\
s.t. \quad y_n(\langle w,x_n\rangle+b\ge1) \quad for \ all \quad n=1,\cdots,N</script><p>上式就是<strong>硬边界支持向量机</strong>（hard margin SVM）。之所以称为“硬”，是因为这个边界不允许任何数据点违反边界条件。</p>
<h2 id="为什么将间隔设为1（Why-We-Can-Set-the-Margin-to-1）"><a href="#为什么将间隔设为1（Why-We-Can-Set-the-Margin-to-1）" class="headerlink" title="为什么将间隔设为1（Why We Can Set the Margin to 1）"></a>为什么将间隔设为1（Why We Can Set the Margin to 1）</h2><p>我们需要证明：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\max _{\boldsymbol{w}, b, r} \underbrace{r}_{\text {margin }} \\
&\text { subject to } \quad \underbrace{y_{n}\left(\left\langle\boldsymbol{w}, \boldsymbol{x}_{n}\right\rangle+b\right) \geqslant r}_{\text {data fitting }}, \underbrace{\|\boldsymbol{w}\|=1}_{\text {normalization }}, \quad r>0
\end{aligned}</script><p>与</p>
<script type="math/tex; mode=display">
\min _{\boldsymbol{w}, b} \underbrace{\frac{1}{2}\|\boldsymbol{w}\|^{2}}_{\text {margin }}\\{\text { subject to }} \underbrace{y_{n}\left(\left\langle\boldsymbol{w}, \boldsymbol{x}_{n}\right\rangle+b\right) \geqslant 1}_{\text {data fitting }} .</script><p>是等价的。后者是利用了假设$r=1$.以下证明不严格，主要用于描述证明思路。<br>假设一个超平面的方程为：$wx+b=r$，将右边归一化之后得：$\frac{w}{r}x+\frac{b}{r}=1$,于是可以令:$w’=\frac{w}{r},\ b’=\frac{b}{r}$于是:$|w’|=\frac 1r |w|$,由于原命题中有一个假设：$|w|=1$,所以可以得到：$|w’|=\frac 1r$.带入原命题中，可以得到与要证明的命题一致的形式：</p>
<script type="math/tex; mode=display">
\min _{\boldsymbol{w'}, b} \underbrace{\frac{1}{2}\|\boldsymbol{w'}\|^{2}}_{\text {margin }}\\{\text { subject to }} \underbrace{y_{n}\left(\left\langle\boldsymbol{w'}, \boldsymbol{x}_{n}\right\rangle+b\right) \geqslant 1}_{\text {data fitting }} .</script><p>或者是说，两个参数同时变化相当于对超平面的平移，但是无论怎么平移，方程都是指向同一个超平面的。（几何间隔与函数间隔）</p>
<h2 id="软间隔支持向量机：几何视角（Soft-Margin-SVM-Geometric-View）"><a href="#软间隔支持向量机：几何视角（Soft-Margin-SVM-Geometric-View）" class="headerlink" title="软间隔支持向量机：几何视角（Soft Margin SVM: Geometric View）"></a>软间隔支持向量机：几何视角（Soft Margin SVM: Geometric View）</h2><p>由于测量误差等的因素，很难保证数据点都准确。所以我们希望能够允许部分的数据点被错误分类，这种允许一些错误分类的支持向量机称为<strong>软间隔支持向量机</strong>。<br>在几何视角下，我们需要介绍一个关键变量：<strong>松弛变量</strong>（slack variable）</p>
<p><center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://img-blog.csdnimg.cn/img_convert/f500ab634f2592cb2887e5669816d165.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">Figure 12.7 松弛变量描述的是被错误分类的点到对应的间隔超平面的距离，x+是被错误分类的数据点</div>
</center><br><br></p>
<p>我们为每一组数据$(x_i,y_i)$引入一个松弛变量$ \xi_i$这样允许一组数据在间隔以内，甚至是在超平面的错误的一边。我们将松弛变量加入到硬间隔支持向量机中：</p>
<script type="math/tex; mode=display">\min_{w,b,\xi}\frac 12\|w\|^2+C\sum^N_{n=1}\xi_n\\
s.t.\quad y_n(\langle w,x_n\rangle +b)\ge1-\xi_n,\quad \xi_n\ge0</script><p>其中，$C$被称为<strong>正则化系数</strong>， $|w|^2$被称为<strong>正则项</strong>。这个定义与之前的好像略有不同，可以认为是在原先的正则化式子中同时除以了一个正则化系数$\lambda$.上面这个式子就是<strong>软间隔支持向量机</strong>（Soft Margin SVM）.</p>
<blockquote>
<p>注意到式中的b没有正则化，因为未正则化的b使理论分析复杂化并且降低了计算效率。<br>The unregularized term b complicates theoretical analysis (Steinwart and Christmann, 2008, chapter 1) and decreases computational efficiency (Fan et al., 2008).<strong>（？）</strong><br><strong>公式理解</strong>：$1-\xi$是错误分类的数据点距超平面的距离。</p>
</blockquote>
<h2 id="软间隔SVM：损失函数视角（Soft-Margin-SVM-Loss-Function-View）"><a href="#软间隔SVM：损失函数视角（Soft-Margin-SVM-Loss-Function-View）" class="headerlink" title="软间隔SVM：损失函数视角（Soft Margin SVM: Loss Function View）"></a>软间隔SVM：损失函数视角（Soft Margin SVM: Loss Function View）</h2><p>在SVM中，我们假设类就是超平面：</p>
<script type="math/tex; mode=display">f(x)=\langle w,x\rangle+b</script><p>现在我们要找到对应的损失函数，在之前的章节中的线性规划问题中使用的平方损失函数在分类问题中并不适合，所以我们需要找到其他的损失函数。<br>有一个候选函数就是<strong>0-1损失函数</strong>（zero-one loss）。当样本被错误分类的时候，函数值为1，否则为0，这个函数标识为$\boldsymbol 1(f(x)\ne y_n)$。但是使用这个损失函数就需要解决一个组合优化问题，难度很大。<br>还有一种损失函数为<strong>合页损失函数</strong>（hinge loss）：</p>
<script type="math/tex; mode=display">\ell = \max\{0,1-t\},\quad where \quad t=yf(x)=y(\langle w,x\rangle+b)</script><p>也就是当预测结果在正确的方向且$t\ge1$时， 函数值为0.其他情况为非零，也可以将上式写成：</p>
<script type="math/tex; mode=display">\ell =\left\{\begin{aligned}
&0\quad &if\quad y\ge1 \\
&1-t\quad &if\quad t<1
\end{aligned}\right.</script><p>对于硬间隔SVM：</p>
<script type="math/tex; mode=display">\ell=\left\{\begin{aligned}
&0\quad &if\quad t\ge 1\\
&\infin\quad &if \quad t<1
\end{aligned}\right.</script><p>损失函数在图中的表示为：</p>
<p><center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://img-blog.csdnimg.cn/img_convert/b8279f9e6cb07969b873bed32897a8a7.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">Figure 12.8 合页损失函数是0-1损失函数的凸上界</div>
</center><br><br></p>
<p>将合页损失函数带到原先的优化问题中：</p>
<script type="math/tex; mode=display">\min_{w,b}\underbrace {\frac 12\|w\|^2}_{regularizer}+\underbrace{C\sum^N_{n=1}\max\{0,1-y_n(\langle w,x_n\rangle + b)\}}_{error\ term}</script><p>由上可以知道，最大间隔实际上就是正则化。上述的无约束优化问题的解可以直接用梯度下降法求解，与之前的约束优化问题的结果是一致的。这是因为：</p>
<script type="math/tex; mode=display">\min_{t}\max\{0,1-t\}</script><p>等价于：</p>
<script type="math/tex; mode=display">\min_{\xi,t}\quad\xi\\
s.t. \quad \xi\ge0,\xi\ge1-t</script><p>将上式带入无约束优化问题中，经过整理可以得到与软间隔SVM一致的形式。</p>
<h1 id="对偶支持向量机（Dual-Support-Vector-Machine）"><a href="#对偶支持向量机（Dual-Support-Vector-Machine）" class="headerlink" title="对偶支持向量机（Dual Support Vector Machine）"></a>对偶支持向量机（Dual Support Vector Machine）</h1><p>原先我们提到的支持向量机的参数数量是由特征的数量决定的。在这部分，我们介绍对偶支持向量机，他的参数数量是由训练集数据的数量决定，这样能够有效处理特征多，数据少的数据集。另外， 对偶支持向量机能够很好地引入核函数。在这里地对偶主要指<strong>凸对偶</strong>（convex duality）</p>
<h2 id="利用拉格朗日乘子解决凸对偶（Convex-Duality-via-Lagrange-Multipliers）"><a href="#利用拉格朗日乘子解决凸对偶（Convex-Duality-via-Lagrange-Multipliers）" class="headerlink" title="利用拉格朗日乘子解决凸对偶（Convex Duality via Lagrange Multipliers）"></a>利用拉格朗日乘子解决凸对偶（Convex Duality via Lagrange Multipliers）</h2><p>将之前的约束优化问题利用拉格朗日乘子转化成非约束优化问题，其中$\alpha,\gamma$是拉格朗日乘子</p>
<script type="math/tex; mode=display">
\begin{aligned}
\mathfrak{L}(\boldsymbol{w}, b, \xi, \alpha, \gamma)=& \frac{1}{2}\|\boldsymbol{w}\|^{2}+C \sum_{n=1}^{N} \xi_{n} \\
& \underbrace{-\sum_{n=1}^{N} \alpha_{n}\left(y_{n}\left(\left\langle\boldsymbol{w}, \boldsymbol{x}_{n}\right\rangle+b\right)-1+\xi_{n}\right)}_{\text {constraint (12.26b) }} \underbrace{-\sum_{n=1}^{N} \gamma_{n} \xi_{n}}_{\text {constraint }(12.26 \mathrm{c})}
\end{aligned}</script><p>将拉格朗日函数对各个参数进行求导：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac{\partial \mathfrak{L}}{\partial \boldsymbol{w}} &=\boldsymbol{w}^{\top}-\sum_{n=1}^{N} \alpha_{n} y_{n} \boldsymbol{x}_{n}^{\top}, \\
\frac{\partial \mathfrak{L}}{\partial b} &=-\sum_{n=1}^{N} \alpha_{n} y_{n} \\
\frac{\partial \mathfrak{L}}{\partial \xi_{n}} &=C-\alpha_{n}-\gamma_{n}
\end{aligned}</script><p>将第一个式子设为0,得到：</p>
<script type="math/tex; mode=display">w=\sum^N_{n=1}\alpha_ny_nx_n</script><p>于是可以知道原始SVM的权重向量就是数据集的线性组合。这印证了我们原先提到的<strong>表示定理</strong>（representer theorem）：最小经验风险的解就在由数据定义的子空间中。</p>
<blockquote>
<p>表示会定理也给支持向量机这个名字提供了另一种解释。当$x_n$对应的$\alpha_n$为0的时候，说明这个数据点对解没有贡献，而当它大于0的时候，就被称为<strong>支持向量</strong>，它支撑起了超平面。</p>
</blockquote>
<p>将$w$的式子带入到上面的拉格朗日函数中：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\mathfrak{D}(\xi, \alpha, \gamma)=& \frac{1}{2} \sum_{i=1}^{N} \sum_{j=1}^{N} y_{i} y_{j} \alpha_{i} \alpha_{j}\left\langle\boldsymbol{x}_{i}, \boldsymbol{x}_{j}\right\rangle-\sum_{i=1}^{N} y_{i} \alpha_{i}\left\langle\sum_{j=1}^{N} y_{j} \alpha_{j} \boldsymbol{x}_{j}, \boldsymbol{x}_{i}\right\rangle \\
&+C \sum_{i=1}^{N} \xi_{i}-b \sum_{i=1}^{N} y_{i} \alpha_{i}+\sum_{i=1}^{N} \alpha_{i}-\sum_{i=1}^{N} \alpha_{i} \xi_{i}-\sum_{i=1}^{N} \gamma_{i} \xi_{i}
\end{aligned}</script><p>再令$\frac{\partial \mathfrak{L}}{\partial b}=-\sum<em>{n=1}^{N} \alpha</em>{n} y_{n}=0$带入，由于内积是对称函数而且具有双线性，所以上式中的前两项是可以合并的。于是得到：</p>
<script type="math/tex; mode=display">
\mathfrak{D}(\xi, \alpha, \gamma)=-\frac{1}{2} \sum_{i=1}^{N} \sum_{j=1}^{N} y_{i} y_{j} \alpha_{i} \alpha_{j}\left\langle x_{i}, x_{j}\right\rangle+\sum_{i=1}^{N} \alpha_{i}+\sum_{i=1}^{N}\left(C-\alpha_{i}-\gamma_{i}\right) \xi_{i}</script><p>又再令$\frac{\partial \mathfrak{L}}{\partial \xi<em>{n}} =C-\alpha</em>{n}-\gamma_{n}=0$,又由于拉格朗日乘子$\gamma_i\ge0$,所以$\alpha_i\le C$,于是原先的双系数拉格朗日就转换成单系数拉格朗日：</p>
<script type="math/tex; mode=display">
\begin{array}{ll}
\min _{\boldsymbol{\alpha}} & \frac{1}{2} \sum\limits_{i=1}^{N} \sum\limits_{j=1}^{N} y_{i} y_{j} \alpha_{i} \alpha_{j}\left\langle\boldsymbol{x}_{i}, \boldsymbol{x}_{j}\right\rangle-\sum\limits_{i=1}^{N} \alpha_{i} \\
\text { subject to } & \sum\limits_{i=1}^{N} y_{i} \alpha_{i}=0 \\
0 \leqslant \alpha_{i} \leqslant C & \text { for all } i=1, \ldots, N
\end{array}</script><p>这就是<strong>对偶支持向量机</strong>（Dual SVM）,它对应的约束被称为“<strong>框型约束</strong>”（box constraints）拉格朗日乘子被限制在一个方形的区域内（$[0,C]$）.这种与坐标轴平行的约束，在数值计算的过程中非常高效。<br>当我们得到$\alpha$之后，可以利用表示定理将最优的$w$求出来。假设这个参数为$w^*$</p>
<blockquote>
<p>在 L2 正则化问题上：<br>表示定理是指任意一个 L2 正则化的问题，其最佳 w* 都可以用 βn 与 Zn 线性组合得到。</p>
</blockquote>
<p>假设数据点$x_n$在边界上， 所以有$\langle w^*, x_n\rangle+b=y_n$，所以参数b的解为：</p>
<script type="math/tex; mode=display">b^*=y_n-\langle w^*,x_n\rangle</script><p>当假设不成立的时候，需要计算所有支持向量的上式右边式子的绝对值，然后找到中位数，这里省略。</p>
<h2 id="对偶支持向量机：凸包视角（Dual-SVM-Convex-Hull-View）"><a href="#对偶支持向量机：凸包视角（Dual-SVM-Convex-Hull-View）" class="headerlink" title="对偶支持向量机：凸包视角（Dual SVM: Convex Hull View）"></a>对偶支持向量机：凸包视角（Dual SVM: Convex Hull View）</h2><p>另一种理解支持向量机的方式需要借助一种几何参数。我们将拥有同样标签的数据点限制在我们构造的凸包中，如下图所示。<br><img src="https://img-blog.csdnimg.cn/34dc2628007e4a438705f2b5c2f5fabf.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>现在我们对凸包进行一个直观的解释。假设空间中有两个不相等的数据点$x<em>1,x_2$，现在有两个参数$\alpha_1, \alpha_2$,且$\alpha_1+\alpha_2=1$，所以$\alpha_1x</em>!+\alpha<em>2x_2$表示的就是$x_1,x_2$之间的数，现在加上另一个数据点及参数$x_3,\alpha_3$,这时候$\sum\limits^3</em>{i=1}\alpha_i=1$,这时候，三个点的线性组合的数据点在一个二维的区域内。这个区域就称为<strong>凸包</strong>（convex hull）。<br>通常，构建一个凸包，可以利用一个非负的权重$\alpha_n\ge0$,对应数据$x_n$,于是，凸包可以表示为：</p>
<script type="math/tex; mode=display">\operatorname{conv}(X)=\left\{\sum^N_{n=1}\alpha_nx_n\right\}, \quad with \ \sum^N_{n=1}\alpha_n=1,\alpha_n\ge0</script><p>假设数据是可以分离的，那么这些数据对应的凸包就不会重合，我们找到两类数据中距离另一类最近的数据点$c,d$,如上图所示，定义两个凸包之间的距离为：</p>
<script type="math/tex; mode=display">w:=c-d</script><p>想要这两个数据点尽可能接近，等价于以下的优化问题：</p>
<script type="math/tex; mode=display">\arg \min_w\|w\|=\arg \min_w\frac 12\|w\|^2</script><p>由于c点在正凸包中，所以c点可以表示为：</p>
<script type="math/tex; mode=display">c=\sum_{n:y_n=+1}\alpha^+_nx_n</script><p>同样的，d点可以表示为：</p>
<script type="math/tex; mode=display">d=\sum_{n:y_n=-1}a_n^-x_n</script><p>其中，$n:y_n=-1$标签为-1的坐标索引。将两式带入到优化方程中：</p>
<script type="math/tex; mode=display">\min_\alpha\frac12\left\|
\sum_{n:y_n=+1}\alpha^+_nx_n-\sum_{n:y_n=+1}\alpha^+_nx_n
\right\|</script><p>对于参数$\alpha$:</p>
<script type="math/tex; mode=display">\sum_{n:y_n=+1}\alpha^+_nx_n=1,\quad \sum_{n:y_n=-1}a_n^-x_n=1</script><p>由于：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{n=1}^{N} y_{n} \alpha_{n} &=\sum_{n: y_{n}=+1}(+1) \alpha_{n}^{+}+\sum_{n: y_{n}=-1}(-1) \alpha_{n}^{-} \\
&=\sum_{n: y_{n}=+1} \alpha_{n}^{+}-\sum_{n: y_{n}=-1} \alpha_{n}^{-}=1-1=0
\end{aligned}</script><p>所以,优化问题的约束条件为：</p>
<script type="math/tex; mode=display">\sum_{n=1}^Ny_n\alpha_n=0</script><p>这里得到的约束优化问题与之前的对偶硬间隔支持向量机中的约束优化问题一致。</p>
<blockquote>
<p>想要得到软间隔的支持向量机的约束优化问题，我们需要利用<strong>缩小包</strong>（reduce hull），这对参数的规模进行了限制</p>
</blockquote>
<h1 id="核方法（Kernels）"><a href="#核方法（Kernels）" class="headerlink" title="核方法（Kernels）"></a>核方法（Kernels）</h1><p>在对偶SVM中，内积只是在样本之间，而在样本与参数之间没有内积的关系，所以可以使用一个特征$\phi(x)$将式中的内积代替。这样问题就具有了模块性，使得我们能够将特征表示方法和分类方法分开考虑。<br>由于有些数据并非是线性可分的，所以需要$\phi(x)$是非线性函数，但是我们不是去定义一个这样的非线性的函数，然后计算它的内积，而是定义一个相似函数$k(x_i,x_j)$,在这里这个相似函数称为<strong>核函数</strong>（Kernel Function）,核函数的定义为：<br>对于一个非线性特征映射$\phi(\cdot)$</p>
<script type="math/tex; mode=display">k:\mathcal X\times\mathcal X\rightarrow\mathbb R</script><p>存在一个<strong>希尔伯特空间</strong>（Hilbert space）$\mathcal H$有：<script type="math/tex">\phi:\mathcal X\rightarrow \mathcal H</script>.特征映射的定义为：</p>
<script type="math/tex; mode=display">k(x_i,x_j)=\langle \phi(x_i),\phi(x_j)\rangle_\mathcal H</script><p>每一个核函数都对应着唯一一个<strong>再生核希尔伯特空间</strong>（reproducing kernel Hilbert space）。在这种关系中，$\phi(x)=k(\cdot,x)$被称为<strong>规范特征图</strong>（Canonical Feature Map）.这种将一个内积转换成核函数的方法称为<strong>核方法</strong>（Kernel Trick）。这种方法避免了显式的非线性特征映射。<br>由数据内积或者是将数据带入到核函数$k(\cdot,\cdot)$得到的矩阵$K\in\mathbb R^{N\times N}$被称为<strong>克莱姆矩阵</strong>（Cram Matrix）,有时候也直接被称为<strong>核矩阵</strong>（Kernel Matrix）,核函数需要时对称且半正定的，这样核矩阵才能是对称和半正定的，对此核矩阵的定义为：</p>
<script type="math/tex; mode=display">\forall z\in \mathbb R^N:z^\top Kz\ge0</script><p>一些比较常用的核函数为：多项式核函数，高斯径向基核函数，有理二次核函数。下图是利用不同的核函数进行分类的结果：<br><img src="https://img-blog.csdnimg.cn/51546caf200e49b59e74ea817a13e844.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>注意函数的假设类仍旧是线性的，图中的非线性边界来源于核函数.</p>
<blockquote>
<p>这个“核”有很多定义，在这里的核是来源于再生核希尔伯特空间。我们之前提到过的核空间代表的是零空间。还有一种就是在密度估计中的光滑核函数。</p>
</blockquote>
<p>由于特征$\phi(x)$在数学上与核函数$k(x_i,x_j)$等价，所以我们常常选用一些比内积更好计算的核函数。例如，假设我们使用多项式核函数，当数据较多时，这时候即使是多项式的次数比较低，也会导致大量的特征($x_1,x_2,x_3 \rightarrow x_1<em>x_2, x_1</em>x_3\cdots$),但是使用核函数只需要对每一个输入进行一次乘法就可以了。<br>核方法的另一个优势是不需要将输入的数据表示为多元实数。而对于核函数的选择以及核函数的参数需要通过嵌套交叉验证的方式选择。</p>
<h1 id="数值解（Numerical-Solution）"><a href="#数值解（Numerical-Solution）" class="headerlink" title="数值解（Numerical Solution）"></a>数值解（Numerical Solution）</h1><p>在这部分，我们对原先提到的内容进行回顾。<br>首先我们是从损失函数的角度对支持向量机进行了解释，我们使用的合页损失函数$\max{0,1-t}$,但是这个损失函数是一个不可微的函数，于是我们采用次梯度（subgradient）的方法，得到损失函数的梯度：</p>
<script type="math/tex; mode=display">g(t)=\left\{\begin{aligned}
&-1,\quad&t<1\\
&[-1,0]&t=1\\
&0&t>1 
\end{aligned}\right.</script><p>这样我们就可以使用之前学过的一些优化算法进行优化了。<br>要想将原始支持向量机转换成二次规划的标准形式，我们假设内积为点乘，同时将原先所有的优化变量全部移到等式左边：</p>
<script type="math/tex; mode=display">\min_{w,b,\xi}\frac 12\|w\|^2+C\sum^N_{n=1}\xi_n\\
s.t.\quad \left\{\begin{aligned}
&-y_nx_n^\top w-y_nb-\xi_n\le-1 \\
&-\xi_n\le0
\end{aligned}\right.</script><p>将上式矩阵化（将变量$w,x_n,b$放到向量中）：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\min _{\boldsymbol{w}, b, \boldsymbol{\xi}} \quad \frac{1}{2}\left[\begin{array}{l}
\boldsymbol{w} \\
b \\
\boldsymbol{\xi}
\end{array}\right]^{\top}\left[\begin{array}{cc}
\boldsymbol{I}_{D} & \mathbf{0}_{D, N+1} \\
\mathbf{0}_{N+1, D} & \mathbf{0}_{N+1, N+1}
\end{array}\right]\left[\begin{array}{c}
\boldsymbol{w} \\
b \\
\boldsymbol{\xi}
\end{array}\right]+\left[\begin{array}{ll}
\mathbf{0}_{D+1,1} & C \mathbf{1}_{N, 1}
\end{array}\right]^{\top}\left[\begin{array}{l}
\boldsymbol{w} \\
b \\
\boldsymbol{\xi}
\end{array}\right] \\
&\text { subject to }\left[\begin{array}{ccc}
-\boldsymbol{Y} \boldsymbol{X} & -\boldsymbol{y} & -\boldsymbol{I}_{N} \\
\mathbf{0}_{N, D+1} & -\boldsymbol{I}_{N}
\end{array}\right]\left[\begin{array}{c}
\boldsymbol{w} \\
b \\
\boldsymbol{\xi}
\end{array}\right] \leqslant\left[\begin{array}{c}
-\mathbf{1}_{N, 1} \\
\mathbf{0}_{N, 1}
\end{array}\right]
\end{aligned}</script><p>这其中$\boldsymbol 0,\boldsymbol1, \boldsymbol I,\boldsymbol Y, \boldsymbol X$分别代表零矩阵，全一矩阵，单位矩阵，标签组成的对角矩阵，样本矩阵。<br>而对于对偶支持向量机，想要将其表示为标准形式，我们首先需要表示核函数矩阵$K$,其中的每一个元素为$K<em>{ij}=k(x_i,x_j)$,如果我们有明确的特征表示$x_i$则我们可以定义$K</em><br>{ij}\langle x_i,x_j\rangle$,为了方便，我们将有标签组成的对角矩阵表示为$Y=diag(y)$,这时，对偶支持向量机可以写为：</p>
<script type="math/tex; mode=display">\min_\alpha\frac12\alpha^\top YKY\alpha\boldsymbol 1^\top_{N.1}\alpha\\
s.t.\quad \begin{bmatrix}
y^\top\\
-y^\top\\-I_N\\I_n
\end{bmatrix}\alpha
\le\begin{bmatrix}\boldsymbol 0_{N+2,1}\\C\boldsymbol 1_{N,1}
\end{bmatrix}</script><p>为了将式子表示为标准形式，所以将等式写成了两个不等式：</p>
<script type="math/tex; mode=display">Ax=b\Leftrightarrow AX\le b\quad and\quad AX\ge b</script><p>正是由于支持向量机能够清晰描述为优化问题，这使得许多的基于数值优化的技术能够被应用。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6ch11%EF%BC%9A%E5%9F%BA%E4%BA%8E%E9%AB%98%E6%96%AF%E6%B7%B7%E5%90%88%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%AF%86%E5%BA%A6%E4%BC%B0%E8%AE%A1%EF%BC%88Density-Estimation-with-Gaussian-Mixture-Models%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6ch11%EF%BC%9A%E5%9F%BA%E4%BA%8E%E9%AB%98%E6%96%AF%E6%B7%B7%E5%90%88%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%AF%86%E5%BA%A6%E4%BC%B0%E8%AE%A1%EF%BC%88Density-Estimation-with-Gaussian-Mixture-Models%EF%BC%89/" class="post-title-link" itemprop="url">机器学习中的数学ch11：基于高斯混合模型的密度估计（Density Estimation with Gaussian Mixture Models）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-07-05 10:09:14" itemprop="dateCreated datePublished" datetime="2021-07-05T10:09:14+08:00">2021-07-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-09 18:49:43" itemprop="dateModified" datetime="2023-03-09T18:49:43+08:00">2023-03-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>@[toc]<br>在本章节中，我们会介绍关于密度估计的几个主要的概念，例如：<strong>期望最大化算法</strong>（expectation maximization (EM) algorithm）。<br>当我们使用数据进行模型训练的时候，我们需要将数据按照一些方法表示出来，最常见的方法就是将数据点本身代表数据，如下图：<br><img src="https://img-blog.csdnimg.cn/20210703073427339.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>但是当数据集很大的时候，这种方法就不是很有效了（在上图这种多模型数据中的表现也不好）。在密度估计中，我们使用参数族（例如高斯分布、贝塔分布等）中的密度来表示数据。例如，我们可以找到数据集的均值和方差，然后利用高斯模型表示这些数据，我们可以认为数据集就是从这些模型中抽样出来的。<br>但是 ，在实践过程中，这些模型有时候不能很好地表示这些数据，也就是说这些模型的具有<strong>有限的建模能力</strong>（have limited modeling capabilities）。所以，我们介绍一种更通用的数据模型：<strong>混合模型</strong>（mixture model）。<br>混合模型可以将一个概率分布用K种不同的基本分布的<strong>凸组合</strong>（convex combination）表示：</p>
<script type="math/tex; mode=display">p(x)=\sum^K_{k=1}\pi_k p_k(x)\\   0\le \pi_k\le 1,\quad \sum^K_{k=1}\pi_k=1</script><p>其中，$p_k$为基本分布（高斯分布，贝塔分布等），$\pi_k$为<strong>混合权重</strong>（mixture weight），混合权重能够保证混合模型的概率密度分布的总积分仍旧是1。通过将基本模型进行混合，混合模型能够很好地表示一些多模型数据（如上图中数据）。<br>在本章中，主要讨论<strong>高斯混合模型</strong>（Gaussian mixture models (GMMs)）。我们的目标是通过最大化模型参数的似然来训练GMMs。这里我们不会项之前那样找到一个闭型（closed-form，解析解）的极大似然估计的解，而是找到一组相互独立的联立方程（dependent simultaneous equation），解这些方程只能通过迭代的方式。</p>
<h1 id="高斯混合模型（Gaussian-Mixture-Model）"><a href="#高斯混合模型（Gaussian-Mixture-Model）" class="headerlink" title="高斯混合模型（Gaussian Mixture Model）"></a>高斯混合模型（Gaussian Mixture Model）</h1><p>高斯混合模型是一个密度模型，在这个模型中，我们将K个高斯分布组合起来，即$\mathcal N(x|\mu_k,\Sigma_k)$:</p>
<script type="math/tex; mode=display">p(x|\theta)= \sum^K_{k=1}\pi_k\mathcal N(x|\mu_k.\Sigma_k)\\0\le \pi_k\le1,\sum^K_{k=1}\pi_k=1</script><p>其中，$\theta := {\mu_k.\Sigma_k,\pi_k:k = 1,\cdots,K}$为模型参数的整合参数。这个混合模型能够在数据处理的时候提供更高的灵活度。下图是一个高斯混合模型的曲线图：<br><img src="https://img-blog.csdnimg.cn/20210703084107518.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210703084128185.png" alt="在这里插入图片描述"></p>
<h1 id="利用极大似然估计进行参数学习（Parameter-Learning-via-Maximum-Likelihood）"><a href="#利用极大似然估计进行参数学习（Parameter-Learning-via-Maximum-Likelihood）" class="headerlink" title="利用极大似然估计进行参数学习（Parameter Learning via Maximum Likelihood）"></a>利用极大似然估计进行参数学习（Parameter Learning via Maximum Likelihood）</h1><p>假设有一个从未知分布$p(x)$中抽样得到的独立同分布的数据集$\mathcal X={x_1,\cdots,x_N}$，我们的目标是找到能够更好地表示这个未知分布的GMM的参数$\theta$。这里我们使用极大似然估计求解参数，由于数据都是独立同分布的，所以我们可以对似然函数进行分解：</p>
<script type="math/tex; mode=display">p(\mathcal X|\theta)=\prod^N_{n=1}p(x_n|\theta),\quad p(x_n|\theta)=\sum^K_{k=1}\pi_k\mathcal N(x_n|\mu_k,\Sigma_k)</script><p>其中的每一个$p(x_n|\theta)$都是一个高斯混合密度，所以对应的自然对数似然为：</p>
<script type="math/tex; mode=display">\log p(\mathcal X|\theta)=\sum^N_{n=1}\log p(x_n|\theta)=\underbrace{\sum^N_{n=1}\log \sum^K_{k=1}\pi_k \mathcal N(x_n|\mu_k,\Sigma_k)}_{=: \mathcal L}</script><p>我们的目标就是找到能够最小化这个自然对数似然的模型参数，我们原先讨论极大似然估计的解的时候，是将这个似然函数对参数球偏导，然后将这个偏导设为0，求解出参数的值。但是在这里我们不能求出一个闭型的解。</p>
<blockquote>
<p><strong>不能求出闭型的解的原因？</strong><br>原先我们讨论的是单个高斯分布，所以对应的自然对数概率分布为：</p>
<script type="math/tex; mode=display">\log \mathcal N(x|\mu,\Sigma)=-\frac D2\log (2\pi)-\frac 12\log\det(\Sigma)-\frac 12(x-\mu)^\top \Sigma^{-1}(x-\mu)</script><p>这个简单的形式能够让我们找到闭型的解，但是对于混合函数，其中的log后面的K次求和没有办法拆开，所以也就很难找到闭型的解了。</p>
</blockquote>
<p>所以我们使用迭代的方式找到模型的最佳参数$\theta_{ML}$,这个方法就是<strong>期望最大化算法</strong>（expectation maximization (EM) algorithm），EM的关键思想就是更新其中一个参数，而保持其他参数固定。<br>由于函数的局部最优解出的梯度都是0，所以可以将$\mathcal L$对参数分别进行求偏导，然后将这些偏导设为0，这是最优化自然对数似然的必要条件：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\frac{\partial \mathcal{L}}{\partial \boldsymbol{\mu}_{k}}=\mathbf{0}^{\top} \Longleftrightarrow \sum_{n=1}^{N} \frac{\partial \log p\left(\boldsymbol{x}_{n} \mid \boldsymbol{\theta}\right)}{\partial \boldsymbol{\mu}_{k}}=\mathbf{0}^{\top}, \\
&\frac{\partial \mathcal{L}}{\partial \boldsymbol{\Sigma}_{k}}=\mathbf{0} \Longleftrightarrow \sum_{n=1}^{N} \frac{\partial \log p\left(\boldsymbol{x}_{n} \mid \boldsymbol{\theta}\right)}{\partial \boldsymbol{\Sigma}_{k}}=\mathbf{0} \\
&\frac{\partial \mathcal{L}}{\partial \pi_{k}}=0 \Longleftrightarrow \sum_{n=1}^{N} \frac{\partial \log p\left(\boldsymbol{x}_{n} \mid \boldsymbol{\theta}\right)}{\partial \pi_{k}}=0
\end{aligned}</script><p>由于$\mathcal L$是一个复合函数，所以可以使用链式法则进行求偏导：</p>
<script type="math/tex; mode=display">\frac{\partial\log p(x_n|\theta)}{\partial \theta}= \frac {1}{p(x_n|\theta)}\frac{\partial p(x_n|\theta)}{\partial \theta}</script><p>其中：$p(x<em>n|\theta)=\sum^K</em>{k=1}\pi_k\mathcal N(x_n|\mu_k,\Sigma_k)$；  $\theta := {\mu_k.\Sigma_k,\pi_k:k = 1,\cdots,K}$.接下来主要介绍求解上述的几个等式。但是在求解之前我们介绍一个很重要的概念：<strong>责任</strong>（responsibilities）</p>
<h2 id="责任（Responsibilities）"><a href="#责任（Responsibilities）" class="headerlink" title="责任（Responsibilities）"></a>责任（Responsibilities）</h2><p>我们将第k个混合成分对第n个数据点的<strong>责任</strong>定义为：</p>
<script type="math/tex; mode=display">r_{nk}:=\frac{\pi_k\mathcal N(x_n|\mu_k,\Sigma_k)}{\sum^K_{j=1}\pi_j\mathcal N(x_n|\mu_j,\Sigma_j)}</script><p>这个第k个混合成分（Mixture Component）对数据点$x<em>n$的责任$r</em>{nk}$与下面的似然函数呈比例：</p>
<script type="math/tex; mode=display">p(x_n|\pi_k,\mu_k,\Sigma_k)= \pi_k\mathcal N(x_n|\mu_k,\Sigma_k)</script><p>如果一个数据点与其中的混合成分越匹配（模型对应的部分能够很好地表示数据），那么相对应的责任也就越大。一个数据点的责任可以使用一个规范化的概率向量表示：$r<em>n:=[r</em>{n1,\cdots,r<em>{nK}}]^\top\in \mathbb R^K, \sum_kr</em>{nk}=1,r_{nk}\ge0$。（？ $r_n$满足Boltzmann/Gibbs分布）<br>可以将责任理解为数据点在各个混合成分中，所占有的比例，也就是各混合成分得到这个数据点的概率（一个不是很准确的理解就是，这个数据在各个混合成分之间的分量）.<br>接下来确定模型参数的时候，都需要依赖于这个责任，我们先改变一个参数，而保持其他的参数不变，然后计算对应的责任，之后不断将这两个步骤进行迭代，知道得到一个局部最优解。其实，正是二者与责任的高度相关性，使得最终的解没有一个闭型的解。</p>
<h2 id="更新均值（Updating-the-Means）"><a href="#更新均值（Updating-the-Means）" class="headerlink" title="更新均值（Updating the Means）"></a>更新均值（Updating the Means）</h2><p><strong>定理</strong>：（GMM均值的更新）GMM的均值参数$\mu_k,k=1,\cdots,K$为：</p>
<script type="math/tex; mode=display">\mu^{new}_{k}=\frac{\sum^N_{n=1}r_{nk}x_n}{\sum^N_{n=1}r_{nk}}</script><p>由于更新一个混合模型的参数需要所有混合模型的均值、协方差矩阵和混合权重，所以我们不能一次性为所有的$\mu_k$找到闭型的解。（我们需要同步更新？像梯度下降法那样？）<br><strong>证明</strong>：这里对定理进行简单的证明，但是不做详细说明<br>结合之前的结论，我们求解似然函数对均值的偏导：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac{\partial p\left(\boldsymbol{x}_{n} \mid \boldsymbol{\theta}\right)}{\partial \boldsymbol{\mu}_{k}} &=\sum_{j=1}^{K} \pi_{j} \frac{\partial \mathcal{N}\left(\boldsymbol{x}_{n} \mid \boldsymbol{\mu}_{j}, \boldsymbol{\Sigma}_{j}\right)}{\partial \boldsymbol{\mu}_{k}}=\pi_{k} \frac{\partial \mathcal{N}\left(\boldsymbol{x}_{n} \mid \boldsymbol{\mu}_{k}, \boldsymbol{\Sigma}_{k}\right)}{\partial \boldsymbol{\mu}_{k}} \\
&=\pi_{k}\left(\boldsymbol{x}_{n}-\boldsymbol{\mu}_{k}\right)^{\top} \boldsymbol{\Sigma}_{k}^{-1} \mathcal{N}\left(\boldsymbol{x}_{n} \mid \boldsymbol{\mu}_{k}, \boldsymbol{\Sigma}_{k}\right)
\end{aligned}</script><p>将上述的似然函数带入到对代价函数的偏导中：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac{\partial \mathcal{L}}{\partial \boldsymbol{\mu}_{k}} &=\sum_{n=1}^{N} \frac{\partial \log p\left(\boldsymbol{x}_{n} \mid \boldsymbol{\theta}\right)}{\partial \boldsymbol{\mu}_{k}}=\sum_{n=1}^{N} \frac{1}{p\left(x_{n} \mid \theta\right)} \frac{\partial p\left(\boldsymbol{x}_{n} \mid \boldsymbol{\theta}\right)}{\partial \boldsymbol{\mu}_{k}} \\
&=\sum_{n=1}^{N}\left(\boldsymbol{x}_{n}-\boldsymbol{\mu}_{k}\right)^{\top} \boldsymbol{\Sigma}_{k}^{-1}\underbrace{\frac{\pi_{k} \mathcal{N}\left(\boldsymbol{x}_{n} \mid \boldsymbol{\mu}_{k}, \boldsymbol{\Sigma}_{k}\right)}{\sum_{j=1}^{K} \pi_{j} \mathcal{N}\left(x_{n} \mid \mu_{j}, \Sigma_{j}\right)}}_{=r_{nk}} = \sum^N
_{n=1}  r_{n k}\left(\boldsymbol{x}_{n}-\boldsymbol{\mu}_{k}\right)^{\top} \boldsymbol{\Sigma}_{k}^{-1}
\end{aligned}</script><p>为了求解$\mu^{new}_{k}$,需要求解$\frac{\partial \mathcal L(\mu^{new_k})}{\partial \mu_k}=0^\top$:</p>
<script type="math/tex; mode=display">\sum^N_{n=1}r_{nk}x_n=\sum^N_{n=1}r_{nk}\mu_k^{new}\Leftrightarrow \mu^{new}_k=\frac{1}{N_k}\sum^N_{n=1}r_{nk}x_n</script><p>我们定义第k个混合元素对数据集的总贡献为：</p>
<script type="math/tex; mode=display">N_k:=\sum^N_{n=1}r_{nk}</script><p>得证。</p>
<p>这个均值更新的过程还可以使用<strong>重要性加权的蒙特卡罗估计</strong>（importance-weighted Monte Carlo estimate）理解。数据点$x<em>n$的重要性权值就是所有混合成份对数据点的责任(存疑where the importance weights of data point $x_n$ are the responsibilities $r</em>{nk}$ of the kth cluster for $x_n, k = 1, \cdots K$.)。<br>可以将均值的更新过程想象成均值点被各个数据点拉着移动，而每个数据点对均值点的力的大小就是责任，如下图：</p>
<p><div align="center"><br><img src="https://img-blog.csdnimg.cn/20210704073859551.png"></div></p>
<p>也可以将更新过程理解为在下式分布中的所有的数据点的期望值：</p>
<script type="math/tex; mode=display">r_k:=[r_{1k},\cdots,r_{Nk}]^\top/N_k</script><p>这也是一个规范化的概率向量：</p>
<script type="math/tex; mode=display">\mu_k\leftarrow \mathbb E_{rk}[\mathcal X]</script><h2 id="更新协方差（Updating-the-Covariances）"><a href="#更新协方差（Updating-the-Covariances）" class="headerlink" title="更新协方差（Updating the Covariances）"></a>更新协方差（Updating the Covariances）</h2><p><strong>定理</strong>（更新GMM的协方差）更新协方差参数：</p>
<script type="math/tex; mode=display">\Sigma^{new}_k=\frac1N_k\sum^N_{n=1}r_{nk}(x_n-\mu_k)(x_n-\mu_k)^\top</script><p>证明过程（原书p356）比较麻烦，这里略过.<br>与更新均值相似，更新协方差可以理解为是中心化数据$\tilde \mathcal X_k:={x_1-\mu_k,\cdots.x_N-\mu_k}$的平方的重要性加权期望值。</p>
<h2 id="更新混合权重（Updating-the-Mixture-Weights）"><a href="#更新混合权重（Updating-the-Mixture-Weights）" class="headerlink" title="更新混合权重（Updating the Mixture Weights）"></a>更新混合权重（Updating the Mixture Weights）</h2><p><strong>定理</strong>：</p>
<script type="math/tex; mode=display">\pi^{new}_k=\frac{N_k}{N},\quad k=1,\cdots,K</script><p>其中，N是数据点的个数。<br><strong>证明</strong>：<br>略（原书p358）</p>
<p>关于权重的更新即为第k个混合成分全部责任与数据点的个数的比。因为$N=\sum<em>kN_k$也可以理解为所有混合成分的的所有责任的总和，所以$\pi_k$可以理解为第k个混合成分对于整个数据集的相对重要性。<br>由于$N_k=\sum^N</em>{i=1}r_{nk}$的更新等式依赖于责任，所以更新这个式子需要依赖于其他的所有参数：$\pi_j,\mu_j,\Sigma_j,j=1,\cdots,K$</p>
<h2 id="实例（Example）"><a href="#实例（Example）" class="headerlink" title="实例（Example）"></a>实例（Example）</h2><p><strong>初始化</strong><br>假设一个一维数据集$\mathcal X={-3,-2.5,-1,0,2,4,5}$,现在有一个由三个成分混合而成的GMM，混合成份分别为：</p>
<script type="math/tex; mode=display">\begin{aligned}
p_1(x) &= \mathcal N(x|-4,1) \\
p_2(x) &= \mathcal N(x|0,0.2)\\
 p_3(x) &= \mathcal N(x|8,3)
\end{aligned}</script><p>初始化权重为：$\pi_1=\pi_2=\pi_3=\frac13$,在坐标中表示为：<br><img src="https://img-blog.csdnimg.cn/20210704094533886.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>责任</strong>：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{ccc}
1.0 & 0.0 & 0.0 \\
1.0 & 0.0 & 0.0 \\
0.057 & 0.943 & 0.0 \\
0.001 & 0.999 & 0.0 \\
0.0 & 0.066 & 0.934 \\
0.0 & 0.0 & 1.0 \\
0.0 & 0.0 & 1.0
\end{array}\right] \in \mathbb{R}^{N \times K} .</script><p>第n行告诉我们对$x_n$的所有混合成分的责任，责任之和为1，列告诉我们一个混合成分对所有的数据集的责任的情况。<br><strong>更新均值</strong><br>经计算，均值的变化为：</p>
<script type="math/tex; mode=display">\begin{aligned}
& \mu_1:-4\rightarrow -2.7\\
& \mu_2:0\rightarrow -0.4\\
& \mu_3:8\rightarrow3.7
\end{aligned}</script><p>变化形式表现在图中为：；<br><img src="https://img-blog.csdnimg.cn/2021070410003747.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>可以看到第一个混合成分和第三个混合成分朝着数据域的方向上移动。<br><strong>协方差更新</strong></p>
<script type="math/tex; mode=display">\begin{aligned}
&\sigma^2_1:1\rightarrow 0.14\\
& \sigma^2_2:0.2\rightarrow0.44\\
& \sigma_3^2:3\rightarrow1.53
\end{aligned}</script><p>这些变化表现在图像上为：<br><img src="https://img-blog.csdnimg.cn/20210704101115459.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>权重参数更新</strong></p>
<script type="math/tex; mode=display">
\pi_1:\frac13\rightarrow0.29\\
\pi_2:\frac13\rightarrow0.29\\
\pi_3:\frac 13\rightarrow0.42</script><p><img src="https://img-blog.csdnimg.cn/20210704101407676.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>注意到图像中的各个峰值发生了变化。经过这一系列的更新，得到的模型能够更好地拟合给定的数据。</p>
<h1 id="期望最大化算法（EM-Algorithm）"><a href="#期望最大化算法（EM-Algorithm）" class="headerlink" title="期望最大化算法（EM Algorithm）"></a>期望最大化算法（EM Algorithm）</h1><p>由于之前提到的参数更新的过程依赖于责任$r_{nk}$,而责任又与这些参数呈复杂的依赖关系，使得上述的更新过程没有一个闭型的解。接下来我们介绍一种解决参数的问题的迭代方案——<strong>期望最大化算法</strong>（The expectation maximization algorithm）。这其实是一种参数学习的泛化迭代方案。在高斯混合模中，我们选择参数的初始化值$\mu_k,\Sigma_k,\pi_k$,不断改变这些参数，直到他们收敛于<strong>期望步</strong>（E-step）和<strong>极大步</strong>（M-step）之间的不断迭代。</p>
<blockquote>
<p><strong>期望步</strong>：评估责任$r_{nk}$(属于k混合成分的的数据点n的后验概率)<br><strong>极大步</strong>：用更新后的责任重新估计参数</p>
</blockquote>
<p>由于EM算法每进行一次迭代都会导致似然函数值上升，所以可以利用这个特性直接检查自然对数似然或者参数。一个实例化的步骤如下：<br><img src="https://img-blog.csdnimg.cn/20210704103243446.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>迭代过程中的变化情况：<br><img src="https://img-blog.csdnimg.cn/20210704103427675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>现在我们对开篇的时候的数据进行处理：<br><img src="https://img-blog.csdnimg.cn/20210704104233277.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我们观察迭代的最终结果：<br><img src="https://img-blog.csdnimg.cn/20210704104324146.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt><br>由上图可以直到，左边的一簇数据可以由一个单一的成分进行表示，但是右边的一簇数据是由两个成分混合儿而成的，所以这两个混合成分对这一簇的数据的责任在0.5左右。</p>
<h1 id="潜变量角度（Latent-Variable-Perspective）"><a href="#潜变量角度（Latent-Variable-Perspective）" class="headerlink" title="潜变量角度（Latent-Variable Perspective）"></a>潜变量角度（Latent-Variable Perspective）</h1><p>我们使用一个离散型的潜变量模型来理解GMM。这样就可以将原先提到的责任的概念解释为后验概率分布了。其实，这个潜变量就是用来描述一个数据点在各个混合成分中的占有情况（表现为概率）。</p>
<h2 id="生成过程和概率模型（Generative-Process-and-Probabilistic-Model）"><a href="#生成过程和概率模型（Generative-Process-and-Probabilistic-Model）" class="headerlink" title="生成过程和概率模型（Generative Process and Probabilistic Model）"></a>生成过程和概率模型（Generative Process and Probabilistic Model）</h2><p>想要得到对应的概率模型，我们需要弄清楚数据的生成过程。<br>假设一个混合模型由K个成分组成，而且每一个数据只能够由唯一的一个混合成分生成，这里我们引入一个定义域由0，1组成的随机变量$z_k\in{0,1}$,这个随机变量表示第k个混合成份是否生成了该模型。所以：</p>
<script type="math/tex; mode=display">p(x|z_k=1)=\mathcal N(x|\mu_k,\Sigma_k)</script><p>其中，$z:=[z_1,\cdots,z_K]^\top$,其中包含$K-1$个0和$1$个1.例如，$z=[z_1,z_2z,_3]^\top=[0,1,0]^\top$表示该数据是由第二个混合元素生成的。<br><img src="https://img-blog.csdnimg.cn/20210704171437698.png" alt="在这里插入图片描述"><br>在实际过程中，$z_k$可能是未知的，也就是可能是由不同的高斯模型混合按照不同的比例混合而成的。所以假设一个关于潜变量的先验分布：</p>
<script type="math/tex; mode=display">p(z)=\pi=[\pi_1,\cdots,\pi_K]^\top,\sum^K_{k=1}\pi_k=1</script><p>其中，$\pi_k=p(z_k=1)$表示该数据点由第k个成分生成的概率（类比为混合比例）。<br>潜变量的建模过程实际上对应着数据的生成过程，下面是单个数据的生成过程：</p>
<p><div align="center"><br><img src="https://img-blog.csdnimg.cn/20210705070333595.png"></div></p>
<p>生成关系为：</p>
<script type="math/tex; mode=display">z_{(i)}\sim p(z)\\x^{(i)}\sim p(x|z^{(i)}=1)</script><p>这种数据的采样依赖于图模型中的父节点的采样，这种采样称为<strong>原始采样</strong>(Ancestral Sampling)<br>通常一个概率模型是由数据和潜变量的联合分布定义的，结合前面的知识，我们可以得到所有K个成分的联合分布：</p>
<script type="math/tex; mode=display">p(x,z_k=1)=p(x|z_k=1)p(z_k=1)=\pi_k\mathcal N(x|\mu_k,\Sigma_k)</script><p>对于所有的$k=1,\cdots ,K$:</p>
<script type="math/tex; mode=display">
p(\boldsymbol{x}, \boldsymbol{z})=\left[\begin{array}{c}
p\left(\boldsymbol{x}, z_{1}=1\right) \\
\vdots \\
p\left(\boldsymbol{x}, z_{K}=1\right)
\end{array}\right]=\left[\begin{array}{c}
\pi_{1} \mathcal{N}\left(\boldsymbol{x} \mid \boldsymbol{\mu}_{1}, \boldsymbol{\Sigma}_{1}\right) \\
\vdots \\
\pi_{K} \mathcal{N}\left(\boldsymbol{x} \mid \boldsymbol{\mu}_{K}, \boldsymbol{\Sigma}_{K}\right)
\end{array}\right]</script><h2 id="似然（Likelihood）"><a href="#似然（Likelihood）" class="headerlink" title="似然（Likelihood）"></a>似然（Likelihood）</h2><p>想要得到似然函数$p(x|\theta)$,我们需要将潜变量消去，由于我们原先定义的潜变量是离散型的，所以只需要连加就可以将潜变量消掉：</p>
<script type="math/tex; mode=display">p(z|\theta)=\sum_zp(x|\theta,z)p(z|\theta), \quad \theta:=\{\mu_k,\Sigma_k,\pi_k:k=1,\dots,K\}</script><p>采样的图模型为：(N个样本点)</p>
<p><div align="center"><br><img src="https://img-blog.csdnimg.cn/20210705072428252.png"></div></p>
<p>结合之前的知识，我们可以得到：</p>
<script type="math/tex; mode=display">p(x|\theta)=\sum^K_{k=1}\pi_k\mathcal N(x|\mu_k,\Sigma_k)</script><p>所以对于给定的数据集$\mathcal X$的似然函数为：</p>
<script type="math/tex; mode=display">p(\mathcal X|\theta)=\prod^N_{n=1}p(x_n|\theta)=\prod^N_{n=1}\sum^K_{k=1}\pi_k\mathcal N(x_n|\mu_k,\Sigma_k)</script><p>这个与原先的概率模型一致</p>
<h2 id="后验分布（Posterior-Distribution）"><a href="#后验分布（Posterior-Distribution）" class="headerlink" title="后验分布（Posterior Distribution）"></a>后验分布（Posterior Distribution）</h2><p>根据贝叶斯公式，我们得到潜变量的后验分布：</p>
<script type="math/tex; mode=display">p(z_k=1|x)=\frac{p(z_k)p(x|z_k=1)}{p(x)}</script><p>将之前的结论带入：</p>
<script type="math/tex; mode=display">p(z_k|x)=\frac{p(z_k)p(x|z_k)}{\sum^K_{j=1}p(z_j)p(x|z_j)}=\frac{\pi_k\mathcal N(x|\mu_k,\Sigma_k)}{\sum^K_{j=1}\pi_j\mathcal N(x|\mu_j,\Sigma_j)}</script><p>可以发现，这就是我们之前提到的<strong>责任</strong></p>
<h2 id="拓展到整个数据集（Extension-to-a-Full-Dataset）"><a href="#拓展到整个数据集（Extension-to-a-Full-Dataset）" class="headerlink" title="拓展到整个数据集（Extension to a Full Dataset）"></a>拓展到整个数据集（Extension to a Full Dataset）</h2><p>我们原先讨论的是单个数据，现在考虑一个数据集$\mathcal X:={x_1,\cdots,x_N}$每一个数据点都有自己的潜变量:</p>
<script type="math/tex; mode=display">z_n=[z_{n1},\cdots,z_{nK}]^\top\in\mathbb R^K</script><p>由于所有的数据都是独立同分布的，所以可以将条件分布分解为连积的形式：</p>
<script type="math/tex; mode=display">p(x_1,\cdots,x_N|z_1,\cdots,z_N)=\prod^N_{n=1}p(x_n|z_n)</script><p>后验分布：</p>
<script type="math/tex; mode=display">
\begin{aligned}
p\left(z_{n k}=1 \mid \boldsymbol{x}_{n}\right) &=\frac{p\left(\boldsymbol{x}_{n} \mid z_{n k}=1\right) p\left(z_{n k}=1\right)}{\sum_{j=1}^{K} p\left(\boldsymbol{x}_{n} \mid z_{n j}=1\right) p\left(z_{n j}=1\right)} \\
&=\frac{\pi_{k} \mathcal{N}\left(\boldsymbol{x}_{n} \mid \boldsymbol{\mu}_{k}, \boldsymbol{\Sigma}_{k}\right)}{\sum_{j=1}^{K} \pi_{j} \mathcal{N}\left(\boldsymbol{x}_{n} \mid \boldsymbol{\mu}_{j}, \boldsymbol{\Sigma}_{j}\right)}=r_{n k}
\end{aligned}</script><p>这还是第k个混合元素的责任。</p>
<h2 id="期望最大化算法重新回顾（EM-Algorithm-Revisited）"><a href="#期望最大化算法重新回顾（EM-Algorithm-Revisited）" class="headerlink" title="期望最大化算法重新回顾（EM Algorithm Revisited）"></a>期望最大化算法重新回顾（EM Algorithm Revisited）</h2><p>EM算法是一种用于求解极大似然估计的迭代算法，可以从潜变量的角度推导得来。对于一个给定的模型参数$\theta^{(t)}$,在期望步时，计算自然对数似然的期望：</p>
<script type="math/tex; mode=display">Q(\theta|\theta^{(t)})=\mathbb E_{z|x,\theta^{(t)}}[\log p(x,z|\theta)]=\int \log p(x,z|\theta)p(z|x,\theta^{(t)})dz</script><p>之后的极大步算则一个最大化上式的参数用于更新。但是EM算法并不一定会收敛于极大似然估计的解，有时候会收敛于局部最优解。可以采用不同的初始化值，这样可以减少得到局部最优解的风险。</p>
<h1 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h1><p><strong>核密度估计</strong>（Kernel Density Estimation）:<br>核密度估计是一种非参数密度估计，其实我们熟悉的直方图就是一种非参数估计，其中直方图的间距不合适可能会导致过拟合或者欠拟合。对于一个数据集，核密度估计的分布为：</p>
<script type="math/tex; mode=display">p(x)=\frac{1}{Nh}\sum^N_{n=1}k(\frac{x-x_n}{h})</script><p>其中，k为<strong>核函数</strong>（Kernel Function），就是一个非负且积分值为1的函数。$h&gt;0$是一个<strong>光滑参数</strong>（smoothing/bandwidth parameter）这个与直方图的面元（直方图的柱子的宽度，bin size）大小类似。核函数通常的选择就是高斯函数或者时均匀分布函数。同时，核密度估计与直方图密切相关，但是核密度估计是光滑的，直方图不是。<br><img src="https://img-blog.csdnimg.cn/20210705100827193.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/02/MML-ch-10-%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90%E9%99%8D%E7%BB%B4%EF%BC%88Dimensionality-Reduction-with-Principal-Component-Analysis%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/02/MML-ch-10-%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90%E9%99%8D%E7%BB%B4%EF%BC%88Dimensionality-Reduction-with-Principal-Component-Analysis%EF%BC%89/" class="post-title-link" itemprop="url">MML ch 10 主成分分析降维（Dimensionality Reduction with Principal Component Analysis）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-07-02 12:38:46" itemprop="dateCreated datePublished" datetime="2021-07-02T12:38:46+08:00">2021-07-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-09 18:49:04" itemprop="dateModified" datetime="2023-03-09T18:49:04+08:00">2023-03-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>@[toc]<br>对于一些高维的数据，分析难度大，而且想要对这些数据进行可视化几乎是不可能的，并且想要存储这些数据的代价也是及其昂贵的，所以我们想要找到一种能够将数据的维度降低的方法。这其中，<strong>主成分分析法</strong>（principal component analysis (PCA)）是最常用的方法之一。</p>
<h1 id="问题设置（Problem-Setting）"><a href="#问题设置（Problem-Setting）" class="headerlink" title="问题设置（Problem Setting）"></a>问题设置（Problem Setting）</h1><p>在PCA中，我们希望能够找到一个一个向量的投影向量$\tilde x_n$,与原向量尽可能相近。<br>对于一个独立均匀分布的数据集$\mathcal X={x_1,\cdots,x_N}, x_n\in \mathbb R^D$,它的均值为0， 对应的数据方差矩阵为：</p>
<script type="math/tex; mode=display">S=\frac 1N \sum^N_{n=1}x_nx^\top</script><p>压缩之后表示为：</p>
<script type="math/tex; mode=display">z_n = B^\top x_n\in \mathbb R^M</script><p>其中，B为投影矩阵，定义为：</p>
<script type="math/tex; mode=display">B := [b_1,\cdots,b_M]\in \mathbb R^{D\times M}</script><p>假设$b_i$为正交规范基，则$b_i^\top b_j=0, i\ne j;b_i^\top b_i=1$.我们希望找到一个M维的子空间$U\subseteq \mathbb R^D,\operatorname{dim}(U)=M &lt; D$,向其中的投影的向量与原先的向量最相似，因为压缩造成的损失最小。我们将投影的数据表示为$\tilde x_n\in U$,对应的坐标为$z_n$(基向量为$b_1,\cdots,b_M$)<br><img src="https://img-blog.csdnimg.cn/20210615092117707.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>PCA的目标是最小化平方重构误差（the Squared Reconstruction Error）$| x_n-\tilde x_n|^2$.<br>从数据压缩的角度来看，我们先是将源数据压缩到一个更低维度的空间中，对应下图的$z$，然后将压缩的信息复原，对应下图中的$\tilde x$; $z$控制着多少信息能够从$x$到$\tilde x$.在PCA中，我们考虑原始数据与低维数据之间的线性关系，所以有以下关系：<br>$z = B^\top x;\tilde x = Bz$。将PCA看成是一个数据压缩的过程，所以可以认为第一个箭头是<strong>编码器</strong>(encoder)，第二个箭头是<strong>解码器</strong>(decoder)<br><img src="https://img-blog.csdnimg.cn/20210615162848433.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>Graphical illustration of PCA. In PCA, we find a compressed version z of original data x. The compressed data can be reconstructed into $\tilde x$, which lives in the original data space, but has an intrinsic lower-dimensional representation than $x$.</p>
</blockquote>
<h1 id="最大化方差的角度看PCA（Maximum-Variance-Perspective）"><a href="#最大化方差的角度看PCA（Maximum-Variance-Perspective）" class="headerlink" title="最大化方差的角度看PCA（Maximum Variance Perspective）"></a>最大化方差的角度看PCA（Maximum Variance Perspective）</h1><p>在下图中，我们丢弃了数据关于$x_2$的信息，这样做能够达到降维的效果，而且使得数据的损失最小化，是源数据与降维之后的数据尽可能相似。假设忽略$x_1$的信息，则得到的数据就很不相似了，也就是说这个降维操作导致了很多的信息损失。通过观察可以发现，数据在两个维度上的分散程度不一样。当数据在一个维度上越分散，说明这个维度上所包含的信息也就越多，而方差可以表示数据分散程度的大小，所以从方差的角度理解<code>PCA就是找到低维空间中数据方差最大的维度</code>。<br><img src="https://img-blog.csdnimg.cn/20210615092117707.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>为了运算方便，我们对数据进行一个<strong>均值归一化</strong>（Mean Normalization）,因为我们要研究的是方差，而对数据整体的几何运算并不会影响数据的方差</p>
<script type="math/tex; mode=display">\mathbb V_z[z]=\mathbb V_x[B^\top(x-\mu)]=\mathbb V_x[B^\top x - B^\top \mu]=\mathbb V_x[B^\top x]</script><p>这时候对应的低维空间的数据的均值也是0:$\mathbb E_z[z]=\mathbb E_x[\boldsymbol B^\top \boldsymbol x]=\boldsymbol B^\top \mathbb E_x[\boldsymbol x]=\boldsymbol 0$。</p>
<blockquote>
<p>$\boldsymbol B$是投影矩阵，将源数据投影到主成分上，从而实现降维。</p>
<p><img src="https://img-blog.csdnimg.cn/20210615165552555.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="最大方差的方向（Direction-with-Maximal-Variance）"><a href="#最大方差的方向（Direction-with-Maximal-Variance）" class="headerlink" title="最大方差的方向（Direction with Maximal Variance）"></a>最大方差的方向（Direction with Maximal Variance）</h2><p>为了找到数据在低维空间中的最大的方差，我们先找到一个向量$b_1\in \mathbb R^D$,数据在这个向量上的投影的方差最大,也就是要最大化$z\in \mathbb R^M$中第一个坐标$z_1$的方差：</p>
<script type="math/tex; mode=display">V_1 := \mathbb V[z_1]=\frac1N\sum^N_{n=1}z^2_{1n}</script><p>我们将$z_{1n}$表示为数据($x_n\in \mathbb R^D$)在低维空间（$z_n\in \mathbb R^M$）的第一个坐标。$z_n$的第一个成分为：</p>
<script type="math/tex; mode=display">z_{1n}=b_1^\top x_n</script><p>这是$x_n$在$b_1$张成的一维子空间中的正交投影，将上面二式联立：</p>
<script type="math/tex; mode=display">V_1=\frac1N\sum^N_{n=1}(b_1^\top x_n)^2=\frac 1N \sum^N_{n=1}b_1^\top x_n x_n^\top b_1=b_1^\top\begin{pmatrix}\frac 1N\sum\limits^N_{n=1}x_nx_n^\top \end{pmatrix}b_1=b_1^\top Sb_1</script><p>其中， S为数据协方差矩阵。由上式可知，正交基（$b_i$）会对最终的方差的结果产生影响,所以这里要求这些基向量为规范正交基（$|b_1|^2=1$），这样问题就转换成一个约束问题：</p>
<script type="math/tex; mode=display">\max_{b_1}b_1^\top Sb_1,\quad s.t.\ \|b_1\|^2 = 1</script><p>利用拉格朗日方法：</p>
<script type="math/tex; mode=display">\mathfrak L(b_1,\lambda)=b_1^\top Sb_1+\lambda_1(1-b_1^\top b_1)</script><p>对上式分别求偏导：</p>
<script type="math/tex; mode=display">\frac{\partial \mathfrak L}{\partial b_1}=2b_1^\top S-2\lambda_1 b_1^\top,\quad \frac{\partial \mathfrak L}{\partial \lambda_1}=1-b_1^\top b_1</script><p>令偏微分的结果为0：</p>
<script type="math/tex; mode=display">\begin{aligned}Sb_1&=\lambda_1 b_1 \\b_1^\top b_1 &= 1\end{aligned}</script><p>由上式可以知道，$\lambda_1$是方差S的一个特征值，$b_1$是一个特征向量，利用这个式子，我们可以将问题转化成：</p>
<script type="math/tex; mode=display">V_1=b_1^\top Sb_1 = \lambda_1b_1^\top b_1 = \lambda_1</script><p>所以我们需要找到一个特征值最大的特征向量,这样源数据在投影之后的方差最大，这个特征向量称为<strong>主成分</strong>（Principal Component）我们可以得到投影数据点：</p>
<script type="math/tex; mode=display">\tilde x_n=b_1 z_{1n}=b_1b_1^\top x_n\in \mathbb R^D</script><p>注意这里的投影点上的数据是高纬度空间中的数据，但是实际上存储的时候只需要用低纬度的空间信息就可以表示了。</p>
<h2 id="M维子空间下的最大方差（M-dimensional-Subspace-with-Maximal-Variance）"><a href="#M维子空间下的最大方差（M-dimensional-Subspace-with-Maximal-Variance）" class="headerlink" title="M维子空间下的最大方差（M-dimensional Subspace with Maximal Variance）"></a>M维子空间下的最大方差（M-dimensional Subspace with Maximal Variance）</h2><p>$m-1$个主成分对应的是$S$的$m-1$个特征向量，这些特征向量对应着最大的$m-1$个特征值。由于$S = \frac1N \sum\limits_{n=1}^Nx_nx_n^\top$,所以S是一个对称矩阵，所以由谱定理可以得知，这些特征向量能够形成$\mathbb R^D$空间下的$m-1$维子空间的正交规范特征基。想要找到这些正交基，可以使用向量减法：</p>
<script type="math/tex; mode=display">\tilde X := X=\sum^{m-1}_{i=1}b_ib_i^\top X=X-B_{m-1}X</script><p>其中，数据点的列向量$X=[x<em>1,\cdots,x_N]\in \mathbb R^{D\times N}$(这里使用列向量是为了计算方便),投影矩阵$B</em>{m-1}:=\sum\limits^{m-1}_{i=1}b_ib_i^\top$<br>所以想要找到第m个主成分，我们需要最大化方差;</p>
<script type="math/tex; mode=display">V_m=\mathbb V[z_m]=\frac1N \sum^N_{n=1}(b^\top_m \hat x_n)^2=b^\top_m \hat Sb_m,\quad s.t. \ \|b_m\|^2=1</script><p>其中，$\hat S$表示为数据集在正交变换之后（$\hat\mathcal X$）的方差.<br>假设我们已经知道了$\hat S$的特征向量，设$b_i$为S的特征向量：</p>
<script type="math/tex; mode=display">\begin{aligned}\hat Sb_i &= \frac 1N \hat X \hat X^\top b_i=\frac1N(X-B_{m-1}X)(X-B_{m-1}X)^\top b_i\\&=(S-SB_{m-1}-B_{m-1}S+B_{m-1}SB_{m-1})b_i,\end{aligned}\quad (*)</script><p>由于$b_i$都是这个子空间下的规范正交基（ONB），所以：</p>
</blockquote>
<script type="math/tex; mode=display">\boldsymbol B_{m-1}\boldsymbol b_i=\left\{
\begin{aligned}
\boldsymbol b_i, \quad i< m \\
 \boldsymbol0, \quad i\ge m
\end{aligned}
\right.\\</script><p>当$i&lt;m$时，说明$b_i$是子空间下的一个正交基，由于是规范正交基，所以与其他基向量的乘积为0，与自身相乘仍为自身。当$i\ge m$时，说明$b_i$不是子空间下的正交基，这时候，这$b_i$与其他的所有的正交基相互垂直，所以与他们的乘积也就为0.<br>由上面的关系可以得到：</p>
<script type="math/tex; mode=display">\hat S b_i=(S-B_{m-1}S)b_i=Sb_i=\lambda_ib_i\\\hat Sb_m = Sb_m=\lambda_mb_m</script><p>这可以知道正交投影之后的向量的特征向量的是一致的。<br>当$i&lt;m$时，$B_{m-1}$的关系式带入到（*）中：</p>
<script type="math/tex; mode=display">
\hat{\boldsymbol{S}} b_{i}=\left(\boldsymbol{S}-\boldsymbol{S} \boldsymbol{B}_{m-1}-\boldsymbol{B}_{m-1} \boldsymbol{S}+\boldsymbol{B}_{m-1} \boldsymbol{S} \boldsymbol{B}_{m-1}\right) \boldsymbol{b}_{i}=\mathbf{0}=0 \boldsymbol{b}_{i}</script><p>所以可以发现$b<em>1,\cdots,b</em>{m-1}$张成于$\hat S$的零空间<br>由$\hat Sb_m = Sb_m=\lambda_mb_m$和$b^\top_mb_m=1$,可以得到数据在m维上的正交投影的方差为：</p>
<script type="math/tex; mode=display">V_m=b_m^\top S b_m=\lambda_mb^\top_mb_m=\lambda_m</script><p>由上式可以看到数据方差于对应的特征值之间的关系。<br><img src="https://img-blog.csdnimg.cn/20210616085600867.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>由上表可知，在200 个特征值中，仅有少数的特征值是显著大于0的，所以方差只存在于少数的主成分之中。<br>为了评估PCA造成的信息损失，我们有以下标准：<br>M个主成分所能包含的最大方差：</p>
<script type="math/tex; mode=display">V_m=\sum^M_{m=1}\lambda_m</script><p>其中的$\lambda_m$是前M个最大的特征值<br>因数据压缩导致的方差损失：</p>
<script type="math/tex; mode=display">J_m:=\sum^D_{j=M+1}\lambda_i=V_D-V_m</script><p>或者使用相对方差捕获率（the relative variance captured）$\frac{V_M}{V_D}$，或者是压缩方差损失$1-\frac{V_M}{V_D}$</p>
<h1 id="投影的角度看待PCA-Projection-Perspective"><a href="#投影的角度看待PCA-Projection-Perspective" class="headerlink" title="投影的角度看待PCA(Projection Perspective)"></a>投影的角度看待PCA(Projection Perspective)</h1><p>我们可以将PCA理解为找到一个子空间，源数据在上面的正交投影与源数据最为相似，也就是正交投影的数据与源数据的欧几里得距离最小。<br><img src="https://img-blog.csdnimg.cn/20210616213629430.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="问题设置和问题目标（Setting-and-Objective）"><a href="#问题设置和问题目标（Setting-and-Objective）" class="headerlink" title="问题设置和问题目标（Setting and Objective）"></a>问题设置和问题目标（Setting and Objective）</h2><p>假设一个规范正交基$B=(b_1,\cdots,b_D)\in \mathbb R^D$,所以在这个空间中的所有的向量都可以看成是这些正交基的线性组合：</p>
<script type="math/tex; mode=display">x=\sum_{d=1}^D\zeta_db_d=\sum^M_{m=1}\zeta_mb_m+\sum^D_{j=M+1}\zeta_jb_j,\quad \zeta \in \mathbb R</script><p>在一个低维的子空间中($U\subseteq \mathbb R^D, \operatorname{dim}(U)=M$):</p>
<script type="math/tex; mode=display">\tilde x = \sum^M_{m=1}z_mb_m\in U\in\mathbb R^D</script><p>我们的目标就是最小化两种向量之间的欧几里得距离$|x-\tilde x|$,这个最小化的向量所在的空间被称为<strong>主子空间</strong>（Principal Subspace）,标记为：</p>
<script type="math/tex; mode=display">\tilde x_n:=\sum^M_{m=1}z_{mn}b_m=Bz_n\in \mathbb R^D,\quad z_n := [z_{1n},\cdots,z_{Mn}]^\top\in \mathbb R^M</script><p>$z_n$为投影矩阵的坐标。<br>描述PCA之后的损失的量度为<strong>重构误差</strong>（Reconstruction Error）:</p>
<script type="math/tex; mode=display">J_m:=\frac 1N \sum^N_{n=1}\| x_n-\tilde x_n\|^2</script><h2 id="找到最优化坐标（Finding-Optimal-Coordinates）"><a href="#找到最优化坐标（Finding-Optimal-Coordinates）" class="headerlink" title="找到最优化坐标（Finding Optimal Coordinates）"></a>找到最优化坐标（Finding Optimal Coordinates）</h2><p>想要找到最优化的坐标，需要找到原向量在基向量空间中的正交映射.如下图所示，我的目标也可以理解为找到最小的$\tilde x-x$,由图中可以知道最小的时候是向量正交投影到基向量上的时候。<br><img src="https://img-blog.csdnimg.cn/20210624160905266.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>接下来我们从数学的角度理解这个结论。<br>对于一个规范正交基$b=(b<em>1,\cdots,b_M),U \subseteq \mathbb R^D$,假设最优的坐标为$z</em>{1n},\cdots,z_{Mn}$,对应投影$\tilde x_n,n=1,\cdots,N$。为了找到各个维度（坐标）下的最佳的坐标，我们需要将目标函数对坐标进行求导</p>
<script type="math/tex; mode=display">\begin{aligned}&\frac {\partial J_M}{\partial z_{in}}=\frac{\partial J_M}{\partial\tilde x_n}\frac{\partial \tilde x_n}{\partial z_{in}} \\ &\frac{\partial J_M}{\partial \tilde x_n}-\frac{2}{N}(x_n-\tilde x_n)^\top\in \mathbb R^{1\times D}\end {aligned}</script><p>因为：</p>
<script type="math/tex; mode=display">\tilde x_n:=\sum^M_{m=1}z_{mn}b_m=Bz_n\in \mathbb R^D</script><p>所以有：</p>
<script type="math/tex; mode=display">\frac {\partial J_M}{\partial z_{in}}=-\frac 2N(x_n-\tilde x_n)^\top b_i=-\frac 2N (x_n-\sum_{m=1}^Mz_{mn}b_m)^\top b_i\overset{b_ib_j=0}{=}-\frac{2}{N}(x_n^\top b_i-z_{in}b^\top_ib_i)=-\frac2N(x_n^\top b_i-z_{in})</script><p>将上面的偏微分设为0，可以得到最优情况下的坐标：</p>
<script type="math/tex; mode=display">z_{in}=x_n^\top b_i=b_i^\top x_n,\quad i=1\cdots M,n=1,\cdots ,N</script><p>这就说明最优坐标就是将原始数据做正交投影到目标向量空间中的坐标。</p>
<p><img src="https://img-blog.csdnimg.cn/2021062417503110.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>现在我们稍微复习一下向基向量的正交投影：<br>一个向量向正交基$(b_1,\cdots,b_D)\in \mathbb R^D$进行正交投影</p>
<script type="math/tex; mode=display">\tilde x=b_j(\underbrace{ b_j^\top b_j}_{ONB,=I})^{-1}b_j^\top x=b_j b_j^\top x \in \mathbb R^D</script><p>其中，$b_j^\top x$是正交投影之后的坐标</p>
</blockquote>
<p>在新的坐标系下，虽然$\tilde x\in \mathbb R^D$，但是我们只需要用前M个坐标，因为在这个坐标系下剩下的坐标都是0.</p>
<h2 id="找到主子空间的基向量（Finding-the-Basis-of-the-Principal-Subspace）"><a href="#找到主子空间的基向量（Finding-the-Basis-of-the-Principal-Subspace）" class="headerlink" title="找到主子空间的基向量（Finding the Basis of the Principal Subspace）"></a>找到主子空间的基向量（Finding the Basis of the Principal Subspace）</h2><p>为了找到主子空间的基向量，我们需要对原先的代价函数的形式进行一些改造。：</p>
<script type="math/tex; mode=display">\tilde x _n = \sum_{m=1}^Mz_{mn}b_m=\sum _{m=1}^M(x_n^\top b_m)b_m</script><p>根据点积的对称性：</p>
<script type="math/tex; mode=display">\tilde x _n=(\sum^M_{m=1}b_mb_m^\top)x_n</script><blockquote>
<p>补充（原因）</p>
</blockquote>
<p>原先提到原始数据可以用基向量线性组合表示，所以(这里可以理解为将原向量分解为投影向量和位移向量)</p>
<script type="math/tex; mode=display">
\begin{aligned}
\boldsymbol{x}_{n} &=\sum_{d=1}^{D} z_{d n} \boldsymbol{b}_{d} \stackrel{(10.32)}{=} \sum_{d=1}^{D}\left(\boldsymbol{x}_{n}^{\top} \boldsymbol{b}_{d}\right) \boldsymbol{b}_{d}=\left(\sum_{d=1}^{D} b_{d} \boldsymbol{b}_{d}^{\top}\right) \boldsymbol{x}_{n} \\
&=\left(\sum_{m=1}^{M} \boldsymbol{b}_{m} \boldsymbol{b}_{m}^{\top}\right) \boldsymbol{x}_{n}+\left(\sum_{j=M+1}^{D} \boldsymbol{b}_{j} \boldsymbol{b}_{j}^{\top}\right) \boldsymbol{x}_{n}
\end{aligned}</script><p>所以位移向量（displacement vector）为：</p>
<script type="math/tex; mode=display">\begin{aligned} x_n-\tilde x_n&=(\sum_{j=M+1}^Db_jb_j^\top)x_n\\&=\sum^D_{j=M+1}(x_n^\top b_j)b_j\end{aligned}</script><p>其中，$\sum_{j=M+1}^Db_jb_j^\top$为投影矩阵。<br><img src="https://img-blog.csdnimg.cn/20210625194024145.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>这里可以看出，位移矩阵是在垂直于主子空间的空间中。</p>
<blockquote>
<p><strong>低秩近似</strong>（(Low-Rank Approximation）：<br>由之前的讨论得知，投影矩阵为:</p>
<script type="math/tex; mode=display">\sum_{m=1}^Mb_mb^\top_m=BB^\top</script><p>由此，原先的平均平方重构误差可以写为：</p>
<script type="math/tex; mode=display">\frac 1N\sum^N_{n=1}\|x_n-\tilde x\|^2=\frac 1N \sum_{n=1}^N\|x_n-BB^\top x_n\|^2=\frac 1N \sum^N_{n=1}\|(I-BB^\top)x_n\|^2</script><p>所以可以将PCA理解为找到与单位矩阵最接近的$BB^\top$的$M$秩逼近。</p>
</blockquote>
<p>现在我们能够重构损失函数：</p>
<script type="math/tex; mode=display">J_M=\frac 1N\sum^N_{n=1}\|x_n-\tilde x_n\|^2=\frac 1N \sum^N_{n=1}\Vert\sum_{j=M+1}^D(b_j^\top x_n)b_j\|^2</script><p>我们将平方范数展开，并结合$b_j$是来源于规范正交基，可以得到下式：</p>
<script type="math/tex; mode=display">J_M=\frac 1N \sum^N_{n=1}\sum^D_{j=M+1}(b_j^\top x_n)^2=\frac {1}{N}\sum^N_{n=1}\sum_{j=M+1}^D b_j^\top x_nb^\top_j x_n=\frac 1N \sum^N_{n=1}\sum^D_{j=M+1}b_j^\top x_n x_n^\top b_j</script><blockquote>
<p>补充推导过程</p>
</blockquote>
<p>由于点乘的对称性，我们可以知道$b^\top_jx_n=x^\top_nb_j$,带入上式：</p>
<script type="math/tex; mode=display">
\begin{aligned}
J_{M} &=\sum_{j=M+1}^{D} \boldsymbol{b}_{j}^{\top} \underbrace{\left(\frac{1}{N} \sum_{n=1}^{N} \boldsymbol{x}_{n} \boldsymbol{x}_{n}^{\top}\right)}_{=: \boldsymbol{S}} \boldsymbol{b}_{j}=\sum_{j=M+1}^{D} \boldsymbol{b}_{j}^{\top} \boldsymbol{S} \boldsymbol{b}_{j} \\
&=\sum_{j=M+1}^{D} \operatorname{tr}\left(\boldsymbol{b}_{j}^{\top} \boldsymbol{S} \boldsymbol{b}_{j}\right)=\sum_{j=M+1}^{D} \operatorname{tr}\left(\boldsymbol{S} \boldsymbol{b}_{j} \boldsymbol{b}_{j}^{\top}\right)=\operatorname{tr}(\underbrace{\left(\sum_{j=M+1}^{D} \boldsymbol{b}_{j} \boldsymbol{b}_{j}^{\top}\right)}_{\text {projection matrix }} \boldsymbol{S})
\end{aligned}</script><p>由上可知，损失函数可以被理解为源数据在主子空间的正交补上的方差。这也对应这主成分分析是在最小化我们忽略的维度上的误差。等价的来说也就是我们需要保留方差最大的那几个维度。所以当我们投影到M维主子空间的时候，所对应的重构误差为：</p>
<script type="math/tex; mode=display">J_M=\sum^D_{j=M+1}\lambda_j</script><blockquote>
<p>为什么是这个？</p>
</blockquote>
<p>其中的$\lambda$数据协方差的奇异值。所以想要最小化这个重构误差，就需要选择$D-M$个最小的特征值，这些特征值对应的是主子空间的正交基的特征向量。这也就是说，主子空间所对应的特征向量的特征值是协方差矩阵中的最大的M个特征值。</p>
<blockquote>
<p>这一节有很多问题，待补充。。。</p>
</blockquote>
<h1 id="特征向量计算以及低秩逼近（Eigenvector-Computation-and-Low-Rank-Approximations）"><a href="#特征向量计算以及低秩逼近（Eigenvector-Computation-and-Low-Rank-Approximations）" class="headerlink" title="特征向量计算以及低秩逼近（Eigenvector Computation and Low-Rank Approximations）"></a>特征向量计算以及低秩逼近（Eigenvector Computation and Low-Rank Approximations）</h1><p>为了计算方差矩阵的特征值，我们可以采用特征值分解或者是奇异值分解，前者可以直接计算出矩阵的特征值和特征向量。而使用SVD的可行性，是因为方差矩阵是对称并且能够分解为$XX^\top$所以，方差矩阵的特征值就是$X$的奇异值的平方。</p>
<script type="math/tex; mode=display">S=\frac 1N \sum^N_{n=1}x_nx_n^\top  = \frac 1N XX^\top,\quad X=[x_1,\cdots , x_N]\in \mathbb R^{D\times N}</script><p>矩阵$X$对应的SVD为：</p>
<script type="math/tex; mode=display">\underbrace X_{D\times N}=\underbrace U_{D\times D}\underbrace\Sigma_{D\times N}\underbrace {V^\top}_{N\times N}</script><p>其中U和V都是正交矩阵，$\Sigma$为对角矩阵，主对角线上的元素为奇异值$\sigma_{ii}\ge 0$.将这个式子带入到方差矩阵中：</p>
<script type="math/tex; mode=display">S=\frac 1N XX^\top=\frac 1NU\Sigma\underbrace{V^\top V}_{=I_N}\Sigma^\top U^\top=\frac 1N U\Sigma\Sigma^\top U^\top</script><blockquote>
<p>SVD分解之后的两端的矩阵是酉矩阵（$V^\top=V^{-1}$）：<br>Specifically, the singular value decomposition of an m\times n complex matrix M is a factorization of the form $\mathbf {U\Sigma V^{*}}$, where U is an $m\times m$ complex unitary matrix, $\mathbf{\Sigma}$ is an $m\times n$ rectangular diagonal matrix with non-negative real numbers on the diagonal, and V is an $n\times n$ complex <u>unitary matrix</u>(酉矩阵).</p>
</blockquote>
<p>所以U的列向量是$XX^\top$的特征向量，也是方差矩阵的特征向量。其中特征值与奇异值的关系为：</p>
<script type="math/tex; mode=display">\lambda_d=\frac{\sigma^2_d}{N}</script><p>S的特征值和X的奇异值的关系对应的是原先的最大方差视角和奇异值分解之间的关系。</p>
<blockquote>
<p>如何理解？</p>
</blockquote>
<h2 id="用低秩逼近的PCA-PCA-Using-Low-Rank-Matrix-Approximations"><a href="#用低秩逼近的PCA-PCA-Using-Low-Rank-Matrix-Approximations" class="headerlink" title="用低秩逼近的PCA(PCA Using Low-Rank Matrix Approximations)"></a>用低秩逼近的PCA(PCA Using Low-Rank Matrix Approximations)</h2><p>PCA需要找出前N个最大特征值所对应的特征向量，实现这个目标可以采用低秩逼近的方式。</p>
<blockquote>
<p>Eckart-Young theorem:就是评估低秩逼近之后造成的损失<br><img src="https://img-blog.csdnimg.cn/20210626104053635.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</blockquote>
<p>由Eckart-Young theorem：</p>
<script type="math/tex; mode=display">\tilde X_M:=\operatorname{argmin}_{\operatorname{rk(A)\le M}}\|X-A\|_2\in \mathbb R^{D\times N}</script><p>所以，对应的低秩逼近就是找出前M大的奇异值：</p>
<script type="math/tex; mode=display">\tilde X_M=\underbrace {U_M}_{D\times M}\underbrace{\Sigma_M}_{M\times M}\underbrace{V_M^\top}_{M\times N}\in \mathbb R^{D\times N}</script><p>其中，$\Sigma$包含X的前M个最大的奇异值。</p>
<h2 id="实际方面（Practical-Aspects）"><a href="#实际方面（Practical-Aspects）" class="headerlink" title="实际方面（Practical Aspects）"></a>实际方面（Practical Aspects）</h2><p>我们可以直接采用特征多项式求解出特征值和特征多项式，但是由Abel-Ruffini theorem，五阶或者五阶以上的多项式方程没有几何解。所以在解决大于$4\times 4$的矩阵的时候会遇到这个问题。<br>由于在主成分分析中，我们会只需要前M大的特征向量和特征多项式，所以计算出所有的特征向量和特征值然后再舍弃一些特征值是很没有必要的。在一些极端的情况下，我们只需要第一个特征向量，这时候使用<strong>幂迭代</strong>（Power iteration）效率会非常高。</p>
<blockquote>
<p><strong>幂迭代</strong><br>首先先随机选取一个不在S的零空间的向量$x_0$,然后按照下式进行迭代：</p>
<script type="math/tex; mode=display">x_{k+1}=\frac{Sx_k}{\|Sx_k\|},\quad k=0,1,\cdots</script><p>这个式子总是有$|x_k|=1$,最终这个式子会收敛于最大的特征值所对应的特征向量。当S为不可逆的时候，应该保证$x_0 \ne 0$<br><br>In mathematics, power iteration (also known as the power method) is an eigenvalue algorithm: given a diagonalizable matrix A, the algorithm will produce a number \lambda , which is the greatest (in absolute value) eigenvalue of A, and a nonzero vector v, which is a corresponding eigenvector of $\lambda$ , that is, $Av=\lambda v$. The algorithm is also known as the Von Mises iteration.<br><br><br>Power iteration is a very simple algorithm, but it may converge slowly. The most time-consuming operation of the algorithm is the multiplication of matrix A by a vector, so it is effective for a very large sparse matrix with appropriate implementation.</p>
</blockquote>
<h1 id="高维PCA（PCA-in-High-Dimensions）"><a href="#高维PCA（PCA-in-High-Dimensions）" class="headerlink" title="高维PCA（PCA in High Dimensions）"></a>高维PCA（PCA in High Dimensions）</h1><p>想要对数据使用PCA，需要求解出数据的协方差矩阵，对于一个D维的数据，如果使用特征多项式（$|\lambda E-A|=0$）的时间复杂度为$O(D^3)$.所以需要找到一种更加高效的方法解决这个问题。<br>下面我们讨论数据的个数远小于数据维度的情况，即$N\ll D$<br>假设一组中心化（均值为0）的数据集$x_1,\cdots,x_N,\ \ x_n\in\mathbb R^{D\times D}$，对应的协方差矩阵为：</p>
<script type="math/tex; mode=display">S=\frac 1N XX^\top\in\mathbb R^{D\times D},\quad X=[x_1,\cdots,x_N]\in\mathbb R^{D\times N}</script><p>由于我们假设$N\ll D$所以数据点的数量远小于数据的维度，也就是说数据的秩为N，则有$D-N+1$个特征值为0，接下来我们探究将D维协方差矩阵转换成N维，且对应的特征值都是正数。所以有特征向量的等式：</p>
<script type="math/tex; mode=display">Sb_m=\lambda_m b_m,\quad m=1,\cdots M</script><p>其中b是主子空间的基向量，现在将S的定义带入：</p>
<script type="math/tex; mode=display">Sb_m =\frac 1N XX^\top b_m=\lambda_m b_m</script><p>现在等式两边同时乘以$X^\top\in \mathbb R^{N\times D}$</p>
<script type="math/tex; mode=display">\frac 1N \underbrace {X^\top X}_{N\times N}\underbrace{X^\top b_m}_{=:c_m}=\lambda_m X^\top b_m\Leftrightarrow\frac 1N X^\top Xc_m=\lambda_mc_m</script><p>所以可以发现协方差矩阵的特征值为$\lambda_m$对应的特征向量为$c_m$</p>
<blockquote>
<p>印证原先提到的：$XX^\top$的非零特征值等于$X^\top X$的非零特征值</p>
</blockquote>
<p>现在我们得到了映射之后的特征值和特征向量，现在我们需要找到源数据的特征值和特征向量。现在对上式两边同时左乘$X$：</p>
<script type="math/tex; mode=display">\underbrace{\frac 1NXX^\top}_SXc_m=\lambda_mXc_m</script><p>这样我们得到了源数据(X是酉矩阵？)，这仍旧是S的特征向量。</p>
<h1 id="PCA在实践中的关键步骤-Key-Steps-of-PCA-in-Practice"><a href="#PCA在实践中的关键步骤-Key-Steps-of-PCA-in-Practice" class="headerlink" title="PCA在实践中的关键步骤(Key Steps of PCA in Practice)"></a>PCA在实践中的关键步骤(Key Steps of PCA in Practice)</h1><ol>
<li><strong>减去数据均值</strong>（Key Steps of PCA in Practice）</li>
<li>这一步将所有数据减去数据的均值，使得处理后的数据的均值为0，这一步不是必须的，但是减小遇到数值问题的风险。</li>
<li><strong>规范化</strong>（Standardization）：</li>
<li>将数据除以数据的标准偏差$\sigma_d$</li>
<li><strong>协方差矩阵的特征值分解</strong>（Eigendecomposition of the covariance matrix）</li>
<li>由于协方差是对称的，根据谱定理，我们能够找到特征向量的规范正交基</li>
<li><strong>投影</strong>（Projection）</li>
<li>将数据点$x_*\in \mathbb R^D$投影到主子空间中：</li>
<li><script type="math/tex; mode=display">x^{(d)}\leftarrow\frac{x_*^{(d)}-\mu_d}{\sigma_d}\quad d = 1,\cdots,D</script>10.其中，$x^{(d)}<em>*$代表的是$x</em>*$的第d个成分，所以对应的投影为：<script type="math/tex; mode=display">\tilde x_*=BB^\top x_*</script>对应的坐标为：<script type="math/tex; mode=display">z_*=B^\top x_*</script>其中B由数据协方差矩阵最大的几个特征值所对应的特征向量组成。注意PCA返回的是坐标，而不是投影向量。<br>要得到原始数据的投影，我们需要将投影之后的数据进行“反规范化”：<script type="math/tex; mode=display">\tilde x^{(d)}_*\leftarrow \tilde x^{(d)}_*\sigma_d+\mu_d,\quad d= 1,\cdots, D</script><img src="https://img-blog.csdnimg.cn/20210629075518708.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><blockquote>
<p><strong>MNIST数字：重构</strong>（MNIST Digits: Reconstruction）<br>由下图可知，当主成分为一的时候，图像就是一个可以识别的数字了，随着主成分的增加，图像变得清晰了些<br><img src="https://img-blog.csdnimg.cn/20210629075830290.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>下图中展示了图像信息损失和主成分数量之间的关系：</p>
<script type="math/tex; mode=display">\frac 1N \sum^N_{n=1}\|x_n-\tilde x_n\|^2=\sum^D_{i=M+1}\lambda_i</script><p><img src="https://img-blog.csdnimg.cn/20210629080209101.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这也印证之前提到的，大多数的信息只存在于少量的主成分之中。</p>
</blockquote>
</li>
</ol>
<h1 id="用潜变量看待PCA-Latent-Variable-Perspective"><a href="#用潜变量看待PCA-Latent-Variable-Perspective" class="headerlink" title="用潜变量看待PCA(Latent Variable Perspective)"></a>用潜变量看待PCA(Latent Variable Perspective)</h1><p>原先讨论PCA的时候没有使用概率方面的理论，这样能够帮助我们避开一些由概率论引起的数学上的困难，但是用概率论的能够帮助我们更好地理解PCA，而且在处理带有噪音的数据的时候，概率论中的似然函数提供了分析方式。</p>
<blockquote>
<p>Observational Noise. The error between the true value in a system and its observed value due to imprecision in measurement. Also called Measurement Noise.<br><strong>观测噪音</strong>（Observation Noise）实际上就是我们所说的测量误差，由仪器等因素导致的于真实值的偏差。</p>
</blockquote>
<p>通过介绍连续的潜变量$z\in \mathbb R^M$, 我们能够将PCA用<strong>概率潜变量模型</strong>(probabilistic latent-variable model)来描述，这被称为<strong>概率主成分分析</strong>（probabilistic PCA ， PPCA）</p>
<h2 id="生成过程及概率模型（Generative-Process-and-Probabilistic-Model）"><a href="#生成过程及概率模型（Generative-Process-and-Probabilistic-Model）" class="headerlink" title="生成过程及概率模型（Generative Process and Probabilistic Model）"></a>生成过程及概率模型（Generative Process and Probabilistic Model）</h2><p>我们考虑一个线性降维，对于一个连续随机变量$z\in \mathbb R^M$以及一个标准正态先验$p(z)=\mathcal N(0, I)$, 潜变量以及观测值之间的关系为：</p>
<script type="math/tex; mode=display">x=Bz+\mu+\epsilon\in \mathbb R^D</script><p>其中$\epsilon \sim \mathcal N(0,\sigma^2I)$为高斯观测噪音，而$B\in \mathbb R^{D\times M},\quad \mu \in \mathbb R^D$是潜变量到观测变量的线性/仿射映射。所以，潜变量于观测值之间的联系方式为：</p>
<script type="math/tex; mode=display">p(x|z,B,\mu,\sigma^2)=\mathcal N(x|Bz+\mu, \sigma^2I)</script><p>整体来说，PPCA的生成过程为：</p>
<script type="math/tex; mode=display">\begin{aligned} z&\sim \mathcal N(z|0,I)\\ x_n|z_n&\sim\mathcal N(x|Bz_n+\mu,\sigma^2I)\end{aligned}</script><p>想要得到获得这些参数，需要一些典型数据，想要得到这样的数据可以使用<strong>祖先抽样</strong>（Ancestral sampling）</p>
<blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210701100758830.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Ancestral sampling 实际上就是通过采样解决条件概率问题。</p>
</blockquote>
<p>在这里，先采样得到潜变量$z$,然后再从潜变量中采样得到预测数据。于是，上面的生辰过程可以写成:</p>
<script type="math/tex; mode=display">p(x,z|B,\mu,\sigma^2)=p(x|z,B,\mu,\sigma^2)p(x)</script><p>对应的图模型：</p>
<p><div align="center"><br><img src="https://img-blog.csdnimg.cn/20210701101258115.png"></div></p>
<blockquote>
<p>Graphical model for probabilistic PCA. The observations $x_n$ explicitly depend on corresponding latent variables $z_n \sim \mathcal N(0,I)$ The model parameters $B;\mu$ and the likelihood parameter $\sigma$ are shared across the dataset.<br><img src="https://img-blog.csdnimg.cn/20210701101627104.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>可以将潜变量用于生成新的数据（<u>补充理解</u>）<br><img src="https://img-blog.csdnimg.cn/20210701101827655.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="似然以及联合分布（Likelihood-and-Joint-Distribution）"><a href="#似然以及联合分布（Likelihood-and-Joint-Distribution）" class="headerlink" title="似然以及联合分布（Likelihood and Joint Distribution）"></a>似然以及联合分布（Likelihood and Joint Distribution）</h2><p>由原先的概率论部分，我们知道可以采用积分将潜变量消掉：</p>
<script type="math/tex; mode=display">p(x|B,\mu,\sigma^2)=\int p(x|z,B,\mu,\sigma^2)p(z)dz=\int \mathcal N(x|Bz+\mu,\sigma^2I)\mathcal N(z|0,I)dz</script><p>还是由原先的知识，我们可以知道这个积分的结果是高斯分布，其均值及方差为：</p>
<script type="math/tex; mode=display">\begin{aligned}\mathbb E_x[x]&=\mathbb E_z[Bz+\mu]+\mathbb E_\epsilon[\epsilon]=\mu \\ \mathbb V[x]&=\mathbb V_z[Bz+\mu]+\mathbb V_\epsilon[\epsilon]=\mathbb V_z[Bz]+\sigma^2I\\&=B\mathbb V_z[z]B^\top+\sigma^2I=BB^\top+\sigma^2I\end{aligned}</script><p>先前我们不适用条件概率分布的原因是极大似然估计以及极大似然后验估计需要的似然函数可以是数据以及模型参数的函数，但是不能是潜变量的函数，这里是用积分消去潜变量之后才用的。<br><br><strong>潜变量以及模型参数的关系</strong>（需要补充）</p>
</blockquote>
<p>因为潜变量$z$的线性/仿射变换$x=Bz$是联合高斯分布，现在已知一些边际概率分布:$p(z)=\mathcal N(z|0,I);p(x)=\mathcal N(x|\mu,BB^\top +\sigma^2I)$.所以对应<strong>交叉协方差</strong>（cross-covariance）为：</p>
<script type="math/tex; mode=display">\operatorname{Cov}[x,z]=\operatorname{Cov}_z[Bz+\mu]=B\operatorname{Cov}_z[z,z]=B</script><p>所以潜变量以及观测到的随机变量之间的联合分布为：</p>
<script type="math/tex; mode=display">
p\left(\boldsymbol{x}, \boldsymbol{z} \mid \boldsymbol{B}, \boldsymbol{\mu}, \sigma^{2}\right)=\mathcal{N}\left(\left[\begin{array}{l}
\boldsymbol{x} \\
\boldsymbol{z}
\end{array}\right] \mid\left[\begin{array}{l}
\boldsymbol{\mu} \\
\mathbf{0}
\end{array}\right],\left[\begin{array}{cc}
\boldsymbol{B} \boldsymbol{B}^{\top}+\sigma^{2} \boldsymbol{I} & \boldsymbol{B} \\
\boldsymbol{B}^{\top} & \boldsymbol{I}
\end{array}\right]\right)</script><p>其中均值向量的长度为$D+M$,协方差矩阵的大小为$(D+M)\times (D+M)$</p>
<h2 id="后验分布（Posterior-Distibution）"><a href="#后验分布（Posterior-Distibution）" class="headerlink" title="后验分布（Posterior Distibution）"></a>后验分布（Posterior Distibution）</h2><p>由前面提到的联合概率分布$p(x,z|B,\mu,\sigma^2)$可以求得后验分布$p(z|x)$(参数求解方式在概率论那一章有提及)</p>
<script type="math/tex; mode=display">
\begin{aligned}
p(\boldsymbol{z} \mid \boldsymbol{x}) &=\mathcal{N}(\boldsymbol{z} \mid \boldsymbol{m}, \boldsymbol{C}) \\
\boldsymbol{m} &=\boldsymbol{B}^{\top}\left(\boldsymbol{B} \boldsymbol{B}^{\top}+\sigma^{2} \boldsymbol{I}\right)^{-1}(\boldsymbol{x}-\boldsymbol{\mu}) \\
\boldsymbol{C} &=\boldsymbol{I}-\boldsymbol{B}^{\top}\left(\boldsymbol{B} \boldsymbol{B}^{\top}+\sigma^{2} \boldsymbol{I}\right)^{-1} \boldsymbol{B}
\end{aligned}</script><p>注意后验协方差与数据无关，协方差矩阵C告诉我们<u>（？）嵌入的可信度（？p343）</u><br>我们可以利用这个后验分布得到数据对应的潜变量，然后再利用潜变量得到重构向量$\tilde x<em>*\sim p(x|z</em>*,B,\mu,\sigma^2)$.将这个过程重复多次，我们能够得到潜变量的后验分布以及其暗含的观测数据</p>
<h1 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h1><p>现在我们想想之前做了什么。我们使用两个角度看待PCA，一个是投影的角度（最小化重构误差），一个是最大化方差的角度，除此之外还有其他的角度。我们先将高维数据$x\in \mathbb R^D$用矩阵$B^\top$转换成用低维表示的数据$z\in \mathbb R^M$,其中B由协方差矩阵的最大的特征值所对应的特征向量组成。得到低阶矩阵之后，我们可以利用投影矩阵$BB^\top$将数据复原到源数据的维度:$x\approx\tilde x=Bz=BB^\top x\in\mathbb R^D$.<br>当然我们还将PCA看成一个<strong>线性自动编码机</strong>(Linear Auto-encoder)<br><img src="https://img-blog.csdnimg.cn/20210702083437356.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>由此可以得到重构误差：</p>
<script type="math/tex; mode=display">\frac 1N \sum^N_{n=1}\|x_n-\tilde x_n\|^2=\frac 1N\sum^N_{n=1}\|x_n-BB^\top x_n\|</script><p>如果我们将线性映射转换成非线性映射，我们就会得到非线性自动编码机。当编码器是神经网络的时候，这个被称为<strong>认知网络或推理网络</strong>（recognition network or inference network），编码器称为<strong>生成器</strong>(Generator)。<br>还有一种对PCA的理解涉及到<strong>信息论</strong>（information theory），就是将编码当成原始数据的压缩版本。当我们将压缩的信息还原，这并不能得到与原始一摸一样的数据，我们称这个压缩过程为有损失的。所以我们的目标就是尽可能将原始数据与压缩数据之间的相关性最大化。这种关系称为<strong>交互信息</strong>（the mutual information）。<br>在讨论PPCA的时候，我们默认模型的参数（$B,\mu$,似然参数$\sigma^2$）都是已知的，这些参数为：（我们将$D$维数据投影到$M$维子空间中）</p>
<script type="math/tex; mode=display">\begin{aligned}\mu_{Ml} &=\frac 1N \sum^N_{n=1}x_n\\ B_{ML}&=T(\Lambda-\sigma^2I)^{\frac 12}R\\ \sigma^2_{ML}&=\frac{1}{D-M}\sum^D_{j=M+1}\lambda_j\end{aligned}</script><p>其中，$T\in \mathbb R^{D\times M}$包含协方差矩阵的M个特征向量，$\Lambda=\operatorname{diag}(\lambda<em>1,\cdots,\lambda_M)\in \mathbb R^{M\times M}$是一个对角矩阵，包含主子空间所对应的特征向量所对应的特征值。$R\in \mathbb R^{M\times M}$是一个随意的正交矩阵。$B</em>{ML}$是极大似然的解。$\sigma_{ML}^2$是主子空间的正交补上的平均方差，可以认为是正交映射之后造成的损失。<br>当处理一个无噪音的数据的时候，也就是$\sigma \rightarrow 0$,这时候PPCA与PCA得到的结构是一致的。由于协方差矩阵是对称的，所以可以被正交化，所以存在一个矩阵T包含S的特征向量：</p>
<script type="math/tex; mode=display">S=T\Lambda T^{-1}</script><p>数据的协方差矩阵就是高斯似然函数（$p(x|B,\mu,\sigma^2)$）的协方差矩阵,也就是$BB^\top+\sigma^2I$。当$\sigma\rightarrow 0$时，两种PCA的数据方差相等，所以有：</p>
<script type="math/tex; mode=display">\operatorname{Cov}[\mathcal X]=T\Lambda T^{-1}=BB^\top\Leftrightarrow B=T\Lambda^{\frac 12}R</script><p>所以实际上，这些PCA都是在对数据的协方差矩阵进行分解。</p>
<blockquote>
<p>接触下来的内容难度较大，理解不够透彻，后续补充</p>
</blockquote>
<ol>
<li>iterative expectation maximization (EM) algorithm</li>
<li>Bayesian PCA</li>
<li>Markov chain Monte Carlo /variational inference.</li>
<li>independent component analysis </li>
<li>blind-source separation</li>
<li>deep auto-encoder</li>
<li>Gaussian process latent-variable model (GP-LVM)</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/15/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6%EF%BC%9A%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92Linear-Regression/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/15/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6%EF%BC%9A%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92Linear-Regression/" class="post-title-link" itemprop="url">机器学习中的数学：线性回归Linear Regression</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-06-15 09:12:40" itemprop="dateCreated datePublished" datetime="2021-06-15T09:12:40+08:00">2021-06-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-09 18:48:22" itemprop="dateModified" datetime="2023-03-09T18:48:22+08:00">2023-03-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>@[toc]<br>回归的目的就是找到一个函数$f$,将输入的数据$\boldsymbol x\in \mathbb R^n$映射成$f(\boldsymbol x)\in \mathbb R$.数据的观测噪音为：$y_n=f(x_n)+\epsilon$,其中$\epsilon$是一个独立均匀分布的随机变量，描述数据噪音。</p>
<blockquote>
<p>噪音理解成预测值与观测值的偏差，准不准确？</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210527102646532.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="问题描述（Problem-Formulation）"><a href="#问题描述（Problem-Formulation）" class="headerlink" title="问题描述（Problem Formulation）"></a>问题描述（Problem Formulation）</h1><p>因为观测噪音的缘故，我们使用概率模型，并且用一个似然函数对噪音进行建模。具体来说，我们考虑以下回归问题的的似然函数：</p>
<script type="math/tex; mode=display">p(y|\boldsymbol x)=\mathcal N(y|f(\boldsymbol x),\sigma^2)</script><p>其中，$\boldsymbol x\in \mathbb R^n$是输入值,$y\in \mathbb R$为噪音函数值（目标）<br>$\boldsymbol x$与$y$之间的关系为：</p>
<script type="math/tex; mode=display">y= f(\boldsymbol x)+\epsilon</script><p>其中，$\epsilon \sim\mathcal N(0,\sigma^2)$是一个独立均匀的高斯分布。</p>
<blockquote>
<p>Our objective is to find a function that is close (similar) to <u>the unknown function $f$ </u>that generated the data and that generalizes well.</p>
<p>假设在线性模型的条件下：</p>
<script type="math/tex; mode=display">p(y|\boldsymbol x,\boldsymbol \theta)=\mathcal N(y|\boldsymbol x^\top\boldsymbol\theta,\sigma^2)\Leftrightarrow y=\boldsymbol x^\top\boldsymbol\theta+\epsilon,\quad \epsilon \sim \mathcal N(0,\sigma^2)</script><p>Why?<br><img src="https://img-blog.csdnimg.cn/20210527104841262.png" alt="在这里插入图片描述"></p>
</blockquote>
<p>这里说明一下线性模型的意思，线性代表的是输入数据的线性组合，所以对于$y=\phi^\top(\boldsymbol x)\boldsymbol\theta$,即使$\phi^\top(\boldsymbol x)$是非线性函数，这个模型也是线性模型。</p>
<h1 id="参数估计（Parameter-Estimation）"><a href="#参数估计（Parameter-Estimation）" class="headerlink" title="参数估计（Parameter Estimation）"></a>参数估计（Parameter Estimation）</h1><p>给定一个训练集$\mathcal D :={(x_1,y_1),\cdots,(x_N,y_N)$,包含$N$个输入$x_n\in \mathbb R^D$和观测值$y_n\in \mathbb R,n=1,\cdots, N$.<br>用概率图模型（Probabilistic graphical model）可以表示为：</p>
<p><div align="center"><br><img src="https://img-blog.csdnimg.cn/20210527154036716.png"> </div></p>
<p>又因为每一个样本又是相互独立的，所以可以将似然方程进行分解：</p>
<script type="math/tex; mode=display">p(\mathcal Y|\mathcal X,\boldsymbol\theta)=p(y_1,\cdots,y_N|\boldsymbol x_1,\cdots,\boldsymbol x_N,\boldsymbol\theta)=\prod^N_{n=1}p(y_n|\boldsymbol x_n,\boldsymbol\theta) = \prod^N_{n=1}\mathcal N(y_n|\boldsymbol x_n^\top\boldsymbol\theta,\sigma^2)</script><p>接下来详细介绍获取最优化参数的方法。</p>
<h2 id="极大似然估计（Maximum-Likelihood-Estimation）"><a href="#极大似然估计（Maximum-Likelihood-Estimation）" class="headerlink" title="极大似然估计（Maximum Likelihood Estimation）"></a>极大似然估计（Maximum Likelihood Estimation）</h2><p>我们可以通过极大似然估计得到参数：</p>
<script type="math/tex; mode=display">\boldsymbol \theta_{ML}=\arg \max_\theta p(\mathcal Y|\mathcal X,\boldsymbol\theta)</script><p>上面的似然概率不是参数$\theta$的分布，而是函数。极大似然估计的目的就是最大化训练数据的概率分布。<br>在实际过程中，我们常常采用似然对数转换（Log-Transformation）的方式，将问题转化成最小化负对数似然：</p>
<script type="math/tex; mode=display">-\log p(\mathcal Y|\mathcal X,\boldsymbol\theta)=-\log \prod_{n=1}^N p(y_n|\boldsymbol x_n,\boldsymbol\theta)=-\sum^N_{n=1}\log p(y_n|\boldsymbol x_n,\boldsymbol\theta)</script><p>这样做可以将原先的乘积转换成和，</p>
<blockquote>
<p><strong>What does this suppose means?</strong><br>More specifically, numerical underflow will be a problem when we multiply N probabilities, where N is the number of data points, since we cannot represent very small numbers, such as $10^{256}$.</p>
</blockquote>
<p>由于在线性规划中，似然概率分布满足高斯分布（噪音项$\epsilon$满足高斯分布），所以可以得到：</p>
<blockquote>
<p>?？需要补充<br>Note that:</p>
<script type="math/tex; mode=display">p(y|x,\theta)=\mathcal N(y|x^\top\theta,\sigma^2)=\frac{1}{\sqrt{2\pi \sigma^2}}e^{-\frac{(y-x^\top)^2}{2\sigma^2}}</script></blockquote>
<script type="math/tex; mode=display">\log p(y_n|\boldsymbol x_n,\boldsymbol\theta)=-\frac{1}{2\sigma^2}(y_n-\boldsymbol x_n^\top\boldsymbol\theta)^2+\operatorname {const}</script><p>于是得到损失函数：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\mathcal{L}(\boldsymbol{\theta}) &:=\frac{1}{2 \sigma^{2}} \sum_{n=1}^{N}\left(y_{n}-\boldsymbol{x}_{n}^{\top} \boldsymbol{\theta}\right)^{2} \\
&=\frac{1}{2 \sigma^{2}}(\boldsymbol{y}-\boldsymbol{X} \boldsymbol{\theta})^{\top}(\boldsymbol{y}-\boldsymbol{X} \boldsymbol{\theta})=\frac{1}{2 \sigma^{2}}\|\boldsymbol{y}-\boldsymbol{X} \boldsymbol{\theta}\|^{2}
\end{aligned}</script><p>我们将$\boldsymbol X:=[x_1,x_2,\cdots,x_N]^\top\in \mathbb R^{N\times D}$定义为<strong>设计矩阵</strong>（Design Matrix）<br>可以通过求导求解损失函数的最小值：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac{\mathrm{d} \mathcal{L}}{\mathrm{d} \boldsymbol{\theta}} &=\frac{\mathrm{d}}{\mathrm{d} \boldsymbol{\theta}}\left(\frac{1}{2 \sigma^{2}}(\boldsymbol{y}-\boldsymbol{X} \boldsymbol{\theta})^{\top}(\boldsymbol{y}-\boldsymbol{X} \boldsymbol{\theta})\right) \\
&=\frac{1}{2 \sigma^{2}} \frac{\mathrm{d}}{\mathrm{d} \boldsymbol{\theta}}\left(\boldsymbol{y}^{\top} \boldsymbol{y}-2 \boldsymbol{y}^{\top} \boldsymbol{X} \boldsymbol{\theta}+\boldsymbol{\theta}^{\top} \boldsymbol{X}^{\top} \boldsymbol{X} \boldsymbol{\theta}\right) \\
&=\frac{1}{\sigma^{2}}\left(-\boldsymbol{y}^{\top} \boldsymbol{X}+\boldsymbol{\theta}^{\top} \boldsymbol{X}^{\top} \boldsymbol{X}\right) \in \mathbb{R}^{1 \times D}
\end{aligned}</script><p>（$\frac {d\boldsymbol X^\top B\boldsymbol X}{d\boldsymbol X}=(B+B^\top)\boldsymbol X$）<br>令上式等于0：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac{\mathrm{d} \mathcal{L}}{\mathrm{d} \boldsymbol{\theta}}=\mathbf{0}^{\top} {\longrightarrow} \boldsymbol{\theta}_{\mathrm{ML}}^{\top} \boldsymbol{X}^{\top} \boldsymbol{X}=\boldsymbol{y}^{\top} \boldsymbol{X} \\
 \Longleftrightarrow \boldsymbol{\theta}_{\mathrm{ML}}^{\top}=\boldsymbol{y}^{\top} \boldsymbol{X}\left(\boldsymbol{X}^{\top} \boldsymbol{X}\right)^{-1} \\
 \Longleftrightarrow \boldsymbol{\theta}_{\mathrm{ML}}=\left(\boldsymbol{X}^{\top} \boldsymbol{X}\right)^{-1} \boldsymbol{X}^{\top} \boldsymbol{y} .
\end{aligned}</script><p><img src="https://img-blog.csdnimg.cn/2021052906543623.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>Normal equation is derived by MLE.——Ng</p>
<h3 id="基于特征的极大似然估计（Maximum-Likelihood-Estimation-with-Features）"><a href="#基于特征的极大似然估计（Maximum-Likelihood-Estimation-with-Features）" class="headerlink" title="基于特征的极大似然估计（Maximum Likelihood Estimation with Features）"></a>基于特征的极大似然估计（Maximum Likelihood Estimation with Features）</h3><p>当遇到更复杂的数据时，一次函数模型有时候很难很好地拟合数据，但是由于线性回归模型只是对”参数的线性”(“linear in the parameters”),所以可以在线性回归模型中对非线性模型进行拟合。这就是说我们可以先将输入值进行非线性变换之后，再放到线性模型中。<br>In Ng’s courses he said this is Linear regression with higher order features. We can alse use SVM to derive new features.</p>
</blockquote>
<script type="math/tex; mode=display">p(y|\boldsymbol x,\theta)=\mathcal N(y|\phi^\top(x)\boldsymbol\theta,\sigma^2)\Longleftrightarrow y=\phi^\top(x)\boldsymbol\theta+\epsilon=\sum^{K-1}_{k=0}\theta_k\phi_k(x)+\epsilon</script><p>其中，$\phi:\mathbb R^D\rightarrow\mathbb R^K$是一个对$x$的（非）线性变换，$\phi_k:\mathbb R^D\rightarrow\mathbb R$是特征向量的第k个分量。</p>
<p>一个实例：<br>一种对输入数据常用的变换如下</p>
<script type="math/tex; mode=display">
\phi(x)=\left[\begin{array}{c}
\phi_{0}(x) \\
\phi_{1}(x) \\
\vdots \\
\phi_{K-1}(x)
\end{array}\right]=\left[\begin{array}{c}
1 \\
x \\
x^{2} \\
x^{3} \\
\vdots \\
x^{K-1}
\end{array}\right] \in \mathbb{R}^{K}</script><p>所以：</p>
<script type="math/tex; mode=display">f(x)=\sum\limits^{K-1}_{k=0}\theta_kx^k=\phi^\top(x)\boldsymbol\theta</script><p>现在看看参数$\theta$在线性回归模型下的极大似然估计：</p>
<script type="math/tex; mode=display">
\Phi:=\left[\begin{array}{c}
\phi^{\top}\left(x_{1}\right) \\
\vdots \\
\phi^{\top}\left(x_{N}\right)
\end{array}\right]=\left[\begin{array}{ccc}
\phi_{0}\left(x_{1}\right) & \cdots & \phi_{K-1}\left(x_{1}\right) \\
\phi_{0}\left(x_{2}\right) & \cdots & \phi_{K-1}\left(x_{2}\right) \\
\vdots & & \vdots \\
\phi_{0}\left(x_{N}\right) & \cdots & \phi_{K-1}\left(x_{N}\right)
\end{array}\right] \in \mathbb{R}^{N \times K}</script><p>where $\Phi<em>{i j}=\phi</em>{j}\left(\boldsymbol{x}<em>{i}\right)$ and $\phi</em>{j}: \mathbb{R}^{D} \rightarrow \mathbb{R}$.<br>这个矩阵被称为<strong>特征矩阵</strong>（feature matrix）或<strong>设计矩阵</strong>(design matrix)<br>有了上面这个矩阵，我们可以将线性回归模型：</p>
<script type="math/tex; mode=display">p(y|\boldsymbol x,\boldsymbol \theta)=\mathcal N(y|\boldsymbol x^\top\boldsymbol\theta,\sigma^2)\Leftrightarrow y=\boldsymbol x^\top\boldsymbol\theta+\epsilon,\quad \epsilon \sim \mathcal N(0,\sigma^2)</script><blockquote>
<p>从这个式子中可以看出，预测值的结果主要分布于均值的周围</p>
</blockquote>
<p>写成：</p>
<script type="math/tex; mode=display">-\log p(\mathcal Y|\mathcal X,\boldsymbol\theta)=\frac{1}{2\sigma^2}(y-\Phi\boldsymbol\theta)^\top(y-\Phi\boldsymbol\theta)+\operatorname{const}</script><p>将两式子进行比较，发现二者只是将$\phi$欢成了$\Phi$,所以直接利用模型的结论，得到$\theta$的估计值：</p>
<script type="math/tex; mode=display">\theta_{ML}=(\Phi^\top\Phi)^{-1}\Phi^\top y</script><blockquote>
<p>需要讨论$\Phi$的可逆性<br>这个是不是支持向量机中的多项式核函数？</p>
<script type="math/tex; mode=display">(x_1\times x_2 + r)^d</script><p>其中，r为多项式的参数，d为多项式的次数，$x_1、x_2$为观测值</p>
<h3 id="噪声方差（Estimating-the-Noise-Variance）"><a href="#噪声方差（Estimating-the-Noise-Variance）" class="headerlink" title="噪声方差（Estimating the Noise Variance）"></a>噪声方差（Estimating the Noise Variance）</h3><p>我们之前的讨论都是假定$\sigma^2$是已知的，但是实际上可以利用极大似然估计的方式对噪声方差进行估计，所有的步骤与之前一致：<br>将$p(\mathcal y|\mathcal x,\theta,\sigma^2)=\frac{1}{\sigma\sqrt{2\pi}}e^{-\frac{1}{2}(\frac{x-\mu}{\sigma})^2}$带入到似然函数中：</p>
<script type="math/tex; mode=display">
\begin{array}{l}
\log p\left(\mathcal{Y} \mid \mathcal{X}, \boldsymbol{\theta}, \sigma^{2}\right)=\sum\limits_{n=1}^{N} \log \mathcal{N}\left(y_{n} \mid \phi^{\top}\left(\boldsymbol{x}_{n}\right) \boldsymbol{\theta}, \sigma^{2}\right) \\
=\sum\limits_{n=1}^{N}\left(-\frac{1}{2} \log (2 \pi)-\frac{1}{2} \log \sigma^{2}-\frac{1}{2 \sigma^{2}}\left(y_{n}-\phi^{\top}\left(\boldsymbol{x}_{n}\right) \boldsymbol{\theta}\right)^{2}\right) \\
=-\frac{N}{2} \log \sigma^{2}-\frac{1}{2 \sigma^{2}} \underbrace{\sum_{n=1}^{N}\left(y_{n}-\boldsymbol{\phi}^{\top}\left(\boldsymbol{x}_{n}\right) \boldsymbol{\theta}\right)^{2}}_{=: s}+\text { const. }
\end{array}</script><p>对$\sigma^2$求偏导：</p>
<script type="math/tex; mode=display">
\begin{aligned}
& \frac{\partial \log p\left(\mathcal{Y} \mid \mathcal{X}, \boldsymbol{\theta}, \sigma^{2}\right)}{\partial \sigma^{2}}=-\frac{N}{2 \sigma^{2}}+\frac{1}{2 \sigma^{4}} s=0 \\
\Longleftrightarrow & \frac{N}{2 \sigma^{2}}=\frac{s}{2 \sigma^{4}}
\end{aligned}</script></blockquote>
<p>所以得到$\sigma^2$的极大似然估计的结果为：</p>
<script type="math/tex; mode=display">\sigma^2=\frac{s}{N}=\frac{1}{N}\sum^N_{n-1}(y_n-\phi^\top(\boldsymbol x_n)\theta)^2</script><blockquote>
<p>the maximum likelihood estimate of the noise variance is <strong>the empirical mean of the squared distances</strong> between the noise-free function values $\phi^\top(x_n)\theta$and the corresponding noisy observations $y_n$ at input locations $x_n$.</p>
</blockquote>
<h2 id="线性回归中的过拟合（Overfitting-in-Linear-Regression）"><a href="#线性回归中的过拟合（Overfitting-in-Linear-Regression）" class="headerlink" title="线性回归中的过拟合（Overfitting in Linear Regression）"></a>线性回归中的过拟合（Overfitting in Linear Regression）</h2><p>我们可以使用均方根误差（root mean square error，RMSE）来衡量一个模型的好坏：</p>
<script type="math/tex; mode=display">\sqrt{\frac{1}{N}\|y-\Phi\boldsymbol\theta\|^2}=\sqrt{\frac{1}{N}\sum^N_{n=1}(y_n-\phi^\top(x_n)\boldsymbol\theta)^2}</script><p>噪声参数$\sigma^2$不是一个自由模型参数，所以没有直接加到上式，所以没有包含到上面，这样做的好处就是能够使得计算前后的量纲保持一致。<br>当多项式的次数小于训练样本数量的时候，可以得到一个唯一的极大似然估计值，当大于的时候，需要求解一个欠定方程组（有无穷多解的方程组），这样得到无穷多的估计值。<br>采用不同级别的多项式模型拟合10个数据的结果如下图：<br><img src="https://img-blog.csdnimg.cn/20210529085722190.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>各个模型的均方根误差：<br><img src="https://img-blog.csdnimg.cn/20210529085737340.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>注意一点，训练集的RMSE不会增加。</p>
<h2 id="极大后验估计（Maximum-A-Posteriori-Estimation）"><a href="#极大后验估计（Maximum-A-Posteriori-Estimation）" class="headerlink" title="极大后验估计（Maximum A Posteriori Estimation）"></a>极大后验估计（Maximum A Posteriori Estimation）</h2><p>当出现过拟合的时候，参数的数值会变得很大，为了解决这个问题，我们可以使用先验分布$p(\theta)$。这个先验分布标明了参数值在什么范围内是合理的。例如一个高斯先验$p(\theta)=\mathcal N(0,1)$,这个信息中暗示了参数的范围应该在$[-2,2]$之间（$\mu\pm2\sigma$）.当数据集可用的时候，我们需要去找能够最大化后验分布$p(\theta|\mathcal X,\mathcal Y)$的参数值$\theta$,这个过程称为<strong>极大后验估计</strong>（Maximum a Posteriori Estimation,MAP）,后验分布可以利用贝叶斯公式求解：</p>
<script type="math/tex; mode=display">p(\theta|\mathcal X,\mathcal Y)=\frac{p(\mathcal Y|\mathcal X, \theta)p(\theta)}{p(\mathcal Y|\mathcal X)}</script><blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210606102552583.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</blockquote>
<p>要求出参数向量$\theta_{MAP}$,我们需要遵循与极大似然估计一致的方法，首先，先自然对数转换（log-transform）：</p>
<script type="math/tex; mode=display">\log p(\theta|\mathcal X,\mathcal Y)=\log p(\mathcal Y|\mathcal X,\theta)+\log p(\theta)+\operatorname{const}</script><p>其中，$\operatorname {const}$中包含独立于$\theta$的项。可以看到，后验似然估计是参数先验（在输入数据之前的对参数的认知）和依赖于数据的似然之间的折中。<br>要求的参数向量，我们要：</p>
<script type="math/tex; mode=display">\theta_{MAP}\in\arg \min_\theta\{-\log p(\mathcal Y|\mathcal X,\theta)-\log p(\theta)\}</script><p>将负对数后验对$\theta$进行求导：</p>
<script type="math/tex; mode=display">
-\frac{\mathrm{d} \log p(\boldsymbol{\theta} \mid \mathcal{X}, \mathcal{Y})}{\mathrm{d} \boldsymbol{\theta}}=-\frac{\mathrm{d} \log p(\mathcal{Y} \mid \mathcal{X}, \boldsymbol{\theta})}{\mathrm{d} \theta}-\frac{\mathrm{d} \log p(\boldsymbol{\theta})}{\mathrm{d} \theta}</script><blockquote>
<p>第一项是之前提到的负自然对数似然的梯度：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac{\mathrm{d} \mathcal{L}}{\mathrm{d} \theta} &=\frac{\mathrm{d}}{\mathrm{d} \theta}\left(\frac{1}{2 \sigma^{2}}(y-X \theta)^{\top}(y-X \theta)\right) \\
&=\frac{1}{2 \sigma^{2}} \frac{\mathrm{d}}{\mathrm{d} \theta}\left(y^{\top} y-2 y^{\top} X \theta+\theta^{\top} \boldsymbol{X}^{\top} \boldsymbol{X} \theta\right) \\
&=\frac{1}{\sigma^{2}}\left(-\boldsymbol{y}^{\top} \boldsymbol{X}+\boldsymbol{\theta}^{\top} \boldsymbol{X}^{\top} \boldsymbol{X}\right) \in \mathbb{R}^{1 \times D}
\end{aligned}</script></blockquote>
<p>利用参数的一个（共轭）高斯先验$p(\theta)=\mathcal N(0,b^2\boldsymbol I)$:</p>
<script type="math/tex; mode=display">
-\log p(\theta \mid \mathcal{X}, \mathcal{Y})=\frac{1}{2 \sigma^{2}}(y-\Phi \theta)^{\top}(y-\Phi \theta)+\frac{1}{2 b^{2}} \theta^{\top} \theta+\text { const }</script><blockquote>
<p>这里有点疑问，利用了</p>
<script type="math/tex; mode=display">p(y|\boldsymbol x,\theta)=\mathcal N(y|\phi^\top(x)\boldsymbol\theta,\sigma^2)\Longleftrightarrow y=\phi^\top(x)\boldsymbol\theta+\epsilon=\sum^{K-1}_{k=0}\theta_k\phi_k(x)+\epsilon</script><p>？？</p>
</blockquote>
<p>上式右边的第一个式子来源于自然对数似然，第二个式子来源于自然对数先验。所以自然对数先验对$\theta$的先验为：</p>
<script type="math/tex; mode=display">-\frac{d\log p(\theta|\mathcal X,\mathcal Y)}{d\theta}=\frac{1}{\sigma^2}(\theta^\top\Phi^\top\Phi-y^\top\Phi)+\frac{1}{b^2}\theta^\top</script><p>将梯度设置为0：</p>
<script type="math/tex; mode=display">
\begin{aligned}
& \frac{1}{\sigma^{2}}\left(\theta^{\top} \Phi^{\top} \Phi-y^{\top} \Phi\right)+\frac{1}{b^{2}} \theta^{\top}=0^{\top} \\
\Longleftrightarrow & \theta^{\top}\left(\frac{1}{\sigma^{2}} \Phi^{\top} \Phi+\frac{1}{b^{2}} I\right)-\frac{1}{\sigma^{2}} y^{\top} \Phi=0^{\top} \\
\Longleftrightarrow & \theta^{\top}\left(\Phi^{\top} \Phi+\frac{\sigma^{2}}{b^{2}} I\right)=y^{\top} \Phi \\
\Longleftrightarrow & \theta^{\top}=y^{\top} \Phi\left(\Phi^{\top} \Phi+\frac{\sigma^{2}}{b^{2}} I\right)^{-1}
\end{aligned}</script><p>整理得：</p>
<script type="math/tex; mode=display">\theta_{MAP}=(\Phi^\top\Phi+\frac{\sigma^2}{b^2}I)^{-1}\Phi^\top y</script><p>与极大似然估计的结果：$\theta_{ML}=(\Phi^\top\Phi)^{-1}\Phi^\top y$相比较，只是在逆当中多了一项$\frac{\sigma^2}{b^2}I$，这一项保证了$\Phi^\top\Phi+\frac{\sigma^2}{b^2}I$是一个对称严格正定的。也就是说这个矩阵是可逆的，而且是线性方程的唯一解。同时他也反应了<strong>正则项</strong>(regularizer)的影响的大小</p>
<blockquote>
<p>虽然先验能够让高次多项式变得更加光滑，但也是仅仅将过拟合的边界向后推移了，想要解决过拟合的问题需要其他的方法。<br><img src="https://img-blog.csdnimg.cn/20210529160218756.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="极大后验估计作为正则化"><a href="#极大后验估计作为正则化" class="headerlink" title="极大后验估计作为正则化"></a>极大后验估计作为正则化</h3><p>带正则项的最小二乘的损失函数为：</p>
<script type="math/tex; mode=display">\|\boldsymbol y-\boldsymbol\Phi\boldsymbol\theta\|^2+\lambda\|\boldsymbol\theta\|_2^2</script><p>这里的范数采用的是$p$-范数,当$p$的值越小，得到的结果中$\theta=0$的个数就越多。当$p=1$时，被称为<strong>最小绝对收缩和选择算子</strong>（least absolute shrinkage and selection operator，LASSO）<br><img src="https://img-blog.csdnimg.cn/20210608202819264.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</blockquote>
<p>上式中的正则项可以理解为极大后验估计中的<strong>高斯自然对数先验</strong>（negative log-Gaussian prior），具体来说，对于一个正态分布$p(\boldsymbol\theta)=\mathcal N(\boldsymbol0,b^2\boldsymbol I)$的高斯自然对数先验为：</p>
<script type="math/tex; mode=display">-\log p(\boldsymbol\theta)=\frac{1}{2b^2}\|\boldsymbol \theta\|^2_2+\operatorname{const}</script><p>这里的正则项为$\frac{1}{2b^2}$与极大后验估计的先验一致。这样看来，正则化后的最小二乘损失函数包含的项与负自然对数似然和负自然对数先验有紧密关系，所以最小化最小二乘损失函数的过程与极大后验估计一致.<br>最小化带正则项的最小二乘损失函数（regularized least-squares loss function）：</p>
<script type="math/tex; mode=display">\boldsymbol\theta_{RLS}=(\boldsymbol\Phi^\top\boldsymbol\Phi+\lambda \boldsymbol I)^{-1}\boldsymbol\Phi^\top \boldsymbol y</script><p>这个与极大后验估计一致，这里的正则项为$\lambda=\frac{\sigma^2}{b^2}$,其中，$\sigma^2$是噪声方差，$b^2$为（各向同性）高斯先验方差$p(\boldsymbol\theta)=\mathcal N(\boldsymbol0,b^2\boldsymbol I)$<br>至此，我们讨论的都是点估计得到$\theta^*$，以对目标函数进行优化。接下来我们讨论使用贝叶斯推断，通过获得所有合理的参数的均值得到优化结果。</p>
<h1 id="贝叶斯线性回归（Bayesian-Linear-Regression）"><a href="#贝叶斯线性回归（Bayesian-Linear-Regression）" class="headerlink" title="贝叶斯线性回归（Bayesian Linear Regression）"></a>贝叶斯线性回归（Bayesian Linear Regression）</h1><p>先前讨论的是采用极大似然估计和极大后验估计来估计模型的参数，极大似然估计容易出现过拟合的现象，尤其是在训练集比较小的时候。极大后验估计使用一个概率先验来解决这个问题。而贝叶斯回归不求出单一的参数，而是选择求所有合理的参数的均值。</p>
<h2 id="模型（Model）"><a href="#模型（Model）" class="headerlink" title="模型（Model）"></a>模型（Model）</h2><script type="math/tex; mode=display">\begin{aligned}&prior \quad p(\boldsymbol\theta)=\mathcal N(\boldsymbol m_0,\boldsymbol S_0)\\ & likelihood\quad p(y|\boldsymbol x,\boldsymbol\theta)=\mathcal (y|\phi^\top(x)\boldsymbol\theta,\sigma)\end{aligned}</script><p>对应的图模型：</p>
<p><div align="center"></div></p>
<image src="https://img-blog.csdnimg.cn/20210531102756290.png">

<p>已观测变量与未观测变量的联合概率分布为：</p>
<script type="math/tex; mode=display">p(y,\boldsymbol\theta|x)=p(y|\theta,x)p(\boldsymbol\theta)</script><blockquote>
<p>推导过程</p>
<script type="math/tex; mode=display">p(y,\theta|x)=\frac{p(y|\theta,x)p(\theta ,x)}{p(x)}=p(y|\theta,x)\cdot p(\theta|x)</script><p>所以x与$\theta$是相互独立的？应该是$\theta$与验证数据无关</p>
</blockquote>
<h2 id="预测先验（Prior-Predictions）"><a href="#预测先验（Prior-Predictions）" class="headerlink" title="预测先验（Prior Predictions）"></a>预测先验（Prior Predictions）</h2><p>预测的最终目的不是获得模型的参数，而是获得预测值，在贝叶斯回归中，预测值是所有合理参数的预测值的均值：</p>
<script type="math/tex; mode=display">p(y_*|x_*)=\int p(y_*|\boldsymbol x_*,\boldsymbol\theta)p(\boldsymbol\theta)d\boldsymbol\theta=\mathbb E_\theta[p(y_*|\boldsymbol x_*,\boldsymbol\theta)]</script><blockquote>
<p>连续概率分布的均值，样品值乘以样品出现的概率，将他们之和加起来，得到均值</p>
<p>我们选取一个$\theta$的（共轭）高斯先验作为模型，于是可以知道预测结果也是高斯分布，对于一个先验分布$p(\boldsymbol\theta)=\mathcal N(\boldsymbol m_0,\boldsymbol S_0)$,对应的预测结果的分布为：</p>
<script type="math/tex; mode=display">p(y_*|\boldsymbol x_*)=\mathcal N(\boldsymbol\phi^\top(\boldsymbol x_*)\boldsymbol m_0,\phi^\top(\boldsymbol x_*)\boldsymbol S_0\phi(\boldsymbol x_*)+\sigma^2)</script><p>贝叶斯回归模型为：</p>
<script type="math/tex; mode=display">p(\theta) =\mathcal N(m_0,S_0)\\ p(y|x,\theta)=\mathcal N(y|\phi^\top\theta,\sigma^2)</script><p>x与y的对应关系为：$y^<em>=\phi^\top(x^</em>)\theta$<br>所以对应y的均值为：$\phi^\top m<em>0$<br>由$\mathbb V_Y[y]=\mathbb V_X[Ax+b]=\mathbb V_X[Ax]=A\mathbb V_X A^\top=A\Sigma A^\top$:<br>y的对应的方差为：$\phi^\top(x</em><em>)S<em>0\phi(x</em></em>)$,加上噪声项即为上式</p>
</blockquote>
<p>上式中的$\sigma^2$是由于测量误差导致的不确定分布。<br>这里预测值是高斯分布是因为高斯共轭和边际化的性质。由于高斯噪音是相互独立的，所以：</p>
<script type="math/tex; mode=display">\mathbb V[y_*]=\mathbb V_\boldsymbol\theta[\phi^\top(x_*)\boldsymbol\theta]+\mathbb V_\epsilon[\epsilon]</script><p>如果我们考虑无噪音函数：$f(\boldsymbol x<em>*)=\phi^\top(x</em>*)\boldsymbol\theta$</p>
<script type="math/tex; mode=display">p(f(x_*))=\mathcal N(\phi^\top(x_*)m_0,\phi^\top(x_*)S_0\phi(x_*))</script><p>这个式子与原先式子不同之处在于少了噪音项$\sigma^2$<br><strong>函数分布</strong>（Distribution over Functions）：<br>我们可以用一系列的参数$\theta_i$表示参数分布$p(\boldsymbol\theta)$,而每一个参数对应一个函数$f(\cdot)=\boldsymbol\theta^\top_i\phi(\cdot)$于是可以得到对应函数的分布$p(f(\cdot))$</p>
<blockquote>
<p>p305 没弄清楚<br><img src="https://img-blog.csdnimg.cn/2021053117070927.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>置信区间和置信边界</p>
</blockquote>
<h2 id="后验分布（Posterior-Distribution）"><a href="#后验分布（Posterior-Distribution）" class="headerlink" title="后验分布（Posterior Distribution）"></a>后验分布（Posterior Distribution）</h2><p>利用贝叶斯公式可以计算参数的后验分布：</p>
<script type="math/tex; mode=display">p(\theta|\mathcal X,\mathcal Y)=\frac{p(\mathcal Y|\mathcal X, \theta)p(\theta)}{p(\mathcal Y|\mathcal X)}</script><p>其中$\mathcal X$是训练的输入值，$\mathcal Y$是训练目标。<br>其中的边际似然（marginal likelihood/evidence）与参数无关：</p>
<script type="math/tex; mode=display">p(\mathcal Y|\mathcal X)=\int p(\mathcal Y|\mathcal X, \theta)p(\theta)d\theta=\mathbb E_\theta[p(\mathcal Y|\mathcal X,\theta)]</script><p>边际似然可以被看成是所有合理参数下预测值的均值。<br><strong>参数后验</strong>：</p>
<script type="math/tex; mode=display">\begin{aligned}p(\boldsymbol\theta|\mathcal X, \mathcal Y) & =\mathcal N(\boldsymbol\theta |\boldsymbol m_N,\boldsymbol S_N)\\ \boldsymbol S_N &=(\boldsymbol S_0^{-1}{+\sigma^{-2}}\Phi^\top\Phi)^{-1}\\\boldsymbol m_N&=\boldsymbol S_N(\boldsymbol S_0^{-1}\boldsymbol m_0+\sigma^{-2}\Phi^\top \boldsymbol y)\end{aligned}</script><p>其中的N代表的是训练集的大小。<br><strong>证明</strong>：</p>
<blockquote>
<p>证明思路类似是用两种方式将参数后验表示出来，然后将对应部分的进行对比，得到想要的参数。</p>
</blockquote>
<p>由贝叶斯公式可以得知，后验概率分布与似然概率分布和先验概率分布成比例</p>
<script type="math/tex; mode=display">
\begin{array}{ll}
\text { Posterior } & p(\boldsymbol{\theta} \mid \mathcal{X}, \mathcal{Y})=\frac{p(\mathcal{Y} \mid \mathcal{X}, \boldsymbol{\theta}) p(\boldsymbol{\theta})}{p(\mathcal{Y} \mid \mathcal{X})} \\
\text { Likelihood } & p(\mathcal{Y} \mid \mathcal{X}, \boldsymbol{\theta})=\mathcal{N}\left(\boldsymbol{y} \mid \boldsymbol{\Phi} \boldsymbol{\theta}, \sigma^{2} \boldsymbol{I}\right) \\
\text { Prior } & p(\boldsymbol{\theta})=\mathcal{N}\left(\boldsymbol{\theta} \mid \boldsymbol{m}_{0}, \boldsymbol{S}_{0}\right)
\end{array}</script><p>现在考虑自然对数先验与自然对数似然之和：</p>
<script type="math/tex; mode=display">\begin{aligned}&\log \mathcal N(y|\Phi\theta,\sigma^2 I)+\log \mathcal N(\theta|m_0,S_0)\\&=-\frac{1}{2}(\sigma^{-2}(y-\Phi\theta)^\top(y-\Phi\theta)+(\theta-m_0)^\top S_0^{-1}(\theta-m_0))+\operatorname{const}\end{aligned}</script><p>其中的const包含一些独立于$\theta$的项。<br>将上式进行展开：（将式子中的二次项一次项进行整合）</p>
<script type="math/tex; mode=display">
\begin{aligned}
&-\frac{1}{2}\left(\sigma^{-2} \boldsymbol{y}^{\top} \boldsymbol{y}-2 \sigma^{-2} \boldsymbol{y}^{\top} \Phi \theta+\boldsymbol{\theta}^{\top} \sigma^{-2} \boldsymbol{\Phi}^{\top} \boldsymbol{\Phi} \boldsymbol{\theta}+\boldsymbol{\theta}^{\top} \boldsymbol{S}_{0}^{-1} \boldsymbol{\theta}\right.\\
&\left.-2 m_{0}^{\top} S_{0}^{-1} \theta+\boldsymbol{m}_{0}^{\top} \boldsymbol{S}_{0}^{-1} \boldsymbol{m}_{0}\right) \\
=&-\frac{1}{2}\left(\boldsymbol{\theta}^{\top}\left(\sigma^{-2} \boldsymbol{\Phi}^{\top} \boldsymbol{\Phi}+\boldsymbol{S}_{0}^{-1}\right) \boldsymbol{\theta}-2\left(\sigma^{-2} \Phi^{\top} y+S_{0}^{-1} m_{0}\right)^{\top} \theta\right)+\mathrm{const}
\end{aligned}</script><p>我们可以发现上式与$\theta$呈二次关系。</p>
<blockquote>
<p>The fact that the unnormalized log-posterior distribution is a (negative) quadratic form implies that the posterior is Gaussian</p>
</blockquote>
<script type="math/tex; mode=display">p(\theta|\mathcal X,\mathcal Y)=\exp(\log p(\theta|\mathcal X,\mathcal Y))\propto \exp(\log p(\mathcal Y|\mathcal X,\theta)+\log p(\theta))\\ \propto \exp(-\frac{1}{2}(\theta^\top(\sigma^{-2}\Phi^\top\Phi+S_0^{-1})\theta-2(\sigma^{-2}\Phi^\top y+S_0^{-1}m_0)^\top \theta))</script><p>最后需要从上式中找到均值和方差矩阵($\mathcal N(\theta|m_N,S_N)$)：</p>
<script type="math/tex; mode=display">\log \mathcal{N}\left(\boldsymbol{\theta} \mid \boldsymbol{m}_{N}, \boldsymbol{S}_{N}\right)=-\frac{1}{2}\left(\boldsymbol{\theta}-\boldsymbol{m}_{N}\right)^{\top} \boldsymbol{S}_{N}^{-1}\left(\boldsymbol{\theta}-\boldsymbol{m}_{N}\right)+ const\\=-\frac{1}{2}\left(\theta^{\top} S_{N}^{-1} \theta-2 m_{N}^{\top} S_{N}^{-1} \theta+\boldsymbol{m}_{N}^{\top} \boldsymbol{S}_{N}^{-1} \boldsymbol{m}_{N}\right)</script><p>通过比较上面二式可以得到：</p>
<script type="math/tex; mode=display">
\begin{array}{c}
S_{N}^{-1}=\Phi^{\top} \sigma^{-2} \boldsymbol{I} \Phi+S_{0}^{-1} \\
\Longleftrightarrow \boldsymbol{S}_{N}=\left(\sigma^{-2} \boldsymbol{\Phi}^{\top} \boldsymbol{\Phi}+\boldsymbol{S}_{0}^{-1}\right)^{-1} \\ \\
\boldsymbol{m}_{N}^{\top} \boldsymbol{S}_{N}^{-1}=\left(\sigma^{-2} \boldsymbol{\Phi}^{\top} \boldsymbol{y}+\boldsymbol{S}_{0}^{-1} \boldsymbol{m}_{0}\right)^{\top} \\
\Longleftrightarrow \boldsymbol{m}_{N}=\boldsymbol{S}_{N}\left(\sigma^{-2} \boldsymbol{\Phi}^{\top} \boldsymbol{y}+\boldsymbol{S}_{0}^{-1} \boldsymbol{m}_{0}\right)
\end{array}</script><blockquote>
<p><strong>完全平方的一般方法</strong>（General Approach to Completing the Squares）<br>对于一个等式($A$是一个堆成正定矩阵)：</p>
<script type="math/tex; mode=display">x^\top A^\top x-2a^\top x+const_1</script><p>可以得到：</p>
<script type="math/tex; mode=display">(x-\mu)^\top \Sigma(x-\mu)+const_2</script><p>其中，$\Sigma := A;\mu := \Sigma^{-1}a;const_2 = const_1-\mu^\top\Sigma\mu$<br><strong>这部分需要补充</strong></p>
</blockquote>
<h2 id="后验预测（Posterior-Predictions）"><a href="#后验预测（Posterior-Predictions）" class="headerlink" title="后验预测（Posterior Predictions）"></a>后验预测（Posterior Predictions）</h2><script type="math/tex; mode=display">
\begin{aligned}
p\left(y_{*} \mid \mathcal{X}, \mathcal{Y}, \boldsymbol{x}_{*}\right) &=\int p\left(y_{*} \mid \boldsymbol{x}_{*}, \boldsymbol{\theta}\right) p(\boldsymbol{\theta} \mid \mathcal{X}, \mathcal{Y}) \mathrm{d} \boldsymbol{\theta} \\
&=\int \mathcal{N}\left(y_{*} \mid \phi^{\top}\left(\boldsymbol{x}_{*}\right) \boldsymbol{\theta}, \sigma^{2}\right) \mathcal{N}\left(\boldsymbol{\theta} \mid \boldsymbol{m}_{N}, \boldsymbol{S}_{N}\right) \mathrm{d} \boldsymbol{\theta} \\
&=\mathcal{N}\left(y_{*} \mid \phi^{\top}\left(\boldsymbol{x}_{*}\right) \boldsymbol{m}_{N}, \boldsymbol{\phi}^{\top}\left(\boldsymbol{x}_{*}\right) \boldsymbol{S}_{N} \phi\left(\boldsymbol{x}_{*}\right)+\sigma^{2}\right)
\end{aligned}</script><p>右式中的第一个分布式利用训练得到的参数和输入值计算之后得到的结果的分布（$y^<em>=\phi(x^</em>)\theta$）,第二个分布是用训练集训练得到的参数$\theta$,$\phi^\top(x<em>*)S_N\phi(x</em>*)$表示关于后验的不确定性.<br>上式可以等价地写成</p>
<script type="math/tex; mode=display">\mathbb E_{\theta|\mathcal X,\mathcal Y}[p(y_*|x_*,\theta)]</script><blockquote>
<p><strong>分布方程</strong>（Distribution over Functions）<br>当我们使用积分将参数$\theta$消掉时，我们得到了一个分布函数：如果我们从$\theta<em>i \sim p(\theta|\mathcal X, \mathcal Y)$中取样，我们可以得到方程$\theta^\top_i\phi(\cdot)$。均值方程为所有预测值的期望$\mathbb E</em>\theta[f(\cdot)|\theta,\mathcal X,\mathcal Y]=m^\top_N\phi(\cdot)$,函数的方差为$\phi^\top(\cdot) S_N\phi(\cdot)$<br>从$p(\theta)=\mathcal N(0,\frac14I)$中对参数进行抽样,表示为第三张图：<br><img src="https://img-blog.csdnimg.cn/20210610124325373.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>无噪音函数值的均值和方差</strong>（Mean and Variance of Noise-Free Function Values）<br>在很多情况下，我们并不关心(含噪音的)预测值的分布$p(y<em>*|\mathcal X, \mathcal Y,x</em><em>)$。我们更关注于无噪音的函数值$f(x_</em>)=\phi^\top(x_*)\theta$,可以得到该函数的均值和方差：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\mathbb{E}\left[f\left(\boldsymbol{x}_{*}\right) \mid \mathcal{X}, \mathcal{Y}\right]=& \mathbb{E}_{\boldsymbol{\theta}}\left[\phi^{\top}\left(\boldsymbol{x}_{*}\right) \boldsymbol{\theta} \mid \mathcal{X}, \mathcal{Y}\right]=\phi^{\top}\left(\boldsymbol{x}_{*}\right) \mathbb{E}_{\boldsymbol{\theta}}[\boldsymbol{\theta} \mid \mathcal{X}, \mathcal{Y}] \\
&=\phi^{\top}\left(\boldsymbol{x}_{*}\right) \boldsymbol{m}_{N}=\boldsymbol{m}_{N}^{\top} \phi\left(\boldsymbol{x}_{*}\right), \\
\mathbb{V}_{\boldsymbol{\theta}}\left[f\left(\boldsymbol{x}_{*}\right) \mid \mathcal{X}, \mathcal{Y}\right] &=\mathbb{V}_{\boldsymbol{\theta}}\left[\phi^{\top}\left(\boldsymbol{x}_{*}\right) \boldsymbol{\theta} \mid \mathcal{X}, \mathcal{Y}\right] \\
&=\phi^{\top}\left(\boldsymbol{x}_{*}\right) \mathbb{V}_{\boldsymbol{\theta}}[\boldsymbol{\theta} \mid \mathcal{X}, \mathcal{Y}] \phi\left(\boldsymbol{x}_{*}\right) \\
&=\phi^{\top}\left(\boldsymbol{x}_{*}\right) \boldsymbol{S}_{N} \phi\left(\boldsymbol{x}_{*}\right)
\end{aligned}</script><p>我们可以发现均值与含噪音观测的均值一致，因为噪音的均值为0，因为噪音的方差为$\sigma^2$,所以当预测含噪音的函数值时，需要加上，无噪音的时候则不需要。<br><strong>还是没能很好地理解噪音这个概念</strong></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210610130744637.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>上图是由参数后验得到的后验分布。由上图可知，当多项式为低阶的时候，参数的分布不会很分散。而对于高阶的贝叶斯回归模型，后验概率的不确定性很大，这个信息对于<strong>决策系统</strong>（decision-making system）很重要。</p>
<h2 id="边际似然的计算（Computing-the-Marginal-Likelihood）"><a href="#边际似然的计算（Computing-the-Marginal-Likelihood）" class="headerlink" title="边际似然的计算（Computing the Marginal Likelihood）"></a>边际似然的计算（Computing the Marginal Likelihood）</h2><p>在本节中，我们介绍参数为共轭高斯先验的贝叶斯线性回归的边际似然的计算。<br>考虑以下参数形成的过程：</p>
<script type="math/tex; mode=display">\begin{aligned}\theta&\sim \mathcal N(m_0,S_0)\\y_n|x_n, \theta&\sim\mathcal N(x_n^\top\theta,\sigma^2),\quad n=1,\dots,N\end{aligned}</script><p>则对应的边际似然为：</p>
<script type="math/tex; mode=display">\begin{aligned} p(\mathcal Y|\mathcal X)&=\int p(\mathcal Y|\mathcal X, \theta)p(\theta)d\theta\\&=\int \mathcal N(y|X\theta,\sigma^2I)\mathcal N(\theta|m_0,S_0)d\theta\end{aligned}</script><p>上面这个式子可以理解为参数先验下的似然的期望：$\mathbb E_\theta[p(\mathcal Y|\mathcal X,\theta)]$<br>计算边际似然需要两个步骤，首先先确定边际似然是高斯分布，然后计算出这个高斯分布的均值和方差。<br>由高斯分布的性质，两个高斯分布的乘积仍旧是高斯分布。<br>下面开始计算这个高斯分布的均值和方差：</p>
<script type="math/tex; mode=display">\mathbb E[\mathcal Y|\mathcal X]=\mathbb E_{\theta,\epsilon}[X\theta+\epsilon]=X\mathbb E_\theta[\theta]=Xm_0,\quad \epsilon \sim \mathcal N(0,\sigma^2I)</script><p>方差为：</p>
<script type="math/tex; mode=display">\begin{aligned}\operatorname{Cov}[\mathcal Y|\mathcal X]&=\operatorname{Cov}_{\theta,\epsilon}[X\theta+\epsilon]=\operatorname{Cov}[X\theta]+\sigma^2I\\ &=X\operatorname{Cov}_\theta[\theta]X^\top+\sigma^2I=XS_0X^\top+\sigma^2I\end{aligned}</script><p>所以，边际似然为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
p(\mathcal{Y} \mid \mathcal{X})=&(2 \pi)^{-\frac{N}{2}} \operatorname{det}\left(\boldsymbol{X} \boldsymbol{S}_{0} \boldsymbol{X}^{\top}+\sigma^{2} \boldsymbol{I}\right)^{-\frac{1}{2}} \\
& \cdot \exp \left(-\frac{1}{2}\left(\boldsymbol{y}-\boldsymbol{X} \boldsymbol{m}_{0}\right)^{\top}\left(\boldsymbol{X} \boldsymbol{S}_{0} \boldsymbol{X}^{\top}+\sigma^{2} \boldsymbol{I}\right)^{-1}\left(\boldsymbol{y}-\boldsymbol{X} \boldsymbol{m}_{0}\right)\right)
\\&=\mathcal N(y|Xm_0,XS_0X^\top+\sigma^2I)
\end{aligned}</script><blockquote>
<p>与之前的内容进行联系，为什么形式是这样的？</p>
</blockquote>
<h2 id="用正交投影解释极大似然估计（Maximum-Likelihood-as-Orthogonal-Projection）"><a href="#用正交投影解释极大似然估计（Maximum-Likelihood-as-Orthogonal-Projection）" class="headerlink" title="用正交投影解释极大似然估计（Maximum Likelihood as Orthogonal Projection）"></a>用正交投影解释极大似然估计（Maximum Likelihood as Orthogonal Projection）</h2><p>考虑一个简单的线性规划模型：</p>
<script type="math/tex; mode=display">y=x\theta+\epsilon,\quad \epsilon \sim \mathcal N(0,\sigma^2)</script><p>由原先的提到的极大似然估计，得到斜率参数：</p>
<script type="math/tex; mode=display">\theta_{ML}=(X^\top X)^{-1}X^\top y=\frac{X^\top y}{X^\top X}\in \mathbb R</script><p>其中，$X\in \mathbb R^N$和$y\in \mathbb R^N$为训练集中的元素(都是向量，所以$X^\top X$为标量，这也是将这一项放到分母的原因)。<br>所以对应的目标为：</p>
<script type="math/tex; mode=display">X\theta_{ML}=X\frac{X^\top y}{X^\top X}=\frac{XX^\top}{X^\top X}y</script><p>所以可以理解为，我们的目标是找到$y=X\theta$的解。由原先的线性代数和解析几何，可以将上式理解为<u>y在X张成的一维子空间的正交投影</u>，其中$\frac{XX^\top}{X^\top X}$为投影矩阵,$\theta<em>{ML}$为y在一维子空间中的正交投影的坐标，$X\theta</em>{ML}$为$y$在这个子空间中的正交投影。<br>所以，极大似然估计的解得到的是在$X$子空间中找到一个与观测值$y$最接近的向量。这里的距离表示$y_n$和 $x_n\theta$的最短（平方）距离<br><img src="https://img-blog.csdnimg.cn/20210615071428677.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>在广义的线性规划中：</p>
<script type="math/tex; mode=display">y=\phi^\top(x)\theta+\epsilon,\quad \epsilon \sim \mathcal N(0,\sigma^2)</script><p>其中,$\phi(x)\in \mathbb R^K$,利用极大似然估计得到参数结果：</p>
<script type="math/tex; mode=display">\boldsymbol y\approx \Phi\theta_{ML}\\\theta_{ML}=(\Phi^\top\Phi)^{-1}\Phi^\top \boldsymbol y</script><p>上式实际上就是一个往特征矩阵$\Phi$张成的K维子空间的投影。若将特征矩阵$\Phi$构造成规范正交，这时候$\Phi$就形成了一个规范正交基。因为$\Phi^\top\Phi=I$所以，对应的投影为：</p>
<script type="math/tex; mode=display">\Phi(\Phi^\top\Phi)^{-1}\Phi^\top \boldsymbol y = \Phi\Phi^\top \boldsymbol y=\begin{pmatrix} \sum\limits^K_{k=1}\phi_k\phi_k^\top\end{pmatrix}\boldsymbol y</script><p>所以极大似然的投影这时候就是y向基向量$\phi_k$的投影的和。</p>
<blockquote>
<p>这部分需要深入理解一下，为什么？<br>the coupling between different features has disappeared due to the orthogonality of the basis.</p>
<p><strong>Further Reading:</strong><br>1.In deffenrent cases we may choose deffenrent model functions which corresponding to the likelihood function<br>2.<strong>generalized linear models</strong>:there is a a smooth and invertible function $\sigma(\cdot)$(which could be nonlinear), so that $y = \sigma(f(x))$,where $f(x)=\theta^\top \phi(x)$ which also $f(x)=\sigma\circ f$. The first one is activate function, and the later one is linear function model. This can form a neural network model.<br>$y=\sigma(Ax+b)$,where A is <strong>weight matrix</strong>, b is <strong>bias vector</strong> so:</p>
<script type="math/tex; mode=display">\begin{aligned} x_{k+1}&=f_k(x_k)\\f_k(x_k)&=\sigma_k(A_kx_k+b_k)\end{aligned}</script><p>This is a K-layer deep neural network($f_{K-1}\circ\cdots\circ f_0$)</p>
</blockquote>
</image>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6-When-Models-Meet-Data/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6-When-Models-Meet-Data/" class="post-title-link" itemprop="url">机器学习中的数学: When Models Meet Data</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-05-26 10:51:34" itemprop="dateCreated datePublished" datetime="2021-05-26T10:51:34+08:00">2021-05-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-09 18:48:23" itemprop="dateModified" datetime="2023-03-09T18:48:23+08:00">2023-03-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Data-Models-and-Learning"><a href="#Data-Models-and-Learning" class="headerlink" title="Data, Models, and Learning"></a>Data, Models, and Learning</h1><p>The title contains three major components of a machine learning system.</p>
<h2 id="Data-as-Vectors"><a href="#Data-as-Vectors" class="headerlink" title="Data as Vectors"></a>Data as Vectors</h2><p>First, we need to make information as number, so as to we can use it as training data.</p>
<h2 id="Models-as-Functions"><a href="#Models-as-Functions" class="headerlink" title="Models as Functions"></a>Models as Functions</h2><p>There are two main school relative to the machine learning, function and probabilistic model. The former one gives a specific value, the later one would give the distribution of the result.<br><img src="https://img-blog.csdnimg.cn/20210517101400415.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>And in order to value a model, we use cost function or loss function to discribe it.</p>
<h1 id="经验风险最小化（Empirical-Risk-Minimization）"><a href="#经验风险最小化（Empirical-Risk-Minimization）" class="headerlink" title="经验风险最小化（Empirical Risk Minimization）"></a>经验风险最小化（Empirical Risk Minimization）</h1><p>本节主要探讨几个问题：那些函数可以被用作预测函数？如何衡量一个模型的好坏？如何让一个从已知训练集中训练出来的模型很好地预测未见得数据？在找合适的模型时，应该遵循什么样的步骤？</p>
<h2 id="假设函数的种类（Hypothesis-Class-of-Functions）"><a href="#假设函数的种类（Hypothesis-Class-of-Functions）" class="headerlink" title="假设函数的种类（Hypothesis Class of Functions）"></a>假设函数的种类（Hypothesis Class of Functions）</h2><p>我们训练的目的是找到一个参数列表$\theta^*$,使得函数的输出结果能够更接近真实值，即：</p>
<script type="math/tex; mode=display">f(x_n,\theta^*)\approx y_n\quad for \ all\ \ a = 1,\cdots,N</script><p>在本节中使用$\hat y_n=f(x_n,\theta^*)$代表模型的预测值。</p>
<h2 id="代价函数-Loss-Function-for-Training"><a href="#代价函数-Loss-Function-for-Training" class="headerlink" title="代价函数(Loss Function for Training)"></a>代价函数(Loss Function for Training)</h2><p><strong>经验风险</strong>（empirical risk）：真实值与预测值的偏差</p>
<p>对于一个给定的训练集${(x_1,y_1),\cdots,(x_N,y_N) }$,实例矩阵（example matrix）：$\boldsymbol X :=[x_1,\cdots,x_N]^\top\in \mathbb R^{N\times D}$,标签矩阵$y:=[y_1,\cdots,y_N]^\top\in \mathbb R^N$,对应的平均损失为：</p>
<script type="math/tex; mode=display">R_{emp}(f,\boldsymbol X, y)=\frac{1}{N}\sum\limits^N_{n-1} l(y_n,\hat y_n)</script><p>我们希望模型不仅仅能够很好地拟合训练数据，还希望模型能够很好地预测数据，所以能够找到一个<strong>期望风险</strong>（Expected Risk）</p>
<script type="math/tex; mode=display">\bold R_{true}(f)=\boldsymbol{\mathbb E_{x,y}}[l(y,f(\boldsymbol x))]</script><h2 id="正则化减小过拟合-Regularization-to-Reduce-Overfitting"><a href="#正则化减小过拟合-Regularization-to-Reduce-Overfitting" class="headerlink" title="正则化减小过拟合(Regularization to Reduce Overfitting)"></a>正则化减小过拟合(Regularization to Reduce Overfitting)</h2><p>如果有足够的参数，给定地模型一般能够很好地拟合测试数据，但是预测数据却与实际数据有较大的偏差，这时候就是模型发生了<strong>过拟合</strong>。<br>一般情况下，已知的数据分为测试数据和训练数据，分别用于测试和训练模型。</p>
<blockquote>
<p>Regularization is a way to compromise between accurate solution of empirical risk minimization and the size or complexity of the solution.<br>对于一个最小二乘问题：$\min\limits_\theta\frac{1}{N}|y-X\theta|^2$,加上正则项则是：</p>
<script type="math/tex; mode=display">\min\limits_\theta\frac{1}{N}\|y-X\theta\|^2+\lambda \|\theta\|</script></blockquote>
<h2 id="用交叉验证评估泛化性能-Cross-Validation-to-Assess-the-Generalization-Performance"><a href="#用交叉验证评估泛化性能-Cross-Validation-to-Assess-the-Generalization-Performance" class="headerlink" title="用交叉验证评估泛化性能(Cross-Validation to Assess the Generalization Performance)"></a>用交叉验证评估泛化性能(Cross-Validation to Assess the Generalization Performance)</h2><p>我们将已知数据进行拆分，一部分用于模型训练，一部分用于模型性能测试，这个称为<strong>验证集</strong>（validation set）。但是如果训练数据太少，可能导致得不到好的模型，如果训练数据太少可能导致噪声估计。所以应该对已有的数据进行合理的划分，这就有<strong>K-折交叉验证</strong>（K-fold cross-validation）<br><img src="https://img-blog.csdnimg.cn/20210518102941859.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>这样得到的<strong>期望泛化误差</strong>（expected generalization error）为：</p>
<script type="math/tex; mode=display">\mathbb E_\mathcal V[R(f,\mathcal V)]\approx\frac{1}{K}\sum^K_{k=1}R(f^{(k)},\mathcal V^{(k)})</script><p>其中，$R(f^{(k)},\mathcal V^{(k)})$为预测值与真实值之间的误差。<br>但是这个方法有几个缺点，首先是不合理的数据划分可能会导致的几个不好的结果，与之前的训练集和测试集之间的大小关系导致不同后果一致。同时需要对模型进行K次训练，可能需要大量的计算资源。</p>
<blockquote>
<p>Evaluating the quality of the model, depending on these hyperparameters, may result in a number of training runs that is exponential in the number of model parameters. </p>
</blockquote>
<h1 id="参数估计（Parameter-Estimation）"><a href="#参数估计（Parameter-Estimation）" class="headerlink" title="参数估计（Parameter Estimation）"></a>参数估计（Parameter Estimation）</h1><h2 id="最大似然估计（Maximum-Likelihood-Estimation）"><a href="#最大似然估计（Maximum-Likelihood-Estimation）" class="headerlink" title="最大似然估计（Maximum Likelihood Estimation）"></a>最大似然估计（Maximum Likelihood Estimation）</h2><p>定义一个关于参数的函数，去评估模型对数据的拟合的好坏。一般使用<strong>负对数似然</strong>（negative log-likelihood）：</p>
<script type="math/tex; mode=display">\mathcal L_x(\boldsymbol\theta)=-\log p(\boldsymbol x|\boldsymbol\theta)</script><p>在上式中，样品值是固定的，变化的是参数,这个函数彰显的是给定参数的情况下，取得样品值的概率。<br>假设两个相互独立且均匀分布的数据集，$\mathcal X={x_1,\cdots,x_N }$,$\mathcal Y={y_1,\cdots,y_N }$,他们的似然方程可以呗分解为：</p>
<script type="math/tex; mode=display">p(\mathcal Y|\mathcal X,\theta)=\prod^N_{n=1}p(y_n|\boldsymbol x_n,\boldsymbol\theta)</script><p>但是从优化的角度来看，和比乘积更容易处理：</p>
<script type="math/tex; mode=display">\mathcal L(\theta)=-\log p(\mathcal Y|\mathcal X, \theta)=-\sum^N_{n=1}\log p(y_n|x_n,\theta)</script><blockquote>
<p>hence should be interpreted as observed and fixed, this interpretation is incorrect.</p>
</blockquote>
<h2 id="最大后验估计（Maximum-A-Posteriori-Estimation）"><a href="#最大后验估计（Maximum-A-Posteriori-Estimation）" class="headerlink" title="最大后验估计（Maximum A Posteriori Estimation）"></a>最大后验估计（Maximum A Posteriori Estimation）</h2><p>如果我们有关于参数的先验知识，这样可以利用贝叶斯公式更新后验概率，以对参数进行估计。这个与之前提到的正则项类似，在似然概率之后乘以一个对参数的先验概率分布。</p>
<blockquote>
<p>这部分需要补充</p>
</blockquote>
<h2 id="模型拟合（Model-Fitting）"><a href="#模型拟合（Model-Fitting）" class="headerlink" title="模型拟合（Model Fitting）"></a>模型拟合（Model Fitting）</h2><p>拟合的意思就是优化模型的参数，以最小化代价函数。<br><strong>参数化</strong>（arametrization）：一种描述模型的方式。</p>
<script type="math/tex; mode=display">y = ax+b\rightarrow \theta:=\{a,b\}</script><p><img src="https://img-blog.csdnimg.cn/20210521104544345.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>书中使用$M_\theta$表示参数化的模型，$M^<em>$为真实值，上图中的红线可以认为是代价函数。<br><em>*拟合的三种结果</em></em>：<br><img src="https://img-blog.csdnimg.cn/20210521104758825.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>泛化线性模型(generalized generalized linear)：<br>In statistics, the generalized linear model (GLM) is a flexible generalization of ordinary linear regression that allows for response variables that have error distribution models other than a normal distribution.<br>连接函数（Link Function）：<br>The link function provides the relationship between the linear predictor and the mean of the distribution function.</p>
</blockquote>
<h2 id="贝叶斯推断（Bayesian-Inference）"><a href="#贝叶斯推断（Bayesian-Inference）" class="headerlink" title="贝叶斯推断（Bayesian Inference）"></a>贝叶斯推断（Bayesian Inference）</h2><p>之前提到的极大似然估计和极大后验估计最后都是在解决一个优化问题，通过解决这个优化问题，我们可以得到模型参数，利用这个参数我们可以得到预测值的分布$p(x|\theta^*)$<br>由于仅仅是关注于部分数据的后验分布会损失部分的信息，而损失的信息可能对决策系统至关重要，所以得到一个完成数据的后验分布十分重要</p>
<blockquote>
<p>这部分需要补充，关于信息损失</p>
</blockquote>
<p>对于一个数据集$\mathcal X$、一个参数先验$p(\theta)$和一个似然方程的后验分布为：</p>
<script type="math/tex; mode=display">p(\theta|\mathcal X)=\frac{p(\mathcal X|\theta)p(\theta)}{p(\mathcal X)},\quad p(\mathcal X)=\int p(\mathcal X|\theta)p(\theta)d\theta</script><p>利用参数的后验分布，我们可以将对参数的不确定性转移到数据上,也就是我们的预测值不再依赖于参数了：</p>
<script type="math/tex; mode=display">p(\boldsymbol x)=\int p(\boldsymbol x|\boldsymbol\theta)p(\boldsymbol\theta)d\boldsymbol\theta=\mathbb E_\boldsymbol\theta[p(\boldsymbol x|\boldsymbol\theta)]</script><p>上式说明，预测值是所有参数下的预测值的均值。</p>
<h2 id="潜变量模型（Latent-Variable-Models）"><a href="#潜变量模型（Latent-Variable-Models）" class="headerlink" title="潜变量模型（Latent-Variable Models）"></a>潜变量模型（Latent-Variable Models）</h2><blockquote>
<p>Mathematical models that aim to explain observed variables in terms of latent variables are called <strong>latent variable models</strong></p>
<p><strong>潜变量</strong>（Latent-Variable）<br>These could in principle be measured, but may not be for practical reasons. In this situation, the term hidden variables is commonly used (reflecting the fact that the variables are meaningful, but not observable).</p>
</blockquote>
<p>想要简化模型，最简单的方法就是减少模型的参数的数量。但是利用潜变量模型（expectation maximization (EM) algorithm），可以更加规范地简化模型。<br>潜变量模型能够帮助我们描述从参数中获取预测值地过程：<br>将数据表示为$\boldsymbol x$,模型的参数表示为$\boldsymbol\theta$,潜变量表示为$z$,我们可以得到条件分布：</p>
<script type="math/tex; mode=display">p(\boldsymbol x|\boldsymbol z,\boldsymbol\theta)</script><p>想要得到给定模型参数下的预测数据，我们需要消去潜变量：</p>
<script type="math/tex; mode=display">p(x|\theta)=\int p(x|z,\theta)p(z)dz</script><p>注意到似然方程与潜变量无关，有了上面这个式子，我们可以直接使用极大似然估计来进行参数估计。<br>用上式带入到贝叶斯公式中：</p>
<script type="math/tex; mode=display">p(\theta|\mathcal X)=\frac{p(\mathcal X|\theta)p(\theta)}{p(\mathcal X)}</script><p>其中，$\mathcal X$为给定的数据集。这样得到了后验概率分布，可以用于贝叶斯推断。<br>与上式类似，我们可以得到潜变量的后验分布：</p>
<script type="math/tex; mode=display">p(z|\mathcal X)=\frac{p(\mathcal X|z)p(z)}{p(\mathcal X)},\quad p(\mathcal X|z)=\int p(\mathcal X|z,\theta)p(\theta)d\theta</script><p>但是还是遇到了积分。而且同时将参数和潜变量消掉也非常困难。<br>下面这个式子相对好计算：</p>
<script type="math/tex; mode=display">p(z|\mathcal X,\theta)=\frac{p(\mathcal X|z,\theta)p(z)}{p(\mathcal X|\theta)}</script><blockquote>
<p>补充一下这部分？含义？</p>
</blockquote>
<h1 id="有向图模型（Directed-Graphical-Models-Bayesian-networks）"><a href="#有向图模型（Directed-Graphical-Models-Bayesian-networks）" class="headerlink" title="有向图模型（Directed Graphical Models/Bayesian networks）"></a>有向图模型（Directed Graphical Models/Bayesian networks）</h1><p>将一个随机变量表示为一个有向图的节点，随机变量之间的关系表示为有向图的边，这样可以很好的得出随机变量之间的关系，而且可以将随机变量之间的关系变换转换成有向图的操作.</p>
<h2 id="图的语义（Graph-Semantics）"><a href="#图的语义（Graph-Semantics）" class="headerlink" title="图的语义（Graph Semantics）"></a>图的语义（Graph Semantics）</h2><p>下图表示的是a、b、c三个随机变量，边代表条件概率分布，例如a、b节点，代表$p(b|a)$<br><img src="https://img-blog.csdnimg.cn/20210524173813873.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>所以，一个联合概率分布可以表示为：</p>
<script type="math/tex; mode=display">p(\boldsymbol x)=\prod^K_{k=1}p(x_k|Pa_k)</script><p>其中，$Pa_k$表示节点$x_k$的父节点。<br>对于一个重复N次的伯努利实验的联合概率分布为：<br><img src="https://img-blog.csdnimg.cn/20210524174426163.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>图(b)是一种更加紧凑的表示方法，图 (c)中的$\alpha 、\beta$是潜变量$\mu$的<strong>超参数</strong>（Hyperparameter）也是$\mu$的一个超前驱（hyperprior）</p>
<h2 id="条件概率分布和d-分离（有向分离）（Conditional-Independence-and-d-Separation）"><a href="#条件概率分布和d-分离（有向分离）（Conditional-Independence-and-d-Separation）" class="headerlink" title="条件概率分布和d-分离（有向分离）（Conditional Independence and d-Separation）"></a>条件概率分布和d-分离（有向分离）（Conditional Independence and d-Separation）</h2><p>假设一个互不相交的节点集，$\mathcal A,\mathcal B,\mathcal C$,在$\mathcal C$下，$\mathcal A$与$\mathcal B$条件独立，表示为：</p>
<script type="math/tex; mode=display">\mathcal A \perp \!\!\!\perp\mathcal B\ |\ \mathcal C</script><p><code>有向分离</code>(d-separation)的基本思想：通过贝叶斯网中看两个事件的关系（两个事件是否条件独立），从而简化概率计算。（利用两时间的相互独立的性质）<br>当三个节点满足下面地条件之一的时候，则表示$\mathcal A,\mathcal B$是d-分离的。<br><img src="https://img-blog.csdnimg.cn/2021052515431295.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210525154505655.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>下面的参考博客中有对应结论的推导</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ybdesire/article/details/78998398?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162190960216780264053425%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=162190960216780264053425&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-78998398.first_rank_v2_pc_rank_v29&amp;utm_term=d%E5%88%86%E7%A6%BB&amp;spm=1018.2226.3001.4187">参考</a><br>这里两种情况：</p>
<ol>
<li>若$\mathcal C$不观测，则$P(\mathcal X, \mathcal Y)=\Sigma_\mathcal Z(\mathcal X,\mathcal Y,\mathcal Z)$,只有$P(\mathcal X,\mathcal Y)=P(\mathcal X)P(\mathcal Y)$才能说明$\mathcal X,\mathcal Y$相互独立，也就是$X,Y$<code>有向独立</code>（d-separation）</li>
<li>若观测$\mathcal C$,则使用条件概率公式$P(\mathcal X,\mathcal Y|\mathcal C)=\frac{P(\mathcal X)P(\mathcal C|\mathcal X)P(\mathcal Y|\mathcal C)}{P(\mathcal C)}$,只有满足$P(\mathcal X,\mathcal Y|\mathcal C)=P(\mathcal X|\mathcal Z)P(\mathcal Y|\mathcal C)$才能说明$\mathcal X,\mathcal Y$相互独立，也就是$\mathcal X,\mathcal Y$<code>有向独立</code>（d-separation）</li>
</ol>
<h1 id="模型选择（Model-Selection）"><a href="#模型选择（Model-Selection）" class="headerlink" title="模型选择（Model Selection）"></a>模型选择（Model Selection）</h1><p>越复杂的模型能够表示的数据之间的关系就越多，例如一个二次函数模型，除了能够表示线性关系之外，还可以表示数据之间的二次关系。虽然复杂的模型能够表示更多的数据关系，但是有时候因为数据量比较小，可能会导致<code>过拟合</code>的现象。我们还需要知道如何评估模型在泛化数据下的性能。</p>
<h2 id="嵌套交叉验证（Nested-Cross-Validation）"><a href="#嵌套交叉验证（Nested-Cross-Validation）" class="headerlink" title="嵌套交叉验证（Nested Cross-Validation）"></a>嵌套交叉验证（Nested Cross-Validation）</h2><p><img src="https://img-blog.csdnimg.cn/20210526093453995.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>将数据分为三个部分，第一部分用于训练模型，第二部分用于计算误差：</p>
<script type="math/tex; mode=display">\mathbb E_\mathcal V[\boldsymbol R(\mathcal V| M)]\approx = \frac{1}{K}\sum^K_{k=1}\boldsymbol R(\mathcal V^{(k)}|M)</script><p>其中$\boldsymbol R$代表的是<strong>经验风险</strong>(empirical risk)<br>计算所有模型的经验风险，然后选取经验风险最小的模型作为最终模型，然后利用测试数据计算模型的泛化误差。</p>
<h2 id="贝叶斯模型选择（Bayesian-Model-Selection）"><a href="#贝叶斯模型选择（Bayesian-Model-Selection）" class="headerlink" title="贝叶斯模型选择（Bayesian Model Selection）"></a>贝叶斯模型选择（Bayesian Model Selection）</h2><p>简单的模型较复杂的模型不容易出现过拟合的现象，所以在能够合理拟合数据的情况下，应该尽可能选取简单的模型，这被称为<strong>奥卡姆剃刀</strong>（Occam’s razor）。在贝叶斯概率的应用过程中，定量地体现了一个“自动奥卡姆剃刀”</p>
<blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210526095407220.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="贝叶斯推断中的奥卡姆剃刀"><br>上图中，横坐标表示所有的可能的数据集，纵坐标表示模型对对应数据的拟合程度。我们会选用拟合程度更好的模拟作为最终的模型。</p>
</blockquote>
<p>下图是数据生成过程：<br><img src="https://img-blog.csdnimg.cn/20210526101506995.png" div align="left"><br>第一个表示模型的先验概率，表示模型被选取的概率，第二个表示模型对应的参数的分布，最后一个是模型的生成数据。</p>
<p>用贝叶斯网可以表示为：<br><img src="https://img-blog.csdnimg.cn/20210526101352294.png" div align="left"><br>我们可以利用贝叶斯公式计算后验分布：</p>
<script type="math/tex; mode=display">p(M_k|\mathcal D)\propto p(M_k)p(\mathcal D|M_k)，\quad(*)</script><p>其中的后验分布不依赖于参数$\boldsymbol\theta_i$,因为：</p>
<script type="math/tex; mode=display">p(\mathcal D|M_k)=\int p(\mathcal D|\boldsymbol \theta_k)p(\boldsymbol \theta_k|M_k)d\boldsymbol \theta_k</script><p>这个式子被称为<strong>边际似然</strong>（marginal likelihood）<br>利用(*)式，可以得到极大后验估计：</p>
<script type="math/tex; mode=display">M^*=\operatorname {arg}\max_{M_k}p(M_k|\mathcal D)</script><blockquote>
<p>似然与边际似然有些不同点，前者更容易出现过拟合的现象，后者因为参数被边际化掉了，出现过拟合的现象更小。而且边际似然中嵌套着模型复杂度和数据拟合之间的一个折中。</p>
</blockquote>
<h2 id="模型比较中的贝叶斯因子（Bayes-Factors-for-Model-Comparison）"><a href="#模型比较中的贝叶斯因子（Bayes-Factors-for-Model-Comparison）" class="headerlink" title="模型比较中的贝叶斯因子（Bayes Factors for Model Comparison）"></a>模型比较中的贝叶斯因子（Bayes Factors for Model Comparison）</h2><p>在给定数据集$\mathcal D$和两个模型$M_1,M_2$,想要计算后验分布$p(M_1|\mathcal D) \&amp; \  p(M_2|\mathcal D)$</p>
<script type="math/tex; mode=display">
\underbrace{\frac{p\left(M_{1} \mid \mathcal{D}\right)}{p\left(M_{2} \mid \mathcal{D}\right)}}_{\text {posterior odds(后验相对风险) }}=\frac{\frac{p\left(\mathcal{D} \mid M_{1}\right) p\left(M_{1}\right)}{p(\mathcal{D})}}{\frac{p\left(\mathcal{D} \mid M_{2}\right) p\left(M_{2}\right)}{p(\mathcal{D})}}=\underbrace{\frac{p\left(M_{1}\right)}{p\left(M_{2}\right)}}_{\text {prior odds }} \underbrace{\frac{p\left(\mathcal{D} \mid M_{1}\right)}{p\left(\mathcal{D} \mid M_{2}\right)}}_{\text {Bayes factor }}</script><blockquote>
<p>???<br><img src="https://img-blog.csdnimg.cn/20210526104142218.png" alt="在这里插入图片描述"></p>
</blockquote>
<p>如果选择每一个模型的概率相等，即$\frac {p(M_1)}{p(M_2)}=1$,则可以根据贝叶斯因子与1的关系，选择模型。</p>
<blockquote>
<p><strong>信息准则</strong>（information criteria）：<br><strong>Akaike information criterion</strong>：$\log p(x|\theta)-M$corrects for the bias of the maximum likelihood estimator by addition of a penalty term to compensate for the overfitting of more complex models with lots of parameters.<br>其中，M表示参数的个数<br><strong>Bayesian information criterion (BIC)</strong></p>
<script type="math/tex; mode=display">\log p(x)=\log\int p(x|\boldsymbol\theta)p(\boldsymbol\theta)d\boldsymbol\theta\approx\log p(x|\boldsymbol\theta)-\frac{1}{2}M\log N</script><p>这里N表示数据集，M表示参数个数<br><u><strong>这部分遇到的时候在详细学习</strong></u></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">39</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
