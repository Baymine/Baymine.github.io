<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-01-16T11:35:05.596Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GeePRC notes</title>
    <link href="http://example.com/2023/01/05/GeePRC-notes/"/>
    <id>http://example.com/2023/01/05/GeePRC-notes/</id>
    <published>2023-01-05T08:48:47.000Z</published>
    <updated>2023-01-16T11:35:05.596Z</updated>
    
    <content type="html"><![CDATA[<h2 id="项目大纲"><a href="#项目大纲" class="headerlink" title="项目大纲"></a>项目大纲</h2><ul><li><p>codec.go</p><ul><li>报文Header</li><li>消息体编码解码的接口 Codec<ul><li>读取报头</li><li>读取主体</li><li>写入报头的方法</li></ul></li><li>Codec的构造函数</li><li>可选用的编码方式<ul><li>存储在一个map中<ul><li>不同的编码方式调用不同的codec构造函数</li></ul></li></ul></li></ul></li><li><p>gob.go</p><ul><li>gob结构体</li><li>GobCodec实现接口codec</li></ul></li><li><p>server.go</p><ul><li>Option<ul><li>标识<ul><li>Magic number</li></ul></li><li>编码方式</li><li>默认的Option</li></ul></li></ul></li><li><p>main.go</p><ul><li>创建一个监听者<ul><li>通过一个协程在执行</li><li>协程中的得到的地址通过管道通知主线程</li></ul></li><li>确定编码方式</li><li>发送接收<ul><li>创建报头</li><li>写入<ul><li>cc.Write()</li></ul></li><li>接收回应<ul><li>cc.ReadHeader()</li></ul></li></ul></li></ul></li></ul><h2 id="bug"><a href="#bug" class="headerlink" title="bug"></a>bug</h2><p>day5, go run main.go:<br>rpc server: register Foo.Sum<br>rpc server debug path: &#x2F;debug&#x2F;geerpc<br>call Foo.Sum error:rpc server: request handle timeout: expect within 10ns<br>exit status 1</p><h2 id="Chanllenge"><a href="#Chanllenge" class="headerlink" title="Chanllenge"></a>Chanllenge</h2><h3 id="网络粘包"><a href="#网络粘包" class="headerlink" title="网络粘包"></a>网络粘包</h3><p>执行 <code>go test -v</code> 会有一定概率出现测试卡死无响应的bug<br><a href="https://github.com/geektutu/7days-golang/issues/26">issue</a></p><h2 id="Great-designs"><a href="#Great-designs" class="headerlink" title="Great designs"></a>Great designs</h2><h3 id="使用通道实现超时判断"><a href="#使用通道实现超时判断" class="headerlink" title="使用通道实现超时判断"></a>使用通道实现超时判断</h3><p>在goroutine中，完成一步之后往管道内传入<code>struct &#123;&#125;&#123;&#125;</code>这样，在goroutine外部就可以接收到这些信息，这样外部就知道goroutine内部某个函数完成了，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">callChannel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">  err := call(args)</span><br><span class="line">  callChannel &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> &lt;-time.After(timeout):  <span class="comment">// 处理超时</span></span><br><span class="line">    timeout handling</span><br><span class="line">  <span class="keyword">case</span> &lt;-callChannel:</span><br><span class="line">    function finished</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Knowledges"><a href="#Knowledges" class="headerlink" title="Knowledges"></a>Knowledges</h2><h3 id="如何结束一个goroutine"><a href="#如何结束一个goroutine" class="headerlink" title="如何结束一个goroutine"></a>如何结束一个goroutine</h3><p>利用管道传入一个结束信息（这里是true），然后返回函数即可</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;- quit:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">// Do other stuff</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do stuff</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Quit goroutine</span></span><br><span class="line">quit &lt;- <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="encoding-x2F-gob"><a href="#encoding-x2F-gob" class="headerlink" title="encoding&#x2F;gob"></a>encoding&#x2F;gob</h3><ul><li>Package gob 管理 gobs 流 - 在编码器（发送器）和解码器（接收器）之间交换的二进制值</li><li><pre><code class="go">enc := gob.NewEncoder(&amp;network) // 将写入网络。dec := gob.NewDecoder(&amp;network) // 将从网络上读取。// Encoding（发送）一些值。err := enc.Encode(P&#123;3, 4, 5, &quot;Pythagoras&quot;&#125;)// 接收var q Qerr = dec.Decode(&amp;q)</code></pre></li></ul><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><h3 id="Context-package"><a href="#Context-package" class="headerlink" title="Context package"></a>Context package</h3><ul><li>context 主要用来在 goroutine 之间传递上下文信息，包括：取消信号、超时时间、截止时间、k-v 等。</li><li>一句话：context 用来解决 goroutine 之间 <code>退出通知</code>、<code>元数据传递</code>的功能。</li><li><img src="https://pic3.zhimg.com/80/v2-6a27526f536505cea08a5813ccce05b2_720w.webp"></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;项目大纲&quot;&gt;&lt;a href=&quot;#项目大纲&quot; class=&quot;headerlink&quot; title=&quot;项目大纲&quot;&gt;&lt;/a&gt;项目大纲&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;codec.go&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;报文Header&lt;/li&gt;
&lt;li&gt;消息体编码解码的接口 Co</summary>
      
    
    
    
    
    <category term="Projects" scheme="http://example.com/tags/Projects/"/>
    
  </entry>
  
  <entry>
    <title>C++ Memory Management</title>
    <link href="http://example.com/2022/12/18/C-Memory-Management/"/>
    <id>http://example.com/2022/12/18/C-Memory-Management/</id>
    <published>2022-12-18T07:04:19.000Z</published>
    <updated>2022-12-21T09:08:01.289Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一讲-primitives"><a href="#第一讲-primitives" class="headerlink" title="第一讲 primitives"></a>第一讲 primitives</h1><h3 id="1-overview"><a href="#1-overview" class="headerlink" title="1. overview"></a>1. overview</h3><ul><li>资料： <a href="http://gee.cs.oswego.edu/dl/">DL Malloc</a></li><li>涉及的库</li></ul><p><img src="/.com//C-Memory-Management/1671347745514.png" alt="1671347745514"></p><h3 id="2、3-内存分配的每一层面及基本用法"><a href="#2、3-内存分配的每一层面及基本用法" class="headerlink" title="2、3. 内存分配的每一层面及基本用法"></a>2、3. 内存分配的每一层面及基本用法</h3><p><img src="/.com//C-Memory-Management/1671348085106.png" alt="1671348085106"></p><p>本课程只考虑CRT以上的层次。</p><p><strong>基本工具</strong></p><p><img src="/.com//C-Memory-Management/1671348161500.png" alt="1671348161500"></p><p><strong>基本用法</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* p3 = ::<span class="keyword">operator</span> <span class="built_in">new</span> (<span class="number">512</span>);   <span class="comment">// 512 bytes</span></span><br><span class="line">::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(p3)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __BORLANDC__  <span class="comment">// 不同库不同</span></span></span><br><span class="line"><span class="comment">// 申请5个int。 一般容器中使用</span></span><br><span class="line"><span class="type">int</span>* p4 = <span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">allocate</span>(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">deallocate</span>(p4, <span class="number">5</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __GNUC__   <span class="comment">// 较早版本中</span></span></span><br><span class="line"><span class="type">void</span>* p4 = alloc::<span class="built_in">allocate</span>(<span class="number">512</span>);</span><br><span class="line">alloc::<span class="built_in">deallocate</span>(p4, <span class="number">512</span>);</span><br><span class="line"> <span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="4、5、6、基本构件——new-delete-expression"><a href="#4、5、6、基本构件——new-delete-expression" class="headerlink" title="4、5、6、基本构件——new delete expression"></a>4、5、6、基本构件——new delete expression</h3><p>new 中实际上就是在调用malloc</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class_name* pc = <span class="keyword">new</span> <span class="built_in">class_name</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器转换为</span></span><br><span class="line"><span class="comment">// 加上try catch</span></span><br><span class="line"><span class="type">void</span>* mem = <span class="keyword">operator</span> <span class="built_in">new</span>(<span class="built_in">sizeof</span>(class_name));</span><br><span class="line">pc = <span class="built_in">static_cast</span>&lt;class_name*&gt;(mem);</span><br><span class="line">pc-&gt;class_name::<span class="built_in">class_name</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 只有编译其才能这样调用构造函数</span></span><br><span class="line"><span class="comment">// 但是可以直接调用析构函数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="7、Array-new"><a href="#7、Array-new" class="headerlink" title="7、Array new"></a>7、Array new</h3><p>当new一个数组的时候，系统会使用4个字节存放数组的一些信息，即为下图中的 <code>cookie</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Complex* pca = <span class="keyword">new</span> Complex[<span class="number">3</span>];</span><br></pre></td></tr></table></figure><p><img src="/.com//C-Memory-Management/1671438018665.png" alt="1671438018665"></p><ul><li>在进行array new的时候，单个元素不会独自进行内存对齐。</li><li>构建的时候是从上往下，析构的时候是由下往上</li><li><img src="/.com//C-Memory-Management/1671439085184.png" alt="1671439085184"><ul><li><code> 61h</code>就是cokie，需要进行内存对齐（VC6)中是16位对齐</li><li>对于申请的int类型的数组，可以直接使用delete，因为这些数据类型没有析构函数，</li></ul></li><li><img src="/.com//C-Memory-Management/1671440046493.png" alt="1671440046493"><ul><li>因为数组个数被写入，所以内存的整体布局会发生变化，所以不能直接用 <code>delete</code>来回收</li><li><code>61h</code>的大小计算<ul><li>类大小<em>类个数&#x3D;((3</em>4) * 3) &#x3D; 36\ 上下debugger header &#x3D; 32 + 4\ 两个61h&#x3D;4*2&#x3D;8</li><li>最后向16的倍数内存对齐最后的 <code>pad</code></li></ul></li></ul></li></ul><h3 id="8-palcement-new"><a href="#8-palcement-new" class="headerlink" title="8.palcement new"></a>8.palcement new</h3><p>允许将对象构造与已分配的内存中</p><p><img src="/.com//C-Memory-Management/1671441329456.png" alt="1671441329456"></p><h3 id="9-random"><a href="#9-random" class="headerlink" title="9.random"></a>9.random</h3><ul><li>placement new 的重载</li><li>嵌入式指针使用案例（内存池）<ul><li>通过一次性申请一定量的内存，减少每个内存中的cookie的数量，同时减少malloc的调用</li><li>整个内存是通过一个链表管理的，释放内存就是将空闲的内存插入到链表头部</li><li>但是申请的内存没有真正释放，所以可能会存在使用峰值的问题</li></ul></li></ul><p><img src="/.com//C-Memory-Management/1671541094430.png" alt="1671541094430"></p><ul><li>可以自定义handler来让更多的空间可用，或者调用abort() 或 exit();</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set_new_handler</span>(handlerFunctionPoint);</span><br></pre></td></tr></table></figure><ul><li>default, delete 关键字</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第一讲-primitives&quot;&gt;&lt;a href=&quot;#第一讲-primitives&quot; class=&quot;headerlink&quot; title=&quot;第一讲 primitives&quot;&gt;&lt;/a&gt;第一讲 primitives&lt;/h1&gt;&lt;h3 id=&quot;1-overview&quot;&gt;&lt;a hr</summary>
      
    
    
    
    
    <category term="侯捷C++" scheme="http://example.com/tags/%E4%BE%AF%E6%8D%B7C/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.S081</title>
    <link href="http://example.com/2022/12/16/MIT6-S081/"/>
    <id>http://example.com/2022/12/16/MIT6-S081/</id>
    <published>2022-12-16T03:53:01.000Z</published>
    <updated>2022-12-30T01:54:18.556Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Reading"><a href="#Reading" class="headerlink" title="Reading"></a>Reading</h1><h3 id="Chapter-1-Operating-system-interfaces"><a href="#Chapter-1-Operating-system-interfaces" class="headerlink" title="Chapter 1: Operating system interfaces"></a>Chapter 1: Operating system interfaces</h3><ul><li><p>the shell is a user program, and not part of the kernel</p></li><li><p>Although the child has the same memory contents as the parent initially, the parent and child are executing with different memory and different registers: changing a variable in one does not affect the other.</p></li><li><p><code>exec</code> replaces the calling process’s memory but preserves its file table</p><ul><li><code>exec</code> replaces the memory and registers of the current process with a new program</li></ul></li><li><p>I&#x2F;O and File descriptors</p><ul><li>The shell ensures that it always has three file descriptors open<ul><li>std input, std output, std error</li><li>先close(0); 然后open, 让文件描述符与读相连接</li></ul></li><li>read(fd, buf, n)</li><li>write(fd, buf, n)</li><li><code>dup</code> system call duplicates an existing file descriptor, returning a new one that refers to the same underlying I&#x2F;O object.</li><li>File descriptors are a powerful abstraction, because they hide the details of what they are connected to</li></ul></li><li><p>1.3 Pipes</p><ul><li>A pipe is a small kernel buffer exposed to processes as a pair of file descriptors, one for reading and one for writing.</li><li>命令行pipe实例： grep fork sh.c | wc -l 程序会分别为两个程序创建一个子进程，并递归地运行命令（可能会出现多管道的现象， a | b | c）</li><li>与重定向的优势<ul><li>会自动清理（重定向需要小心清理临时文件）</li><li>能传入任意长的数据流（重定向需要足够的disk空间存储所有的数据）</li><li>能够并行执行（重定向只能串行）</li></ul></li></ul></li><li><p>1.4 File system</p><ul><li><code>chdir</code>: change current directory</li><li><code>mkdir</code> creates a new directory, <code>open</code> with the <code>O_CREATE</code> flag creates a new data file, and <code>mknod</code> creates a new device file</li><li>The <code>link</code> system call creates another file system name referring to the same inode as an existing file.</li><li>The <code>fstat</code> system call retrieves information from the inode that a file descriptor refers to. It fills in a <code>struct stat</code>, defined in <code>stat.h</code><ul><li>Each inode is identified by a unique <code>inode number</code>.</li><li>The file’s inode and the disk space holding its content are only freed when the file’s link count is zero and no file descriptors refer to it(using <code>unlink</code>)</li></ul></li><li>sum-up： 文件目录变换，文件的结构和信息，文件的创建和关闭，Unix中运行文件相关命令的方法</li></ul></li></ul><h3 id="Chapter-2-Operating-system-organization"><a href="#Chapter-2-Operating-system-organization" class="headerlink" title="Chapter 2: Operating system organization"></a>Chapter 2: Operating system organization</h3><ul><li><p>Thus an operating system must fulfill three requirements: multiplexing, isolation, and interaction.</p></li><li><p>2.1 Abstracting physical resources</p><ul><li>通过函数结构访问disk的优势（让OS管理内存）</li></ul></li><li><p>2.2 User mode, supervisor mode, and system calls</p><ul><li>Machine mode<ul><li>have full privilege; a CPU starts in machine mode. Machine mode is mostly intended for configuring a computer.</li></ul></li><li>Supervisor mode(Kernel space)<ul><li>the CPU is allowed to execute privileged instructions<ul><li>If running privileged instructions in user mode, CPU wouldn’t execute it, but switch to the supervisor mode to terminate it</li></ul></li><li>the kernel control the entry point for transitions to supervisor mode</li></ul></li><li>User mode(User space)</li><li>实现程序之间隔离的方法</li></ul></li><li><p>2.3 Kernel organization</p><ul><li><p>monolithic kernel</p><ul><li>The <strong>entire operating system resides in the kernel</strong>, so that the implementations of all system calls run in supervisor mode</li><li><code>Pros</code>: Easy to cooperate, doesn’t have to decide which part of the operating system doesn’t need full hardware privileg</li><li><code>Cons</code>: 1. the interfaces between different parts of the operating system are often complex 2. a mistake is fatal, because an error in supervisor mode will often cause the kernel to fail</li></ul></li><li><p>microkernel</p><ul><li>minimize the amount of operating system code that runs in supervisor mode</li><li><img src="/.com//microkernel.png" alt="img"></li><li>the kernel provides an <code>inter-process communication mechanism</code> to send messages from one user-mode process to another</li><li>OS services running as processes are called servers.<ul><li>it sends a message to the file server and waits for a response.</li></ul></li></ul></li><li><p>sum-up： 两种不同的内核设计方式</p></li></ul></li><li><p>2.5 Process overview</p><ul><li>The unit of isolation is a process.</li><li>The mechanisms used by the kernel to implement processes include the user&#x2F;supervisor mode flag, address spaces, and time-slicing of threads</li><li>Xv6 maintains a separate page table for each process that defines that process’s address space<ul><li><p><img src="/.com//virtual%20address%20space.png" alt="img"></p><ul><li>the trampoline page contains the code to transition in and out of the kernel</li><li>mapping the trapframe is necessary to save&#x2F;restore the state of the user process</li></ul></li><li><p>The xv6 kernel maintains many pieces of state for each process, which it gathers into a <code>struct proc</code></p><ul><li>most important pieces of kernel state are its page table, its kernel stack, and its run state.</li></ul></li><li><p>Context switch between user space and kernel space</p><ul><li>To switch transparently between processes, the kernel suspends the currently running thread and resumes another process’s thread.</li><li>Each process has two stacks: a user stack and a kernel stack (<code>p-&gt;kstack</code>)<ul><li>the kernel can execute even if a process has wrecked its user stack.</li></ul></li><li><code>ecall</code>: change to kernel space; <code>sret</code>: to user space</li></ul></li></ul></li><li>Sum-up<ul><li>an address space to give a process the illusion of its own memory, and, a thread, to give the process the illusion of its own CPU</li><li>如何利用进程实现隔离性的以及进程的工作方式</li></ul></li></ul></li><li><p>2.7 Security Model</p><ul><li>Safeguards<ul><li>Assertions, type checking, stack guard pages, etc.</li></ul></li></ul></li></ul><h3 id="Chapter-3-Page-tables"><a href="#Chapter-3-Page-tables" class="headerlink" title="Chapter 3: Page tables"></a>Chapter 3: Page tables</h3><ul><li><p>provides each process with its own private address space and memory</p></li><li><p>Xv6 performs a few tricks: mapping the same memory (a trampoline page) in several address spaces, and guarding kernel and user stacks with an unmapped page.</p></li><li><p>3.1 Paging hardware</p><ul><li><p>The structure of page table</p><ul><li><img src="/.com//pageTable.png" alt="img"></li></ul></li><li><p>Address translation</p><ul><li>A page table is stored in physical memory as a three-level tree. (first nine bits is used for indexing PPN of each <code>page directory</code>. and etc.)</li><li>If page is not found, raise <code>page-fault exception</code></li><li>In the common case in which large ranges of virtual addresses have no mappings, the three-level structure can omit entire page directories.(Allocate pages when they are needed)</li><li>flag bits that tell the paging hardware how the associated virtual address is allowed to be used<ul><li><strong>每个PTE都包含标志位，说明虚拟地址的使用权限。</strong><ul><li><code>PTE_V</code>表示 PTE 是否存在于页表中：如果未设置，那么一个对该页的引用会引发错误(也就是：不允许被使用（ <strong>validity</strong> ）)。</li><li><code>PTE_W</code>控制着能否对页执行写操作；</li><li><code>PTE_R</code> 控制是否允许使用指令读取页。</li><li><code>PTE_X</code>控制CPU是否可以将页面内容解释为指令并执行它们。</li><li><code>PTE_U</code>控制着用户程序能否使用该页；如果不能，则只有内核能够使用该页。</li></ul></li></ul></li><li><code>satp</code>: the physical address of the root pagetable page<ul><li>each CPU has its own <code>satp</code>(different CPUs can run different processes)</li></ul></li><li></li><li><img src="/.com//address%20translation.png" alt="img"></li></ul></li><li><p>Translation Look-aside Buffer (TLB)</p><ul><li>Motivation: To avoid the cost of loading PTEs from physical memory<ul><li>a potential downside of three levels is that the CPU must load three PTEs from memory to perform the translation of the virtual address in the load&#x2F;store instruction to a physical address.</li></ul></li><li>when xv6 changes a page table, it must tell the CPU to invalidate corresponding cached TLB entries.</li></ul></li></ul></li><li><p>3.2 Kernel address space</p><ul><li>Xv6 maintains one page table per process, describing each process’s user address space, plus a single page table that describes the kernel’s address space</li><li>The kernel gets at RAM and memory-mapped device registers using “direct mapping;<ul><li>Direct mapping simplifies kernel code that reads or writes physical memory.</li></ul></li><li>The guard page’s PTE is invalid (i.e.,PTE_V is not set), so that if the kernel overflows a kernel stack, it will likely cause an exception</li><li><img src="/.com//kernel%20address%20space.png" alt="img"></li></ul></li><li><p>3.4 Physical memory allocation</p><ul><li>The kernel must allocate and free physical memory at run-time for page tables, user memory, kernel stacks, and pipe buffers.</li><li>Allocation consists of removing a page from the linked list; freeing consists of adding the freed page to the list.</li></ul></li><li><p>3.6 Process address space</p><ul><li><img src="/.com//user%20addr%20space.png" alt="img"></li><li>A process’s user memory starts at virtual address zero and can grow up to <code>MAXVA</code>(The max bits the address can take)</li><li>Xv6 maps the data, stack, and heap with the permissions <code>PTE_R</code>, <code>PTE_W</code>, and <code>PTE_U</code>.<ul><li>Avoid the program modifies the unexpected regions.(the hardware will refuse to execute the store and raises a page fault)</li></ul></li></ul></li></ul><h5 id="Lecture-Note"><a href="#Lecture-Note" class="headerlink" title="Lecture Note"></a>Lecture Note</h5><ul><li>Address space<ul><li>pagetable<ul><li>implemented in hardware by the processor or by unit called MMU</li><li>CPU–VA–&gt;MMU—PA—&gt;Memory<ul><li><code>satp</code>: In CPU, this register is used to specify where the map is(VA-&gt;PA). Each one process has unique address for the map(This is writen by the kernel for isolation)</li><li>MMU: 读取内存并转换，不保存映射</li></ul></li><li>The max bits of the virtual address is determined by the number of the registers</li></ul></li></ul></li><li>paging hardware(RISC-V)</li><li>xv6 virtual memory code and layout of the kernel address spaces and user address spaces</li><li>多级页表中存储PPN是44位的，末尾加上12个0，得到56位物理地址，这就是下一级页表的物理地址<ul><li>多次访问耗费时间，所以使用TLB（快表）[VA, PA] mapping</li></ul></li><li>MMU —hardware</li></ul><h3 id="Chapter-4-Traps-and-system-calls"><a href="#Chapter-4-Traps-and-system-calls" class="headerlink" title="Chapter 4 Traps and system calls"></a>Chapter 4 Traps and system calls</h3><ul><li><p>CPU Interrupt</p><ul><li><p>Cases</p><ul><li>system call</li><li>exception</li><li>device interrupt<ul><li>While commonality among the three trap types suggests that a kernel could handle all traps with a single code path, it turns out to be convenient to have separate code for three distinct cases: traps from user space, traps from kernel space, and timer interrupts.</li></ul></li></ul></li><li><p>The usual sequence</p><ul><li>a trap forces a transfer of control into the kernel</li><li>the kernel saves registers and other state</li><li>the kernel restores the saved state and returns from the trap</li><li>original code resumes where it left off</li></ul></li><li><p>For what</p><ul><li>isolation demands that only the kernel be allowed to use devices</li><li>the kernel is a convenient mechanism with which to share devices among multiple processes</li></ul></li></ul></li><li><p>4.1 RISC-V trap machinery</p><ul><li>Each RISC-V CPU has a set of control registers that the kernel writes to tell the CPU how to handle traps, and that the kernel can read to find out about a trap that has occurred.</li><li>sum-up: CPU用专用的寄存器完成上下文转换。但为了trap的效率CPU并不会将所有任务都完成，剩余的工作需要由内核软件完成</li></ul></li><li><p>4.2 Traps from user space</p><ul><li>Occur if the user program makes a system call (<code>ecall</code> instruction), or does something illegal, or if a device interrupts</li><li>RISC-V hardware does not switch page tables when it forces a trap<ul><li>Things need to do<ul><li>trap handling code needs to switch to the kernel page table</li><li>the kernel page table must also have a mapping for the handler pointed to by stvec</li></ul></li><li>Trampoline page<ul><li><blockquote><p>Trampoline page <strong>stores code to switch between user and kernel space</strong>. The code is mapped at the same virtual address (TRAMPOLINE) in user and kernel space so that it continues to work when it switches page tables.</p></blockquote></li></ul></li><li><code>TRAPFRAME</code><ul><li>address of <code>TRAPFRAME</code> is stored in <code>sscratch</code> register. Saves all the user registers there, including the user’s a0, read back from sscratch.</li><li><code>TRAPFRAME</code> also contain the kernel information and the address of <code>usertrap</code> function.<ul><li><code>usertrap</code>: The job of <code>usertrap</code> is to determine the cause of the trap, process it, and return</li></ul></li></ul></li></ul></li><li>Pointer as argument on system call<ul><li>Problems<ul><li>Invalid pointer</li><li>kernel page table mappings are not the same as the user page table mappings so the kernel cannot use ordinary instructions to load or store from user-supplied addresses.</li></ul></li><li>Find PA by using user space page table and map it to the VA in the kernel space.</li></ul></li><li>sum-up: 在用户空间中调用trap。</li></ul></li><li><p>4.5 Traps from kernel space</p></li><li><p>4.6 Page-fault exceptions</p><ul><li><p>Actions</p><ul><li>In user space: kill the faulting process</li><li>In kernel space: kernel panics<ul><li><blockquote><p><strong>内核错误 (Kernel panic</strong> )是指操作系统在监测到内部的致命错误，并无法安全处理此错误时采取的动作。</p></blockquote></li></ul></li></ul></li><li><p>three kinds of page fault</p><ul><li>load page faults (when a load instruction cannot translate its virtual address)</li><li>store page faults (when a store instruction cannot translate its virtual address)</li><li>instruction page faults (when the address in the program counter doesn’t translate)</li></ul></li><li><p>The applications of page-fault exception</p><ul><li><p>copy-on-write fork</p><ul><li>Procedure<ul><li>the parent and child to initially share all physical pages, but for each to map them read-only</li><li>Write to that memory will raise a page-fault exception</li><li>The kernel’s trap handler responds by allocating a new page of physical memory and<br>copying into it the physical page that the faulted address maps to.</li></ul></li></ul></li><li><p>Lazy allocation</p><ul><li>Procedure<ul><li>application asks for more memory by calling <code>sbrk</code></li><li>The kernel notes the increase in size, but does not allocate memory or create PTEs</li><li>When page-fault occurs in those address, the kernel allocates a page of physical memory and maps it into the page table</li></ul></li><li>Since applications often ask for more memory than they need</li><li>Problem<ul><li>The extra overhead introduced by kernel&#x2F;user transition<ul><li>reduce this cost by allocating a batch of consecutive pages per page fault instead of one page</li><li>specializing the kernel entry&#x2F;exit code for such page-faults.</li></ul></li></ul></li></ul></li><li><p>demand paging(需求分页)</p><ul><li><p>Problem</p><ul><li>Since applications can be large and reading from disk is expensive, this startup cost may be noticeable to users</li></ul></li><li><p>Solution</p><ul><li>a modern kernel creates the page table for the user address space, but marks the PTEs for the pages invalid</li><li>On a page fault, the kernel reads the content of the page from disk and maps it into the user address space</li></ul></li></ul></li><li><p>paging to disk</p><ul><li><p>Problem</p><ul><li>The programs running on a computer may need more memory than the computer has RAM</li></ul></li><li><p>Solution</p><ul><li>to store only a fraction of user pages in RAM, and to store the rest on disk in a paging area.</li><li>The memory stored in the paging area is set as invalid.</li><li>Access paging area will incur a page fault. The kernel trap handler will allocate a page of physical RAM, read the page from disk into the RAM, and modify the relevant PTE to point to the RAM</li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="Chapter5-Interrupts-and-device-drivers"><a href="#Chapter5-Interrupts-and-device-drivers" class="headerlink" title="Chapter5 Interrupts and device drivers"></a>Chapter5 Interrupts and device drivers</h3><ul><li>A driver is the code in an operating system that<ul><li>manages a particular device: it configures the device hardware tells the device to perform operations</li><li>handles the resulting interrupts</li><li>interacts withprocesses that may be waiting for I&#x2F;O from the device.</li></ul></li><li>device drivers execute code in two contexts<ul><li>top half that runs in a process’s kernel thread<ul><li>ask the hardware to start an operation</li><li>wait for the operation complete</li><li>raise an interrupt when the code is completed</li></ul></li><li>a bottom half that executes at interrupt time.<ul><li>what operation has completed, wakes up a waiting process if appropriate</li><li>tells the hardware to start work on any waiting next operation</li></ul></li></ul></li><li>A general pattern to note is the decoupling of device activity from process activity via buffering<br>and interrupts. (This idea is sometimes called <code>I/O concurrency</code>.)<ul><li>This decoupling can increase performance by allowing processes to execute concurrently with device I&#x2F;O</li></ul></li><li>驱动程序完全禁用中断，并定期检查设备是否需要注意。这种技术被称为轮询（polling）<ul><li>如果设备执行操作非常快，轮询是有意义的，但是如果设备大部分空闲，轮询会浪费CPU时间。一些驱动程序根据当前设备负载在轮询和中断之间动态切换。</li></ul></li><li>程序I&#x2F;O很简单，但速度太慢，无法在高数据速率下使用。需要高速移动大量数据的设备通常使用直接内存访问（DMA）<ul><li>DMA设备硬件直接将传入数据写入内存，并从内存中读取传出数据。</li><li>一些操作系统能够直接在用户空间缓冲区和设备硬件之间移动数据，通常带有DMA。</li></ul></li></ul><h3 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h3><ul><li><p>锁的缺点是它们会扼杀性能，因为它们会串行化并发操作</p></li><li><p>竞态条件是指多个进程读写某些共享数据（至少有一个访问是写入）的情况</p><ul><li>在内存池中，两个进程并行地释放内存，那么可能会导致释放的内存被放到同一个地址中，从而变成了覆盖</li><li><code>acquire</code>和 <code>release</code>之间的指令序列通常被称为临界区域（critical section）。（加锁的区域）</li><li>代码在执行的时候，依托一些 <code>不变量</code>(相当于一些条件)，但是其他进程对这个变量的操作暂时改变了这种不变量，所以导致代码运行错误。（上面就是链表头部指针有一个时间段中不是指向链表头部的，这时候其他进程的操作就可能导致竞态）</li><li>以将锁视为串行化（serializing）并发的临界区域，以便同时只有一个进程在运行这部分代码，从而维护不变量（假设临界区域设定了正确的隔离性）</li></ul></li><li><p>冲突</p><ul><li>如果多个进程同时想要相同的锁或者锁经历了争用，则称之为发生冲突（conflict）</li></ul></li><li><p>要使用多少锁，以及每个锁应该保护哪些数据和不变量</p><ul><li>任何时候可以被一个CPU写入，同时又可以被另一个CPU读写的变量，都应该使用锁来防止两个操作重叠</li><li>锁保护不变量（invariants）：如果一个不变量涉及多个内存位置，通常所有这些位置都需要由一个锁来保护，以确保不变量不被改变。</li><li>大内核锁（big kernel lock）<ul><li>如果并行性不重要，那么可以安排只拥有一个线程，而不用担心锁。一个简单的内核可以在多处理器上做到这一点，方法是拥有一个锁，这个锁必须在进入内核时获得，并在退出内核时释放</li></ul></li></ul></li><li><p>死锁和锁排序</p><ul><li>如果在内核中执行的代码路径必须同时持有数个锁，那么所有代码路径以相同的顺序获取这些锁是很重要的（否则有死锁的风险）</li><li>全局锁获取顺序的需求意味着锁实际上是每个函数规范的一部分：调用者必须以一种使锁按照约定顺序被获取的方式调用函数。</li></ul></li><li><p>锁和中断处理函数</p><ul><li>一个进程中持有一个变量，在执行过程中出现了中断，而中断处理函数可能又会需要访问这个变量，这时候处理函数就会等待这个变量被释放，这时候就产生了死锁<ul><li>如果一个自旋锁被中断处理程序所使用，那么CPU必须保证在启用中断的情况下永远不能持有该锁。</li></ul></li></ul></li><li><p>Re-entrant locks</p><ul><li>It might appear that some deadlocks and lock-ordering challenges could be avoided by using re-entrant locks, which are also called recursive locks.<ul><li>if the lock is held by a process and if that process attempts to acquire the lock again, then the kernel could just allow this</li></ul></li></ul></li><li><p>指令和内存访问顺序</p><ul><li>规则确实允许重新排序后改变并发代码的结果，并且很容易导致多处理器上的不正确行为。CPU的排序规则称为内存模型（memory model）。</li><li><code>__sync_synchronize()</code>是一个内存障碍：它告诉编译器和CPU不要跨障碍重新排序 <code>load</code>或 <code>store</code>指令。</li></ul></li><li><p>睡眠锁</p><ul><li>因为等待会浪费CPU时间，所以自旋锁最适合短的临界区域；睡眠锁对于冗长的操作效果很好。</li></ul></li></ul><h3 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h3><ul><li><p>任何操作系统都可能运行比CPU数量更多的进程，所以需要一个进程间分时共享CPU的方案</p><ul><li>通过将进程多路复用到硬件CPU上，使每个进程产生一种错觉，即它有自己的虚拟CPU</li></ul></li><li><p>多路复用</p><ul><li>情景<ul><li>进程等待设备或管道I&#x2F;O完成，或等待子进程退出，或在 <code>sleep</code>系统调用中等待时，xv6使用睡眠（sleep）和唤醒（wakeup）机制切换</li><li>xv6周期性地强制切换以处理长时间计算而不睡眠的进程。</li></ul></li></ul></li><li><p>协程</p><ul><li>在两个线程之间进行这种样式化切换的过程有时被称为协程（coroutines）<ul><li>协程运行在线程之上，当一个协程执行完成后，可以选择主动让出，让另一个协程运行在当前线程之上。 <strong>协程并没有增加线程数量，只是在线程的基础之上通过分时复用的方式运行多个协程</strong> ，而且协程的切换在用户态完成，切换的代价比线程从用户态到内核态的代价小很多。</li><li><img src="https://pic3.zhimg.com/80/v2-f4fb2dea86d909ed60498b7021d0fe66_720w.webp" alt="img"></li><li>每个线程中运行多个协程</li><li><strong>协程只有和异步IO结合起来才能发挥出最大的威力。</strong><ul><li>假设协程运行在线程之上，并且协程调用了一个阻塞IO操作，这时候会发生什么？实际上操作系统并不知道协程的存在，它只知道线程，<strong>因此在协程调用阻塞IO操作的时候，操作系统会让线程进入阻塞状态，当前的协程和其它绑定在该线程之上的协程都会陷入阻塞而得不到调度，这往往是不能接受的。</strong></li></ul></li></ul></li><li>sleep 和 wakeup<ul><li>Xv6使用了一种称为 <code>sleep</code>和 <code>wakeup</code>的方法，它允许一个进程在等待事件时休眠，而另一个进程在事件发生后将其唤醒。睡眠和唤醒通常被称为序列协调（sequence coordination）或条件同步机制（conditional synchronization mechanisms）。<ul><li><code>Sleep(chan)</code>在任意值 <code>chan</code>上睡眠，称为等待通道（wait channel）。 释放CPU用于其他任务</li><li><code>Wakeup(chan)</code>唤醒所有在 <code>chan</code>上睡眠的进程（如果有），使其 <code>sleep</code>调用返回。</li><li>为了防止死锁，使用 <code>条件锁</code>，让进程在睡眠之后释放锁<ul><li><code>条件锁</code>就是所谓的条件变量，某一个线程因为某个条件为满足时可以使用条件变量使该程序处于阻塞状态。一旦条件满足以“信号量”的方式唤醒一个因为该条件而被阻塞的线程。</li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><ul><li>文件系统的目的是组织和存储数据</li><li>解决的问题<ul><li>文件系统需要磁盘上的数据结构来表示目录和文件名称树，记录保存每个文件内容的块的标识，以及记录磁盘的哪些区域是空闲的。</li><li>文件系统必须支持崩溃恢复（crash recovery）。</li><li>文件系统代码必须协调以保持不变量（不同的进程可能在相同的文件系统上运行）</li><li>文件系统必须保持常用块的内存缓存（访问磁盘慢）</li></ul></li></ul><table><thead><tr><th>文件描述符（File descriptor）</th></tr></thead><tbody><tr><td>路径名（Pathname）</td></tr><tr><td>目录（Directory）</td></tr><tr><td>索引结点（Inode）</td></tr><tr><td>日志（Logging）</td></tr><tr><td>缓冲区高速缓存（Buffer cache）</td></tr><tr><td>磁盘（Disk)</td></tr></tbody></table><p><img src="/.com//Structure%20of%20file%20system.png"></p><ul><li>日志<ul><li>日志驻留在超级块中指定的未知。</li><li>事务中途奔溃将导致日志头块中的计数为0，提交后奔溃将导致非零计数</li></ul></li></ul><h1 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h1><h2 id="Lecture-3-OS-design"><a href="#Lecture-3-OS-design" class="headerlink" title="Lecture 3: OS design"></a>Lecture 3: OS design</h2><ul><li><p>Lecture Topic:</p><ul><li>OS design<ul><li>system calls</li><li>micro&#x2F;monolithic kernel</li></ul></li><li>First system call in xv6</li></ul></li><li><p>OS picture</p><ul><li>apps: sh, echo, …</li><li>system call interface (open, close,…)<br>OS</li></ul></li><li><p>Goal of OS</p><ul><li>run multiple applications</li><li>isolate them</li><li>multiplex them</li><li>share</li></ul></li><li><p>Strawman design: No OS</p><ul><li>Application directly interacts with hardware<ul><li>CPU cores &amp; registers</li><li>DRAM chips</li><li>Disk blocks</li><li>…</li></ul></li><li>OS library perhaps abstracts some of it</li></ul></li><li><p>Strawman design not conducive to multiplexing</p><ul><li>each app periodically must give up hardware</li><li>BUT, weak isolation<ul><li>app forgets to give up, no other app runs</li><li>apps has end-less loop, no other app runs</li><li>you cannot even kill the badly app from another app</li></ul></li><li>but used by real-time OSes<ul><li>“cooperative scheduling”</li></ul></li></ul></li><li><p>Strawman design not conducive to memory isolation</p><ul><li>all apps share physical memory</li><li>one app can overwrites another apps memory</li><li>one app can overwrite OS library</li></ul></li><li><p>Unix interface conducive to OS goals</p><ul><li>abstracts the hardware in way that achieves goals</li><li>processes (instead of cores): fork<ul><li>OS transparently allocates cores to processes<ul><li>Saves and restore registers</li></ul></li><li>Enforces that processes give them up<ul><li>Periodically re-allocates cores</li></ul></li></ul></li><li>memory (instead of physical memory): exec<ul><li>Each process has its “own” memory</li><li>OS can decide where to place app in memory</li><li>OS can enforce isolation between memory of different apps</li><li>OS allows storing image in file system</li></ul></li><li>files (instead of disk blocks)<ul><li>OS can provide convenient names</li><li>OS can allow sharing of files between processes&#x2F;users</li></ul></li><li>pipes (instead of shared physical mem)<ul><li>OS can stop sender&#x2F;receiver</li></ul></li></ul></li><li><p>OS must be defensive</p><ul><li>an application shouldn’t be able to crash OS</li><li>an application shouldn’t be able to break out of its isolation</li><li>&#x3D;&gt; need strong isolation between apps and OS</li><li>approach: hardware support</li></ul></li><li><p>user&#x2F;kernel mode</p></li><li><p>virtual memory</p></li><li><p>Processors provide user&#x2F;kernel mode</p><ul><li>kernel mode: can execute “privileged” instructions<ul><li>e.g., setting kernel&#x2F;user bit</li><li>e.g., reprogramming timer chip</li></ul></li><li>user mode: cannot execute privileged instructions</li><li>Run OS in kernel mode, applications in user mode</li><li>[RISC-V has also an M mode, which we mostly ignore]</li></ul></li><li><p>Processors provide virtual memory</p><ul><li>Hardware provides page tables that translate virtual address to physical</li><li>Define what physical memory an application can access</li><li>OS sets up page tables so that each application can access only its memory</li></ul></li><li><p>Apps must be able to communicate with kernel</p><ul><li>Write to storage device, which is shared &#x3D;&gt; must be protected &#x3D;&gt; in kernel</li><li>Exit app</li><li>…</li></ul></li><li><p>Solution: add instruction to change mode in controlled way</p><ul><li>ecall <code>&lt;n&gt;</code></li><li>enters kernel mode at a pre-agreed entry point</li></ul></li><li><p>Modify OS picture</p><ul><li>user &#x2F; kernel (redline)</li><li>app -&gt; printf() -&gt; write() -&gt; SYSTEM CALL -&gt; sys_write() -&gt; …<br>user-level libraries are app’s private business</li><li>kernel internal functions are not callable by user</li><li>other way of drawing picture:</li><li>syscall 1  -&gt; system call stub -&gt; kernel entry -&gt; syscall -&gt; fs</li><li>syscall 2                                                 -&gt; proc</li><li>system call stub executes special instruction to enter kernel<br>hardware switches to kernel mode<br>but only at an entry point specified by the kernel</li><li>syscall need some way to get at arguments of syscall</li><li>[syscalls the topic of this week’s lab]</li></ul></li><li><p>Kernel is the Trusted Computing Base (TCB)</p><ul><li>Kernel must be “correct”<ul><li>Bugs in kernel could allow user apps to circumvent kernel&#x2F;user<br>Happens often in practice, because kernels are complex<br>See CVEs</li></ul></li><li>Kernel must treat user apps as suspect<br>User app may trick kernel to do the wrong thing<br>Kernel must check arguments carefully<br>Setup user&#x2F;kernel correctly<br>Etc.</li><li>Kernel in charge of separating applications too<br>One app may try to read&#x2F;write another app’s memory<br>&#x3D;&gt; Requires a security mindset<br>Any bug in kernel may be a security exploit</li></ul></li><li><p>Aside: can one have process isolation WITHOUT h&#x2F;w-supported<br>kernel&#x2F;user mode and virtual memory?</p><ul><li>yes! use a strongly-typed programming language</li></ul></li><li><p>For example, see Singularity O&#x2F;S<br>the compiler is then the trust computing base (TCB)<br>but h&#x2F;w user&#x2F;kernel mode is the most popular plan</p></li><li><p>Monolothic kernel<br>OS runs in kernel space<br>Xv6 does this.  Linux etc. too.<br>kernel interface &#x3D;&#x3D; system call interface<br>one big program with file system, drivers, &amp;c</p></li><li><p>good: easy for subsystems to cooperate<br>one cache shared by file system and virtual memory</p></li><li><p>bad: interactions are complex<br>leads to bugs<br>no isolation within</p></li><li><p>Microkernel design</p><ul><li>many OS services run as ordinary user programs<ul><li>file system in a file server</li></ul></li><li>kernel implements minimal mechanism to run services in user space<ul><li>processes with memory</li><li>inter-process communication (IPC)</li></ul></li><li>kernel interface !&#x3D; system call interface</li></ul></li><li><p>good: more isolation</p></li><li><p>bad: may be hard to get good performance<br>both monolithic and microkernel designs widely used</p></li><li><p>Xv6 case study</p><ul><li>Monolithic kernel<ul><li>Unix system calls &#x3D;&#x3D; kernel interface</li></ul></li><li>Source code reflects OS organization (by convention)<ul><li>user&#x2F;    apps in user mode</li><li>kernel&#x2F;  code in kernel mode</li></ul></li><li>Kernel has several parts<ul><li>kernel&#x2F;defs.h<ul><li>proc</li><li>fs<br>..</li></ul></li></ul></li><li>Goal: read source code and understand it (without consulting book)</li></ul></li><li><p>The RISC-V computer</p><ul><li>A very simple board (e.g., no display)</li></ul></li><li><p>RISC-V processor with 4 cores</p></li><li><p>RAM (128 MB)</p></li><li><p>support for interrupts (PLIC, CLINT)</p></li><li><p>support for UART<br>allows xv6 to talk to console<br>allows xv6 to read from keyboard</p></li><li><p>support for e1000 network card (through PCIe)<br>Qemu emulates several RISC-V computers</p></li><li><p>we use the “virt” one<br><a href="https://github.com/riscv/riscv-qemu/wiki">https://github.com/riscv/riscv-qemu/wiki</a></p></li><li><p>close to the SiFive board (<a href="https://www.sifive.com/boards">https://www.sifive.com/boards</a>)<br>but with virtio for disk</p></li><li><p>Boot xv6 (under gdb)</p><ul><li>$ make CPUS&#x3D;1 qemu-gdb<ul><li>runs xv6 under gdb (with 1 core)</li></ul></li><li>Qemu starts xv6 in kernel&#x2F;entry.S (see kernel&#x2F;kernel.ld)<ul><li>set breakpoint at _entry<ul><li>look at instruction</li><li>info reg</li></ul></li><li>set breakpoint at main<ul><li>Walk through main<br>single step into userinit<br>Walk through userinit<br>show kalloc<br>show proc.h<br>show allocproc()<br>show initcode.S&#x2F;initcode.asm<br>break forkret()<br>walk to userret<br>break syscall<br>print num<br>syscalls[num]<br>exec “&#x2F;init”<br>points to be made:<br>page table in userinit<br>ecall: U -&gt; K<br>a7: syscall #<br>exec: defensive</li></ul></li></ul></li></ul></li><li><p>kernel</p><p>$$<br>\text{proc.c} \stackrel{\text{gcc}}{\rightarrow} \text{proc.s} \stackrel{\text{assembler}}{\rightarrow} \text{proc.o} \rightarrow\text{link different .o file together}<br>$$</p></li></ul><h2 id="6-S081-2020-Lecture-4-Virtual-Memory"><a href="#6-S081-2020-Lecture-4-Virtual-Memory" class="headerlink" title="6.S081 2020 Lecture 4: Virtual Memory"></a>6.S081 2020 Lecture 4: Virtual Memory</h2><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><ul><li>plan:<br>address spaces<br>paging hardware<br>xv6 VM code</li></ul><h3 id="Virtual-memory-overview"><a href="#Virtual-memory-overview" class="headerlink" title="Virtual memory overview"></a>Virtual memory overview</h3><ul><li><p>today’s problem:<br>[user&#x2F;kernel diagram]<br>[memory view: diagram with user processes and kernel in memory]<br>suppose the shell has a bug:<br>sometimes it writes to a random memory address<br>how can we keep it from wrecking the kernel?<br>and from wrecking other processes?</p></li><li><p>we want isolated address spaces<br>each process has its own memory<br>it can read and write its own memory<br>it cannot read or write anything else<br>challenge:<br>how to multiplex several memories over one physical memory?<br>while maintaining isolation between memories</p></li><li><p>xv6 uses RISC-V’s paging hardware to implement AS’s<br>ask questions! this material is important<br>topic of next lab (and shows up in several other labs)</p></li><li><p>paging provides a level of indirection for addressing<br>CPU -&gt; MMU -&gt; RAM<br>VA     PA</p><p>$$<br>\text{CPU}\stackrel{\text{VA}}{\rightarrow}MMU\stackrel{\text{PA}}{\rightarrow}\text{RAM}<br>$$</p><p>s&#x2F;w can only ld&#x2F;st to virtual addresses, not physical<br>kernel tells MMU how to map each virtual address to a physical address<br>MMU essentially has a table, indexed by va, yielding pa<br>called a “page table”<br>one page table per address space<br>MMU can restrict what virtual addresses user code can use<br>By programming the MMU, the kernel has complete control over va-&gt;pa mapping<br>Allows for many interesting OS features&#x2F;tricks</p></li><li><p>RISC-V maps 4-KB “pages”<br>and aligned – start on 4 KB boundaries<br>4 KB &#x3D; 12 bits<br>the RISC-V used in xv6 has 64-bit for addresses<br>thus page table index is top 64-12 &#x3D; 52 bits of VA<br>except that the top 25 of the top 52 are unused<br>no RISC-V has that much memory now<br>can grow in future<br>so, index is 27 bits.</p></li><li><p>MMU translation<br>see Figure 3.1 of book<br>use index bits of VA to find a page table entry (PTE)<br>construct physical address using PPN from PTE + offset of VA</p></li><li><p>what is in PTE?<br>each PTE is 64 bits, but only 54 are used<br>top 44 bits of PTE are top bits of physical address<br>“physical page number”<br>low 10 bits of PTE flags<br>Present, Writeable, &amp;c<br>note: size virtual addresses !&#x3D; size physical addresses</p></li><li><p>where is the page table stored?<br>in RAM – MMU loads (and stores) PTEs<br>o&#x2F;s can read&#x2F;write PTEs<br>read&#x2F;write memory location corresponding to PTEs</p></li><li><p>would it be reasonable for page table to just be an array of PTEs? how big is it?<br>2^27 is roughly 134 million<br>64 bits per entry<br>134*8 MB for a full page table<br>wasting roughly 1GB per page table<br>one page table per address space<br>one address space per application<br>would waste lots of memory for small programs!<br>you only need mappings for a few hundred pages<br>so the rest of the million entries would be there but not needed</p></li><li><p>RISC-V 64 uses a “three-level page table” to save space<br>see figure 3.2 from book<br>page directory page (PD)<br>PD has 512 PTEs<br>PTEs point to another PD or is a leaf<br>so 512<em>512</em>512 PTEs in total<br>PD entries can be invalid<br>those PTE pages need not exist<br>so a page table for a small address space can be small</p></li><li><p>how does the mmu know where the page table is located in RAM?<br>satp holds phys address of top PD<br>pages can be anywhere in RAM – need not be contiguous<br>rewrite satp when switching to another address space&#x2F;application</p></li><li><p>how does RISC-V paging hardware translate a va?<br>need to find the right PTE<br>satp register points to PA of top&#x2F;L2 PD<br>top 9 bits index L2 PD to get PA of L1 PD<br>next 9 bits index L1 PD to get PA of L0 PD<br>next 9 bits index L0 PD to get PA of PTE<br>PPN from PTE + low-12 from VA</p></li><li><p>flags in PTE<br>V, R, W, X, U<br>xv6 uses all of them</p></li><li><p>what if V bit not set? or store and W bit not set?<br>“page fault”<br>forces transfer to kernel<br>trap.c in xv6 source<br>kernel can just produce error, kill process<br>in xv6: “usertrap(): unexpected scause … pid&#x3D;… sepc&#x3D;… stval&#x3D;…”<br>or kernel can install a PTE, resume the process<br>e.g. after loading the page of memory from disk</p></li><li><p>indirection allows paging h&#x2F;w to solve many problems<br>e.g. phys memory doesn’t have to be contiguous<br>avoids fragmentation<br>e.g. lazy allocation (a lab)<br>e.g. copy-on-write fork (another lab)<br>many more techniques<br>topic of next lecture</p></li><li><p>Q: why use virtual memory in kernel?<br>it is clearly good to have page tables for user processes<br>but why have a page table for the kernel?<br>could the kernel run with using only physical addresses?<br>top-level answer: yes<br>most standard kernels do use virtual addresses<br>why do standard kernels do so?<br>some reasons are lame, some are better, none are fundamental</p><ul><li>the hardware makes it difficult to turn it off<br>e.g. on entering a system call, one would have to disable VM</li><li>the kernel itself can benefit from virtual addresses<br>mark text pages X, but data not (helps tracking down bugs)<br>unmap a page below kernel stack (helps tracking down bugs)<br>map a page both in user and kernel (helps user&#x2F;kernel transition)</li></ul></li></ul><h3 id="Virtual-memory-in-xv6"><a href="#Virtual-memory-in-xv6" class="headerlink" title="Virtual memory in xv6"></a>Virtual memory in xv6</h3><ul><li>kernel page table<br>See figure 3.3 of book<br>simple maping mostly<br>map virtual to physical one-on-one<br>note double-mapping of trampoline<br>note permissions<br>why map devices?</li><li>each process has its own address space<br>and its own page table<br>see figure 3.4 of book<br>note: trampoline and trapframe aren’t writable by user process<br>kernel switches page tables (i.e. sets satp) when switching processes</li><li>Q: why this address space arrangement?<br>user virtual addresses start at zero<br>of course user va 0 maps to different pa for each process<br>16,777,216 GB for user heap to grow contiguously<br>but needn’t have contiguous phys mem – no fragmentation problem<br>both kernel and user map trampoline and trapframe page<br>eases transition user -&gt; kernel and back<br>kernel doesn’t map user applications<br>not easy for kernel to r&#x2F;w user memory<br>need translate user virtual address to kernel virtual address<br>good for isolation (see spectre attacks)<br>easy for kernel to r&#x2F;w physical memory<br>pa x mapped at va x</li><li>Q: does the kernel have to map all of phys mem into its virtual address space?</li></ul><h3 id="Code-walk-through"><a href="#Code-walk-through" class="headerlink" title="Code walk through"></a>Code walk through</h3><ul><li>setup of kernel address space<br>kvmmap()<br>Q: what is address 0x10000000 (256M)<br>Q: how much address space does 1 L2 entry cover? (1G)<br>Q: how much address space does 1 L1 entry cover? (2MB)<br>Q: how much address space does 1 L0 entry cover? (4096)<br>print kernel page table<br>Q: what is size of address space? (512G)<br>Q: how much memory is used to represent it after 1rst kvmmap()? (3 pages)<br>Q: how many entries is CLINT? (16 pages)<br>Q: how many entries is PLIC? (1024 pages, two level 1 PDs)<br>Q: how many pages is kernel text (8 pages)<br>Q: how many pages is kernel total (128M &#x3D; 64 * 2MB)<br>Q: Is trampoline mapped twice? (yes, last entry and direct-mapped, entry [2, 3, 7])<br>kvminithart();<br>Q: after executing w_satp() why will the next instruction be sfence_vma()?</li><li>mappages() in vm.c<br>arguments are top PD, va, size, pa, perm<br>adds mappings from a range of va’s to corresponding pa’s<br>rounds b&#x2F;c some uses pass in non-page-aligned addresses<br>for each page-aligned address in the range<br>call walkpgdir to find address of PTE<br>need the PTE’s address (not just content) b&#x2F;c we want to modify<br>put the desired pa into the PTE<br>mark PTE as valid w&#x2F; PTE_P</li><li>walk() in vm.c<br>mimics how the paging h&#x2F;w finds the PTE for an address<br>PX extracts the 9 bits at Level level<br>&amp;pagetable[PX(level, va)] is the address of the relevant PTE<br>if PTE_V<br>the relevant page-table page already exists<br>PTE2PA extracts the PPN from the PDE<br>if not PTE_V<br>alloc a page-table page<br>fill in pte with PPN (using PA2PTE)<br>now the PTE we want is in the page-table page</li><li>procinit() in proc.c<br>alloc a page for each kernel stack with a guard page</li><li>setup user address space<br>allocproc(): allocates empty top-level page table<br>fork(): uvmcopy()<br>exec(): replace proc’s page table with a new one<br>uvmalloc<br>loadseg<br>print user page table for sh<br>Q: what is entry 2?</li><li>a process calls sbrk(n) to ask for n more bytes of heap memory<br>user&#x2F;umalloc.c calls sbrk() to get memory for the allocator<br>each process has a size<br>kernel adds new memory at process’s end, increases size<br>sbrk() allocates physical memory (RAM)<br>maps it into the process’s page table<br>returns the starting address of the new memory</li><li>growproc() in proc.c<br>proc-&gt;sz is the process’s current size<br>uvmalloc() does most of the work<br>when switching to user space satp will be loaded with updated page table</li><li>uvmalloc() in vm.c<br>why PGROUNDUP?<br>arguments to mappages()…</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Reading&quot;&gt;&lt;a href=&quot;#Reading&quot; class=&quot;headerlink&quot; title=&quot;Reading&quot;&gt;&lt;/a&gt;Reading&lt;/h1&gt;&lt;h3 id=&quot;Chapter-1-Operating-system-interfaces&quot;&gt;&lt;a hre</summary>
      
    
    
    
    
    <category term="OS" scheme="http://example.com/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>Basic Knoledge</title>
    <link href="http://example.com/2022/11/29/Basic-Knoledge/"/>
    <id>http://example.com/2022/11/29/Basic-Knoledge/</id>
    <published>2022-11-29T12:44:45.000Z</published>
    <updated>2023-01-13T12:25:06.401Z</updated>
    
    <content type="html"><![CDATA[<h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><ul><li><p>Small tricks</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取中间的数：</span></span><br><span class="line"><span class="type">int</span> mid = (left + right) / <span class="number">2</span>; <span class="comment">// 有溢出的风险</span></span><br><span class="line"><span class="type">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>); <span class="comment">// 这样更好</span></span><br></pre></td></tr></table></figure></li><li><p>当异常发⽣时，C++通常会调⽤对象的析构函数来释放资源</p></li><li><p>指向虚函数表的指针 <code>vptr</code>需要在构造函数中进⾏初始化</p></li><li><p>如何让类不能实例化</p><ul><li>将类定义位抽象类（包含纯虚函数）</li><li>将构造器声明为 <code>private</code></li></ul></li><li><p>虚继承</p><ul><li>在菱形继承的场景下，会产生两份基类数据，浪费空间，同时访问基类还需要通过域运算符</li><li>利用虚继承，在间接继承共同基类时是保留一份基类成员。创建派生类实例的时候，只需要调用一次基类的构造函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 C 语言中，数据类型指的是用于声明不同类型的变量或函数的一个广泛的系统。变量的类型决定了变量存储占用的空间，以及如何解释存储的位模式。</p></li><li><h4 id="Linux-和-UNIX-的关系-x2F-区别"><a href="#Linux-和-UNIX-的关系-x2F-区别" class="headerlink" title="Linux 和 UNIX 的关系&#x2F;区别"></a>Linux 和 UNIX 的关系&#x2F;区别</h4><ul><li>Linux 是一个类似 Unix 的操作系统，Unix 要早于 Linux，Linux 的初衷就是要替代 UNIX，并在功能和用户体验上进行优化，所以 Linux 模仿了 UNIX（但并没有抄袭 UNIX 的源码），使得 Linux 在外观和交互上与 UNIX 非常类似。</li></ul></li><li><p>析构函数</p><ul><li>类类型：如 <code>struct</code>、<code>class</code>、<code>union</code><ul><li>没有自定义析构函数，那么编译器就会为它们生成内联(inline)、public 的析构函数。</li></ul></li><li>对于析构函数的调用，需要是 public 的访问权限，否则会导致编译错误。</li></ul></li></ul><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><p>$$<br>\text{工作区}\stackrel{add}{\rightarrow}\text{暂存区}\stackrel{commit}{\rightarrow}\text{本地仓库}\stackrel{push}{\rightarrow}\text{远程仓库}\stackrel{pull}{\rightarrow}\text{本地}<br>$$</p><p><img src="/.com//Basic-Knoledge/1672140678237.png" alt="1672140678237"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># In the work directory</span></span><br><span class="line">git config --global user.name <span class="string">&quot;yourName&quot;</span></span><br><span class="line">git config --global user.email yourEmail</span><br><span class="line"></span><br><span class="line">git init <span class="comment"># initialize the repository</span></span><br><span class="line">git status <span class="comment"># repository information</span></span><br><span class="line">git add fileName</span><br><span class="line">git commit -m <span class="string">&quot;commit msg&quot;</span>EADADWE</span><br><span class="line">git <span class="built_in">log</span>  <span class="comment"># 查看以前的版本</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">touch</span> .gitignore  <span class="comment"># 不追踪的文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建新分支</span></span><br><span class="line">git branch branchName</span><br><span class="line"></span><br><span class="line"><span class="comment"># 两种切换分支的命令</span></span><br><span class="line">git checkout branchName</span><br><span class="line">- git checkout -d branchName  <span class="comment"># 删除分支</span></span><br><span class="line">- git checkout -b temp  <span class="comment"># 创建并切换到新建的分支</span></span><br><span class="line">git switch branchName</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并分支</span></span><br><span class="line">git merge temp</span><br><span class="line"></span><br><span class="line"><span class="comment"># add 和 commit合在一起写</span></span><br><span class="line">git commit -a -m <span class="string">&quot;msg&quot;</span>  <span class="comment"># 或者-am</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载远程内容</span></span><br><span class="line"><span class="comment">#### 直接下载zip是不会下载版本信息的，所以需要使用以下命令</span></span><br><span class="line">git <span class="built_in">clone</span></span><br><span class="line"></span><br><span class="line"> ESDAW</span><br></pre></td></tr></table></figure><h1 id="C-x2F-C"><a href="#C-x2F-C" class="headerlink" title="C&#x2F;C++"></a>C&#x2F;C++</h1><h3 id="条件变量的虚假唤醒"><a href="#条件变量的虚假唤醒" class="headerlink" title="条件变量的虚假唤醒"></a><a href="https://www.cnblogs.com/tqyysm/articles/9765667.html">条件变量的虚假唤醒</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wait 端</span></span><br><span class="line"><span class="built_in">lock</span>(mutex);</span><br><span class="line"><span class="keyword">while</span>(queue.<span class="built_in">empty</span>())&#123;  <span class="comment">// 如果使用if可能会导致虚假唤醒</span></span><br><span class="line">cond.<span class="built_in">wait</span>();</span><br><span class="line">&#125;</span><br><span class="line">x = queue.<span class="built_in">pop</span>();</span><br><span class="line"><span class="built_in">unlock</span>(mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// signal/broadcast端</span></span><br><span class="line"><span class="built_in">lock</span>(mutex);</span><br><span class="line">queue.<span class="built_in">push_back</span>(x);</span><br><span class="line"><span class="built_in">unlock</span>(mutex);</span><br><span class="line">cond.<span class="built_in">notify</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当条件变量满足的时候，挂起的线程会被唤醒，当他准备获取锁之前，有其他线程将变量改变了，这时候条件变量不满足了，所以这次唤醒是虚假的。</p><p>当某个条件满足的时候（即wait端中while中的条件），之后就进入挂起状态，用if语句那么挂起状态结束以后，就会继续往下，但是这个时候条件不一定满足（虚假唤醒时），所以应该利用while，这样可以<strong>进行第二次判断</strong>，这样就不会因为虚假唤醒的情况而被唤醒。</p><h3 id="Function-pointer"><a href="#Function-pointer" class="headerlink" title="Function pointer"></a><a href="https://stackoverflow.com/questions/840501/how-do-function-pointers-in-c-work">Function pointer</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">addInt</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n+m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> (*functionPtr)(<span class="type">int</span>,<span class="type">int</span>); <span class="comment">// Declare</span></span><br><span class="line">functionPtr = &amp;addInt;  <span class="comment">// Assigment</span></span><br><span class="line"><span class="type">int</span> sum = (*functionPtr)(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">// usage: sum == 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// As a parameter</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add2to3</span><span class="params">(<span class="type">int</span> (*functionPtr)(<span class="type">int</span>, <span class="type">int</span>))</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (*functionPtr)(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this is a function called functionFactory which receives parameter n</span></span><br><span class="line"><span class="comment">// and returns a pointer to another function which receives two ints</span></span><br><span class="line"><span class="comment">// and it returns another int</span></span><br><span class="line"><span class="built_in">int</span> (*<span class="built_in">functionFactory</span>(<span class="type">int</span> n))(<span class="type">int</span>, <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Got parameter %d&quot;</span>, n);</span><br><span class="line">    <span class="built_in">int</span> (*functionPtr)(<span class="type">int</span>,<span class="type">int</span>) = &amp;addInt;</span><br><span class="line">    <span class="keyword">return</span> functionPtr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// note that the typedef name is indeed myFuncDef</span></span><br><span class="line"><span class="comment">// Confused here ???????</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*myFuncDef)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">myFuncDef <span class="title">functionFactory</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Got parameter %d&quot;</span>, n);</span><br><span class="line">    myFuncDef functionPtr = &amp;addInt;</span><br><span class="line">    <span class="keyword">return</span> functionPtr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">addInt</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n+m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> (*functionPtr)(<span class="type">int</span>,<span class="type">int</span>); <span class="comment">// Declare</span></span><br><span class="line">functionPtr = &amp;addInt;  <span class="comment">// Assigment</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; addInt &lt;&lt; endl; <span class="comment">// Return 1</span></span><br></pre></td></tr></table></figure><blockquote><p>cout 打印函数返回1的<a href="https://blog.csdn.net/Q_1849805767/article/details/107391572">原因</a>：<br>C++调用非静态的成员函数时，采用的是一种 __thiscall 的函数调用方式。采用这种调用方式，编译器在编译的时候，会在调用的函数形参表中增加一个指向调用该成员函数的指针，也就是我们经常说的this指针。调用的形式类似于Base::f1(Base* this, otherparam…)，在函数体中，涉及到对象的成员变量或者其他成员函数，都会通过这个this指针来调用，从而达到在成员函数中处理调用对象所对应的数据，而不会错误处理其他对象的数据。可见，虽然我们必须通过对象来调用动态函数，但是其实我们访问的都是同一个成员函数。所以我们采用&amp;Base::f1来获取成员函数地址是没错的，动态函数同样是跟类绑定而不是跟对象绑定的。</p></blockquote><blockquote><p>出错的原因是，<code>输出操作符&lt;&lt;没有对void(__thiscall A:: *)()类型重载，编译器将这种类型转换为bool类型，所以输出了1；</code></p></blockquote><blockquote><p>对于静态函数，其调用方式并非__thiscall，&lt;&lt;有对它的重载，因此类的静态函数可以直接用cout输出函数地址。我们可以用printf输出，因为他可以接收任意类型的参数，包括__thiscall类型</p></blockquote><h2 id="Upcasting"><a href="#Upcasting" class="headerlink" title="Upcasting"></a><a href="http://c.biancheng.net/view/2284.html">Upcasting</a></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; <span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : A&#123; <span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>; &#125;</span><br><span class="line"></span><br><span class="line">A a; B b;</span><br><span class="line"><span class="comment">// b = a; // Downcasting</span></span><br><span class="line">a = b; <span class="comment">// Upcasting. 派生类成员变量将会被舍去，只保留基类成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象之间的赋值不会影响成员函数，也不会影响 this 指针</span></span><br><span class="line">a.<span class="built_in">func1</span>(); <span class="comment">// 调用的是A中的函数。</span></span><br></pre></td></tr></table></figure><blockquote><p>这种转换关系是不可逆的，只能 <code>用派生类对象给基类对象赋值</code>，而 <code>不能</code>用基类对象给派生类对象赋值。理由很简单，基类不包含派生类的成员变量，无法对派生类的成员变量赋值。同理，同一基类的不同派生类对象之间也不能赋值。(如果多出数据，编译器会舍弃，但是少数据了，那么编译器就不知道如何填充剩下的内存了)</p></blockquote><p><strong>将派生类指针赋值给基类指针</strong></p><blockquote><p>将派生类指针赋值给基类指针时，通过基类指针只能使用派生类的成员变量，但不能使用派生类的成员函数.</p><blockquote><p>编译器通过指针访问成员变量，但是不会通过指针访问成员函数，而是通过指针类型来访问。所以，当指针变化的时候，改变的只是指向的内存，也就是对应的类成员变量存储的位置变成了赋值类中的成员变量。</p></blockquote></blockquote><h2 id="MMAP"><a href="#MMAP" class="headerlink" title="MMAP"></a><a href="https://zhuanlan.zhihu.com/p/357820303">MMAP</a></h2><ul><li><p>传统IO</p><ul><li><p>整个过程发生了<strong>4次用户态和内核态的上下文切换</strong>和<strong>4次拷贝(1.用户发起read，2.读缓存拷贝到用户缓存，3.用户发起write，4.拷贝到网卡)</strong></p></li><li><p><img src="/.com//readio.webp" alt="img"></p></li><li><p>DMA拷贝</p><ul><li>IO操作，都是通过CPU发出对应的指令来完成，但是相比CPU来说，IO的速度太慢了，CPU有大量的时间处于等待IO的状态。因此就产生了<strong>DMA（Direct Memory Access</strong>)直接内存访问技术，本质上来说他就是一块 <code>主板上独立的芯片</code>，通过它来进行内存和IO设备的数据传输，从而减少CPU的等待时间。</li></ul></li></ul></li><li><p>零拷贝</p><ul><li><p>计算机执行操作时，CPU不需要先将数据从某处内存复制到另一个特定区域，这种技术通常用于通过网络传输文件时节省CPU周期和内存带宽。</p></li><li><p>减少用户态和内核态的切换次数以及CPU拷贝的次数。</p></li><li><p>常见的几种零拷贝技术</p><ul><li>mmap + write<ul><li>使用 <code>mmap</code>替换了read+write中的read操作，减少了一次CPU的拷贝。</li><li><code>mmap</code>主要实现方式是将读缓冲区的地址和用户缓冲区的地址进行映射</li><li><strong>4次用户态和内核态的上下文切换</strong>和<strong>3次拷贝</strong>（1.mmap调用，2.mmap返回，3.用户调用write，4.拷贝到网卡）</li><li><img src="/.com//mmap+write.webp" alt="img"></li><li><code>mmap</code>的方式节省了一次CPU拷贝，同时由于用户进程中的内存是虚拟的，只是映射到内核的读缓冲区，所以可以节省一半的内存空间，比较适合大文件的传输。</li></ul></li><li>sendfile<ul><li>Linux2.1内核版本后引入的一个系统调用函数，通过使用 <code>sendfile</code>数据可以直接在内核空间进行传输，因此避免了用户空间和内核空间的拷贝</li><li><strong>2次用户态和内核态的上下文切换</strong>和<strong>3次拷贝</strong></li><li><img src="/.com//sendfile.webp" alt="img"></li><li>sendfile方法IO数据对用户空间完全不可见，所以只能适用于完全不需要用户空间处理的情况，比如静态文件服务器。</li></ul></li><li>sendfile + DMA Scatter&#x2F;Gather<ul><li>对 <code>sendfile</code>做了进一步优化，通过引入新的硬件支持，这个方式叫做DMA Scatter&#x2F;Gather 分散&#x2F;收集功能。</li><li><strong>2次用户态和内核态的上下文切换</strong>和 <strong>2次拷贝</strong> ，其中更重要的是完全没有CPU拷贝</li><li><img src="/.com//DMS.webp"></li></ul></li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;杂项&quot;&gt;&lt;a href=&quot;#杂项&quot; class=&quot;headerlink&quot; title=&quot;杂项&quot;&gt;&lt;/a&gt;杂项&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Small tricks&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Q&amp;A</title>
    <link href="http://example.com/2022/11/23/Q-A/"/>
    <id>http://example.com/2022/11/23/Q-A/</id>
    <published>2022-11-23T08:06:49.000Z</published>
    <updated>2023-01-14T00:01:01.097Z</updated>
    
    <content type="html"><![CDATA[<h2 id="右值引用的用法"><a href="#右值引用的用法" class="headerlink" title="右值引用的用法"></a>右值引用的用法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引用右值，避免生成新对象</span></span><br><span class="line">Foo&amp;&amp; foo2 = <span class="built_in">FooFactory</span>();</span><br></pre></td></tr></table></figure><p><strong><a href="https://zhuanlan.zhihu.com/p/335994370">关于std::move函数</a></strong></p><blockquote><p>std::move移动不了什么，唯一的功能是把左值强制转化为右值，让右值引用可以指向左值。其实现等同于一个类型转换：static_cast&lt;T&amp;&amp;&gt;(lvalue)。 所以，单纯的std::move(xxx)不会有性能提升. move返回值如果有名称就是左值（被赋值给一个变量），没有名称就是右值。</p><p><strong>使用建议</strong>：可移动对象在&lt;需要拷贝且被拷贝者之后不再被需要&gt;的场景，建议使用std::move触发移动语义，提升性能。（类似于 <code>push_back</code>等的函数）。</p><p>对于 <code>unique_ptr</code>只能进行移动构造函数，所以可以使用 <code>move</code>实现赋值构造<br><code>std::unique_ptr&lt;A&gt; ptr = std::move(ptr_a);</code>.</p></blockquote><p><strong>完美转发 std::forward</strong></p><blockquote><p>std::forward <code>&lt;T&gt;</code>(u)有两个参数：T与 u。 a. 当T为左值引用类型时，u将被转换为T类型的左值； b. 否则u将被转换为T类型右值。</p></blockquote><ul><li>const右值引用传入的参数可以被修改，而const左值传入的则不可以修改。</li></ul><h2 id="C-为什么不推荐使用vector-lt-bool-gt"><a href="#C-为什么不推荐使用vector-lt-bool-gt" class="headerlink" title="C++为什么不推荐使用vector&lt;bool&gt;"></a><a href="https://www.zhihu.com/question/23367698">C++为什么不推荐使用vector&lt;bool&gt;</a></h2><p>vector&lt; bool&gt;不是一个标准容器，就是因为它不能支持一些容器该有的基本操作，诸如取地址给指针初始化操作.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">bool</span>&gt; c&#123;<span class="literal">false</span>, <span class="literal">false</span>&#125;;</span><br><span class="line"><span class="type">bool</span> b = c[<span class="number">0</span>]; <span class="comment">// 这里有一个隐式的类型转换</span></span><br></pre></td></tr></table></figure><h2 id="冷不命中-cold-miss"><a href="#冷不命中-cold-miss" class="headerlink" title="冷不命中(cold miss)"></a>冷不命中(cold miss)</h2><p>缓存会在断电之后清空，那么是不是意味着在刚开机的时候，电脑运行的速度会相对较慢？</p><h2 id="ssh命令传输方式"><a href="#ssh命令传输方式" class="headerlink" title="ssh命令传输方式"></a>ssh命令传输方式</h2><p>为什么会因为网络波动而导致无法输入的情况</p><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><ul><li>为什么在Xftp中删除文件那么慢，而直接使用rm会快很多？</li><li>写入空白和覆盖哪个速度更快？</li><li>为什么这么写？while(-1 !&#x3D; (opt &#x3D; getopt(argc, argv, “x:y:”)))<ul><li>防止将&#x3D;&#x3D;写成&#x3D;，此时，如果写成a&#x3D;1编译会通过，如果写成1&#x3D;a编译不会通过，这样做也可减少这种隐形的bug的出现</li></ul></li><li>函数指针（typedef）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// note that the typedef name is indeed myFuncDef</span></span><br><span class="line"><span class="comment">// Confused here ???????</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*myFuncDef)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">myFuncDef <span class="title">functionFactory</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Got parameter %d&quot;</span>, n);</span><br><span class="line">    myFuncDef functionPtr = &amp;addInt;</span><br><span class="line">    <span class="keyword">return</span> functionPtr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>void (*0)( ) ：是⼀个返回值为void，参数为空的函数指针0 (这里的意思是函数名为0吗？)</p></li><li><p>为什么在Linux下不能同时安装多个软件，但是在Windows下可以？（并行和串行的优劣？）</p></li><li><p>在fork之后，父进程和子进程的运行有先后顺序吗？</p></li><li><p>函数名是不是就是函数指针？(是，那么为什么不需要解引用，直接可以调用？)我可以通过函数名调用函数，那可不可以认为这个函数名就是一个句柄？如何理解句柄？异常表中存储就是各种异常处理函数的句柄？能不能理解为一个整数到一个指针的映射？</p><blockquote><p><strong>为什么要用 handle，而不直接用指针呢？</strong></p><ul><li>指针作用太强，可做的事情太多。可做的事情越多，就会越危险。接口设计中，功能刚刚好就够了，并非越多权限越好的。</li><li>handle 通常只是个整数，实现被隐藏起来，假如直接暴露了指针，也就暴露了指针类型（有时也可以暴露 void* 指针作为某种 handle）。用户看到越多细节，其代码就越有可能依赖这些细节。将来情况有变，但又要兼容用户代码，库内部改起来就更麻烦。</li><li>资源在内部管理，通过 handle 作为中间层，可以有效判断 handle 是否合法，也可以通过权限检查防止某种危险操作。</li><li>handle 通常只是个整数，所有的语言都有整数这种类型，但并非所有语言都有指针。接口只出现整数，方便同一实现绑定到各种语言。</li></ul></blockquote></li><li><p>在编写信号处理器的时候，最好调用异步信号安全性函数，那为什么不能再执行函数的时候阻塞所有的信号，这样不能保证函数的原子性吗？</p></li><li><p>printf 和cout混用会有什么后果吗？</p></li><li><p>free 或者delete掉malloc 或 new 出来的内存会发生什么？</p></li><li><p>csapp p588: 在32位模式中，  malloc返回的块的地址总是8的倍数，64位模式中，总是16的倍数。 这是为什么？</p></li><li><p>双字对齐的约束下，块的大小总是为8的倍数，且块大小的最低三位总是为0（这样才能是8的倍数，这里双字表示8字节）</p></li><li><p>csapp: 练习题9.6中的块大小的计算方法(get)</p></li><li><p>docker &amp; virtual machine 之间有什么区别？</p></li><li><blockquote><p>向上转型：子类除继承父类数据成员，并且还会有自己的数据成员，但是在向上转型后子类的数据成员会被舍弃</p></blockquote></li><li><p>转型之后的指针为什么可以通过子类的共有方法调用子类成员变量？</p></li><li><p>多线程：如何理解多线程代码的执行过程，虚假唤醒</p></li></ul><h2 id="代码哲学"><a href="#代码哲学" class="headerlink" title="代码哲学"></a>代码哲学</h2><ul><li>为什么说各个编程语言之间粒度不同呢？在什么方面体现？<ul><li>如果相应的库被实现了，那么这个语言的粒度会不会改变？</li></ul></li><li>短期内形成对方案的评估的能力，能够知晓方案的可行性、难点的能力，这种能力叫什么？如何训练（在刷算法题的时候，往往在完成过程中才能知晓这些，可能的原因有考虑不充分等）</li><li>见到一种技术，如何从技术实现得到技术的类型？</li><li>将碎片知识进行体系化</li><li>解决一个算法问题的过程</li><li>为什么说计算机领域最难的两个问题是变量命名和缓存不命中？</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;右值引用的用法&quot;&gt;&lt;a href=&quot;#右值引用的用法&quot; class=&quot;headerlink&quot; title=&quot;右值引用的用法&quot;&gt;&lt;/a&gt;右值引用的用法&lt;/h2&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;g</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>命令笔记</title>
    <link href="http://example.com/2022/11/08/%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2022/11/08/%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/</id>
    <published>2022-11-08T08:39:05.000Z</published>
    <updated>2023-01-13T05:37:03.904Z</updated>
    
    <content type="html"><![CDATA[<h2 id="linux-命令"><a href="#linux-命令" class="headerlink" title="linux 命令"></a>linux 命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pwd</span> <span class="comment"># Present Working Directory</span></span><br><span class="line">tar &lt;options&gt; &lt;filename&gt; <span class="comment"># Tape ARchive</span></span><br><span class="line"><span class="built_in">rm</span> -rf <span class="comment"># 删除文件夹以及其中的内容</span></span><br><span class="line"><span class="built_in">cat</span> -n <span class="comment"># 查看文件中的内容，-n加上行序号</span></span><br><span class="line">less <span class="comment"># 可以滚动查看， 输入q退出</span></span><br><span class="line">grep &lt;pattern&gt; &lt;file&gt;  <span class="comment"># -v: 不包含模式的字串， -R递归地查找</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">chmod</span> 777 -R &lt;dir_name&gt; <span class="comment"># 将文件夹以及其目录中的所有文件的访问权限全开</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># vim</span></span><br><span class="line">:wq  <span class="comment"># 退出，w：写入； q:退出</span></span><br><span class="line">:q!  <span class="comment"># 强制退出，不保存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 正常模式</span></span><br><span class="line">5yy <span class="comment"># 拷贝5行</span></span><br><span class="line">5dd <span class="comment"># 删除5行</span></span><br><span class="line">p <span class="comment"># 粘贴</span></span><br><span class="line">/main  <span class="comment"># 查找字符串main</span></span><br></pre></td></tr></table></figure><h2 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">info s  # 查看栈信息</span><br><span class="line">info r  # 查看寄存器信息</span><br><span class="line">disas # 查看汇编代码， 可以指定函数</span><br><span class="line">x/[count][format] [address] # 打印内存值</span><br><span class="line"> - x/s 0x402400 # 打印在地址0x402400中的值，转换成string</span><br><span class="line">run res.txt # 后面可以加上传入的参数</span><br><span class="line">stepi # 二进制中的一步</span><br><span class="line">fs next # 切换关注的窗口，gdb或者命令行窗口</span><br><span class="line"></span><br><span class="line">condition 1 item_to_remove==1  # 为断点添加一个条件</span><br><span class="line">backtrace  # 查看错误栈</span><br></pre></td></tr></table></figure><p><strong>快捷键</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl + L: 刷新gdb页面</span><br></pre></td></tr></table></figure><h2 id="快捷键（Linux）"><a href="#快捷键（Linux）" class="headerlink" title="快捷键（Linux）"></a>快捷键（Linux）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl + D: 结束当前任务</span><br></pre></td></tr></table></figure><h2 id="docker-命令"><a href="#docker-命令" class="headerlink" title="docker 命令"></a>docker 命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启docker</span></span><br><span class="line">docker start user_name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入docker</span></span><br><span class="line">docker attach user_name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开ssh服务(进入对应的docker之后)</span></span><br><span class="line">service ssh start</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;linux-命令&quot;&gt;&lt;a href=&quot;#linux-命令&quot; class=&quot;headerlink&quot; title=&quot;linux 命令&quot;&gt;&lt;/a&gt;linux 命令&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Database</title>
    <link href="http://example.com/2022/10/21/Database/"/>
    <id>http://example.com/2022/10/21/Database/</id>
    <published>2022-10-21T04:37:04.000Z</published>
    <updated>2022-12-21T00:42:56.080Z</updated>
    
    <content type="html"><![CDATA[<h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><ul><li><p>SQL therefore treats as unknown the result of any comparison involving a null value</p></li><li><p>我们通过DBMS访问数据库</p></li><li><p><code>NTILE</code> 函数</p><ul><li>将排序分区中的行划分为特定数量的组。从每个组分配一个从一开始的桶号。对于每一行，NTILE()函数返回一个桶号，表示行所属的组。</li></ul></li><li><p>条件语句</p><ul><li><p>if 语句</p><ul><li>IF(condition, value_if_true, value_if_false)</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> salary <span class="keyword">set</span> sex <span class="operator">=</span> if(sex <span class="operator">=</span> <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;m&#x27;</span>);</span><br></pre></td></tr></table></figure><ul><li>IFNULL(<strong>expression_1</strong>,<strong>expression_2</strong>)<ul><li>如果 <code>expression_1</code>不为 <code>NULL</code>，则 <code>IFNULL</code>函数返回 <code>expression_1</code>; 否则返回 <code>expression_2</code>的结果。<ul><li>&#96;&#96;&#96;sql<br>select ifNull((<br>select distinct salary<br>from employee<br>order by salary desc limit 1, 1<br>), null) as SecondHighestSalary;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- case</span><br><span class="line"></span><br><span class="line">  ```sql</span><br><span class="line">  update salary set sex=(case sex when &#x27;m&#x27; then &#x27;f&#x27; else &#x27;m&#x27; end);</span><br><span class="line">  &lt;!-- 通式 --&gt;</span><br><span class="line">  CASE</span><br><span class="line">  WHEN condition1 THEN result1</span><br><span class="line">  WHEN condition2 THEN result2</span><br><span class="line">  WHEN conditionN THEN resultN</span><br><span class="line">  ELSE result</span><br><span class="line">  END;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li></ul><hr></li><li><p>字符串</p><ul><li><code>substr</code>:  <code>substr(string,pos,end)</code>这个函数不填入end就是取pos位置及其之后所有的字符</li><li><code>LEFT(str, n)</code>: 获得字符串左边n个字符（right同理）</li><li><code>length(str)</code>: 获得字符串的大小</li><li><code>CONCAT(str1, str2, ...)</code>：合并字符串函数</li></ul></li><li><p>group_concat()</p><ul><li>concatenate data from multiple rows into one field.</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col1, col2, ..., colN</span><br><span class="line">GROUP_CONCAT ( [<span class="keyword">DISTINCT</span>] col_name1 </span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> clause]  [SEPARATOR str_val] ) </span><br><span class="line"><span class="keyword">FROM</span> table_name <span class="keyword">GROUP</span> <span class="keyword">BY</span> col_name2;</span><br></pre></td></tr></table></figure></li><li><p>时间</p><ul><li><p><code>datediff(date1, date2)</code>: 如果date1比date2大，结果为正；如果date1比date2小，结果为负。</p></li><li><p><code>timestampdiff(时间类型, 日期1, 日期2)</code>: 这个函数和 <code>diffdate</code>的正、负号规则刚好相反。<br>日期1大于日期2，结果为负，日期1小于日期2，结果为正。</p><ul><li>通过添加“day”, “hour”, “second”等关键词，来规定计算天数差、小时数差、还是分钟数差</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> timestampdiff(<span class="keyword">day</span>, <span class="string">&#x27;2019-01-01&#x27;</span>, <span class="string">&#x27;2019-01-03&#x27;</span>) <span class="keyword">as</span> dayInterval; <span class="comment">--计算天数差</span></span><br></pre></td></tr></table></figure></li><li><p><code>DATE_SUB(date,INTERVAL expr type)</code>: 从日期减去指定的时间间隔。</p></li><li><p>&#96;&#96;&#96;sql<br>where activity_date &gt; date_sub(‘2019-07-27’, interval 30 day)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  - `year(time)`: 获取时间中的年份</span><br><span class="line"></span><br><span class="line">**from CMU**</span><br><span class="line"></span><br><span class="line">```sql</span><br><span class="line">-- 窗口函数, 按照指定的分组操作函数（将每一个分组数据作为一个函数的统计对象）</span><br><span class="line">select row_number() over (partition by cid) from titles;</span><br><span class="line">-- Common Table Expressions</span><br><span class="line">with cteName(n1, n2) as (select 1, 2) select n1 + n2 from ctenName;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><blockquote><p>limit 20 offset 10;</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> vend_id <span class="keyword">from</span> products; <span class="comment">--只返回不同值</span></span><br><span class="line"><span class="keyword">select</span> prod_name <span class="keyword">from</span> products limit <span class="number">5</span>;  <span class="comment">--返回不多于5行</span></span><br><span class="line"><span class="keyword">select</span> prod_name <span class="keyword">from</span> products limit <span class="number">5</span>, <span class="number">6</span>;  <span class="comment">--从第5行开始的6行（编号从一开始）</span></span><br></pre></td></tr></table></figure><h3 id="排序命令"><a href="#排序命令" class="headerlink" title="排序命令"></a>排序命令</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 排序</span></span><br><span class="line"><span class="keyword">select</span> prod_name <span class="keyword">from</span> products <span class="keyword">order</span> <span class="keyword">by</span> prod_name, prod_price; <span class="comment">--排序</span></span><br><span class="line"><span class="keyword">select</span> prod_name <span class="keyword">from</span> products <span class="keyword">order</span> <span class="keyword">by</span> prod_name, prod_price <span class="keyword">DESC</span>; <span class="comment">--降序排序</span></span><br><span class="line"><span class="keyword">select</span> prod_name <span class="keyword">from</span> products <span class="keyword">order</span> <span class="keyword">by</span> prod_price <span class="keyword">DESC</span>, prod_name; <span class="comment">--仅价格降序排序（多个列上进行排序，则需要在列名后面都加上这样的关键字，ASC:升序）</span></span><br></pre></td></tr></table></figure><h3 id="过滤数据"><a href="#过滤数据" class="headerlink" title="过滤数据"></a>过滤数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 过滤数据 --</span></span><br><span class="line"><span class="keyword">select</span> prod_name, prod_price <span class="keyword">from</span> products <span class="keyword">where</span> prod_price<span class="operator">=</span><span class="number">2.50</span>; <span class="comment">-- 使用where关键字进行条件筛选。与order by 共用的时候，应该放在where之后</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 几个where的子句符号. &lt;&gt;, !=:不等于； BETWEEN:在指定的两个值之间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 单引号用于限定字符串，当值与字符串进行比较，需要使用单引号</span></span><br><span class="line"><span class="keyword">select</span> prod_name, prod_price <span class="keyword">from</span> products <span class="keyword">where</span> prod_name <span class="operator">=</span> <span class="string">&#x27;fuses&#x27;</span>;</span><br><span class="line"><span class="operator">~</span> <span class="keyword">where</span> prod_price <span class="keyword">between</span> <span class="number">5</span> <span class="keyword">and</span> <span class="number">10</span>;  <span class="comment">-- ~表示与前面语句一致，下同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 检查NULL值.这在匹配过滤或者不匹配过滤时候不会返回。</span></span><br><span class="line"><span class="operator">~</span> <span class="keyword">where</span> prod_price <span class="keyword">is</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 次序计算，AND的优先级要更高，但是最好还是利用圆括号将操作符分开</span></span><br><span class="line"><span class="keyword">select</span> prod_name, prod_price <span class="keyword">from</span> products <span class="keyword">where</span> (vend_id <span class="operator">=</span> <span class="number">1002</span> <span class="keyword">or</span> vend_id <span class="operator">=</span> <span class="number">1003</span>) <span class="keyword">AND</span> prod_price <span class="operator">&gt;=</span> <span class="number">10</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- IN 操作符指定条件范围</span></span><br><span class="line"><span class="keyword">select</span> prod_name, prod_price <span class="keyword">from</span> products <span class="keyword">where</span> vend_id <span class="keyword">in</span> (<span class="number">1002</span>, <span class="number">1003</span>) <span class="keyword">order</span> <span class="keyword">by</span> prod_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- NOT操作符</span></span><br><span class="line"><span class="operator">~</span> <span class="keyword">where</span> vend_id <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="number">1002</span>, <span class="number">1003</span>) <span class="operator">~</span></span><br></pre></td></tr></table></figure><p><strong>利用通配符进行过滤</strong><br>通配符(wildcard)：用来匹配值的一部分特殊字符</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- %: 表示任意长度的字符串，但是不包含NULL</span></span><br><span class="line"><span class="keyword">select</span> prod_id, prod_name <span class="keyword">from</span> products <span class="keyword">where</span> prod_name <span class="keyword">like</span> <span class="string">&#x27;jet%&#x27;</span>; <span class="comment">-- 搜索以&#x27;jet&#x27;开头的词</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- _: 只匹配单个字符</span></span><br><span class="line"><span class="operator">~</span> <span class="keyword">like</span> <span class="string">&#x27;_ to anvil&#x27;</span>;</span><br></pre></td></tr></table></figure><blockquote><p>通配符搜索的处理一般要比前面讨论的其他搜索所花时间更长。如果不是必要不要使用，使用的时候最好不要放在搜索的开始（搜索量太大）。</p></blockquote><p><strong>利用正则表达式进行搜索</strong><br>只需要将原先的 <code>LIKE</code>关键词转换成 <code>REGEXP</code>。注意前者是匹配文本在是这个，后者是存在这个，也就是后者只需要这个模式在文本中有出现即可，而前者需要全部一致。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- &#x27;.&#x27;：表示能够匹配任意的字符</span></span><br><span class="line"><span class="keyword">select</span> prod_name <span class="keyword">from</span> products <span class="keyword">where</span> prod_name REGEXP <span class="string">&#x27;.000&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> prod_name; </span><br><span class="line"><span class="comment">-- 正则表达式默认不区分大小写，如果需要则要加上binary关键词</span></span><br><span class="line"><span class="operator">~</span> <span class="keyword">where</span> prod_name REGEXP <span class="type">binary</span> <span class="string">&#x27;JetPack .000&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- OR 匹配</span></span><br><span class="line"><span class="operator">~</span> regexp <span class="string">&#x27;1000|2000&#x27;</span> <span class="operator">~</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 匹配几个字符之一</span></span><br><span class="line"><span class="operator">~</span> REGEXP <span class="string">&#x27;[123] Ton&#x27;</span> <span class="operator">~</span>; <span class="comment">-- 1 Ton、 2 Ton都行</span></span><br><span class="line"><span class="string">&#x27;1|2|3 Ton&#x27;</span>  <span class="comment">-- 等价于</span></span><br><span class="line"><span class="operator">~</span> regexp <span class="string">&#x27;[1-5] Ton&#x27;</span>; <span class="comment">-- 范围匹配</span></span><br><span class="line"><span class="operator">~</span> <span class="keyword">where</span> vend_name regexp <span class="string">&#x27;\\.&#x27;</span>;  <span class="comment">-- 匹配特殊字符，用\\ 作为前导（转义）</span></span><br><span class="line"><span class="comment">-- 空白元字符： \\f----换页； \\n---换行 。。。。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 匹配字符类</span></span><br></pre></td></tr></table></figure><img src="/.com//10/21/Database/%E7%A9%BA%E7%99%BD%E5%85%83%E5%AD%97%E7%AC%A6.png" class title="空白元字符"><img src="/.com//10/21/Database/%E5%AD%97%E7%AC%A6%E7%B1%BB.png" class title="字符类"><p><strong>匹配多个实例</strong><br>可以利用重复元字符对目标字符中的某一个字符进行指定的性质匹配。</p><img src="/.com//10/21/Database/%E9%87%8D%E5%A4%8D%E5%85%83%E5%AD%97%E7%AC%A6.png" class title="重复云字符"><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> prod_name <span class="keyword">from</span> products <span class="keyword">where</span> prod_name regexp <span class="string">&#x27;\\([0-9] sticks?\\)&#x27;</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> prod_name; <span class="comment">-- 最后匹配的是stick 或者 sticks，最后？表示s是可选的匹配字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- [:digit:]: 匹配数字； 第二个[]是为了指明&#123;4&#125; 的作用域</span></span><br><span class="line"><span class="operator">~</span> <span class="keyword">where</span> prod_name regexp <span class="string">&#x27;[[:digit:]]&#123;4&#125;&#x27;</span>; <span class="comment">-- 匹配连续一起的四个数字</span></span><br></pre></td></tr></table></figure><p><strong>定位符</strong></p><img src="/.com//10/21/Database/%E5%AE%9A%E4%BD%8D%E5%85%83%E5%AD%97%E7%AC%A6.png" class title="定位元字符"><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 找到以数字开头（包括小数点）</span></span><br><span class="line"><span class="operator">~</span> <span class="keyword">where</span> prod_name regexp <span class="string">&#x27;[0-9\\.]&#x27;</span>; <span class="comment">-- 这样不行，这会在文本的任意位置查找匹配</span></span><br><span class="line"><span class="operator">~</span> <span class="keyword">where</span> prod_name regexp <span class="string">&#x27;^[0-9\\.]&#x27;</span>; <span class="comment">-- 仅仅从开头开始查找匹配</span></span><br></pre></td></tr></table></figure><h3 id="创建计算字符串"><a href="#创建计算字符串" class="headerlink" title="创建计算字符串"></a>创建计算字符串</h3><p><strong>拼接字符串</strong>使用 <code>Concat()</code>将值联结到一起构成单个值。 （使用sum，计算值的和）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- sum 与 case结合的实例</span></span><br><span class="line"><span class="built_in">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> operation<span class="operator">=</span><span class="string">&#x27;buy&#x27;</span> <span class="keyword">then</span> <span class="operator">-</span>price <span class="keyword">else</span> price <span class="keyword">end</span>)</span><br></pre></td></tr></table></figure><blockquote><p>多数DBMS使用 <code>+</code>或者 <code>||</code>来实现拼接(sqlite中用 <code>||</code>实现)，但是在MySQL中使用 <code>Concat()</code>函数来实现</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> concat(vend_name, <span class="string">&#x27;(&#x27;</span>, vend_country, <span class="string">&#x27;)&#x27;</span>) <span class="keyword">from</span> vendors ...;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除右侧多余空格来整理数据（RTrim() 函数， LTrim()去掉左侧空格）</span></span><br><span class="line"><span class="keyword">select</span> concat(RTrim(vend_name), <span class="string">&#x27;(&#x27;</span>, RTrim(vend_country), <span class="string">&#x27;)&#x27;</span>)...;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 为拼接的字段取名</span></span><br><span class="line"><span class="keyword">select</span> concat(vend_name, <span class="string">&#x27;(&#x27;</span>, vend_country, <span class="string">&#x27;)&#x27;</span>) <span class="keyword">from</span> vendors <span class="keyword">as</span> vend_title...;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 执行算数运算的结果作为一个项</span></span><br><span class="line"><span class="keyword">select</span> prod_id, quantity<span class="operator">*</span>item_price <span class="keyword">as</span> expanded_price <span class="keyword">from</span> ...;</span><br></pre></td></tr></table></figure><h3 id="使用数据处理函数"><a href="#使用数据处理函数" class="headerlink" title="使用数据处理函数"></a>使用数据处理函数</h3><blockquote><p><strong>函数没有SQL的可移植性强</strong>， 如果你决定使用函数，应该保证做好代码注释，以便以后你（或其他人）能确切地知道所编写SQL代码的含义。</p></blockquote><img src="/.com//10/21/Database/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0(%E9%83%A8%E5%88%86).png" class title="常见的文本处理函数(部分)"><blockquote><p><code>Soundex()</code>:会匹配与搜索字符串读音相似的字符串</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> vend_name, <span class="built_in">Upper</span>(vend_name) <span class="keyword">as</span> vend_name_upcase ...;</span><br></pre></td></tr></table></figure><p><strong>日期和时间处理函数</strong><img src="/.com//10/21/Database/%E5%B8%B8%E7%94%A8%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0.png" class title="常用日期和时间处理函数"></p><blockquote><p>使用 <code>WHERE</code>进行筛选，对应的日期格式为：<code>yyyy-mm-dd</code></p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Date()函数得到的仅仅是日期，Time() 函数得到的是时间</span></span><br><span class="line"><span class="comment">-- 下面这段语句不适用Date函数，将会匹配失败，因为where是整个列值进行比较的</span></span><br><span class="line"><span class="keyword">select</span> cust_id, order_num <span class="keyword">from</span> orders <span class="keyword">where</span> <span class="type">Date</span>(order_date) <span class="operator">=</span> <span class="string">&#x27;2005-09-01&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 时间段进行筛选</span></span><br><span class="line"><span class="operator">~</span> <span class="keyword">where</span> <span class="type">Date</span>(order_data) <span class="keyword">between</span> <span class="string">&#x27;2005-09-01&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;2005-9-30&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取时间中的月份或者年份信息</span></span><br><span class="line"><span class="keyword">year</span>(order_date), <span class="keyword">month</span>(order_date);</span><br></pre></td></tr></table></figure><p><strong>数值处理函数</strong></p><img src="/.com//10/21/Database/%E5%B8%B8%E7%94%A8%E6%95%B0%E5%80%BC%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0.png" class title="常用数值处理函数"><h3 id="汇总数据"><a href="#汇总数据" class="headerlink" title="汇总数据"></a>汇总数据</h3><p>获取表中的汇总信息。</p><img src="/.com//10/21/Database/SQL%E8%81%9A%E9%9B%86%E5%87%BD%E6%95%B0.png" class title="SQL聚集函数"><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 返回特定供应商提供的产品的平均价格</span></span><br><span class="line"><span class="comment">-- 不允许使用count(distinct)</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(<span class="keyword">distinct</span> prod_price) <span class="keyword">from</span> products <span class="keyword">where</span> vend_id <span class="operator">=</span> <span class="number">1003</span>;</span><br></pre></td></tr></table></figure><h3 id="分组数据"><a href="#分组数据" class="headerlink" title="分组数据"></a>分组数据</h3><p>分组数据以便能汇总内容的子集, 将数据按照指定的分组进行统计。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> vend_id, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> num_prods <span class="keyword">from</span> products <span class="keyword">group</span> <span class="keyword">by</span> vend_id;</span><br></pre></td></tr></table></figure><p>过滤分组使用 <code>having</code>,这个子句支持所有 <code>where</code>操作符。(对分组数据进行筛选)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 这里直接使用where无法实现相同的目的</span></span><br><span class="line"><span class="operator">~</span> <span class="keyword">group</span> <span class="keyword">by</span> cust_id <span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 过去12个月具有两个或以上的订单，且价格为10以上</span></span><br><span class="line"><span class="keyword">select</span> vend_id, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> num_prods <span class="keyword">from</span> products <span class="keyword">where</span> prod_price <span class="operator">&gt;=</span> <span class="number">10</span> <span class="keyword">group</span> <span class="keyword">by</span> vend_id <span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p><strong>group by &amp; order by</strong></p><blockquote><p>不要忘记ORDER BY 一般在使用GROUP BY子句时，应该也给出ORDER BY子句。这是保证数据正确排序的唯一方法。千万不要仅依赖GROUP BY排序数据。</p></blockquote><h3 id="子查询语句"><a href="#子查询语句" class="headerlink" title="子查询语句"></a>子查询语句</h3><p>在select语句中嵌套select语句, <code>in</code> 或者 <code>not in</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> cust_id</span><br><span class="line"><span class="keyword">from</span> orders</span><br><span class="line"><span class="keyword">where</span> order_num <span class="keyword">in</span>(<span class="keyword">select</span> order_num</span><br><span class="line">                   <span class="keyword">from</span> orderitems</span><br><span class="line">                   <span class="keyword">where</span> prod_id <span class="operator">=</span> <span class="string">&#x27;TNT2&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="联结表"><a href="#联结表" class="headerlink" title="联结表"></a>联结表</h3><p>在联结两个表时，实际上就是将第一个表中的每一行与第二个表中的每一行进行匹配。Note: left join可以用于数据的剔除（Not in的效果）</p><p><img src="/.com//join.jpg" alt="img"></p><blockquote><p>Ref: Database System Concepts 7ed(Abraham Silberschatz, Henry F. Korth etc.)</p></blockquote><p><strong><code>&gt; some</code>: greater than at least one</strong><br><strong><code>&gt; all</code>: greater than all. <code>&lt;&gt; all</code>: not in</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> salary <span class="operator">&gt;</span> <span class="keyword">some</span> (<span class="keyword">select</span> salary</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> dept name <span class="operator">=</span> <span class="string">&#x27;Biology&#x27;</span>);</span><br></pre></td></tr></table></figure><ul><li><code>cross join</code><ul><li>先将两个表进行笛卡尔积，然后利用后面的on对联结表进行筛选<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a.Id</span><br><span class="line"><span class="keyword">from</span> weather <span class="keyword">as</span> a </span><br><span class="line"><span class="keyword">cross</span> <span class="keyword">join</span> weather <span class="keyword">as</span> b</span><br><span class="line"><span class="keyword">on</span> datediff(a.recordDate, b.recordDate) <span class="operator">=</span> <span class="number">1</span>  <span class="comment">-- 这里就是筛选的条件了</span></span><br><span class="line"><span class="keyword">where</span> a.temperature <span class="operator">&gt;</span> b.temperature;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><strong>内部联结</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.... <span class="keyword">from</span> ...(列名) <span class="keyword">inner</span> <span class="keyword">join</span> ... <span class="keyword">on</span> ....(<span class="keyword">condition</span>);</span><br></pre></td></tr></table></figure><h3 id="高级联结"><a href="#高级联结" class="headerlink" title="高级联结"></a>高级联结</h3><p><strong>自联结</strong>：利用别名对同一个表中的条件进行筛选</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> p1.id, p1.name </span><br><span class="line"><span class="keyword">from</span> product <span class="keyword">as</span> p1, product <span class="keyword">as</span> p2  <span class="comment">-- 对同一个表给予两个不同的别名</span></span><br><span class="line"><span class="keyword">where</span> p1.id <span class="operator">=</span> p2.id <span class="keyword">and</span> p2.id <span class="operator">=</span> <span class="string">&#x27;DTNTR&#x27;</span>;  <span class="comment">-- 这样就得到了id为&#x27;DTNTR&#x27;的名称了</span></span><br></pre></td></tr></table></figure><blockquote><p>使用场景： 删除表中重复的元素.仅保留id较小的元素</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> p1 <span class="keyword">from</span> person <span class="keyword">as</span> p1, person <span class="keyword">as</span> p2</span><br><span class="line"><span class="keyword">where</span> p1.email<span class="operator">=</span>p2.email <span class="keyword">and</span> p1.Id <span class="operator">&gt;</span> p2.id;</span><br></pre></td></tr></table></figure></blockquote><p><strong>外部联结</strong>：联结包含了那些在相关表中没有关联行的行。使用关键字 <code>LEFT OUTER JOIN</code>（左外部联结）</p><h3 id="创建组合查询"><a href="#创建组合查询" class="headerlink" title="创建组合查询"></a>创建组合查询</h3><p>使用关键字 <code>Union</code>将两个子句的结果进行组合。</p><blockquote><p>UNION中的每个查询必须包含相同的列、表达式或聚集函数<br>自动去除重复的行（使用 <code>Union all</code>保留所有的行）<br>末尾的 <code>order by</code>不会是对单一语句的排序，而是对返回的所有的结果进行排序的。</p></blockquote><blockquote><p>union 和 union all都可以起到关联结果集的作用,<br>union 会自动去除关联的两个结果集中的重复数据<br>union all 不会主动去除两个结果集中的重复数据,会展示所有的数据</p></blockquote><h3 id="使用全文本搜索"><a href="#使用全文本搜索" class="headerlink" title="使用全文本搜索"></a>使用全文本搜索</h3><p>在建表的时候， 添加 <code>FULLEXT(...)</code>.在检索的时候，会根据这个指示进行检索</p><blockquote><p>CREATE TABLE语句接受FULLTEXT子句，它给出被索引列的一个逗号分隔的列表。<br>在索引之后，使用两个函数Match()和Against()执行全文本搜索，其中Match()指定被搜索的列，Against()指定要使用的搜索表达式。(Match中的值与FULLEXT中定义的相同)。 这种方法，当匹配词出现在更前面的时候，输出的优先级要高一些。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ... <span class="keyword">where</span> <span class="keyword">Match</span>(note_text) Against(<span class="string">&#x27;rabbit&#x27;</span>);</span><br></pre></td></tr></table></figure><p><strong>查询拓展</strong><br>将包含目标词的语句中的词的语句也同样输出来。(<code>with query expansion</code>)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">... <span class="keyword">where</span> <span class="keyword">match</span>(note_text) Against(<span class="string">&#x27;anvils&#x27;</span> <span class="keyword">with</span> query expansion);</span><br></pre></td></tr></table></figure><p><strong>布尔文本搜索</strong>MySQL支持全文本搜索的另外一种形式，称为布尔方式（boolean mode）。</p><blockquote><p>全文本搜索布尔操作符-和<em>，-排除一个词，而</em>是截断操作符（可想象为用于词尾的一个通配符）</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">... <span class="keyword">where</span> <span class="keyword">match</span>(..) against(<span class="string">&#x27;...&#x27;</span> <span class="keyword">in</span> <span class="type">boolean</span> mode);</span><br><span class="line">... <span class="keyword">where</span> <span class="keyword">match</span>(..) against(<span class="string">&#x27;... -rope*&#x27;</span> <span class="keyword">in</span> <span class="type">boolean</span> mode); <span class="comment">-- 匹配包含...但不包含任意以rope开始的词的行</span></span><br></pre></td></tr></table></figure><h3 id="插入完整的行"><a href="#插入完整的行" class="headerlink" title="插入完整的行"></a>插入完整的行</h3><p>需要指定表名，以及表下所有的对应的列的信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- insert 插入一行到一个表中</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Customers <span class="keyword">values</span>(list_infomation);  <span class="comment">--虽然这种语法很简单，但并不安全，应该尽量避免使用</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Custormers(cust_name, cust_address,....) <span class="keyword">values</span>(list_infomation);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Custormers(cust_name, cust_address,....) <span class="keyword">values</span>(list_infomation1)， (list_infomation2);  <span class="comment">-- 插入两行到一个表中</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Custormers(cust_name, cust_address,....) <span class="keyword">select</span> cust_name, cust_address,.... <span class="keyword">from</span> custnew; <span class="comment">-- 利用select语句进行填充</span></span><br></pre></td></tr></table></figure><h3 id="更新与删除数据"><a href="#更新与删除数据" class="headerlink" title="更新与删除数据"></a>更新与删除数据</h3><p>更新使用关键词 <code>update</code></p><blockquote><p>MySQL没有撤销（undo）按钮。应该非常小心地使用UPDATE和DELETE.</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> customers <span class="keyword">set</span> cust_name <span class="operator">=</span> <span class="string">&#x27;..&#x27;</span>, cust_email <span class="operator">=</span> <span class="string">&#x27;,,&#x27;</span> <span class="keyword">where</span> cust_id <span class="operator">=</span> <span class="number">1002</span>; <span class="comment">-- 可以一次性更新多个信息</span></span><br><span class="line"><span class="comment">-- 为了删除某个列的值，可设置它为NULL（假如表定义允许NULL值）。</span></span><br><span class="line"><span class="comment">-- 替换的新的值可以使用if语句</span></span><br></pre></td></tr></table></figure><p>删除数据使用关键词 <code>delete</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> customers <span class="keyword">where</span> cust_id <span class="operator">=</span> <span class="number">1006</span>; <span class="comment">-- DELETE不需要列名或通配符。DELETE删除整行而不是删除列。为了删除指定的列，请使用UPDATE语句</span></span><br></pre></td></tr></table></figure><h3 id="创建和操纵表"><a href="#创建和操纵表" class="headerlink" title="创建和操纵表"></a>创建和操纵表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tableName(</span><br><span class="line">    <span class="comment">-- AUTO_INCREMENT：本列每当增加一行时自动增量， 每个表只允许一个AUTO_INCREMENT列，而且它必须被索引</span></span><br><span class="line">    <span class="comment">-- 与大多数DBMS不一样，MySQL不允许使用函数作为默认值，它只支持常量</span></span><br><span class="line">    cust_id <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT <span class="keyword">default</span> <span class="number">1</span>,</span><br><span class="line"><span class="comment">--  列名   类型  是否允许NULL             未给出值的时候，默认为1</span></span><br><span class="line">    <span class="comment">-- 主键中只能使用不允许NULL值的列</span></span><br><span class="line">    <span class="keyword">primary</span> key (cust_id)</span><br><span class="line">)ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"><span class="comment">-- 引擎类型，如果省略ENGINE=语句，则使用默认引擎（很可能是MyISAM）。 外键不能跨引擎</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改, 给表添加一个列</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">add</span> vendor <span class="type">char</span>(<span class="number">20</span>);  </span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">drop</span> <span class="keyword">column</span> vendor; <span class="comment">-- 删除</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">add</span> <span class="keyword">constraint</span> .... <span class="comment">-- etc</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除表（删除整个表而不是其内容）</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> table_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">--重命名表</span></span><br><span class="line">rename <span class="keyword">table</span> t <span class="keyword">to</span> t1;</span><br></pre></td></tr></table></figure><h3 id="使用视图"><a href="#使用视图" class="headerlink" title="使用视图"></a>使用视图</h3><p>视图本身不包含数据，因此它们返回的数据是从其他表中检索出来的(实际上就是将一个sql语句进行封装)</p><blockquote><p>视图用 <code>CREATE VIEW</code>语句来创建。</p><ul><li>使用 <code>SHOW CREATE VIEW viewname；</code>来查看创建视图的语句。</li><li>用DROP删除视图，其语法为 <code>DROP VIEW viewname;</code>。</li><li>更新视图时，可以先用DROP再用CREATE，也可以直接用 <code>CREATE OR  REPLACE VIEW</code>。如果要更新的视图不存在，则第2条更新语句会创<br>建一个视图；如果要更新的视图存在，则第2条更新语句会替换原<br>有视图</li></ul></blockquote><blockquote><p>并非所有视图都是可更新的。基本上可以说，如果MySQL不能正确地确定被更新的基数据，则不允许更新（包括插入和删除）</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> view_name <span class="keyword">as</span> <span class="keyword">select</span> .....;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;杂项&quot;&gt;&lt;a href=&quot;#杂项&quot; class=&quot;headerlink&quot; title=&quot;杂项&quot;&gt;&lt;/a&gt;杂项&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;SQL therefore treats as unknown the result of any comparison </summary>
      
    
    
    
    
    <category term="DB" scheme="http://example.com/tags/DB/"/>
    
  </entry>
  
  <entry>
    <title>6.S081lab1</title>
    <link href="http://example.com/2022/10/21/6_S081lab1/"/>
    <id>http://example.com/2022/10/21/6_S081lab1/</id>
    <published>2022-10-21T03:30:25.000Z</published>
    <updated>2022-12-22T06:31:12.115Z</updated>
    
    <content type="html"><![CDATA[<h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><h3 id="使用Tmux在一个终端中创建多个窗口"><a href="#使用Tmux在一个终端中创建多个窗口" class="headerlink" title="使用Tmux在一个终端中创建多个窗口"></a>使用Tmux在一个终端中创建多个窗口</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tmux # 进入新建的会话中</span><br><span class="line">Ctrl + B , % # 垂直分割（左右）</span><br><span class="line">Ctrl + B , “ # 水平分割（上下）</span><br><span class="line">Ctrl + B , 方向键 # 在不同的终端中切换</span><br><span class="line">exit  # 退出会话</span><br></pre></td></tr></table></figure><h3 id="启动qemu的gdb模式"><a href="#启动qemu的gdb模式" class="headerlink" title="启动qemu的gdb模式"></a>启动qemu的gdb模式</h3><p>在第一个窗口运行 <code>make CPUS=1 qemu-gdb</code>, 第二个窗口运行 <code>gdb-multiarch</code>，开启gdb模式。</p><p>如果lient端没有连接到server，那么需要在 <code>/root</code> 创建 <code>.gdbinit</code> 文件, 加上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add-auto-load-safe-path /root/xv6-labs-2022/.gdbinit  # xv6 directory</span><br></pre></td></tr></table></figure><h4 id="gdb的使用方法"><a href="#gdb的使用方法" class="headerlink" title="gdb的使用方法"></a>gdb的使用方法</h4><p>首先是链接文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file fileName</span><br></pre></td></tr></table></figure><p>常见的命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">r = run</span><br><span class="line">c = continue # 让暂停的程序继续运行</span><br><span class="line">n = next  # 运行到下一行</span><br><span class="line">s = step # 单步执行，遇到函数会进入</span><br><span class="line">p = print  # 打印变量或寄存器</span><br></pre></td></tr></table></figure><h2 id="实验一"><a href="#实验一" class="headerlink" title="实验一"></a>实验一</h2><p>预备知识：</p><ul><li><code>pid_t wait(int *wstatus)</code>：等待（阻塞状态）子进程状态发生变化（子进程终结、子进程被信号停止或恢复）。如果子进程是被终结，那么wait能够允许系统释放子进程的资源。如果wait没有得到执行，那么终结的子进程就会变成“僵尸”状态。<code>exit(0)</code>表示等待所有的子进程退出。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RD 0 <span class="comment">//pipe的read端</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WR 1 <span class="comment">//pipe的write端</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> buf = <span class="string">&#x27;P&#x27;</span>; <span class="comment">//用于传送的字节</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd_c2p[<span class="number">2</span>]; <span class="comment">//子进程-&gt;父进程</span></span><br><span class="line">    <span class="type">int</span> fd_p2c[<span class="number">2</span>]; <span class="comment">//父进程-&gt;子进程</span></span><br><span class="line">    <span class="built_in">pipe</span>(fd_c2p);</span><br><span class="line">    <span class="built_in">pipe</span>(fd_p2c);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="type">int</span> exit_status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;fork() error!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(fd_c2p[RD]);</span><br><span class="line">        <span class="built_in">close</span>(fd_c2p[WR]);</span><br><span class="line">        <span class="built_in">close</span>(fd_p2c[RD]);</span><br><span class="line">        <span class="built_in">close</span>(fd_p2c[WR]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">//子进程</span></span><br><span class="line">        <span class="built_in">close</span>(fd_p2c[WR]);</span><br><span class="line">        <span class="built_in">close</span>(fd_c2p[RD]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">read</span>(fd_p2c[RD], &amp;buf, <span class="built_in">sizeof</span>(<span class="type">char</span>)) != <span class="built_in">sizeof</span>(<span class="type">char</span>)) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;child read() error!\n&quot;</span>);</span><br><span class="line">            exit_status = <span class="number">1</span>; <span class="comment">//标记出错</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">1</span>, <span class="string">&quot;%d: received ping\n&quot;</span>, <span class="built_in">getpid</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">write</span>(fd_c2p[WR], &amp;buf, <span class="built_in">sizeof</span>(<span class="type">char</span>)) != <span class="built_in">sizeof</span>(<span class="type">char</span>)) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;child write() error!\n&quot;</span>);</span><br><span class="line">            exit_status = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">close</span>(fd_p2c[RD]);</span><br><span class="line">        <span class="built_in">close</span>(fd_c2p[WR]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(exit_status);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//父进程</span></span><br><span class="line">        <span class="built_in">close</span>(fd_p2c[RD]);</span><br><span class="line">        <span class="built_in">close</span>(fd_c2p[WR]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">write</span>(fd_p2c[WR], &amp;buf, <span class="built_in">sizeof</span>(<span class="type">char</span>)) != <span class="built_in">sizeof</span>(<span class="type">char</span>)) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;parent write() error!\n&quot;</span>);</span><br><span class="line">            exit_status = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">read</span>(fd_c2p[RD], &amp;buf, <span class="built_in">sizeof</span>(<span class="type">char</span>)) != <span class="built_in">sizeof</span>(<span class="type">char</span>)) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;parent read() error!\n&quot;</span>);</span><br><span class="line">            exit_status = <span class="number">1</span>; <span class="comment">//标记出错</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">1</span>, <span class="string">&quot;%d: received pong\n&quot;</span>, <span class="built_in">getpid</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">close</span>(fd_p2c[WR]);</span><br><span class="line">        <span class="built_in">close</span>(fd_c2p[RD]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(exit_status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><ul><li>0、1、2是文件描述符（分别对应stdin、stdout、stderr）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fprintf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span><span class="comment">// C 库函数发送格式化输出到流 stream 中。</span></span></span><br><span class="line"><span class="function"><span class="comment">// -----------------------------------------------------------</span></span></span><br><span class="line"><span class="function"><span class="keyword">struct</span> dirent</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">　　<span class="type">long</span> d_ino; <span class="comment">/* inode number 索引节点号 */</span></span><br><span class="line">    <span class="type">off_t</span> d_off; <span class="comment">/* offset to this dirent 在目录文件中的偏移 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> d_reclen; <span class="comment">/* length of this d_name 文件名长 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> d_type; <span class="comment">/* the type of d_name 文件类型 */</span></span><br><span class="line">    <span class="type">char</span> d_name [NAME_MAX+<span class="number">1</span>]; <span class="comment">/* file name (null-terminated) 文件名，最长255字符 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------------------------------------------</span></span><br><span class="line"><span class="comment">// 从 str2 复制 n 个字符到 str1，但是在重叠内存块这方面，memmove() 是比 memcpy() 更安全的方法</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">memmove</span><span class="params">(<span class="type">void</span> *str1, <span class="type">const</span> <span class="type">void</span> *str2, <span class="type">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="实验二"><a href="#实验二" class="headerlink" title="实验二"></a>实验二</h2><h3 id="trace"><a href="#trace" class="headerlink" title="trace"></a>trace</h3><p>TODO: 理清楚整个调用的过程</p><p>xv6系统调用的过程，这里以fork为例:</p><img src="/.com//10/21/6_S081lab1/fork.png" class>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;杂项&quot;&gt;&lt;a href=&quot;#杂项&quot; class=&quot;headerlink&quot; title=&quot;杂项&quot;&gt;&lt;/a&gt;杂项&lt;/h2&gt;&lt;h3 id=&quot;使用Tmux在一个终端中创建多个窗口&quot;&gt;&lt;a href=&quot;#使用Tmux在一个终端中创建多个窗口&quot; class=&quot;headerli</summary>
      
    
    
    
    
    <category term="OS" scheme="http://example.com/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>C++ primer</title>
    <link href="http://example.com/2022/10/12/C-primer/"/>
    <id>http://example.com/2022/10/12/C-primer/</id>
    <published>2022-10-12T12:07:04.000Z</published>
    <updated>2022-10-22T00:41:39.360Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TODO："><a href="#TODO：" class="headerlink" title="TODO："></a>TODO：</h2><p>总结各种初始化方法</p><h1 id="temp"><a href="#temp" class="headerlink" title="temp"></a>temp</h1><ul><li>p407：内置类型或组合类型的对象的值将是未定义的，而类对象将用默认构造函数进行初始化<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">string *ps = <span class="keyword">new</span> string;  <span class="comment">// empty string</span></span><br><span class="line"><span class="type">int</span> *pi = <span class="keyword">new</span> <span class="type">int</span>;  <span class="comment">// uninitialized int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 值初始化</span></span><br><span class="line"><span class="type">int</span> *pi2 = <span class="keyword">new</span> <span class="built_in">int</span>(); <span class="comment">// initialized as 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝构造也可以这样</span></span><br><span class="line"><span class="keyword">auto</span> p1 = <span class="keyword">new</span> <span class="built_in">auto</span>(p2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态分配const 对象</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *pci = <span class="keyword">new</span> <span class="type">const</span> <span class="built_in">int</span>(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure></li></ul><p>有一个很容易出错的点，当函数返回一个指向动态内存的指针的时候，调用者需要自行删除内存。还有在内存被释放之后，应该将指针空，这样可以防止使用被释放了的内存。当同一块内存释放两次，可能会对自由空间造成破坏。</p><ul><li><p>接受指针参数的只能智能指针的构造函数是explicit的，所以不能将一个内置的指针隐式地转换成智能指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; p1 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1024</span>); <span class="comment">// Error!</span></span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt;<span class="built_in">p2</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">42</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同样函数作为返回值的时候也是不能进行隐式转换的</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">clone</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="comment">// return new int(p); // Error!</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;<span class="type">int</span>&gt;(<span class="keyword">new</span> <span class="built_in">int</span> (p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在利用智能指针进行传参的时候，不能直接传入一个内置的指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(shared_ptr&lt;<span class="type">int</span>&gt; ptr)</span></span>&#123; <span class="comment">// 智能指针的引用+1，在函数中的引用不会小于2</span></span><br><span class="line">....</span><br><span class="line">&#125;<span class="comment">// 离开作用域之后，ptr所指向的内存不会被销毁</span></span><br><span class="line"><span class="comment">// 你需要使用一个临时变量进行传参</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;</span><br><span class="line"><span class="built_in">process</span>(p); <span class="comment">// 离开作用域之后p这个临时变量就会被销毁</span></span><br></pre></td></tr></table></figure></li><li><p>利用get函数能够获得智慧指针的内置指针。</p></li></ul><p><code>永远不要get初始化另一个智能指针或者为另一个智能指针赋值</code>。他们会指向相同的内存</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;</span><br><span class="line"><span class="type">int</span> *q = p.<span class="built_in">get</span>();</span><br></pre></td></tr></table></figure><ul><li>其他操作<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查p是不是指向该内存的唯一指针，是则重置并分配指针</span></span><br><span class="line"><span class="keyword">if</span>(!p.<span class="built_in">unique</span>())p.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">string</span>(*p));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">smart</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="built_in">int</span>();</span><br><span class="line">    <span class="keyword">auto</span> sp = <span class="built_in">shared_ptr</span>&lt;<span class="type">int</span>&gt;(p);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;address of p: &quot;</span> &lt;&lt; p </span><br><span class="line">        &lt;&lt; <span class="string">&quot;\n addresss of sp:&quot;</span> &lt;&lt; sp  <span class="comment">// p与sp的地址相同 </span></span><br><span class="line">        &lt;&lt; <span class="string">&quot;\n Count:&quot;</span> &lt;&lt; sp.<span class="built_in">use_count</span>() &lt;&lt; endl;  <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><strong>unique_ptr</strong></li></ul><p>这种指针只能指向一个给定的对象，不支持普通的拷贝或者赋值操作，没有类似<code>make_shared</code>的标准库函数返回一个这样的指针，只能通过绑定到一个new返回的指针上</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转移</span></span><br><span class="line">unique_ptr&lt;<span class="type">int</span>&gt;<span class="built_in">p1</span>(p2.<span class="built_in">release</span>());</span><br><span class="line"><span class="comment">// 或者.reset释放了p1指向的内存</span></span><br><span class="line">p1.<span class="built_in">reset</span>(p2.<span class="built_in">release</span>());</span><br><span class="line">p2.<span class="built_in">release</span>(); <span class="comment">// Error!要释放p2指向的内存</span></span><br></pre></td></tr></table></figure><h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ul><li><p>当结构体很大且需要将结构体作为指针传入到函数中的时候，这时候最好是转入一个结构体指针</p></li><li><p>C++的函数名表示函数指针，你可以使用这个函数名作为函数的输入参数</p></li><li><p>C++中不允许<code>main()</code>调用自己，而在C语言中可以</p></li><li><p>存在递归的函数不能设置为内联函数</p></li><li><p>应该将默认参数全部放在参数的最后。</p></li><li><p>使用别名传参（引用传参）的时候，传入的变量会可能会被修改，其效果和传址的方式类似。</p></li></ul> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>  <span class="title">swap</span> <span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="built_in">swap</span> (a, b);</span><br><span class="line"><span class="comment">//这个时候函数体内的变量和传入的变量是同一个变量</span></span><br></pre></td></tr></table></figure><img src="/.com//10/12/C-primer/20211209210853.png" class><ul><li>**重载解析(Overload Resolution)**： 编译器选择哪一个版本的函数的过程（函数可能经过重载等会有多个同名函数）</li></ul><h2 id="Object-Oriented-Programming"><a href="#Object-Oriented-Programming" class="headerlink" title="Object-Oriented Programming"></a>Object-Oriented Programming</h2><ul><li>在类中定义的任何函数在默认情况下都会被认为是内联函数（内联函数只能在定义它的文件当中使用，但是一些编译器有智能链接器，可以让内联函数在其他文件当中被使用）<u>p517最后一段不是很理解</u><blockquote><p><strong>重写逻辑（Rewriting Rule）</strong>：</p></blockquote></li><li>其实类的使用与client-sever模型很相似</li><li>如果有一种更好的实现方法，那么你应该仅修改函数的具体实现细节，而不是对应的接口</li></ul><p><strong>构造函数</strong>：</p><ul><li>如果没有构造函数，你不能直接对类进行初始化，因为这些数据是仅能进行私有访问的，所以你需要一个能够访问这些私有变量的函数，也就是构造函数。</li><li>构造函数不需要返回值类型，名称应该与类名一致，并且构造函数还会在类被定义的时候自动被调用，同时为了避免混淆，构造函数中的参数名称不能与成员变量的名称一致，对于成员变量可以在变量名称前面加上<code>m_</code>或者在名称后面加上<code>_</code></li></ul><p>构造函数不能直接通过对象直接访问，当构造函数完成它的任务之后，这个对象的构造函数就消失了。</p><p><strong>关于构造函数的使用</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Stock food = <span class="built_in">Stock</span>(<span class="string">&quot;World Cabbage&quot;</span>, <span class="number">250</span>, <span class="number">1.25</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">Stock <span class="title">garment</span><span class="params">(<span class="string">&quot;Furry Mason&quot;</span>, <span class="number">50</span>, <span class="number">2.5</span>)</span></span>;</span><br><span class="line">Stock pstock* = <span class="keyword">new</span> <span class="built_in">Stock</span>(<span class="string">&quot;Electroshock Games&quot;</span>, <span class="number">19</span>, <span class="number">19.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// List Initialization</span></span><br><span class="line">Stock hot_tip = &#123;<span class="string">&quot;Derivative Plus Plus&quot;</span>, <span class="number">100</span>, <span class="number">45.0</span>&#125;;</span><br><span class="line">Stock hot_tip&#123;<span class="string">&quot;Derivative Plus Plus&quot;</span>, <span class="number">100</span>, <span class="number">45.0</span>&#125;</span><br><span class="line">Stock temp&#123;&#125;;</span><br></pre></td></tr></table></figure><p>在对一个以赋值的类变量进行赋值的时候，编译器会先构造一个临时的变量，然后将内容转移到另一个类变量中，这时候再删除这个变量。一些编译器会让这个临时变量存在一段时间，之后再调用析构函数。下面是一个关于这方面的例子，首先利用一个构造函数创建一个变量，然后对这个变量进行一个重新赋值，这时候，就需要上面的临时变量了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stock stock2 = <span class="built_in">Stock</span>(<span class="string">&quot;Boffo Objects&quot;</span>, <span class="number">2</span>, <span class="number">2.0</span>);  <span class="comment">// Constructor called</span></span><br><span class="line">stock2 = <span class="built_in">Stock</span>(<span class="string">&quot;Nifty Foods&quot;</span>, <span class="number">10</span>, <span class="number">50.0</span>); <span class="comment">// The constructor and destructor for temporary variable will be called</span></span><br></pre></td></tr></table></figure><p>所以可以看出，<strong>利用第一种方法直接对变量初始化是一种更加高效的方法</strong>（防止临时变量的出现）。</p><p>当程序退出的时候，先声明的变量的构造器会最后被调用，因为这些变量都是存放在一个栈中的。</p><p>**<code>const</code> 成员函数 (静态成员变量)**：<br>有时候用一个const关键字修饰了一个类变量，这个变量应该是不能被修改的，但是对于一些函数不能保证不修改这个变量，所以可以在函数后面加上一个<code>const</code>关键字，声明这个函数是不修改静态变量的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// Promises not to change invoking object</span></span><br></pre></td></tr></table></figure><p>TIPS：当你声明的成员函数不修改变量的时候，你最好在后面加上一个<code>const</code>关键字。</p><h3 id="对象列表"><a href="#对象列表" class="headerlink" title="对象列表"></a>对象列表</h3><p>你可以对列表中的每一个元素分别使用构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> STKS = <span class="number">4</span>;</span><br><span class="line">Stock stocks[STKS] = &#123;</span><br><span class="line"><span class="built_in">Stock</span>(<span class="string">&quot;NanoSmart&quot;</span>, <span class="number">12.5</span>, <span class="number">20</span>),</span><br><span class="line"><span class="built_in">Stock</span>(<span class="string">&quot;Boffo Objects&quot;</span>, <span class="number">200</span>, <span class="number">2.0</span>),</span><br><span class="line"><span class="built_in">Stock</span>(<span class="string">&quot;Monolithic Obelisks&quot;</span>, <span class="number">130</span>, <span class="number">3.25</span>),</span><br><span class="line"><span class="built_in">Stock</span>(<span class="string">&quot;Fleep Enterprises&quot;</span>, <span class="number">60</span>, <span class="number">6.5</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="this-指针"><a href="#this-指针" class="headerlink" title="this 指针"></a>this 指针</h3><p>一个指向类自己的指针，当一个函数访问私有变量的时候，实际上就是在使用this这个类来访问。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A member function</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; val&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// C-type</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">const</span> Stock*<span class="keyword">this</span>)</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="keyword">this</span>-&gt;val&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Class-Scope-Constants"><a href="#Class-Scope-Constants" class="headerlink" title="Class Scope Constants"></a>Class Scope Constants</h3><p>属于这个类的常量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">enum</span> &#123;Months=<span class="number">12</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种声明不会创建类数据成员。</p><p>第二种定义类内常量的方式——使用关键词<code>static</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bakery</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> Months = <span class="number">12</span>;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拥有类作用域的枚举类型（C-11）"><a href="#拥有类作用域的枚举类型（C-11）" class="headerlink" title="拥有类作用域的枚举类型（C++11）"></a>拥有类作用域的枚举类型（C++11）</h3><p>在通常的枚举类型中，其中的枚举变量的名称不能一致，因为两个不同的枚举变量之间的作用域是一致的，但是在C++11中，提供了一种拥有类作用域的枚举类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">egg</span>&#123;Small, Medium, Large, Jumbo&#125;;</span><br><span class="line">egg choice = egg::Larger;</span><br></pre></td></tr></table></figure><p>但是不像传统的枚举类型，类枚举类型不能进行隐式类型转换。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">egg_old</span> &#123;Small, Medium, Large, Jumbo&#125;; <span class="comment">// unscoped</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">t_shirt</span> &#123;Small, Medium, Large, Xlarge&#125;; <span class="comment">// scoped</span></span><br><span class="line">egg_old one = Medium; <span class="comment">// unscoped</span></span><br><span class="line">t_shirt rolf = t_shirt::Large; <span class="comment">// scoped</span></span><br><span class="line"><span class="type">int</span> king = one; <span class="comment">// implicit type conversion for unscoped</span></span><br><span class="line"><span class="type">int</span> ring = rolf; <span class="comment">// not allowed, no implicit type conversion</span></span><br><span class="line"><span class="keyword">if</span> (king &lt; Jumbo) <span class="comment">// allowed</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Jumbo converted to int before comparison.\n&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (king &lt; t_shirt::Medium) <span class="comment">// not allowed</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Not allowed: &lt; not defined for scoped enum.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是可以进行显示类型转换</span></span><br><span class="line"><span class="type">int</span> Frodo = <span class="built_in">int</span>(t_shirt::Small);</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以指定其中变量的类型</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">class</span> : <span class="type">short</span> pizza &#123;Small, Medium, Large, XLarge&#125;;</span><br></pre></td></tr></table></figure><h2 id="输入输出方面的命令"><a href="#输入输出方面的命令" class="headerlink" title="输入输出方面的命令"></a>输入输出方面的命令</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">getline</span>(cin, string_var); <span class="comment">// 读取整行，包括前导和嵌入的空格（应该是遇到&quot;\n&quot;时结束）</span></span><br><span class="line">cin &gt;&gt; char_variable; <span class="comment">// 从第一个非空格开始阅读，当读取到下一个空白字符时，停止读取</span></span><br><span class="line">cin.<span class="built_in">get</span>(); <span class="comment">// cin对象的内置函数，获取一个字符，并返回（赋值的方式）</span></span><br><span class="line"><span class="comment">/*对于这个函数，可以用于暂停程序的一个方法（按下回车以继续）*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// What are the differences they make ?</span></span><br></pre></td></tr></table></figure><h2 id="Separate-Compilation"><a href="#Separate-Compilation" class="headerlink" title="Separate Compilation"></a>Separate Compilation</h2><p>在编写大型程序的时候，最好将程序放在三个文件当中。</p><ul><li>一个是头文件，这个用于存储函数头和一些结构体的声明，但是不能定义一些具体的变量，因为这个头文件可能会被不同的程序文件所包含，这使得头文件可能会被反复编译，这可能会导致重定义的问题。</li><li>一个是用于定义函数的文件。</li><li>一个是主程序文件，这个文件中包含main文件。</li></ul><p><strong>守卫</strong>：为了防止一些变量被反复编译，C++中定义了守卫</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># ifndefine FUNCTION_NAME</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> FUNCTION_NAME</span></span><br><span class="line">....<span class="comment">// Your code</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>当存在多个程序文件的时候，程序就会进行联合编译。在window中直接运行即可，但是在UNIX系统中需要指定联合编译的文件。(在Linux系统中只需要执行其中一个文件即可，这是用include语句包含了对应的文件)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CC file1.cpp file2.cpp</span><br><span class="line"></span><br><span class="line">g++ file1.cpp file2.cpp</span><br></pre></td></tr></table></figure><p>在包含文件的时候，不同的标点符号会使得程序查找文件的范围顺序有所差异</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;file&gt;</span>  <span class="comment">//在系统文件中寻找</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&quot;file&quot;</span>  <span class="comment">// 优先在当前路径下查找文件</span></span></span><br></pre></td></tr></table></figure><h2 id="Storage-Duration-Scope-and-Linkage"><a href="#Storage-Duration-Scope-and-Linkage" class="headerlink" title="Storage Duration, Scope, and Linkage"></a>Storage Duration, Scope, and Linkage</h2><p>C++中的常见变量的生命周期：</p><ol><li><strong>Automatic storage duration</strong> ： 在函数中定义的变量，当函数结束的时候，变量会被释放</li><li><strong>Static storage duration</strong>： 在函数外或者其他地方定义的变量，当程序结束的时候被释放</li><li><strong>Thread storage duration (C++11)</strong> ： 生命周期局限于某一个线程</li><li><strong>Dynamic storage duration</strong> ： 由关键字<code>new</code>申请的空间，生命周期由操作者确定，或者在程序结束的时候被释放</li></ol><h3 id="变量的作用域（Scope）"><a href="#变量的作用域（Scope）" class="headerlink" title="变量的作用域（Scope）"></a>变量的作用域（Scope）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> outter = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="type">int</span> outter = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;The inner = &quot;</span> &lt;&lt; outter &lt;&lt; endl; <span class="comment">// 这里的outter与外部的无关</span></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;The outer = &quot;</span> &lt;&lt; outter &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* The inner = 10</span></span><br><span class="line"><span class="comment">The outer = 100*/</span></span><br></pre></td></tr></table></figure><p>在函数内部出现与全局变量一致的变量，这个时候函数内的这个变量会是局部变量，想要访问全局变量需要使用作用域解析运算符<code>::</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> warming = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">local</span> <span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">double</span> warming = <span class="number">5</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Local = &quot;</span>&lt;&lt; warming&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Global = &quot;</span>&lt;&lt; :: warming &lt;&lt; endl;  <span class="comment">// 访问全局变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器是通过利用栈将这些变量的优先级进行调整的，当进入一个函数的时候，声明的变量会出现在栈顶端，这时候条用这个变量的时候就会优先调用这个函数内的局部变量。<br>全局变量应该仅仅被使用于一些通用的变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> months[<span class="number">12</span>] =</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;January&quot;</span>, <span class="string">&quot;February&quot;</span>, <span class="string">&quot;March&quot;</span>, <span class="string">&quot;April&quot;</span>, <span class="string">&quot;May&quot;</span>,</span><br><span class="line"><span class="string">&quot;June&quot;</span>, <span class="string">&quot;July&quot;</span>, <span class="string">&quot;August&quot;</span>, <span class="string">&quot;September&quot;</span>, <span class="string">&quot;October&quot;</span>,</span><br><span class="line"><span class="string">&quot;November&quot;</span>, <span class="string">&quot;December&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里第二个const是为了保证数组不被改变，第一个是为了使得数组内的指针所指向的元素</span></span><br><span class="line"><span class="comment">不会发生改变</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这样理解：第一个const实际上是得到一个类型const char* 这代表数组元素，第二个修饰数组</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>const</code>关键词实际上就是在表明变量的<strong>内存</strong>一旦确定之后在之后就不应该被改变了<br>在联合编译的时候，一个文件中定义的全局变量会在另外一个文件中被访问到，这时候可以使用<code>static</code>关键词，这使得这个变量仅仅存在于当前文件中。</p><blockquote><p>在Ubuntu上面没有办法成功编译！</p></blockquote><p>在函数内定义变量时加上这个关键词，则可以使得这个变量在整个文件中都能够被访问到。<br>当这个关键词被加上之后，这个变量当且仅当被定义的时候初始化为0，其余的时候这其中的值不会被初始化。</p><h4 id="volatile关键词"><a href="#volatile关键词" class="headerlink" title="volatile关键词"></a>volatile关键词</h4><p>当一个变量多次被使用的时候，编译器会将这个变量放到寄存器中，也就是说编译器会为了系统的优化改动定义的变量存储的地址。如果加上<code>volatile</code>关键词，那么这种改动就不会发生</p><h4 id="mutable"><a href="#mutable" class="headerlink" title="mutable"></a>mutable</h4><p>在一个<code>const</code>修饰的变量中，被<code>mutable</code>修饰的成员变量还是能够被修改.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">data</span>&#123;</span><br><span class="line"><span class="keyword">mutable</span> <span class="type">int</span> data;</span><br><span class="line"><span class="type">float</span> value;</span><br><span class="line">&#125;</span><br><span class="line">data d = &#123;<span class="number">10</span>, <span class="number">10.23</span>&#125;</span><br><span class="line">d.data = <span class="number">20</span>; <span class="comment">// Allow</span></span><br><span class="line">d.value = <span class="number">10.20</span>; <span class="comment">// Disallow</span></span><br></pre></td></tr></table></figure><h4 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h4><p><code>extern</code> 修饰的变量不能直接初始化。<br>但是如果想用常量作为具有外部链接的变量，那么可以使用<code>const</code>重载这个修辞</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="keyword">extern</span> <span class="type">int</span> con = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h3 id="Functions-and-Linkage"><a href="#Functions-and-Linkage" class="headerlink" title="Functions and Linkage"></a>Functions and Linkage</h3><p>由于C++中不允许一个函数在另外一个函数中定义，所以，所有的函数的作用域都是静态存储的周期（当程序结束时被释放）。但是你可以在函数原型前面加上一些关键词来指定函数的作用域（像<code>extern</code>、<code>static</code>等）<br>在默认的情况下，函数都是有外部链接的，也就是说联合编译中，其他文件是可以调用不同文件中的函数的。但是要调用其他文件中的函数还是需要包含所使用函数的函数原型。<br>编译器查找的方式是根据函数原型的作用域确定查找范围的。如果你在文件中定义了一个与外部函数有相同名称的函数，那么最终的这个内部链接的函数还覆盖外部链接的函数。</p><h3 id="Language-Linking"><a href="#Language-Linking" class="headerlink" title="Language Linking"></a>Language Linking</h3><p>编译器在链接的过程中需要为每一个不同的函数找一个不同的符号名称（symbolic name）。在C语言中，因为函数不允许重载，所以可以在函数名称前面简单地加上一个下划线即可，但是由于在C++中存在函数的重载，所以需要正在这个符号语言中加上函数的参数信息。例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spiff(double, double) to _spiff_d_d</span><br></pre></td></tr></table></figure><p>如果我们需要在C++中使用C语言中的函数，我们可以显式地指定这种符号名称的类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">void</span> <span class="title">spiff</span><span class="params">(<span class="type">int</span>)</span></span>; <span class="comment">// use C protocol for name look-up</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">spoff</span><span class="params">(<span class="type">int</span>)</span></span>; <span class="comment">// use C++ protocol for name look-up</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C++&quot;</span> <span class="function"><span class="type">void</span> <span class="title">spaff</span><span class="params">(<span class="type">int</span>)</span></span>; <span class="comment">// use C++ protocol for name look-up</span></span><br></pre></td></tr></table></figure><h3 id="Storage-Schemes-and-Dynamic-Allocation"><a href="#Storage-Schemes-and-Dynamic-Allocation" class="headerlink" title="Storage Schemes and Dynamic Allocation"></a>Storage Schemes and Dynamic Allocation</h3><p>编译器会为不同的变量划分出三个不同的内存，分别是：<code>静态变量区</code>、<code>局部变量区（automatic variable）</code>、<code>动态变量区</code>。但是，编译器会适应静态变量存储区或者局部变量区的内存跟踪动态变量区的变量（也就是指针）。</p><blockquote><p>虽然说动态生成的数据的存储空间在程序结束的时候会自动被释放掉，但是对于一些健壮性不是很好的操作系统，这个自动过程可能不会自动执行，所以还是最好使用<code>delete</code>将<code>new</code>出来的变量删掉。</p></blockquote><p>动态变量的初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *a = <span class="keyword">new</span> <span class="built_in">int</span> (<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">name</span>&#123;<span class="type">int</span> x; <span class="type">int</span> y; <span class="type">int</span> z&#125;;</span><br><span class="line"></span><br><span class="line">name* n = <span class="keyword">new</span> name&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;  <span class="comment">// 初始化结构体</span></span><br></pre></td></tr></table></figure><p><code>new</code>、<code>delete</code>是可以被替换的，所以你可以根据自己的需求对这两个函数进行调整。<br>你可以指定申请变量的存储的地址</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;new&gt;</span></span></span><br><span class="line"><span class="type">char</span> buffer[<span class="number">100</span>]; <span class="comment">// 在静态变量区申请的内存</span></span><br><span class="line"><span class="type">int</span>* a = <span class="built_in">new</span> (buffer) <span class="type">double</span> [<span class="number">10</span>]; <span class="comment">// 申请的变量会被存储在指定的内存区域</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是最终不能使用delete删除，这会导致错误。这是因为变量申请的空间是在静态变量空间中，而delete只能删除动态变量空间</span></span><br></pre></td></tr></table></figure><p>传统的<code>new</code>会存储之前可用的内存的位置，或者搜索可用的内存，但是可替换的<code>new</code>不会检查当前的内存是否被占用，也不存储之前可用的内存的位置信息。<br>实际上可替换的<code>new</code>只是简单地将传入的地址的类型转换成<code>void*</code>使得输出的地址能够分配给任意类型的指针。</p><h3 id="名字域"><a href="#名字域" class="headerlink" title="名字域"></a>名字域</h3><p>在每一个定义区域中各个变量之间的定义不会发生冲突。</p><img src="/.com//10/12/C-primer/Scope.png" class><p>作用域，指的是在变量定义之后的区域，也就是程序中可以使用这个变量的区域。不同的定义区域中的变量的作用域不会发生冲突。</p><p>使用关键字<code>namespace</code>定义自己的名字域,这些名字域中可以包含函数或者其他名字域，也可以自己在里面定义一个名字域。由于为了防止直接导入一些不需要的变量可能导致的问题，你可以使用名字域解析运算符或者指定导入变量的方式。也可以自定义一个名字域，在其中放入自己常用的函数或变量。</p><p>将名字域导入到当前的定义域中的方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Name&#123;</span><br><span class="line"><span class="type">int</span> age = <span class="number">20</span>;</span><br><span class="line">string first;</span><br><span class="line">string second;</span><br><span class="line"><span class="function">string <span class="title">Concatenate</span><span class="params">(string a, string b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> std::out;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">namespace</span> life&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给名字域起一个别名</span></span><br><span class="line"><span class="keyword">namespace</span> n = Name::life</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="built_in">func</span>()&#123;</span><br><span class="line"><span class="comment">// using declaration</span></span><br><span class="line"><span class="keyword">using</span> Name::first;</span><br><span class="line"><span class="comment">//这种方式就是将这个变量导入到当前的定义域中，这时候first不能再次被定义</span></span><br><span class="line"><span class="comment">// 有时候利用这种方式导入，可能会导致冲突，编译器会避免这种导入</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> age = <span class="number">25</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// using directive</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Name; <span class="comment">// 导入到当前定义域，其他的定义域中不能使用这个名字域 </span></span><br><span class="line"><span class="type">int</span> age = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; age &lt;&lt; Name::age &lt;&lt; ::age; <span class="comment">// 10 20 25</span></span><br><span class="line"><span class="comment">//这种方式导入，当前的定义域可以直接使用名字域中所有的变量，但是其中的变量没有局部作用域，所以可以被覆写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于名字域的定义不一定需要指定名字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"><span class="type">int</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接下来的代码都能够使用这里的变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> count;</span><br></pre></td></tr></table></figure><blockquote><p>注意一点，静态变量不是不能修改，而是只会初始化一次。之后在遇到初始化的语句就会直接被忽略。</p></blockquote><h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><ul><li>在使用模板的时候，如果出现比较，那么比较的东西可能会与预期的不太一致。还有在赋值的时候可能会出现数值和地址之间的冲突。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T c = a*b <span class="comment">// 这时候c可能会被赋予一个新的地址</span></span><br></pre></td></tr></table></figure>当你想要对模板类型进行具体化的时候，可以采用以下策略：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">maxn</span><span class="params">(T arr[], <span class="type">int</span> n)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="type">char</span>* <span class="built_in">maxn</span>&lt;<span class="type">char</span>*&gt;(<span class="type">char</span>* arr[], <span class="type">int</span> n)&#123;&#125;  <span class="comment">// &lt;char*&gt;是可以忽略的</span></span><br></pre></td></tr></table></figure> 在对模板类型进行具体化的时候，这个过程称为Implicit Instantiation,但是C++提供了显示初始化Explicit Instantiation. <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> <span class="type">void</span> <span class="built_in">Swap</span>&lt;<span class="type">int</span>&gt;(<span class="type">int</span> &amp;, <span class="type">int</span> &amp;);</span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="type">void</span> <span class="title">Swap</span><span class="params">(<span class="type">int</span> &amp;, <span class="type">int</span> &amp;)</span></span>;</span><br></pre></td></tr></table></figure> 当输入的变量类型不一致的时候，使用模板的函数可能会报错，这时候需要显示实例化 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function">T <span class="title">Add</span><span class="params">(T a, T b)</span> <span class="keyword">return</span> a + b</span>;</span><br><span class="line"><span class="type">int</span> m = <span class="number">6</span>;</span><br><span class="line"><span class="type">double</span> x = <span class="number">10.2</span>;</span><br><span class="line">cout &lt;&lt; <span class="built_in">Add</span>&lt;<span class="type">double</span>&gt;(x,m) &lt;&lt; endl;  <span class="comment">// 不实例化会导致报错 p429</span></span><br></pre></td></tr></table></figure> 上述概念的使用场景：</li><li>隐式具体化—模板类型的自动推断</li><li>显示具体化—自定义类型的参数必须使用（？）</li><li>显示实例化—实例化参数 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span> <span class="params">(T &amp;, T &amp;)</span></span>; <span class="comment">// template prototype</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="type">void</span> <span class="built_in">Swap</span>&lt;job&gt;(job &amp;, job &amp;); <span class="comment">// explicit specialization for job</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">template</span> <span class="type">void</span> <span class="built_in">Swap</span>&lt;<span class="type">char</span>&gt;(<span class="type">char</span> &amp;, <span class="type">char</span> &amp;); <span class="comment">// explicit instantiation for char</span></span><br><span class="line"><span class="type">short</span> a, b;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">Swap</span>(a,b); <span class="comment">// implicit template instantiation for short</span></span><br><span class="line">job n, m;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">Swap</span>(n, m); <span class="comment">// use explicit specialization for job</span></span><br><span class="line"><span class="type">char</span> g, h;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">Swap</span>(g, h); <span class="comment">// use explicit template instantiation for char</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>我们想让一个函数能够调用其他函数。这需要完成以下三个步骤：</p><ol><li>获取函数的地址 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">process</span>(<span class="built_in">think</span>())  <span class="comment">// 将函数的返回值作为传入参数</span></span><br><span class="line"><span class="built_in">process</span>(think)   <span class="comment">// 将函数的地址作为参数</span></span><br></pre></td></tr></table></figure></li><li>定义指向函数的指针<blockquote><p>函数签名（function’s signature）: 函数的参数列表<br>C++中的<strong>函数签名</strong>(function signature)：包含了一个<strong>函数</strong>的信息，包括<strong>函数</strong>名、参数类型、参数个数、顺序以及它所在的类和命名空间。（这是为了帮助编译器准确地找到想要访问的函数）</p></blockquote></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">pam</span><span class="params">(<span class="type">int</span>)</span></span>;  <span class="comment">// Function Prototype</span></span><br><span class="line"><span class="built_in">double</span> (*pf) (<span class="type">int</span>); <span class="comment">// 指针pf指向一个输入参数为int，输出为double的函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*本质上就是将函数名用(*pf)进行代替了，这里还利用了括号的具有更高优先级的特性，指明这里是一个指</span></span><br><span class="line"><span class="comment">针，如果pf没有括号，那么就变成一个函数了*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">estimate</span><span class="params">(<span class="type">int</span> lines, <span class="type">double</span>(*pf)(<span class="type">int</span>))</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>在函数中使用函数指针<br>可以通过函数名或者函数指针访问函数。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> x = <span class="built_in">pam</span>(<span class="number">4</span>);  <span class="comment">// Prefer</span></span><br><span class="line"><span class="type">double</span> x = (*pf)(<span class="number">5</span>);</span><br></pre></td></tr></table></figure></li></ol><h3 id="函数指针可能遇到的问题"><a href="#函数指针可能遇到的问题" class="headerlink" title="函数指针可能遇到的问题"></a>函数指针可能遇到的问题</h3><p>定义以下函数的函数指针会不会重名？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">double</span> * <span class="title">f1</span><span class="params">(<span class="type">const</span> <span class="type">double</span> ar[], <span class="type">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">double</span> * <span class="title">f2</span><span class="params">(<span class="type">const</span> <span class="type">double</span> [], <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">double</span> * <span class="title">f3</span><span class="params">(<span class="type">const</span> <span class="type">double</span> *, <span class="type">int</span>)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><ol><li>向函数中传入一个数组和传入一个指针是等价的.</li><li>在函数原型中，参数的名称是可以忽略的，“const double []”就是忽略了数组的名称<br>所以上述的三个函数是一致的</li></ol></blockquote><p>在对函数指针进行初始化的时候，可以利用C++11的新特性，auto自动推断对应的类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> * (*p1)(<span class="type">const</span> <span class="type">double</span> *, <span class="type">int</span>) = f1;</span><br><span class="line"><span class="comment">// Equivelent to</span></span><br><span class="line"><span class="keyword">auto</span> p2 = f2;</span><br></pre></td></tr></table></figure><p><strong>定义一个函数指针数组</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> * (*pa[<span class="number">3</span>])(<span class="type">const</span> <span class="type">double</span> *, <span class="type">int</span>) = &#123;f1, f2, f3&#125;;</span><br></pre></td></tr></table></figure><p>分析中括号的作用： 因为中括号的优先级比较高，所以中括号优先指明这个名称是个数组</p><blockquote><p>Automatic type deduction works with a single initializer value, not an initialization list.也就是说这里前面的指针定义不能用auto代替（因为初始化的是一个数组）。但是我们能够用auto推断数组指针类型</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pb = pa;</span><br></pre></td></tr></table></figure><blockquote><p>数组名<code>a</code>表示的是数组的第一个元素的地址，<code>&amp;a</code>表示的所有数组所有元素的地址，<code>&amp;a+1</code>就表示下一个数组（是不是一个保存数组每一个元素的地址的数组？）</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>]&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;\t&amp;a:&quot;</span> &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;size of a:&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; <span class="string">&quot;\tsize of &amp;a:&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(&amp;a) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a + 1:&quot;</span> &lt;&lt; a + <span class="number">1</span> &lt;&lt; <span class="string">&quot;\t&amp;a+1&quot;</span> &lt;&lt; &amp;a + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">a:00AFFCA4      &amp;a:00AFFCA4</span></span><br><span class="line"><span class="comment">size of a:12    size of &amp;a:4</span></span><br><span class="line"><span class="comment">a + 1:00AFFCA8  &amp;a+1:00AFFCB0  这里增加了C，也就是12</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 可见</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;TODO：&quot;&gt;&lt;a href=&quot;#TODO：&quot; class=&quot;headerlink&quot; title=&quot;TODO：&quot;&gt;&lt;/a&gt;TODO：&lt;/h2&gt;&lt;p&gt;总结各种初始化方法&lt;/p&gt;
&lt;h1 id=&quot;temp&quot;&gt;&lt;a href=&quot;#temp&quot; class=&quot;headerl</summary>
      
    
    
    
    
    <category term="C++ primer" scheme="http://example.com/tags/C-primer/"/>
    
  </entry>
  
  <entry>
    <title>STL和泛型编程</title>
    <link href="http://example.com/2022/10/12/STL%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/"/>
    <id>http://example.com/2022/10/12/STL%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/</id>
    <published>2022-10-12T11:46:55.000Z</published>
    <updated>2022-10-12T12:00:22.565Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-认识header、版本、重要资源"><a href="#1-认识header、版本、重要资源" class="headerlink" title="1. 认识header、版本、重要资源"></a>1. 认识header、版本、重要资源</h3><p>头文件命名形式：</p><ul><li>C++标准库header files 不带（.h）</li><li>新型的C头文件不带.h</li><li>原先的C头文件(带有.h)的，仍旧可以使用（但是最好还是使用最新的形式）</li><li>所有的新式headers都在名字域“std”中</li><li>旧式的头文件不被包含在“std”中</li></ul><h3 id="2-STL体系结构基础介绍"><a href="#2-STL体系结构基础介绍" class="headerlink" title="2.STL体系结构基础介绍"></a>2.STL体系结构基础介绍</h3><p>STL的六大部件：</p><ul><li>容器</li><li>分配器</li><li>算法</li><li>迭代器</li><li>适配器</li><li>仿函数(Functors)</li></ul><img src="/.com//10/12/STL%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/20220915211226.png" class><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;vector&gt;</span>  <span class="comment">// 与容器同名</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> ia[<span class="number">6</span>] = &#123;<span class="number">27</span>, <span class="number">210</span>, <span class="number">12</span>, <span class="number">47</span>, <span class="number">109</span>, <span class="number">83</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>, allocator&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">vi</span>(ia, ia+<span class="number">6</span>);<span class="comment">// 分配器用于分配内存（一般默认）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">count_if: algorithm;</span></span><br><span class="line"><span class="comment">not1: function adapter(negator);</span></span><br><span class="line"><span class="comment">bind2nd: 绑定第二参数，function adapter(binder)</span></span><br><span class="line"><span class="comment">less: function object</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in">count_if</span>(vi.<span class="built_in">begin</span>(), vi.<span class="built_in">end</span>(),</span><br><span class="line"><span class="built_in">not1</span>(<span class="built_in">bind2nd</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(), <span class="number">40</span>)));  <span class="comment">// 大于等于40</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标准库中的容器都是前开后闭的。但是容器的end()方法指向的是容器最后的元素的下一个元素，所以直接将这个指针解引用出来，得到的是一个未知的东西。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Container&lt;T&gt; c;</span><br><span class="line">....</span><br><span class="line">Container&lt;T&gt;::iterator ite = c.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span>(; ite != c.<span class="built_in">end</span>(); ++ite)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++11</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; elem : c)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-容器分类与各种测试"><a href="#3-6-容器分类与各种测试" class="headerlink" title="3~6. 容器分类与各种测试"></a>3~6. 容器分类与各种测试</h3><p>标准库中的集合和map一般用红黑树实现。</p><blockquote><p>代码习惯：测试程序放在名字域中，对应的库放在对应的名字域中，对应的定义变量需要的时候再写，为了注明，定义变量不会进行缩进。</p></blockquote><p><strong>vector</strong>： 对于空间扩充是呈现两倍增长的。这个增长是通过找到一个新的内存，然后将原先的元素全部复制到这个新的空间中，所以这个增长的过程实际上是比较缓慢的。</p><p><code>deque</code> : 分段，但是逻辑上是连续的。没有自己的sort</p><p>关联式容器查找都非常快</p><p><code>multiset</code>:内部是红黑树实现的,可以包含重复元素</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">multiset&lt;string&gt;c;</span><br></pre></td></tr></table></figure><p><code>multimap</code>:不可以使用<code>[]</code>作为插入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">multimap&lt;<span class="type">long</span>, string&gt;c;</span><br><span class="line">c.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">long</span>, string&gt;(i, buf));</span><br><span class="line"><span class="comment">// 访问需要使用first &amp; second</span></span><br></pre></td></tr></table></figure><p><code>unordered_multiset</code>:散列表实现的（哈希表）</p><p><code>set</code>: 不会出现重复的元素</p><p><code>map</code>: 底层实现是红黑树， 可以使用<code>[]</code>添加元素，key不重复，value是有重复的</p><h3 id="7-分配器测试"><a href="#7-分配器测试" class="headerlink" title="7. 分配器测试"></a>7. 分配器测试</h3><p>分配器用于内存分配</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p;</span><br><span class="line">__gnu_cxx::malloc_allocator&lt;<span class="type">int</span>&gt; alloc;</span><br><span class="line">p = alloc.<span class="built_in">allocate</span>(<span class="number">1</span>);</span><br><span class="line">alloc.<span class="built_in">deallocate</span>(p, <span class="number">1</span>);  <span class="comment">// 不建议使用，需要记住申请的内存的大小（用于空间释放）</span></span><br></pre></td></tr></table></figure><h3 id="8-源代码分布"><a href="#8-源代码分布" class="headerlink" title="8.源代码分布"></a>8.源代码分布</h3><h3 id="9-OOP-amp-泛化编程"><a href="#9-OOP-amp-泛化编程" class="headerlink" title="9. OOP &amp; 泛化编程"></a>9. OOP &amp; 泛化编程</h3><p>泛化编程是将数据和方法分开来了。容器与算法（方法）之间通过迭代器相互关联。 </p><blockquote><p>为什么list不能使用<code>::sort()</code>?<br>因为<code>::sort()</code>中使用的迭代器指针需要是能够随机访问的（能前能后），但是在list中，这种性质不满足。</p></blockquote><p><strong>特化</strong><br>模板在特定类型的时候使用特定的方法（更优的）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">type</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__type_traits</span>&#123;</span><br><span class="line">....</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">__type_traits</span>&lt;<span class="type">int</span>&gt;&#123;</span><br><span class="line">....</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">__type_traits</span>&lt;<span class="type">double</span>&gt;&#123;</span><br><span class="line">....</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 偏特化，如果传入的是一个指针（范围上的偏特化）</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">type</span>&gt; <span class="keyword">struct</span> <span class="title class_">__type_traits</span>&lt;type*&gt;&#123;</span><br><span class="line">....</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt;</span><br><span class="line"><span class="keyword">class</span> vector&#123;</span><br><span class="line">....</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 偏特化：仅将其中一个模板参数进行特化（数量上的局部）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">vector</span>&lt;<span class="type">bool</span>, Alloc&gt;</span><br><span class="line">&#123;</span><br><span class="line">....</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="11-分配器"><a href="#11-分配器" class="headerlink" title="11.分配器"></a>11.分配器</h3><p><code>malloc</code>申请内存的时候是有额外的开销的（其中包括了申请的空间的大小）。当申请的空间比较小的时候，这种开销占比比较大<br>在VC6的allocator中知识以<code>::operator new</code> 和 <code>::operator delete</code> 完成allocate() 和 deallocate() 没有特殊设计。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _FARQ</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> _FARQ</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> _PDFT ptrdiff_t</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> _SIZT  size_t</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _POINTER_X(T, A) T_FARQ*</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _REFFERENCE_X(T, A) T_FARQ&amp;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>&gt; <span class="keyword">inline</span></span><br><span class="line">_Ty _FARQ* _Allocate(_PDFT _N, _Ty _FARQ*)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(_N &lt; <span class="number">0</span>) _N = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ((_Ty _FARQ*) <span class="keyword">operator</span> <span class="built_in">new</span>((_SIZT)_N*<span class="built_in">sizeof</span>(_Ty)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">allocator</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> _SIZT size_type;</span><br><span class="line">    <span class="keyword">typedef</span> _PDFT difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Ty _FARQ * pointer;</span><br><span class="line">    <span class="keyword">typedef</span> _Ty value_type;</span><br><span class="line">    <span class="function">pointer <span class="title">allocate</span><span class="params">(size_type _N, <span class="type">const</span> <span class="type">void</span>*)</span> <span class="comment">// 第二个是任意参数</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> (_Allocate((difference_type) _N, (pointer)<span class="number">0</span>)); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deallocate</span><span class="params">(<span class="type">void</span> _FARQ *_P, size_type)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(_P)</span></span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配512 ints</span></span><br><span class="line"><span class="type">int</span>* p = <span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">allocate</span>(<span class="number">512</span>, (<span class="type">int</span>*<span class="number">0</span>));</span><br><span class="line"><span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">deallocate</span>(p, <span class="number">512</span>);  <span class="comment">// 用临时变量调用类方法</span></span><br></pre></td></tr></table></figure><p>这种方式可能会导致太大的额外开销，所以，一些改进的方法是一次申请固定倍数大小的空间，这样可以减少malloc的使用（与vector中的空间拓展思想类似）</p><h3 id="13、14-list源代码"><a href="#13、14-list源代码" class="headerlink" title="13、14. list源代码"></a>13、14. list源代码</h3><blockquote><p>i++ 和 ++i<br>因为符号一样，所以给后置版本加一个int形参作为区分，这个形参是0，但是在函数体中是用不到的，只是为了区分前置后置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self <span class="keyword">operator</span>++(<span class="type">int</span>) &#123; ... &#125; <span class="comment">// i++</span></span><br><span class="line">self <span class="keyword">operator</span>++() &#123; ... &#125; <span class="comment">// ++i （可以认为i作为参数已经传入了）</span></span><br></pre></td></tr></table></figure><p>另外整数不能连续进行两次后连加，可以前加（++++i √，i++++ × ）</p></blockquote><p>为了满足容器前闭后开的性质，在list链表中会有一个空白的头节点，这个就是end指针指向的节点，其内部实际上是一个环形双向链表。</p><h3 id="15-Iterator-必须提供的5种相关类别"><a href="#15-Iterator-必须提供的5种相关类别" class="headerlink" title="15. Iterator 必须提供的5种相关类别"></a>15. Iterator 必须提供的5种相关类别</h3><ul><li>iterator_category</li><li>value_type</li><li>pointer</li><li>reference</li><li>difference_type</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">I</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::reference;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>萃取机（iterator_traits）</strong>: 用于分离class iterator 和 non-class iterator。这是用过偏特化实现的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;calss I&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&#123;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type value_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两种偏特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;T*&gt;&#123;</span><br><span class="line"><span class="keyword">typedef</span> T value_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;<span class="type">const</span> T*&gt;&#123;</span><br><span class="line"><span class="keyword">typedef</span> T value_type; <span class="comment">// 不能用const T，因为这样声明的变量无法赋值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取I的value_type</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> I, ...&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">algorithmn</span><span class="params">(...)</span></span>&#123;</span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;I&gt;::value_type v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个实例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;T*&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> T* pointer;</span><br><span class="line">    <span class="keyword">typedef</span> T&amp; reference;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="16-vector深度探索"><a href="#16-vector深度探索" class="headerlink" title="16.vector深度探索"></a>16.vector深度探索</h3><img src="/.com//10/12/STL%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/20220921095514.png" class><p>在进行扩充的时候，需要重新申请空间，并且原先的空间将会被销毁，这使得这个过程中需要调用大量的构造函数和析构函数。</p><p>如果是连续空间，那么这个容器的迭代器就可以单纯地使用指针来表现。</p><h3 id="17-array、forward-list-深度探索"><a href="#17-array、forward-list-深度探索" class="headerlink" title="17. array、forward_list 深度探索"></a>17. array、forward_list 深度探索</h3><p>在特化array的时候，需要指明大小，这是因为array的大小是固定的，它没有构造器和析构器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>, 10&gt; myArray;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义数组</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">100</span>]; <span class="comment">// √</span></span><br><span class="line"><span class="comment">//int[100] a;  // ×</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> T[<span class="number">100</span>];</span><br><span class="line">T c;  <span class="comment">// √</span></span><br></pre></td></tr></table></figure><h3 id="18，19-deque、queue和stack深度探索"><a href="#18，19-deque、queue和stack深度探索" class="headerlink" title="18，19. deque、queue和stack深度探索"></a>18，19. deque、queue和stack深度探索</h3><p><strong>deque</strong>：这个容器的地址是由几个内存段产生的，用一个向量存储每一个内存段的首地址。对于迭代器，是由一个类组成，其中包含当前内存块的边界，当前指针指向的元素，以及当前内存块在地址向量中的位置</p><img src="/.com//10/12/STL%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/20220921134657.png" class><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里会找到离边界最近的方向移动元素</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="type">const</span> value_type&amp; x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(position.cur == start.cur)&#123;  <span class="comment">// 是否是在开头</span></span><br><span class="line">        <span class="built_in">push_front</span>(x);</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(position.cur == finish.cur)&#123;<span class="comment">// 是否是在尾部 </span></span><br><span class="line">        <span class="built_in">push_back</span>(x);</span><br><span class="line">        iterator tmp = finish;</span><br><span class="line">        --tmp;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">insert_aux</span>(position, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> BufSize&gt;</span><br><span class="line"><span class="keyword">typename</span> deque&lt;T, Alloc, BufSize&gt;::iterator</span><br><span class="line">deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">insert_aux</span>(iterator pos, <span class="type">const</span> value_type)&#123;</span><br><span class="line">difference_type index = pos - start;</span><br><span class="line">value_type x_copy = x;</span><br><span class="line"><span class="keyword">if</span>(index &lt; <span class="built_in">size</span>()/<span class="number">2</span>)&#123;  <span class="comment">// 检查是否小于中点</span></span><br><span class="line"><span class="built_in">push_front</span>(<span class="built_in">front</span>()); <span class="comment">//复制第一个元素</span></span><br><span class="line">...</span><br><span class="line"><span class="built_in">copy</span>(front2, pos1, front1);  <span class="comment">// 全部往前移动</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">push_back</span>(<span class="built_in">back</span>());</span><br><span class="line">....</span><br><span class="line"><span class="built_in">copy_backward</span>(pos, back2, back1);</span><br><span class="line">&#125;</span><br><span class="line">*pos = x_copy;</span><br><span class="line"><span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模拟连续空间，累加，<code>[]</code>，向前移动$n$元素</p><p>在stack和queue中，默认一个deque。 这两者可选择list或deque作为底层结构。二者不可用set或map作为底层结构。转调用的时候，一些函数不满容器特性。<br><code>这二者不允许遍历，也不提供iterator</code>，这种操作会干扰容器的特性（FIFO 或 FILO）</p><p>二者不同的是，queue 不可选择vector作为底层结构，stack可以。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Sequence</span>=deque&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> queue&#123;</span><br><span class="line">....</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">Sequence c;<span class="comment">// 底层容器</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">stack&lt;string, llist&lt;string&gt;&gt;c;</span><br></pre></td></tr></table></figure><h3 id="RB-tree"><a href="#RB-tree" class="headerlink" title="RB-tree"></a>RB-tree</h3><p>关联式容器。<br>RB-tree：平衡二叉搜索树。有利于search和insert。rb_tree 的迭代器不应该用于修改元素，但是未被禁止这种操作，因为它为set和map服务，而map允许data被修改，只有key不可以被修改，此时，红黑树是根据map的key进行排序的。<br>红黑树提供两种insertion操作：<code>insert_unique()</code>, <code>insert_equal</code>前者key是要求独一无二的，后者可以有重复</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">KeyOfValue</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>=alloc&gt;</span><br><span class="line"><span class="keyword">class</span> rb_tree&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">typedef</span> __rb_tree_node&lt;Value&gt; rb_tree_node;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> rb_tree_node* link_type;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="comment">// 大小为9，但是为了内存对齐，这里实际上占用的内存为12 </span></span><br><span class="line">size_type node_count;  <span class="comment">// 节点个数</span></span><br><span class="line">link_type header;</span><br><span class="line">Compare key_compare;  <span class="comment">// key的大小比较准则，是一个函数对象.理论上是0，但是实现为1</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="21-set-amp-multiset"><a href="#21-set-amp-multiset" class="headerlink" title="21.set &amp; multiset"></a>21.set &amp; multiset</h3><ul><li>一个元素不可重复，一个可以重复。</li><li>无法使用二者的iterator改变元素值，这些容器中的key有其固定的排列规则，这种iterator底层是RB tree的const iterator</li><li>元素特性是key就是value， value就是key</li><li>在实现中，set都是在调用rb tree中的操作，所以可以说set是一个容器的适配器</li></ul><h3 id="22-map-amp-multimap"><a href="#22-map-amp-multimap" class="headerlink" title="22.map &amp; multimap"></a>22.map &amp; multimap</h3><ul><li>与之前不同的是，这里的value被分为key和data</li><li>其他的性质与22中提到的类似</li><li>multimap 不可使用<code>[]</code>, map可以，如果找到，则返回值，如果没有就将键值插入到map中。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用逻辑</span></span><br><span class="line">map&lt;<span class="type">int</span>, string&gt;my_map;</span><br><span class="line">map&lt;<span class="type">int</span>, string, less&lt;<span class="type">int</span>&gt;, alloc&gt;my_map;</span><br><span class="line"></span><br><span class="line"><span class="comment">// selectlst: 获取键值，第一个元素</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span>, pair&lt;<span class="type">const</span> <span class="type">int</span>, string&gt;, selectlst&lt;pair&lt;<span class="type">const</span> <span class="type">int</span>, string&gt;&gt;, less&lt;<span class="type">int</span>&gt;, alloc&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">rb_tree</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="23，24、hash-table"><a href="#23，24、hash-table" class="headerlink" title="23，24、hash table"></a>23，24、hash table</h3><ul><li>直接使用原始数字作为键值需要大量的空间，所以通常采用原始数据与一个素数的余数作为键值，这个素数可以被成为“篮子”(扩充大小实际上时固定的，根据不同的版本存在不同)</li><li>当元素个数大于篮子的数时，需要rehashing，重新规划篮子的大小（选下一个素数作为篮子大小，这样所有的元素都要重新计算）。</li></ul><h3 id="26-unodered容器概念"><a href="#26-unodered容器概念" class="headerlink" title="26.unodered容器概念"></a>26.unodered容器概念</h3><p>C++之后，将原先的hash_set、hash_miltiset、hash_map、hash_miltimap中的hash编程unordered</p><h3 id="27-算法形式"><a href="#27-算法形式" class="headerlink" title="27.算法形式"></a>27.算法形式</h3><p>算法的所需的一切信息都由迭代器取得</p><h3 id="28-迭代器的分类"><a href="#28-迭代器的分类" class="headerlink" title="28. 迭代器的分类"></a>28. 迭代器的分类</h3><p>随机访问迭代器、双向迭代器、单向迭代器<br>random_access_iterator, bidirectional_iterator, forward_iterator. </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 特殊的迭代器</span></span><br><span class="line"><span class="built_in">display_category</span>(<span class="built_in">istream_iterator</span>&lt;<span class="type">int</span>&gt;()); <span class="comment">// input_iterator</span></span><br><span class="line"><span class="built_in">display_category</span>(<span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(cout, <span class="string">&quot;&quot;</span>)); <span class="comment">// output_iterator</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="built_in">typeid</span>(itr).<span class="built_in">name</span>(); <span class="comment">// 查看变量类型</span></span><br></pre></td></tr></table></figure><h3 id="29-迭代器分类对算法的影响"><a href="#29-迭代器分类对算法的影响" class="headerlink" title="29. 迭代器分类对算法的影响"></a>29. 迭代器分类对算法的影响</h3><p>如果是随机访问迭代器，那么迭代器可以直接到达指定的位置，如果是input_iterator，迭代器只能一个个加到指定的位置，这种功能可以通过偏特化实现（特化迭代器的类型）</p><p>对于output iterator是write-only，无法像forward iterator那样可以read， 所以不可以使用<code>*</code>运算符进行读取</p><h3 id="30-算法源码剖析"><a href="#30-算法源码剖析" class="headerlink" title="30.算法源码剖析"></a>30.算法源码剖析</h3><p><strong>accumulate</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> jj34</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">myfunc</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123; <span class="keyword">return</span> x + <span class="number">2</span> * y &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> myclass&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="built_in">operator</span>()(<span class="type">int</span> x, <span class="type">int</span> y)&#123; <span class="keyword">return</span> x + <span class="number">3</span> * y; &#125;</span><br><span class="line"></span><br><span class="line">    &#125;myobj;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test_accumlate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> init = <span class="number">100</span>;</span><br><span class="line">        <span class="type">int</span> nums[] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// default</span></span><br><span class="line">        cout &lt;&lt; <span class="built_in">accumulate</span>(nums, nums + <span class="number">3</span>, init); <span class="comment">// 160</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// using functional&#x27;s minus</span></span><br><span class="line">        cout &lt;&lt; <span class="built_in">accumulate</span>(nums, nums + <span class="number">3</span>, init, <span class="built_in">minus</span>&lt;<span class="type">int</span>&gt;());  <span class="comment">//40</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Using self-defined function</span></span><br><span class="line">        cout &lt;&lt; <span class="built_in">accumulate</span>(nums, nums + <span class="number">3</span>, init, myobj);  <span class="comment">// </span></span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">       init = binary_op(init, *first) // binary_op 就是传入的函数，可以传入函数或者仿函数（重载括号运算符）</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>for_each</strong></p><p><strong>replace, replace_if, replace_copy</strong><br>1.替换元素，2。在给定条件下替换  3.不删除被替换元素，将其复制到其他位置</p><p><strong>count， count_if</strong></p><p><strong>find, find_if</strong><br>find:循序查找</p><p><strong>sort</strong>：<br>传入迭代器范围</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">begin</span>() + <span class="number">3</span>); <span class="comment">// 默认从小到大， i &lt; j</span></span><br><span class="line">vec.<span class="built_in">rbegin</span>() = vec.<span class="built_in">end</span>(); <span class="comment">// 一个反向的迭代器</span></span><br></pre></td></tr></table></figure><p><strong>binary_search</strong></p><h3 id="仿函数和函数对象"><a href="#仿函数和函数对象" class="headerlink" title="仿函数和函数对象"></a>仿函数和函数对象</h3><h3 id="binder2nd"><a href="#binder2nd" class="headerlink" title="binder2nd"></a>binder2nd</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里的less&lt;int&gt;() 不是在调用，这是一个对象</span></span><br><span class="line"><span class="built_in">count_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">not</span>(<span class="built_in">bind2nd</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(), <span class="number">40</span>)));</span><br></pre></td></tr></table></figure><p>仿函数可被适配的条件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Arg</span>, <span class="keyword">class</span> <span class="title class_">Result</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">unary_function</span>&#123;</span><br><span class="line"><span class="keyword">typedef</span> Arg argument_type;</span><br><span class="line"><span class="keyword">typedef</span> Result result_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Arg1</span>, <span class="keyword">class</span> <span class="title class_">Arg2</span>, <span class="keyword">class</span> <span class="title class_">Result</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">binary_function</span>&#123;</span><br><span class="line"><span class="keyword">typedef</span> Arg1 first_argument_type;</span><br><span class="line"><span class="keyword">typedef</span> Arg2 second_argument_type;</span><br><span class="line"><span class="keyword">typedef</span> Result result_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 每一个可适配的函数都会继承上面的结构体，因为需要向Function adapter提供上面结构体定义的信息</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">less</span> : <span class="keyword">public</span> binary_function&lt;T, T, <span class="type">bool</span>&gt;&#123;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; x, <span class="type">const</span> T&amp; y)</span><span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> x &lt; y;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>新型适配器<code>bind</code>上述适配器已被弃用。</p><h3 id="34-not1"><a href="#34-not1" class="headerlink" title="34. not1"></a>34. not1</h3><h3 id="35-bind-（C-11）"><a href="#35-bind-（C-11）" class="headerlink" title="35.bind （C++11）"></a>35.bind （C++11）</h3><p>可以绑定：</p><ul><li>functions</li><li>function object</li><li>member function (_1需要是地址)</li><li>data member(_1需要是地址)</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">my_divide</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> x/y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyPair</span>&#123;</span><br><span class="line"><span class="type">double</span> a, b;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">multiply</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> a*b;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholder; <span class="comment">// adds visibility of _1, _2 ....</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> fn_five = <span class="built_in">bind</span>(my_divide, <span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; <span class="built_in">fn_five</span>() ; <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> fn_five = <span class="built_in">bind</span>(my_divide, _1, <span class="number">2</span>);  <span class="comment">// _1 占位符</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">fn_five</span>(<span class="number">10</span>) ; <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> fn_five = <span class="built_in">bind</span>(my_divide, _2, _1); <span class="comment">// _2 第二个占位符</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">fn_five</span>(<span class="number">10</span>, <span class="number">2</span>) ; <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定return type 为int</span></span><br><span class="line"><span class="keyword">auto</span> fn_five = <span class="built_in">bind</span>&lt;<span class="type">int</span>&gt;(my_divide, _2, _1); <span class="comment">// _2 第二个占位符</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">fn_five</span>(<span class="number">10</span>, <span class="number">2</span>) ; <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">MyPair ten_two&#123;<span class="number">10</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> bound_memfn = <span class="built_in">bind</span>(&amp;MyPair::multiply, _1);</span><br><span class="line">cout &lt;&lt; <span class="built_in">vound_memfn</span>(ten_two); <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 本质上就是将函数中的一个参数绑定一个固定的值</span></span><br><span class="line"><span class="comment">// ps： cbegin：表示constant</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-认识header、版本、重要资源&quot;&gt;&lt;a href=&quot;#1-认识header、版本、重要资源&quot; class=&quot;headerlink&quot; title=&quot;1. 认识header、版本、重要资源&quot;&gt;&lt;/a&gt;1. 认识header、版本、重要资源&lt;/h3&gt;&lt;p&gt;头文件命</summary>
      
    
    
    
    
    <category term="侯捷C++" scheme="http://example.com/tags/%E4%BE%AF%E6%8D%B7C/"/>
    
  </entry>
  
  <entry>
    <title>C++标准11-14</title>
    <link href="http://example.com/2022/10/12/C-%E6%A0%87%E5%87%8611-14/"/>
    <id>http://example.com/2022/10/12/C-%E6%A0%87%E5%87%8611-14/</id>
    <published>2022-10-12T11:46:26.000Z</published>
    <updated>2022-10-14T08:19:20.608Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-演进、环境与资源"><a href="#1-演进、环境与资源" class="headerlink" title="1.演进、环境与资源"></a>1.演进、环境与资源</h3><p>C++1.0 : C++ 98<br>C++2.0: C++11</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查看支持的版本</span></span><br><span class="line">cout &lt;&lt; __cplusplus &lt;&lt; enl;</span><br></pre></td></tr></table></figure><h3 id="2-Variadic-Templates-1-21"><a href="#2-Variadic-Templates-1-21" class="headerlink" title="2. Variadic Templates + 1~21"></a>2. Variadic Templates + 1~21</h3><p>数量不定的模板参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;&#125; <span class="comment">// 处理最后的情况，没有参数被传入，这个作为函数出口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样可以传入任意个数任意类型的参数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Types&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> T&amp; firstArg, <span class="type">const</span> Types&amp;... args)</span></span>&#123;</span><br><span class="line">cout &lt;&lt; firstArg &lt;&lt; endl;</span><br><span class="line"><span class="built_in">print</span>(args...)； <span class="comment">// 传入后不断被分开（这实际上是一个包）n = (n - 1) + 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">sizeof</span>...(args); <span class="comment">// 查看包中的参数个数</span></span><br></pre></td></tr></table></figure><p><code>...</code>: 实际上就是一个所谓的包</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用&quot;...&quot; 实现递归继承</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Values&gt; <span class="keyword">class</span> <span class="title class_">tuple</span>; <span class="comment">// 这种数据结构可以方任意个数以及任意类型的数据</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">class</span> <span class="title class_">tuple</span>&lt;&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Head, <span class="keyword">typename</span>... Tail&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">tuple</span>&lt;Head, Tail...&gt;</span><br><span class="line">    : <span class="keyword">private</span> tuple&lt;Tail...&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> tuple&lt;Tail...&gt; inherited;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">tuple</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">tuple</span>(Head v, Tail... vtail)</span><br><span class="line">        : <span class="built_in">m_head</span>(v), <span class="built_in">inherited</span>(vtail...)&#123;&#125;  <span class="comment">// 这是个初始化列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得变量类型</span></span><br><span class="line">    <span class="comment">// typename Head::type head() &#123;return m_head;&#125;  // 这样写会报错，因为像int这样的类型没有无法调用type</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">head</span><span class="params">()</span>-&gt;<span class="title">decltype</span><span class="params">(m_head)</span></span>&#123;<span class="keyword">return</span> m_head;&#125;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="comment">// Head head() &#123;return m_head; &#125;</span></span><br><span class="line">    <span class="function">inherited&amp; <span class="title">tail</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Head m_head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>谁更特化，就优先调用谁。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个版本更加特化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Types&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> T&amp; firstArg, <span class="type">const</span> Types&amp;... args)</span></span>&#123;</span><br><span class="line">cout &lt;&lt; firstArg &lt;&lt; endl;</span><br><span class="line"><span class="built_in">print</span>(args...)； <span class="comment">// 传入后不断被分开（这实际上是一个包）n = (n - 1) + 1 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与上面的函数共存的话，这个函数永远不会被调用</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Types&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printX</span><span class="params">(<span class="type">const</span> Types&amp;... args)</span></span>&#123;<span class="comment">/**********/</span>&#125;</span><br></pre></td></tr></table></figure><p>一些应用实例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在多个参数中找到最大值。这一点也可以通过初始化列表直接调用标准库中的max函数:max(&#123;1,3,2,5&#125;)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maximum</span><span class="params">(<span class="type">int</span> n)</span> <span class="keyword">return</span> n</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maximum</span><span class="params">(<span class="type">int</span> n, Args... args)</span> <span class="keyword">return</span> <span class="title">std::max</span><span class="params">(n, maximum(args...))</span></span>;</span><br><span class="line"><span class="comment">// 标准库中的max函数只能接收两个参数，这里这样调用就像是一个栈</span></span><br></pre></td></tr></table></figure><p>递归复合</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Values&gt;<span class="keyword">class</span> <span class="title class_">tup</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;<span class="keyword">class</span> <span class="title class_">tup</span>&lt;&gt;&#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Head, <span class="keyword">typename</span>... Tail&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">tup</span>&lt;Head, Tail&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> tup&lt;Tail...&gt;composited;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">composited m_tail;</span><br><span class="line">Head m_head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">tup</span>()&#123; &#125;</span><br><span class="line"><span class="built_in">tup</span>(Head v, Tail... vtail)</span><br><span class="line">: <span class="built_in">m_tail</span>(vtail...), <span class="built_in">m_head</span>(v) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Head <span class="title">head</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> m_head;&#125;</span><br><span class="line"><span class="function">composited&amp; <span class="title">tail</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> m_tail;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p><strong>空指针</strong>： <code>nullptr</code></p><p>还可以用<code>0</code>或者<code>NULL</code>定义空指针.但是在传递参数的时候可能会存在歧义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">void</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(<span class="literal">nullptr</span>); <span class="comment">// call void f(void*)</span></span><br></pre></td></tr></table></figure><p><strong>auto</strong>: 尽量当类型比较长或者复杂的时候才使用，或者需要写lambda的类型</p><h3 id="4-Uniform-Initialization"><a href="#4-Uniform-Initialization" class="headerlink" title="4.Uniform Initialization"></a>4.Uniform Initialization</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化对象的方法</span></span><br><span class="line">className c = &#123;...&#125;;</span><br><span class="line"><span class="function">className <span class="title">c</span><span class="params">(...)</span></span>;</span><br><span class="line">className c&#123;...&#125;; <span class="comment">// Uniform Initialization 直接在变量后面的大括号中写初始化的数值</span></span><br><span class="line"><span class="type">int</span> values[] &#123;...&#125;;</span><br></pre></td></tr></table></figure><p>当编译器遇到{}时，会创建一个 initializer_list&lt;T&gt;，然后关联到array&lt;T, n&gt;,然后由此传给构造函数（分解之后，变成构造函数接收的形式）</p><h3 id="4，5、Initializer-list"><a href="#4，5、Initializer-list" class="headerlink" title="4，5、Initializer_list"></a>4，5、Initializer_list</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;  <span class="comment">// 未定义</span></span><br><span class="line"><span class="type">int</span> i&#123;&#125;; <span class="comment">// 初始化为0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">P</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">P</span>(<span class="type">int</span> a, <span class="type">int</span> b)&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">P</span>(initializer_list&lt;list&gt; initlist)&#123; ...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">P <span class="title">p</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>; </span><br><span class="line">P q&#123;<span class="number">77</span>, <span class="number">5</span>&#125;;  <span class="comment">// 如果第二个构造函数不存在，那么编译器会将这两个数拆解，找到接收对应数目的参数的构造函数</span></span><br><span class="line"></span><br><span class="line">P r&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// 如果第二个构造函数不存在，则会报错，因为不存在接收三个参数的构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以利用初始化列表和max函数在三个或以上的数据中找到最大值</span></span><br><span class="line"><span class="built_in">max</span>(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">9</span>&#125;); </span><br></pre></td></tr></table></figure><h3 id="7-Explicit-for-constructor-taking-more-than-one-argument"><a href="#7-Explicit-for-constructor-taking-more-than-one-argument" class="headerlink" title="7. Explicit for constructor taking more than one argument"></a>7. Explicit for constructor taking more than one argument</h3><p>这个关键字存在时，构造函数不会被隐式调用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">12</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">Complex c2 = c1 + <span class="number">5</span>; <span class="comment">// 5会被隐式地转换成complex类型，如果构造函数被加上了explicit 则会报错</span></span><br></pre></td></tr></table></figure><h3 id="8-range-based-for-statement"><a href="#8-range-based-for-statement" class="headerlink" title="8. range-based for statement"></a>8. range-based for statement</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个循环中会有一个赋值地动作，所以可能会出现类型转换</span></span><br><span class="line"><span class="keyword">for</span> (decl : coll) &#123;</span><br><span class="line">statement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-x3D-default-x3D-delete"><a href="#9-x3D-default-x3D-delete" class="headerlink" title="9. &#x3D;default, &#x3D;delete"></a>9. &#x3D;default, &#x3D;delete</h3><p>只能用于构造函数和析构函数，以及赋值重载的函数中。普通的函数没有这种性质。</p><blockquote><p>什么时候需要自己定义Big-Three 呢？<br>大多数时候，当类中有指针的需要写。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Foo</span>(<span class="type">int</span> i) : _i(i) &#123; &#125;</span><br><span class="line"><span class="built_in">Foo</span>() =<span class="keyword">default</span>;<span class="comment">// 保留默认的构造函数</span></span><br><span class="line"></span><br><span class="line">~<span class="built_in">Foo</span>() = <span class="keyword">delete</span>;<span class="comment">// 删除默认的析构函数</span></span><br><span class="line">~<span class="built_in">Foo</span>(<span class="keyword">typename</span> arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-Alias-Template"><a href="#10-Alias-Template" class="headerlink" title="10.Alias Template"></a>10.Alias Template</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Vec = std::vector&lt;T, MyAlloc&lt;T&gt;&gt;;  <span class="comment">// 设置化名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意不能对别名进行特化或者偏特化</span></span><br><span class="line">Vec&lt;<span class="type">int</span>&gt; coll; <span class="comment">// 等价于 std::vector&lt;int, MyAlloc&lt;int&gt;&gt; coll; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意使用define是无法达到相同的效果的，define仅仅会将指定的内容原封不动套入</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传入任意类型的数据, 这里借助容器的萃取机来获取数值类型</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_moveable</span><span class="params">(Container c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">typerdef typername iterator_traits&lt;<span class="keyword">typename</span> Container::iterator&gt;::value_type Valtype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">long</span> i = <span class="number">0</span>; i &lt; SIZE; ++i) c.<span class="built_in">insert</span>(c.<span class="built_in">end</span>(), <span class="built_in">Valtype</span>());</span><br><span class="line"></span><br><span class="line"><span class="built_in">output_static_data</span>(*(c.<span class="built_in">begin</span>());</span><br><span class="line">Container <span class="built_in">c1</span>(c);</span><br><span class="line">Container <span class="built_in">c2</span>(std::<span class="built_in">move</span>(c));</span><br><span class="line">c1.<span class="built_in">swap</span>(c2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-template-template-parameter"><a href="#11-template-template-parameter" class="headerlink" title="11.template template parameter"></a>11.template template parameter</h3><p>化名模板</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">template</span>&lt;<span class="keyword">class</span>&gt; <span class="keyword">class</span> <span class="title class_">Container</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XCls</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Container&lt;T&gt; c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">XCls</span>()&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">long</span> i = <span class="number">0</span>; i &lt; SIZE; ++i) c.<span class="built_in">insert</span>(c.end, <span class="built_in">T</span>());</span><br><span class="line"><span class="built_in">output_static_data</span>(<span class="built_in">T</span>());</span><br><span class="line">Container&lt;T&gt;<span class="built_in">c1</span>(c);</span><br><span class="line">Container&lt;T&gt;<span class="built_in">c2</span>(std::<span class="built_in">move</span>(c));</span><br><span class="line">c1.<span class="built_in">swap</span>(c2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 想要声明变量，你需要定义alias template</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 这个不能在function body之中声明</span></span><br><span class="line"><span class="keyword">using</span> Vec = vector&lt;T, allocator&lt;T&gt;&gt;;</span><br><span class="line"></span><br><span class="line">XCls&lt;MyString, Vec&gt;c1;</span><br></pre></td></tr></table></figure><h3 id="12-Type-Alias-noexcept-override-final"><a href="#12-Type-Alias-noexcept-override-final" class="headerlink" title="12.Type Alias, noexcept, override, final"></a>12.Type Alias, noexcept, override, final</h3><p><strong>Type Alias</strong>: </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> func = <span class="built_in">void</span>(*)(<span class="type">int</span>, <span class="type">int</span>);  <span class="comment">// 这时候就是一个函数指针</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">example</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>&#123;&#125;</span><br><span class="line">func fn = example;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以使用类型化名隐藏模板参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">CharT</span>&gt; <span class="keyword">using</span> mystring = std::basic_string&lt;CahrT, std::char_traits&lt;CahrT&gt;&gt;;</span><br><span class="line">mystring&lt;<span class="type">char</span>&gt;std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//放到结构体中</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Container</span>&#123;</span><br><span class="line"><span class="keyword">using</span> value_type = T;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>noexcept</strong>:<br>不抛出异常，需要在vector的构造函数上使用，使得vector在增长的时候能够调用构造函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;  <span class="comment">// void foo() noexcept(true);</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Type&amp; x, Type&amp; y)</span> <span class="title">noexcept</span> <span class="params">(<span class="keyword">noexcept</span> (x.swap(y)))</span></span>&#123;</span><br><span class="line">x.<span class="built_in">swap</span>(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Override</strong>:<br>覆写需要签名一致，但是如果不一致编译器不会报错，这会产生一个新的函数，加上关键字<code>override</code>会让函数抛出异常。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived2</span>:Base&#123;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vfunc</span><span class="params">(<span class="type">int</span>)</span> <span class="keyword">override</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vfunc</span><span class="params">(<span class="type">float</span>)</span> <span class="keyword">override</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>final</strong>: 无法被继承</p><h3 id="13-decltype"><a href="#13-decltype" class="headerlink" title="13. decltype"></a>13. decltype</h3><p>找出表达式的类型，相当于typeof。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">float</span>&gt;coll;</span><br><span class="line"><span class="keyword">decltype</span>(coll)::value_type elem;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义返回类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">decltype</span>(x+y) <span class="built_in">add</span>(T1 x, T2 y); <span class="comment">// 在C++11之前不可实现，因为对象在这个范围内还没有引入</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T1 x, T2 y)</span>-&gt;<span class="title">decltype</span><span class="params">(x+y)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="title">decltype</span><span class="params">(obj)</span>::iterator iType</span>; <span class="comment">// 等价于typedef typename T::iterator iType;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将decltype used to pass the type of a lambda</span></span><br><span class="line"><span class="keyword">auto</span> cmp = [](<span class="type">const</span> Person&amp; p1, <span class="type">const</span> Person&amp; p2)&#123;</span><br><span class="line"><span class="keyword">return</span> p1.<span class="built_in">lastname</span>() &lt; p2.<span class="built_in">lastname</span>() || </span><br><span class="line">(p1.<span class="built_in">lastname</span>() == p2.<span class="built_in">lastname</span>() &amp;&amp; </span><br><span class="line">p1.<span class="built_in">firstname</span>() &lt; p2.<span class="built_in">firstname</span>());</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">std::set&lt;Person, <span class="title">decltype</span><span class="params">(cmp)</span>&gt; <span class="title">coll</span><span class="params">(cmp)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="lambdas"><a href="#lambdas" class="headerlink" title="lambdas"></a>lambdas</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [id] <span class="keyword">mutable</span> &#123; <span class="comment">// 不加mutable就没有办法修改id</span></span><br><span class="line">std::cout &lt;&lt; id &lt;&lt; std::endl;</span><br><span class="line">++id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价形式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Functor</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">()</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; id &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Functor f;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法举例</span></span><br><span class="line">[x, y](<span class="type">int</span> n) &#123;<span class="keyword">return</span> x &lt; n &amp;&amp; n &lt; y; &#125;</span><br></pre></td></tr></table></figure><p>lambda没有默认构造函数和赋值操作。</p><h2 id="第二讲：标准库"><a href="#第二讲：标准库" class="headerlink" title="第二讲：标准库"></a>第二讲：标准库</h2><h3 id="23-Rvalue-refernces-and-Move-Semantics"><a href="#23-Rvalue-refernces-and-Move-Semantics" class="headerlink" title="23. Rvalue refernces and Move Semantics"></a>23. Rvalue refernces and Move Semantics</h3><ul><li>临时对象就是一种右值（对于自定义的类（例如string）可以，int等类型不可以）</li><li>右值不可以放在左边</li><li>右值在被使用之后，应该被销毁，因为对于它的操作实际上就是改变指针指向，原先的右值的指针会被删除，这样这个右值也需要被删除</li></ul><h3 id="24-Perfect-Forwarding（完美传递）"><a href="#24-Perfect-Forwarding（完美传递）" class="headerlink" title="24. Perfect Forwarding（完美传递）"></a>24. Perfect Forwarding（完美传递）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入左值的版本</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp; i)</span></span>&#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 传入右值的版本</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp;&amp; i)</span></span>&#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">process</span>(a); <span class="comment">// 变量被视为左值</span></span><br><span class="line"><span class="built_in">process</span>(<span class="number">1</span>); <span class="comment">// 临时对象被视为右值</span></span><br><span class="line"><span class="built_in">process</span>(<span class="built_in">move</span>(a));  <span class="comment">// 强制将a由左值转换成右值</span></span><br></pre></td></tr></table></figure><p>不完美传递：在参数传递过程中，参数的左值右值可能会发生变化。这个问题可以使用标准库中的forward函数避免。</p><h3 id="25-写一个move-aware-class"><a href="#25-写一个move-aware-class" class="headerlink" title="25. 写一个move-aware class"></a>25. 写一个move-aware class</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 复制构造 </span></span><br><span class="line"><span class="built_in">MyString</span>(<span class="type">const</span> Mystring&amp; str) : _len(str._len)&#123;</span><br><span class="line">_init_data(str._data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// &amp;&amp;：右值引用; 这个是移动构造</span></span><br><span class="line"><span class="built_in">MyString</span>(MyString&amp;&amp; str) <span class="keyword">noexcept</span></span><br><span class="line">: _data(str._data), _len(str._len)&#123;</span><br><span class="line">str._len = <span class="number">0</span>;</span><br><span class="line">str._data = <span class="literal">NULL</span>; <span class="comment">// 因为传入的如果是临时变量，这个变量的生命周期只在这个函数中，如果这个指针还是指向原先的地址，那么在这个变量生命周期结束的时候，原先地址的数据也会被删除。</span></span><br><span class="line"><span class="comment">// 有那么一瞬间，复制对象和这个临时对象之间指向的是同一个地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="26-Move-aware-class-对容器的效能测试"><a href="#26-Move-aware-class-对容器的效能测试" class="headerlink" title="26.Move-aware class 对容器的效能测试"></a>26.Move-aware class 对容器的效能测试</h3><p>似乎只对vector的影响很大。（两种不同的构造函数）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">M <span class="title">c1</span><span class="params">(c)</span></span>;  <span class="comment">// 如果是vector的话，在内存拓展的时候，需要一个个调用构造函数</span></span><br><span class="line"><span class="built_in">vector</span>(<span class="type">const</span> vector&amp; __x) : _Base(....)&#123;....&#125; <span class="comment">// 调用的构造函数 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">M <span class="title">c2</span><span class="params">(std::move(c))</span></span>;  <span class="comment">// 将c当成右值(这样只是交换了指针)； 往下c就不能再用了，指针被修改了</span></span><br><span class="line"><span class="comment">// 调用的构造函数</span></span><br><span class="line"><span class="built_in">vector</span>(vector&amp;&amp; __x) <span class="keyword">noexcept</span> : _Base(std::<span class="built_in">move</span>(__x)) &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="30-Hash-function"><a href="#30-Hash-function" class="headerlink" title="30.Hash function"></a>30.Hash function</h3><ul><li>对于整数（数字，long也行），其哈希值就是其本身</li><li>对于字符串，用一个哈希函数，得到一个尽可能乱的哈希值</li></ul><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="动态内存（C-Primer-chapter12）"><a href="#动态内存（C-Primer-chapter12）" class="headerlink" title="动态内存（C++ Primer chapter12）"></a>动态内存（C++ Primer chapter12）</h3><ul><li>分配在静态或栈内存中的对象由编译器自动创建和销毁</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-演进、环境与资源&quot;&gt;&lt;a href=&quot;#1-演进、环境与资源&quot; class=&quot;headerlink&quot; title=&quot;1.演进、环境与资源&quot;&gt;&lt;/a&gt;1.演进、环境与资源&lt;/h3&gt;&lt;p&gt;C++1.0 : C++ 98&lt;br&gt;C++2.0: C++11&lt;/p&gt;
&lt;</summary>
      
    
    
    
    
    <category term="侯捷C++" scheme="http://example.com/tags/%E4%BE%AF%E6%8D%B7C/"/>
    
  </entry>
  
  <entry>
    <title>面对对象的续集</title>
    <link href="http://example.com/2022/10/12/%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%AD%E9%9B%86/"/>
    <id>http://example.com/2022/10/12/%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%AD%E9%9B%86/</id>
    <published>2022-10-12T11:45:30.000Z</published>
    <updated>2022-12-13T09:20:58.910Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-主要的内容"><a href="#1-主要的内容" class="headerlink" title="1.主要的内容"></a>1.主要的内容</h3><ul><li>泛型编程</li><li>面对对象的继承关系（底层内容）</li><li>书籍： Effective （modern）C++<br>标准库——&gt; 如何用，如何实现</li></ul><h3 id="转换函数-conversion-function"><a href="#转换函数-conversion-function" class="headerlink" title="转换函数 conversion function"></a>转换函数 conversion function</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fraction</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Fraction</span>(<span class="type">int</span> num, <span class="type">int</span> den = <span class="number">1</span>)</span><br><span class="line">: <span class="built_in">m_numerator</span>(num), <span class="built_in">m_denominator</span>(den) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换函数</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (doubl) (m_numerator / m_denominator);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_numerator;</span><br><span class="line"><span class="type">int</span> m_denominator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="function">Fraction <span class="title">f</span><span class="params">(<span class="number">3</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="comment">// 先检查是否重载了+，然后尝试将f转换成允许的类型（还是要检查需要的函数是否被重载）</span></span><br><span class="line"><span class="type">double</span> d = <span class="number">4</span> + f;</span><br></pre></td></tr></table></figure><h3 id="non-explicit-one-argument-constructor"><a href="#non-explicit-one-argument-constructor" class="headerlink" title="non-explicit-one-argument constructor"></a>non-explicit-one-argument constructor</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fraction</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Fraction</span>(<span class="type">int</span> num, <span class="type">int</span> den=<span class="number">1</span>)</span><br><span class="line">: <span class="built_in">m_numerator</span>(num), <span class="built_in">m_denominator</span>(den)&#123; &#125;</span><br><span class="line"></span><br><span class="line">Fraction <span class="keyword">operator</span>+(<span class="type">const</span> Fraction&amp; f)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Fraction</span>(...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在这里的案例中，会产生歧义，这会报错（这使得两种可以的选择）</span></span><br><span class="line"><span class="comment">//operator double() const &#123;</span></span><br><span class="line"><span class="comment">//return (doubl) (m_numerator / m_denominator);%%tor / m_denominator);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_numerator;</span><br><span class="line"><span class="type">int</span> m_denominator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="function">Fraction <span class="title">f</span><span class="params">(<span class="number">3</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="comment">// 这里会将3转换成Fraction类型，以适应重载函数</span></span><br><span class="line"><span class="type">double</span> d = f + <span class="number">3</span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fraction</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// explicit：不会自动调用</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Fraction</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> den=<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">: m_numerator(num), m_denominator(den)&#123;</span> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (doubl) (m_numerator / m_denominator);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Fraction <span class="keyword">operator</span>+(<span class="type">const</span> Fraction&amp; f)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Fraction</span>(...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_numerator;</span><br><span class="line"><span class="type">int</span> m_denominator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="function">Fraction <span class="title">f</span><span class="params">(<span class="number">3</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="comment">// 这里3将不能转换为Fraction，会报错（double 无法转换成Fraction）</span></span><br><span class="line"><span class="type">double</span> d = f + <span class="number">3</span>;</span><br></pre></td></tr></table></figure><h3 id="4-pointer-like-classes"><a href="#4-pointer-like-classes" class="headerlink" title="4.pointer-like classes"></a>4.pointer-like classes</h3><p><strong>智能指针</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shared_ptr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T&amp; <span class="keyword">operator</span>*() <span class="type">const</span></span><br><span class="line">&#123; <span class="keyword">return</span> *px; &#125;</span><br><span class="line"></span><br><span class="line">T* <span class="keyword">operator</span>-&gt;() <span class="type">const</span></span><br><span class="line">&#123; <span class="keyword">return</span> px; &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">shared_ptr</span>(T* p) : <span class="built_in">px</span>(p)&#123; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* px;</span><br><span class="line"><span class="type">long</span>* pn;</span><br><span class="line">....</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">....</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">method</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;....&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">shared_ptr&lt;Foo&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> Foo)</span></span>;</span><br><span class="line"><span class="function">Foo <span class="title">f</span><span class="params">(*sp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里比较特殊，箭头操作符在执行之后会继续对返回值执行操作</span></span><br><span class="line"><span class="comment">// 注意这里的→操作符用于获取指针，同时还用于获取指针所指向的类中的方法</span></span><br><span class="line">sp-&gt;<span class="built_in">method</span>();</span><br><span class="line"><span class="comment">// 等价</span></span><br><span class="line">px-&gt;<span class="built_in">method</span>();</span><br></pre></td></tr></table></figure><p><strong>迭代器</strong></p><h3 id="5-function-like-classes-仿函数"><a href="#5-function-like-classes-仿函数" class="headerlink" title="5.function-like classes 仿函数"></a>5.function-like classes 仿函数</h3><p>我们将任何一个能够接受”（）”（函数调用符号）的东西叫做函数或者时像函数的东西。<br>实际上，就是尝试对”（）“进行重载</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">identity</span> : <span class="keyword">public</span> unary_function &#123; <span class="comment">// 在标准库中会继承这样的base classes</span></span><br><span class="line"><span class="function"><span class="type">const</span> T&amp;</span></span><br><span class="line"><span class="function"><span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="6-namespace-经验谈"><a href="#6-namespace-经验谈" class="headerlink" title="6.namespace 经验谈"></a>6.namespace 经验谈</h3><p>这样在进行测试的时候可以使用重名的函数，不用去想其他的名字（Great thoughts）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------------------------</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> jj01</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_member_template</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; ..... &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// --------------------------------</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> jj02</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Lst = list&lt;T, allocator&lt;T&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_template_param</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">jj01::<span class="built_in">test_member_template</span>();</span><br><span class="line">jj02::<span class="built_in">test_template_template_param</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-成员模板"><a href="#9-成员模板" class="headerlink" title="9. 成员模板"></a>9. 成员模板</h3><p>在模板函数中，在被调用之前函数可以被编译，在传入参数之后，这个函数会被重新编译，这可能导致编译失败（不支持的类型）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pair</span> &#123;</span><br><span class="line"><span class="keyword">typedef</span> T1 first_type;</span><br><span class="line"><span class="keyword">typedef</span> T2 second_type;</span><br><span class="line"></span><br><span class="line">T1 first;</span><br><span class="line">T2 second;</span><br><span class="line"></span><br><span class="line"><span class="built_in">pair</span>()</span><br><span class="line">: <span class="built_in">first</span>(<span class="built_in">T1</span>()), <span class="built_in">second</span>(<span class="built_in">T2</span>()) &#123; &#125;</span><br><span class="line"><span class="built_in">pair</span>(<span class="type">const</span> T1&amp; a, <span class="type">const</span> T2&amp; b)</span><br><span class="line">: <span class="built_in">first</span>(a), <span class="built_in">second</span>(b) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员模板（外部被确定之后，内部还是不确定的）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">U1</span>, <span class="keyword">class</span> <span class="title class_">U2</span>&gt;</span><br><span class="line"><span class="built_in">pair</span>(<span class="type">const</span> pair&lt;U1, U2&gt;&amp; p)  <span class="comment">// 这里是要求传入的初始值需要能够转换成T类型（一次作为初始化值，是T的子类）</span></span><br><span class="line">: <span class="built_in">first</span>(p.first), <span class="built_in">second</span>(p.second)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">pair&lt;Derived1, Derived2&gt; p;</span><br><span class="line">pair&lt;Base1, Base2&gt;<span class="built_in">p2</span>(p);</span><br><span class="line">|</span><br><span class="line">pair&lt;Base1, Base2&gt;<span class="built_in">p2</span>(<span class="built_in">pair</span>&lt;Derived1, Derived2&gt;());</span><br></pre></td></tr></table></figure><p>子类指针能够指向父类，但是反之不能</p><blockquote><p>鲤鱼是一种鱼类，但是鱼类不是鲤鱼</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base1* ptr = <span class="keyword">new</span> Derived1;  <span class="comment">// up-cast</span></span><br><span class="line">shared_ptr&lt;Base1&gt;<span class="built_in">sptr</span>(<span class="keyword">new</span> Derived1);  <span class="comment">// 模拟up-cast</span></span><br></pre></td></tr></table></figure><h3 id="10、11-模板特化"><a href="#10、11-模板特化" class="headerlink" title="10、11. 模板特化"></a>10、11. 模板特化</h3><p>泛化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">has</span> &#123; &#125;;</span><br></pre></td></tr></table></figure><p>特化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hash</span>&lt;<span class="type">char</span>&gt;&#123;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">char</span> x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>偏特化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数量特化：只对其中一个参数进行特化（不完全特化）</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc=...&gt;</span><br><span class="line"><span class="keyword">class</span> vector</span><br><span class="line">&#123;</span><br><span class="line">.....</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Alloc=....&gt;</span><br><span class="line"><span class="keyword">class</span> vector&lt;<span class="type">bool</span>, Alloc&gt;&#123; .... &#125;  <span class="comment">// 只有一个参数被指定了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 范围特化：指定特化的范围</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">class</span> C</span><br><span class="line">&#123;</span><br><span class="line">....</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的模板变量与前面的不是同一个</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&lt;T*&gt;  <span class="comment">// 指定的是任意的指针</span></span><br><span class="line">&#123;</span><br><span class="line">.....</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">C&lt;string&gt; obj1;</span><br><span class="line">C&lt;string*&gt; obj2;  <span class="comment">// 调用的函数不同</span></span><br></pre></td></tr></table></figure><h3 id="12-模板模板参数"><a href="#12-模板模板参数" class="headerlink" title="12.模板模板参数"></a>12.模板模板参数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span></span><br><span class="line">&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XCls</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Container&lt;T&gt; c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">.....</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------------------</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Lst = list&lt;T, allocator&lt;T&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------------------</span></span><br><span class="line"><span class="comment">// 这种参数能够让用户传入一个未被指定的容器</span></span><br><span class="line">XCls&lt;string, list&gt;mylst1;  <span class="comment">// 直接使用会报错</span></span><br><span class="line">XCLs&lt;string, Lst&gt; mylst2;</span><br></pre></td></tr></table></figure><h3 id="14-三个主题"><a href="#14-三个主题" class="headerlink" title="14.三个主题"></a>14.三个主题</h3><p>**variadic templates(C++11)**：数量不确定的模板</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 最后会仅仅传入0个参数，这时候会调用这个重载函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 实际上是一种操作符了</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> T&amp; firstArg, <span class="type">const</span> Types&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 查看包的大小： sizeof...(args)</span></span><br><span class="line">cout &lt;&lt; firstArg &lt;&lt; endl;</span><br><span class="line"><span class="built_in">print</span>(args...); <span class="comment">// 递归打印其中的组合的元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">7.5</span>, <span class="string">&quot;hello&quot;</span>, <span class="built_in">bitset</span>&lt;<span class="number">16</span>&gt;(<span class="number">377</span>), <span class="number">42</span>);</span><br></pre></td></tr></table></figure><p><strong>auto(C++11)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">list&lt;string&gt; c;</span><br><span class="line">...</span><br><span class="line">list&lt;string&gt;::iterator ite;</span><br><span class="line">ite = <span class="built_in">find</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), target);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用auto，仅用于类型推导</span></span><br><span class="line"><span class="keyword">auto</span> ite = <span class="built_in">find</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), target);</span><br><span class="line"><span class="comment">//但是不能用于申明变量</span></span><br><span class="line"><span class="keyword">auto</span> ite;  <span class="comment">// ×</span></span><br></pre></td></tr></table></figure><p><strong>ranged-base <code>for</code></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> elem : vec) &#123; <span class="comment">// copy</span></span><br><span class="line">.....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要修改原始数据，则需要传引用（引用就是指针）</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; elem : vec)&#123;</span><br><span class="line">elem *= <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15-Reference"><a href="#15-Reference" class="headerlink" title="15. Reference"></a>15. Reference</h3><p>引用类型一定要设定初值</p><img src="/.com//10/12/%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%AD%E9%9B%86/20220913134632.png" class><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span>* p = &amp;x;</span><br><span class="line"><span class="type">int</span>&amp; r = x; <span class="comment">// r代表x，现在r, x 都是0。 实际上就是一个别名</span></span><br><span class="line"><span class="type">int</span> x2 = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">r = x2; <span class="comment">// r不能重新代表其他实物，心啊在r, x都是5</span></span><br><span class="line"><span class="type">int</span>&amp; r2 = r;</span><br></pre></td></tr></table></figure><p>对象和他的reference大小相同，地址也相同（全都是假象）<br>reference通常不用与声明，而是用于参数类型和返回类型的描述 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面两种函数不能共存.二者之间的签名一致</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">imag</span> <span class="params">(<span class="type">const</span> <span class="type">double</span>&amp; im)</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">imag</span> <span class="params">(<span class="type">const</span> <span class="type">double</span> im)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这时候的函数签名与上面不同</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">imag</span> <span class="params">(<span class="type">const</span> <span class="type">double</span>&amp; im)</span> <span class="type">const</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p><code>注意</code>: const也是签名的一部分，</p><h3 id="16-复合-amp-继承关系下的构造和析构"><a href="#16-复合-amp-继承关系下的构造和析构" class="headerlink" title="16. 复合&amp;继承关系下的构造和析构"></a>16. 复合&amp;继承关系下的构造和析构</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由内到外调用构造函数</span></span><br><span class="line">Derived::<span class="built_in">Derived</span>(..):<span class="built_in">Base</span>() &#123;....&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由外到内调用析构函数</span></span><br><span class="line">Derived::~<span class="built_in">Derived</span>(...)&#123;....~<span class="built_in">Base</span>()&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="关于vptr和vtbl"><a href="#关于vptr和vtbl" class="headerlink" title="关于vptr和vtbl"></a>关于vptr和vtbl</h3><blockquote><p>vtbl: virtual table, 为了实现C++的多态，C++使用了一种动态绑定的技术。这个技术的核心是虚函数表</p></blockquote><p>一个类占用了多少的内存，主要看类中声明的变量。继承不仅仅会<code>继承变量</code>，同时也会继承<code>父类的函数的调用权</code>，所以父类有虚函数，子类一定有。<br>当子类重载虚函数的时候，会重新申请一个函数空间，让对应的虚表中的元素指向这个空间。</p><img src="/.com//10/12/%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%AD%E9%9B%86/20220914135123.png" class><p>这里子类重载了父类的虚函数，所以在子类的虚表中，对应的虚表中的指针会指向一个新的虚函数（B::vfunc1()），所以这三次继承下来，一共会产生四个虚函数。<br>对于p的调用，用C语言写出来是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(*(p-&gt;vptr[n])(p); <span class="comment">/*或者图中下方的形式*/</span></span><br><span class="line"> <span class="comment">/*这时候，调用出来的函数是不确定的，需要根据p指向的类型进行确定，这个就是动态绑定（虚机制）*/</span></span><br></pre></td></tr></table></figure><p>静态绑定&amp;动态绑定<br>动态绑定的条件：</p><ol><li>通过指针调用函数</li><li>有一个向上的转型（子类调用，到时候会调用子类的重载函数）</li><li>调用的是虚函数</li></ol><h3 id="18-关于this"><a href="#18-关于this" class="headerlink" title="18.关于this"></a>18.关于this</h3><p>在C++类中，都有一个隐藏的参数<code>this</code></p><h3 id="19-动态绑定"><a href="#19-动态绑定" class="headerlink" title="19. 动态绑定"></a>19. 动态绑定</h3><p>关于<code>const</code>：const对象能够调用const函数，不能调用非const函数，非const对象两者都可以调用。实际上一个常量对象会被多个用户使用（指向同一个对象），当某一个用户需要修改的对象的时候，只需要将其做一份拷贝，这个过程称为Copy on Write. 所以，设置两种不同的函数，一种给常量对象调用，一种是给非常量对象调用，同时，在C++中，规定<code>常量成员函数的const和non-const版本同时存在，const对象只能调用const版本，non-const只能调用non-const版本</code>。</p><h3 id="22-示例"><a href="#22-示例" class="headerlink" title="22.示例"></a>22.示例</h3><p>当一个对象拥有虚函数的时候，则对应的会多出一个指针（虚指针）<br>构建对象数组的时候，每一个元素都会调用一次构造函数<br>分配数组内存的时候，会额外申请一块，用于记录数组的大小（多一个counter）</p><h3 id="23-重载new-amp-delete"><a href="#23-重载new-amp-delete" class="headerlink" title="23.重载new() &amp; delete()"></a>23.重载new() &amp; delete()</h3><p>前提：1.每一版本的声明都必须是独特的参数列表，参数列表的第一参数必须是<code>size_t</code>，其余参数以<code>new</code>所指定的placement arguments为初值，出现在<code>new(...)</code>小括号内的就是placement arguments。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size, <span class="type">long</span> extra)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">malloc</span>(size + extra);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-主要的内容&quot;&gt;&lt;a href=&quot;#1-主要的内容&quot; class=&quot;headerlink&quot; title=&quot;1.主要的内容&quot;&gt;&lt;/a&gt;1.主要的内容&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;泛型编程&lt;/li&gt;
&lt;li&gt;面对对象的继承关系（底层内容）&lt;/li&gt;
&lt;li&gt;书籍： E</summary>
      
    
    
    
    
    <category term="侯捷C++" scheme="http://example.com/tags/%E4%BE%AF%E6%8D%B7C/"/>
    
  </entry>
  
  <entry>
    <title>面对对象编程</title>
    <link href="http://example.com/2022/10/12/%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    <id>http://example.com/2022/10/12/%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</id>
    <published>2022-10-12T06:35:56.000Z</published>
    <updated>2022-10-12T12:02:44.134Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-C-编程简介"><a href="#1-C-编程简介" class="headerlink" title="1.C++编程简介"></a>1.C++编程简介</h3><p>C++: 语言+标准库</p><h3 id="2-头文件与类的声明"><a href="#2-头文件与类的声明" class="headerlink" title="2. 头文件与类的声明"></a>2. 头文件与类的声明</h3><p><strong>防卫式声明</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Header file: complex.h*/</span></span><br><span class="line"><span class="meta"># <span class="keyword">ifndef</span> __COMPLEX__</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __COMPLEX__</span></span><br><span class="line">....</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>写任意一个头文件都应该加上这种防卫语句</p><p><strong>头文件的布局</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">ifndef</span> __headerName__</span></span><br><span class="line"># ....</span><br><span class="line"><span class="comment">// 前置声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">className</span>;</span><br><span class="line"><span class="function">type&amp; <span class="title">func</span><span class="params">(type* var1)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Name</span>&#123;</span><br><span class="line">.....</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类定义</span></span><br><span class="line">Name::function ...</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="3-构造函数"><a href="#3-构造函数" class="headerlink" title="3. 构造函数"></a>3. 构造函数</h3><p>函数可以进行重载，编译器会将函数根据函数签名和其中的参数进行编码，以此作为区分。</p><h3 id="4-参数传递与返回值"><a href="#4-参数传递与返回值" class="headerlink" title="4.参数传递与返回值"></a>4.参数传递与返回值</h3><p>当构造函数放在<code>private</code>区域中，外界将不能够直接创建这个类。但是在一种设计模式<code>Singleton</code>中，会将构造函数放在<code>private</code>区域中。</p><blockquote><p>单例类Singleton保证了程序中同一时刻最多存在该类的一个对象。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> A&amp; <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line"><span class="built_in">setup</span>()&#123;...&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">A</span>();</span><br><span class="line"><span class="built_in">A</span>(<span class="type">const</span> A&amp; rhs);</span><br><span class="line">.....</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A&amp; <span class="title">A::getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">static</span> A a;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建</span></span><br><span class="line">A::<span class="built_in">getInstance</span>().<span class="built_in">setup</span>();</span><br></pre></td></tr></table></figure><p><strong>传递函数参数</strong><br>由于pass by value 是将变量整体进行传递，当变量比较大的时候，效率比较低，所以在传递参数的时候，应该尽量pass by reference(底层是传递指针)， 这样传递的参数可能会在函数中被修改，所以可以通过传递到const中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> className&amp;)</span></span>;  <span class="comment">// 这样传递的方式不会修改传递的值</span></span><br><span class="line"></span><br><span class="line">ostream&amp;</span><br><span class="line"><span class="keyword">operator</span> &lt;&lt; (ostream&amp; os, <span class="type">const</span> <span class="type">int</span>&amp; x)&#123;....&#125; </span><br></pre></td></tr></table></figure><p><strong>返回值传递</strong><br>在返回的时候也应该尽量使用pass by reference</p><p><strong>友元函数</strong><br>友元函数可以使用<code>private</code>中的数据。</p><p>相同class的各个object互为友元：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">complex</span> (<span class="type">double</span> r = <span class="number">0</span>, <span class="type">double</span> i = <span class="number">0</span>)</span><br><span class="line">: <span class="built_in">re</span> (r), <span class="built_in">im</span> (i)</span><br><span class="line">&#123;   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">const</span> complex&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> param.re + param.im; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">double</span> re, im;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/******************************************************************/</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function">complex <span class="title">c1</span><span class="params">(<span class="number">2</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">complex c2;</span><br><span class="line"></span><br><span class="line">c2.<span class="built_in">func</span>(c1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>设计类的几个要点</strong></p><ol><li>数据尽量放在<code>private</code>中</li><li>参数、返回值尽量pass by reference（可能）</li><li>需要加<code>const</code>尽量加</li><li>构造函数尽量使用冒号的赋值方法</li></ol><p><strong>什么时候不能返回引用</strong><br>一些参数通过一些操作之后的结果，需要在函数中申请一个空间存储这个结果，但是在函数结束的时候，这个空间就会被释放掉，这时候再返回原先这里的地址就没有意义了。（局部变量在函数结束的时候被删除）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> complex&amp;</span><br><span class="line">__doapl(complex* ths, <span class="type">const</span> complex&amp; r) <span class="comment">// 第一个参数会被改变，第二不会</span></span><br><span class="line">&#123;</span><br><span class="line">ths-&gt;re += r.re;</span><br><span class="line">ths-&gt;im += r.im;</span><br><span class="line"><span class="keyword">return</span> *ths;*</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> complex&amp;</span><br><span class="line">complex::<span class="keyword">operator</span> += (<span class="type">const</span> complex&amp; r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> __doapl (<span class="keyword">this</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-操作符重载与临时对象"><a href="#4-操作符重载与临时对象" class="headerlink" title="4. 操作符重载与临时对象"></a>4. 操作符重载与临时对象</h3><p>操作符重载中包含一个隐藏参数this（不能写出来）</p><img src="/.com//10/12/%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/20220831211854.png" class><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// do assinment plus(doapl)</span></span><br><span class="line"><span class="keyword">inline</span> complex&amp;  <span class="comment">// 用reference速度快 </span></span><br><span class="line">__adopl(complex* ths, <span class="type">const</span> complexr)</span><br><span class="line">&#123;</span><br><span class="line">    ths-&gt;re += r.re;</span><br><span class="line">    ths-&gt;im += r.im;</span><br><span class="line">    <span class="keyword">return</span> *ths;  <span class="comment">// 返回该地址上的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// c1 += c2 时，可以改用void接受，但是当连加出现时（c3 += c2 += c1）时，不行</span></span><br><span class="line"><span class="keyword">inline</span> complex&amp;  </span><br><span class="line">complex::<span class="keyword">operator</span> += (<span class="type">const</span> complex&amp; r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 使用这种方法的原因是可复用性</span></span><br><span class="line">    <span class="keyword">return</span> __adopl (<span class="keyword">this</span>, r); <span class="comment">// this在参数列表中不能写出来，但是能够使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传递者无需知道接受者是以reference形式接受<br><strong>非成员函数（无this）</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> complex <span class="comment">// 不能返回引用，因为这里返回的必定时局部对象</span></span><br><span class="line"><span class="keyword">operator</span> = (<span class="type">const</span> complex&amp; x, <span class="type">const</span> complex&amp; y)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">complex</span> ( <span class="built_in">real</span> (x) + <span class="built_in">real</span> (y) ,</span><br><span class="line"> <span class="built_in">imag</span> (x) + <span class="built_in">imag</span> (y)) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> complex</span><br><span class="line"><span class="keyword">operator</span> + (<span class="type">const</span> complex&amp; x, <span class="type">double</span> y)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">complex</span> (<span class="built_in">real</span> (x) + y, <span class="built_in">imag</span> (x)); <span class="comment">// 临时对象（无名称，STL用得多）</span></span><br><span class="line">&#125;</span><br><span class="line">....</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="function">complex <span class="title">c1</span><span class="params">(<span class="number">2</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">complex c2;</span><br><span class="line"></span><br><span class="line">complex c3 = c1 + c2;</span><br><span class="line">complex c4 = c1 + <span class="number">4</span>;</span><br><span class="line">complex c5 = <span class="number">4</span> + c1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这种重载函数只能写为全局函数，不能写成成员函数（cout可能不认识你的参数类型， 访问定义的类)</span></span><br><span class="line"><span class="comment">// cout的数据类型是iostream， os的状态会被改变（传入的内容改变的）</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span> <span class="comment">// 不一定放在文件开头</span></span></span><br><span class="line">ostream&amp;  <span class="comment">// cout &lt;&lt; c1;时可以使用void接收，但是cout&lt;&lt;c1&lt;&lt;c2;时，不能用void接收</span></span><br><span class="line"><span class="keyword">operator</span> &lt;&lt; (ostream&amp; os, <span class="type">const</span> complex&amp; x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> os &lt;&lt; <span class="string">&#x27;(&#x27;</span> &lt;&lt; <span class="built_in">real</span> (x) &lt;&lt; <span class="string">&#x27;,&#x27;</span> </span><br><span class="line">  &lt;&lt; <span class="built_in">imag</span> (x) &lt;&lt; <span class="string">&#x27;)&#x27;</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传递的是double类型的时候，传值和传引用效率一样。</p><h3 id="7-三大函数：拷贝函数，拷贝复制，析构"><a href="#7-三大函数：拷贝函数，拷贝复制，析构" class="headerlink" title="7.三大函数：拷贝函数，拷贝复制，析构"></a>7.三大函数：拷贝函数，拷贝复制，析构</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYSTRING__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYSTRING__</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// Big Three </span></span><br><span class="line"><span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* cstr = <span class="number">0</span>); <span class="comment">// 需要赋值，不能设置为const</span></span><br><span class="line"><span class="comment">//如果class中带有指针， 一定不能使用默认版本（符号重载等）</span></span><br><span class="line"><span class="built_in">String</span>(<span class="type">const</span> String&amp; str);  <span class="comment">// 拷贝构造</span></span><br><span class="line">String&amp; <span class="keyword">operator</span>=(<span class="type">const</span> String&amp; str); <span class="comment">// 拷贝复制</span></span><br><span class="line">~<span class="built_in">String</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">get_c_str</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_data; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span>* m_data;  <span class="comment">// 指针占4byte</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span></span></span><br><span class="line"><span class="function"><span class="title">String::String</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* cstr = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(cstr) &#123;</span><br><span class="line">m_data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(cstr) + <span class="number">1</span>];  <span class="comment">// 最后还有一个结束符号</span></span><br><span class="line"><span class="built_in">strcpy</span>(m_data, cstr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;  <span class="comment">// 空字符串</span></span><br><span class="line">m_data = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">1</span>];</span><br><span class="line">*m_data = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> </span><br><span class="line">String::~<span class="built_in">String</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[] m_data;  <span class="comment">// 释放申请的动态内存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝赋值：先将原先的变量中的内容删除，然后将新的内容赋值给这个变量</span></span><br><span class="line"><span class="comment">// 返回类型是考虑到了连串的赋值的情况（否则可以将void作为返回类型）</span></span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line">String&amp; String::<span class="keyword">operator</span>=(<span class="type">const</span> String&amp; str) <span class="comment">// &amp;：reference</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// &amp;： 取地址</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str) <span class="comment">// 效率高且防止赋值内容的地址被释放，这会报错！</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 三步</span></span><br><span class="line"><span class="keyword">delete</span>[] m_data;</span><br><span class="line">m_data = <span class="keyword">new</span> <span class="type">char</span>[ <span class="built_in">strlen</span>(str.m_data) + <span class="number">1</span> ];</span><br><span class="line"><span class="built_in">strcpy</span>(m_data, str.m_data);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="type">const</span> String&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">os &lt;&lt; str.<span class="built_in">get_c_str</span>(); </span><br><span class="line"><span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="function">String <span class="title">s3</span><span class="params">(s1)</span></span>;  <span class="comment">//拷贝构造</span></span><br><span class="line">s3 = s2;  <span class="comment">// 拷贝赋值</span></span><br></pre></td></tr></table></figure><p><strong>当类中存在指针成员的时候，必须要有拷贝构造和拷贝赋值</strong><br>使用默认的操作会使得赋值对象和原先的对象指向相同的地址（浅拷贝），你实际上会得到一个别名（alias）。 </p><h3 id="8-堆，栈与内存管理"><a href="#8-堆，栈与内存管理" class="headerlink" title="8.堆，栈与内存管理"></a>8.堆，栈与内存管理</h3><p><strong>栈</strong>：存在于作用域的一类内存空间。函数本体中声明的任何变量其所使用的内存块都取自这种栈。</p><p><strong>堆（heap）</strong>：用操作系统分配的一种global内存变量，动态申请的变量的内存会被放到堆中。</p><p>stack object: 作用域结束之后会被自动清理<br>static object: 作用域结束之后依旧存在。程序结束才被删除<br>global object: 整个程序结束之后才会删除，可以看成一种static object<br>heap object: </p><p>如果不释放，可能导致<code>内存泄漏</code>，因为在函数中声明的指针变量在作用域结束之后就会被删除，而对应的内存块还被占用着，这时候我们就失去了对这个内存块的控制了。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Complex* pc = <span class="keyword">new</span> <span class="built_in">Complex</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// transformed by compiler</span></span><br><span class="line">Complex *pc;</span><br><span class="line"></span><br><span class="line"><span class="comment">// complex 中的私有变量需要的内存大小</span></span><br><span class="line"><span class="type">void</span>* mem = <span class="keyword">operator</span> <span class="built_in">new</span> ( <span class="built_in">sizeof</span>(Complex) ); <span class="comment">// allocating the memory</span></span><br><span class="line">pc = <span class="built_in">static_cast</span>&lt;Complex*&gt;(mem);  <span class="comment">// change variable type</span></span><br><span class="line">pc-&gt;Complex::<span class="built_in">Complex</span>(<span class="number">1</span>, <span class="number">2</span>);  <span class="comment">// constructor function</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Delete</span></span><br><span class="line">String* ps = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="keyword">delete</span> ps;</span><br><span class="line"><span class="comment">// equal</span></span><br><span class="line">String::~<span class="built_in">String</span>(ps);</span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(ps)</span></span>;</span><br></pre></td></tr></table></figure><p>为了标记占用的内存块，规定在内存块的开头和结尾加上一个cookie标记内存块的大小和状态。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String* p = <span class="keyword">new</span> String[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span>[] p; <span class="comment">// 唤起3次析构函数</span></span><br><span class="line"><span class="keyword">delete</span> p;  <span class="comment">// 只调用一次析构函数，导致除了头元素外的元素所在的空间出现内存泄漏</span></span><br></pre></td></tr></table></figure><h3 id="拓展补充：类模板、函数模板及其他"><a href="#拓展补充：类模板、函数模板及其他" class="headerlink" title="拓展补充：类模板、函数模板及其他"></a>拓展补充：类模板、函数模板及其他</h3><p><strong>static</strong>：<br>非<code>static</code>类中，成员函数只有一份，不同类调用的实际上是同一个成员函数，只是传入了不同的成员变量。<br>静态数据，在内存中只有一份，这意味着这个数据对所有类都是一致的。<br>静态函数，没有this 指针，所以不能处理普通数据，只能处理静态数据</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">double</span> m_rate;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">set_rate</span><span class="params">(<span class="type">const</span> <span class="type">double</span>&amp; x)</span> </span>&#123; m_rate = x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态变量需要在类外进行初始化</span></span><br><span class="line"><span class="type">double</span> Account::m_rate = <span class="number">8.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// 两种调用静态函数的方法</span></span><br><span class="line">Account::<span class="built_in">set_rate</span>(<span class="number">5.0</span>);</span><br><span class="line"></span><br><span class="line">Account a;</span><br><span class="line">a.<span class="built_in">set_rate</span>(<span class="number">7.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Singleton中调用静态函数的方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> A&amp; <span class="title">getInstance</span><span class="params">( <span class="keyword">return</span> a; )</span></span>;</span><br><span class="line"><span class="built_in">setup</span>() &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">A</span>();</span><br><span class="line"><span class="built_in">A</span>(<span class="type">const</span> A&amp; rhs);</span><br><span class="line"><span class="type">static</span> A a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Call</span></span><br><span class="line">A::<span class="built_in">getInstance</span>().<span class="built_in">setup</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>更好的实现方法，单例仅使用的时候才会被构建</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> A&amp; <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line"><span class="built_in">setup</span>() &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">A</span>();</span><br><span class="line"><span class="built_in">A</span>(<span class="type">const</span> A&amp; rhs);</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A&amp; <span class="title">A::getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">static</span> A a;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A::<span class="built_in">getInstance</span>().<span class="built_in">setup</span>();</span><br></pre></td></tr></table></figure><p><strong>进一步补充：cout</strong><br>对<code>&lt;&lt;</code>操作符进行了多种多样的重载</p><p><strong>类模板</strong><br>类型未指定,在定义类的时候使用。在调用的时候需要指定类型</p><p><strong>函数模板</strong><br>函数模板不需要指定类型，可以根据传入变量的类型进行自动推导</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span></span></span><br><span class="line"><span class="function"><span class="type">const</span> T&amp; <span class="title">min</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> b &lt; a ? b : a;  <span class="comment">// 对于操作数的重载需要在类定义中定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>namespace</strong><br>避免重名函数、类冲突</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 三种打开方式</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std:cout;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; ;</span><br></pre></td></tr></table></figure><h3 id="11-组合与继承"><a href="#11-组合与继承" class="headerlink" title="11.组合与继承"></a>11.组合与继承</h3><p><strong>复合</strong>： 容器中包含其他类型（类似结构体）<br>设计模式：配接（adapter）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">queue</span>&#123;</span><br><span class="line">....</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">deque&lt;T&gt; c;  <span class="comment">// 底层容器</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 所有的方法实际上都是由c中的操作函数完成的</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">empty</span>(); &#125;</span><br><span class="line"><span class="function">size_type <span class="title">soze</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">size</span>(); &#125;</span><br><span class="line"><span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">front</span>(); &#125;</span><br><span class="line"><span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">back</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span> </span>&#123; c.<span class="built_in">push_back</span>(x); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123; c.<span class="built_in">pop_front</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>复合情况下的构造和析构</strong><br>container -&gt; component</p><ul><li>构造由内而外（内部的成分, 默认会调用默认的构造函数）</li><li>析构由外而内</li></ul><p><strong>委托(Delegation): composition by reference</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file String.cpp</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StringRep</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">String</span>();</span><br><span class="line"><span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* s);</span><br><span class="line"><span class="built_in">String</span>(<span class="type">const</span> String&amp; s);</span><br><span class="line">String &amp;<span class="keyword">operator</span>=(<span class="type">const</span> String&amp; s);</span><br><span class="line">~<span class="built_in">String</span>();</span><br><span class="line">....</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// 所有的实现都在这个类中 </span></span><br><span class="line">StringRep* rep; <span class="comment">// pimpl</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Pimpl(<strong>P</strong>ointer to <strong>impl</strong>ementation) 是一种减少代码依赖和编译时间的C++编程技巧，其基本思想是将一个外部可见类(visible class)的实现细节（一般是所有私有的非虚成员）放在一个单独的实现类(implementation class)中，而在可见类中通过一个私有指针来间接访问该实现类</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&quot;String.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">namespace</span>&#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StringRep</span>&#123;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">String</span>;</span><br><span class="line"><span class="built_in">StringRep</span>(<span class="type">const</span> <span class="type">char</span>* s);</span><br><span class="line">~<span class="built_in">StringRep</span>();</span><br><span class="line"><span class="type">int</span> count;</span><br><span class="line"><span class="type">char</span>* rep;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String::<span class="built_in">String</span>()&#123; .... &#125;</span><br></pre></td></tr></table></figure><p>这时候多个类实际上共享一组变量，当需要修改的时候，会单独复制一个出来 </p><p><strong>继承</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">_List_node_base</span></span><br><span class="line">&#123;</span><br><span class="line">_List_node_base* _M_next;</span><br><span class="line">_List_node_base* _M_prev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp_&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_List_node</span></span><br><span class="line">: <span class="keyword">public</span> _List_node_base  <span class="comment">// 三种继承public、private、protected</span></span><br><span class="line">&#123;</span><br><span class="line">_Tp _M_data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>构造和析构与复合一致（先调用父类的构造函数， 析构则是先执行子类的析构函数）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Derived::<span class="built_in">Deriveed</span>(...):<span class="built_in">Base</span>() &#123;....&#125;; </span><br><span class="line">Derived::~<span class="built_in">Derived</span>(...)&#123;... ~<span class="built_in">Base</span>() &#125;;</span><br></pre></td></tr></table></figure><p><code>base class的构造函数必须是虚函数，否则会出现 undefined behavior</code></p><h3 id="12-虚函数与多态"><a href="#12-虚函数与多态" class="headerlink" title="12.虚函数与多态"></a>12.虚函数与多态</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;  <span class="comment">// pure virtual: 必须重定义（无法事先定义的函数）</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">error</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span></span>;  <span class="comment">// impure virtual：有默认定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">objectID</span><span class="params">()</span> <span class="type">const</span></span>;  <span class="comment">// non-vitual：不希望重定义</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>: <span class="keyword">public</span> Shape &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ellipse</span>: <span class="keyword">public</span> Shape &#123; ... &#125;;</span><br></pre></td></tr></table></figure><p><strong>虚函数继承</strong>: <code>Template Method</code>(模板函数法 )</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Application framework</span></span><br><span class="line">CDocument::</span><br><span class="line"><span class="built_in">OnFileOpen</span>()</span><br><span class="line">&#123;</span><br><span class="line">....</span><br><span class="line"><span class="built_in">Serialize</span>()  <span class="comment">// 这个函数延缓到子类中实现</span></span><br><span class="line">.....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Application</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CMyDoc</span>:</span><br><span class="line"><span class="keyword">public</span> CDocument</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="title">Serialize</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Call the father function by son</span></span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">CMyDoc myDoc;</span><br><span class="line">....</span><br><span class="line">myDoc.<span class="built_in">OnFileOpen</span>();  </span><br><span class="line"><span class="comment">// 实际上的调用动作</span></span><br><span class="line">CDocument::<span class="built_in">OnFileOpen</span>(&amp;myDoc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>委托+继承</strong><br>*******************************<br><font size="5" color="red">需要补充</font><br>*******************************</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> m_value;</span><br><span class="line">vector&lt;Observer*&gt;m_views;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 注册</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">attach</span><span class="params">(Observer* obs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_views.<span class="built_in">push_back</span>(obs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_val</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_value = value;</span><br><span class="line"><span class="built_in">notify</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通知更新数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">notify</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_views.<span class="built_in">size</span>(); ++i)</span><br><span class="line">m_views[i]-&gt;<span class="built_in">update</span>(<span class="keyword">this</span>, m_value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">update</span><span class="params">(Subject* sub, <span class="type">int</span> value)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="13-委托相关设计"><a href="#13-委托相关设计" class="headerlink" title="13.委托相关设计"></a>13.委托相关设计</h3><img src="/.com//10/12/%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/20220907193955.png" class><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Component</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Component</span>(<span class="type">int</span> val) &#123; value=val; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能设置为纯虚函数，因为有一些子类对这个动作是没有定义的</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">add</span><span class="params">(Component*)</span> </span>&#123; &#125;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Primitive</span>: <span class="keyword">public</span> Component</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Primitive</span>(<span class="type">int</span> val): <span class="built_in">Component</span>(val) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Composite</span>: <span class="keyword">public</span> Component</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;Component*&gt;c;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Composite</span>(<span class="type">int</span> val): <span class="built_in">Component</span>(val) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span> <span class="params">(Component* elem)</span></span>&#123;</span><br><span class="line">c.<span class="built_in">push_back</span>(elem);</span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><font color="red">为什么父类指针能够指向子类，但是子类指针指向父类可能导致不安全？</font></p><p><strong>委托+继承</strong><br>将新建的类与框架搭配到一起，需要创建好的类加入到框架的容器中去。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原型</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">imageType</span></span><br><span class="line">&#123;</span><br><span class="line">LAST, SPOT</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Image</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">static</span> Image *<span class="title">findAndColone</span><span class="params">(imageType)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> imageType <span class="title">returnType</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Image *<span class="title">clone</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">addPrototype</span><span class="params">(Image *image)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_prototypes[_nextSlot++] = image;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// 存放类原型</span></span><br><span class="line"><span class="type">static</span> Image *_prototypes[<span class="number">10</span>];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> _nextSlot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态变量需要在类外进行初始化</span></span><br><span class="line">Image *Image::_prototypes[];</span><br><span class="line"><span class="type">int</span> Imgage::_nextSlot;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过变量类型找出需要调用的原型</span></span><br><span class="line"><span class="function">Image *<span class="title">Image::findAndClone</span><span class="params">(imageType type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; _nextSlot; i++)</span><br><span class="line"><span class="keyword">if</span>(_prototypes[i]-&gt;<span class="built_in">returnType</span>() == type)</span><br><span class="line"><span class="keyword">return</span> _prototypes[i]-&gt;<span class="built_in">clone</span>();  <span class="comment">// 得到目标类的一个备份</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LandSatImage</span>:<span class="keyword">public</span> Image&#123;</span><br><span class="line"><span class="comment">// 创建一个静态的自己，然后放到父类的那个容器中</span></span><br><span class="line"><span class="comment">// 这里需要两个不同的构造函数，一个用于给父类原型时创建类用的，一个时父类在调用这个原型clone时用的，为了将这两种构造函数进行区分，他们的参数之间存在差异</span></span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-C-编程简介&quot;&gt;&lt;a href=&quot;#1-C-编程简介&quot; class=&quot;headerlink&quot; title=&quot;1.C++编程简介&quot;&gt;&lt;/a&gt;1.C++编程简介&lt;/h3&gt;&lt;p&gt;C++: 语言+标准库&lt;/p&gt;
&lt;h3 id=&quot;2-头文件与类的声明&quot;&gt;&lt;a href=</summary>
      
    
    
    
    
    <category term="侯捷C++" scheme="http://example.com/tags/%E4%BE%AF%E6%8D%B7C/"/>
    
  </entry>
  
  <entry>
    <title>机器学习中的数学：信息论(Information Theory)</title>
    <link href="http://example.com/2022/10/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6%EF%BC%9A%E4%BF%A1%E6%81%AF%E8%AE%BA-Information-Theory/"/>
    <id>http://example.com/2022/10/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6%EF%BC%9A%E4%BF%A1%E6%81%AF%E8%AE%BA-Information-Theory/</id>
    <published>2022-10-11T14:19:24.000Z</published>
    <updated>2022-10-11T14:19:36.548Z</updated>
    
    <content type="html"><![CDATA[<p>@[toc]</p><blockquote><p>参考：<em>Dive into Deep Learning A. zhang ect</em> Chapter 18 <strong>Appendix: Mathematics for Deep Learning</strong></p></blockquote><p>利用信息论我们可以测量或者比较在不同的信号（signals）中信息。在这部分，我们主要讨论机器学习对信息论的一些概念和应用。<br>首先我们先简要描述介绍一下机器学习和信息论之间的关系。机器学习的主要的任务就是从数据中提取出有价值的信息，然后利用这些信息去做一些预测。而信息论主要研究信息的编码、解码、转换和操作（sencoding, decoding, transmitting, and manipulating information）。所以，我们可以利用信息论来讨论机器学习在训练中对信息的处理过程。</p><h1 id="信息（Information）"><a href="#信息（Information）" class="headerlink" title="信息（Information）"></a>信息（Information）</h1><p><strong>信息</strong>就是能够将所有事情通过一种或者是多种编码格式编码成一个特定的序列。但是怎么样编码才能正确地表述事物所具有的信息量呢？在我们描述一个事件的时候，如果这件事情是不寻常的，这时候我们需要更多的信息来描述，反之需要更少的信息。这就好比说一个普通的碗和清朝乾隆皇帝御用的碗，后者是比较少见的，需要更多的必要信息才能描述清楚它的特征。所以可以将信息表示为事件发生的抽象概率。</p><h1 id="自信息（Self-information）"><a href="#自信息（Self-information）" class="headerlink" title="自信息（Self-information）"></a>自信息（Self-information）</h1><p>香农（Shannon）将<strong>比特</strong>（bit）作为信息的单位，这将时间发生的概率转换成比特数。这样，对于一个长度为$n$的二进制序列所包含的信息为$n$比特。<br>假设二进制序列每一个位置为1或者0的概率相等（都为$\frac 12$）,所以对于一个事件$X$,这个事件为：一个长度为$n$二进制序列，每种序列出现的概率为$\frac{1}{2^n}$,香农定义了<strong>自信息</strong>，将事件的概率转换成了比特数：<br>$$I(x) &#x3D; -\log_2(p)$$<br>举例来说，对于一个序列“0010”的自信息为：<br>$$I(“0010”) &#x3D; -\log_2(p(“0010”))&#x3D;-\log_2(\frac{1}{2^4})&#x3D;4\ bits$$<br>* <code>在本章节中，我们省略log的下标，如无特殊说明都表示  </code> $\log_2p$</p><h1 id="熵（Entropy）"><a href="#熵（Entropy）" class="headerlink" title="熵（Entropy）"></a>熵（Entropy）</h1><p>自信息只能描述一个离散事件的信息，这部分介绍能够任意随机变量的描述方式。</p><h2 id="提出熵的动机（Motivating-Entropy）"><a href="#提出熵的动机（Motivating-Entropy）" class="headerlink" title="提出熵的动机（Motivating Entropy）"></a>提出熵的动机（Motivating Entropy）</h2><p>熵的形式受限于<strong>香农熵定理</strong>：</p><ol><li>我们通过观察随机变量得到的信息与随机变量的元素的名称无关，与发生概率为0的元素无关。</li><li>两个随机变量<strong>一起</strong>观测得到的信息 $\le$ 两个随机变量<strong>分开</strong>观测得到的信息。当两个随机变量相互独立的时候，取得等号。</li><li>通过一个确定事件所得到的信息为0</li></ol><p>我们可以将抛掷一个完全均匀的硬币所得到的信息为1比特作为基准，以消除使用不同的基本单位而导致的对同一事件的信息量上的差异。</p><h2 id="定义（Definition）"><a href="#定义（Definition）" class="headerlink" title="定义（Definition）"></a>定义（Definition）</h2><p>对于一个随机变量$X$, 遵循概率分布$P$,概率密度函数或概率质量函数为$p(x)$,我们利用熵来描述信息的期望值：<br>$$H(x)&#x3D;-E_{x\sim P}[\log p(x)]$$<br>具体来说：<br>$$H(X)&#x3D;\left{\begin{aligned}<br>&amp; -\sum_i p_i\log p_i, \quad p_i &#x3D; P(X_i)\quad X 是离散型随机变量 \<br>&amp; -\int_x p(x)\log p(x) dx\quad X是连续型随机变量<br>\end{aligned}<br>\right.$$<br>连续性随机变量的熵也被称为<strong>微分熵</strong>（Differential Entropy） </p><h2 id="解释（Interpretation）"><a href="#解释（Interpretation）" class="headerlink" title="解释（Interpretation）"></a>解释（Interpretation）</h2><p>在这一节中，主要解释两个关于上述公式的问题。</p><ol><li><p>为什么要使用负对数？<br> 首先是为什么要使用对数。这是为了保证熵对独立随机变量的可加性。对于一系列相互独立的事件发生的概率为$f_i(x)$, 那么所有事件发生的概率为 $p(X)&#x3D;\prod_if_i(x)$,使用对数可以将这个连乘转换成连加。</p></li><li><p>为什么添加负号？<br> 因为信息的定义。由于发生概率低的事件应该包含更多的信息，但是对数是一个单调递增函数，所以为了保证事件概率和对应的熵之间的反比例的关系，我们需要对对数加一个负号，让他变成单调递减函数。</p></li><li><p>为什么需要期望函数？<br> 对于一个随机变量X，它的自信息（$-\log(p)$）就是对于某个输出的不确定性的数量。但是当事件发生的概率趋向于0的时候，这种不确定性就会趋向于$+\infin$.同样的，我们可以将熵解释为观测事件X的平均不确定性。举例子来说，对于一个模型的相互独立的输出$s_1,\cdots, s_k$的对应的概率为$p_1,\cdots, p_k$， 那么这个系统的熵就是输出值的平均自信息：<br> $$H(S) &#x3D; \sum_ip_i\cdot I(s_i)&#x3D;-\sum_ip_i\cdot\log p_i$$</p></li></ol><h2 id="熵的性质（Properties-of-Entropy）"><a href="#熵的性质（Properties-of-Entropy）" class="headerlink" title="熵的性质（Properties of Entropy）"></a>熵的性质（Properties of Entropy）</h2><p>下面考虑随机事件$X$, 它对应的概率分布为$P$</p><ul><li>对所有离散型随机变量$X$:$H(X)\ge 0$(连续性随机变量的熵可能会是负数)</li><li>假设一个随机事件$X\sim P\quad(p.d.f&#x3D;p(x))$，我们想用一个新的概率分布$Q\quad(p.d.f&#x3D;q(x))$来估计$P$则有：<br>   $$H(X)&#x3D;-E_{x\sim P}[\log p(x)]\le -E_{x\sim P}[\log q(x)]$$<br>   当$P&#x3D;Q$的时候，取得等号。</li><li>对于一个随机变量$X\sim P$, $x$将会传递最多的信息，如果他能将这些信息均匀地分布在所有可能的结果上。具体来说，对于一个概率分布$P$的k种相互独立的输出${p_1,\cdots, p_k}$:<br> $$H(X)\le \log(k), with\ equality\ if \ and \ only \ if \ p_i&#x3D;\frac{1}{k},\forall_i$$<br> 但是如果$P$是一个连续性随机变量，那么处理过程就会很麻烦了。我们假设P在一个有限的区间内，那么，如果这个随机变量在这个区间上满足均匀分布，那么这个随机变量的熵的值将会是最大的。</li></ul><h1 id="互信息（Mutual-Information）"><a href="#互信息（Mutual-Information）" class="headerlink" title="互信息（Mutual Information）"></a>互信息（Mutual Information）</h1><p>在这部分，我们联合变量$(X,Y)$的熵。在本节中，我们使用的联合变量$(X,Y)$遵循联合概率分布$P$,概率密度函数为$P_{X,Y}(x,y)$,其中$X\sim p_X(x);\quad Y\sim p_Y(y)$</p><h2 id="联合熵-Joint-Entropy"><a href="#联合熵-Joint-Entropy" class="headerlink" title="联合熵(Joint Entropy)"></a>联合熵(Joint Entropy)</h2><p>联合熵与先前定义的熵的形式一致：<br>$$H(X,Y)&#x3D;-E_{(x,y)\sim P}[\log p_{X,Y}(x,y)]\tag {<em>}$$<br>具体形式为：<br>$$H(X,Y)&#x3D;\left{\begin{aligned}<br>&amp;-\sum_x\sum_yp_{X,Y}(x,y)\log p_{X,Y}(x,y),\quad 离散型\<br>&amp;-\int_{x,y}p_{X,Y}(x,y)\log p_{X,Y}(x,y)dxdy,\quad 连续型<br>\end{aligned}\right.<br>$$<br>$(</em>)$表示一对随机变量的全部的不确定性。当$X&#x3D;Y$的时候，$H(X,Y)&#x3D;H(X)&#x3D;H(Y)$,当X与Y相互独立的时候$H(X,Y)&#x3D;H(X)+H(Y)$,所以有：<br>$$H(X),H(Y)\le H(X,Y)\le H(X)+H(Y)$$</p><h2 id="条件熵（Conditional-Entropy）"><a href="#条件熵（Conditional-Entropy）" class="headerlink" title="条件熵（Conditional Entropy）"></a>条件熵（Conditional Entropy）</h2><p>在机器学习中，我们更多的时候，我们更关注条件上而不是联合熵。例如我们要根据图片判断图片的标签，这就可以理解为在图片像素信息条件下的对标签的信息。条件熵的定义与之前的几种熵的定义相似：<br>$$H(Y|X)&#x3D;-E_{(x,y)\sim P}[\log p(y|x)]$$<br>其中：$p(y|x)&#x3D;\frac{p_{X,Y}(x,y)}{p_X(x)}$.条件熵与熵和联合熵的关系为：<br>$$H(Y|X)&#x3D;H(X,Y)-H(X)$$<br>这样条件熵既可以理解为存在于Y中的而不存在与X中的的信息。</p><h2 id="互信息（Mutual-Information）-1"><a href="#互信息（Mutual-Information）-1" class="headerlink" title="互信息（Mutual Information）"></a>互信息（Mutual Information）</h2><p>上面我们讨论了联合变量之中独有的信息，现在我们讨论两个变量之间共有的信息。所以根据定义可以得到（互信息:$I(X,Y)$）<br>$$I(X,Y) &#x3D; H(X,Y)-H(Y|X)-H(X|Y)$$<br>将原先的定义式带入，整理可得：<br>$$I(X,Y)&#x3D;E_xE_y\left{<br>p_{X,Y}(x,y)\log \frac{p_{X,Y}(x,y)}{p_X(x)p_Y(y)}<br>\right}<br>$$<br>在本节中提到的定义之间的关系如下图：<br><img src="https://img-blog.csdnimg.cn/013c87570cd9401fb52ba8c3dd7d9da8.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_Q1NETiBATGVhcm5pbmdEZWVwbHk=,size_29,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="互信息的性质-Properties-of-Mutual-Information"><a href="#互信息的性质-Properties-of-Mutual-Information" class="headerlink" title="互信息的性质(Properties of Mutual Information)"></a>互信息的性质(Properties of Mutual Information)</h2><ul><li>对称性：$I(X,Y) &#x3D; I(Y,X)$</li><li>非负性：$I(X,Y)\ge 0$</li><li>如果两个随机变量是相互独立的，那么$I(X,Y)&#x3D;0$</li><li>如果X是Y的可逆函数：$I(X,Y)&#x3D;H(Y)&#x3D;H(X)$</li></ul><h2 id="点间互信息（Pointwise-Mutual-Information）"><a href="#点间互信息（Pointwise-Mutual-Information）" class="headerlink" title="点间互信息（Pointwise Mutual Information）"></a>点间互信息（Pointwise Mutual Information）</h2><p>点间互信息:$pmi(x,y)$就是互信息定义中的对数部分：<br>$$pmi(x,y) &#x3D; \log\frac{p_{X,Y}(x,y)}{p_X(x)p_Y(y)}$$<br>他描述的是两个联合事件发生的概率比分别发生的概率的具体的数值关系。</p><h2 id="互信息的应用（Applications-of-Mutual-Information）"><a href="#互信息的应用（Applications-of-Mutual-Information）" class="headerlink" title="互信息的应用（Applications of Mutual Information）"></a>互信息的应用（Applications of Mutual Information）</h2><p>在自认语言处理中，<strong>歧义消除</strong>（Ambiguity Resolution）是一件比较难的事情。也就是一些词在文中的含义不是很明确。例如先前出现的新闻“亚马逊起火了”，我们不知道是公司起火了，还是那个雨林起火了。这时候就产生了歧义。我们先找出一组词，这些词与亚马逊公司有较大互信息。同样找到与亚马逊雨林有较大互信息的词，然后分析这些那些在文中有更高的出现频率。利用这个，我们能够了解新闻是关于公司的还是雨林的。</p><h1 id="Kullback–Leibler-散度（Kullback–Leibler-Divergence）"><a href="#Kullback–Leibler-散度（Kullback–Leibler-Divergence）" class="headerlink" title="Kullback–Leibler 散度（Kullback–Leibler Divergence）"></a>Kullback–Leibler 散度（Kullback–Leibler Divergence）</h1><p>我们可以利用范数来表示任何维度两点之间的距离。现在我们想知道两个概率分布之间的距离（相似程度）。<strong>KL散度</strong>就是一种测量两种分布之间相似程度的量。</p><h2 id="定义（Definition）-1"><a href="#定义（Definition）-1" class="headerlink" title="定义（Definition）"></a>定义（Definition）</h2><p>对于一个随机变量$X$遵循概率分布$P$,概率密度分布为$p(x)$.我们利用另一个概率分布$Q$($p.d.f&#x3D;q(x)$),那么$P$和$Q$之间的KL散度（相对熵，Relative Entropy）定义为：<br>$$D_{KL}(P|Q)&#x3D;E_{x\sim P}[\log\frac{p(x)}{q(x)}]$$<br>可见DL散度就是在描述两个随机变量之间不确定性程度的相对关系。</p><h2 id="性质（Properties）"><a href="#性质（Properties）" class="headerlink" title="性质（Properties）"></a>性质（Properties）</h2><ul><li>非对称性：$D_{KL}(P|Q)\ne D_{KL}(Q|P)$</li><li>非负性：$D_{KL}(P|Q)\ge0$,当$P&#x3D;Q$时取得等号。</li><li>如果$p(x)&gt;0,\ q(x)&#x3D;0$则$D_{KL}(P|Q)&#x3D;\infin$</li><li>以下三种表达式等价：<br>  $$D_{KL}(P(X,Y)| P(X)P(Y))$$<br>  $$E_Y{D_{KL}(P(X|Y))|P(X))}$$<br>  $$E_X{D_{KL}(P(Y|X)|P(Y))}$$<blockquote><p>For the first term, we interpret mutual information as the KL divergence between P(X, Y ) and the product of P(X) and P(Y ), and thus is a measure of how different the joint distribution is from the distribution if they were independent. For the second term, mutual information tells us the average reduction in uncertainty about Y that results from learning the value of the $X$ʼs distribution. Similarly to the third term.</p></blockquote></li></ul><h1 id="交叉熵（Cross-Entropy）"><a href="#交叉熵（Cross-Entropy）" class="headerlink" title="交叉熵（Cross-Entropy）"></a>交叉熵（Cross-Entropy）</h1><p>对于一个二分类问题，预测值为$\hat y_i &#x3D; p_\theta(y_i|x_i)$.预测结果为1的概率为：$\pi_i&#x3D;p_\theta(y_i&#x3D;1|x_i)$所以log似然方程为：<br>$$\begin{aligned}<br>l(\theta)&amp;&#x3D;\log L(\theta)\<br>&amp;&#x3D;\log \prod^n_{i&#x3D;1}\pi_i^{y_i}(1-\pi_i)^{1-y_i}\<br>&amp;&#x3D;\sum^n_{i&#x3D;1}y_i \log(\pi_i)+(1-y_i)\log(1-\pi_i)<br>\end{aligned}<br>$$<br>我们的目标就是最大化这个似然函数，这种方法就是极大似然估计。看到式中的自然对数，我们可以联想到之前提到一些信息论的概念。这暗示我们这个函数可以从信息论的角度理解。</p><h2 id="正式定义（Formal-Definition）"><a href="#正式定义（Formal-Definition）" class="headerlink" title="正式定义（Formal Definition）"></a>正式定义（Formal Definition）</h2><p>我们假设有两个随机变量:$P\sim p(x);\quad Q\sim q(x)$(前者是真实值的分布，后者是预测值的分布).，我们可以通过交叉熵来描述两种分布之间的散度：<br>$$CE(P,Q)&#x3D;-E_{x\sim P}[\log (q(x))]$$<br>通过之前提到的关系式，可以将上式转化为：<br>$$CE(P,Q) &#x3D; H(P)+D_{KL}(P|Q)$$</p><h2 id="性质（Properties）-1"><a href="#性质（Properties）-1" class="headerlink" title="性质（Properties）"></a>性质（Properties）</h2><p>交叉熵可以用于优化问题的损失函数，以下几种说法是等价的：</p><ul><li>最大化分布对于分布P的预测概率(最大化$E_{x\sim P[\log (q(x))]}$)</li><li>最小化交叉熵$CE(P,Q)$</li><li>最小化KL散度</li></ul><p>这些性质可以从交叉熵的定义中得出。注意因为P是真实值的分布，所以$H(P)$是一个常量。</p><h2 id="交叉熵作为多元分类问题的目标函数（Cross-Entropy-as-An-Objective-Function-of-Multi-class-Classification）"><a href="#交叉熵作为多元分类问题的目标函数（Cross-Entropy-as-An-Objective-Function-of-Multi-class-Classification）" class="headerlink" title="交叉熵作为多元分类问题的目标函数（Cross-Entropy as An Objective Function of Multi-class Classification）"></a>交叉熵作为多元分类问题的目标函数（Cross-Entropy as An Objective Function of Multi-class Classification）</h2><p>现在考虑一个k分类问题，这个分类问题的标签用独热编码（One-hot encoding）表示$y_i&#x3D;(y_{i1},\cdots,y_{ik})$,预测标签值为：<br>$$\hat y_i&#x3D;p_\theta(y_i|x_i)&#x3D;\sum^k_{j&#x3D;1}y_{ij}p_\theta(y_{ij}|x_i)$$<br>所以交叉熵可以表示为：<br>$$CE(y,\hat y)&#x3D;-\sum^n_{i&#x3D;1}y_i\log\hat y_i&#x3D;-\sum^n_{i&#x3D;1}\sum^k_{j&#x3D;1}y_{ij}\log(y_{ij}|x_i)$$<br>另一方面，我们可以利用极大似然估计来解决这个问题。假设一个随机变量$z&#x3D;(z_1,\cdots,z_k)$满足k分类多元伯努利分布，对应的概率为$p&#x3D;(p_1,\cdots, p_k)$,也就是：<br>$$p(z)&#x3D;p(z_1,\cdots,z_k)&#x3D;Multi(p_1,\cdots,p_k),\ where\ \sum^k_{i&#x3D;1}p_i&#x3D;1$$<br>z的联合概率质量函数为:<br>$$p^z&#x3D;\prod^k_{j&#x3D;1}p^{z_j}<em>j$$<br>所以对应的log似然方程为：<br>$$l(\theta)&#x3D;\log L(\theta)&#x3D;\log\prod^n</em>{i&#x3D;1}p^{y_i}&#x3D;\log\prod^n_{i&#x3D;1}\prod_{j&#x3D;1}^{k}p^{y_{ij}}&#x3D;\sum^n_{i&#x3D;1}\sum^k_{j&#x3D;1}y_{ij}\log p_j$$<br>所以对于多分类问题最大化log似然函数等价于最小化交叉熵损失$CE(y,\hat y)$</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;@[toc]&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;参考：&lt;em&gt;Dive into Deep Learning A. zhang ect&lt;/em&gt; Chapter 18 &lt;strong&gt;Appendix: Mathematics for Deep Learning&lt;/s</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>test</title>
    <link href="http://example.com/2022/10/11/test/"/>
    <id>http://example.com/2022/10/11/test/</id>
    <published>2022-10-11T13:57:22.000Z</published>
    <updated>2022-10-11T14:08:23.417Z</updated>
    
    <content type="html"><![CDATA[<p>这是一篇测试文章</p><img src="/.com//10/11/test/test.jpg" class title="图片引用方法一"><p><img src="/.com//10/11/test/test.jpg" alt="图片引用方法二"></p><p>这里的图片放在<code>\source\images</code>目录下<br><img src="/./images/test.png" alt="图片引用方法三"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这是一篇测试文章&lt;/p&gt;
&lt;img src=&quot;/.com//10/11/test/test.jpg&quot; class title=&quot;图片引用方法一&quot;&gt;

&lt;p&gt;&lt;img src=&quot;/.com//10/11/test/test.jpg&quot; alt=&quot;图片引用方法二&quot;&gt;&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>机器学习中的数学 ch12：支持向量机分类（Classification with Support Vector Machines）</title>
    <link href="http://example.com/2021/07/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6-ch12%EF%BC%9A%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%E5%88%86%E7%B1%BB%EF%BC%88Classification-with-Support-Vector-Machines%EF%BC%89/"/>
    <id>http://example.com/2021/07/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6-ch12%EF%BC%9A%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%E5%88%86%E7%B1%BB%EF%BC%88Classification-with-Support-Vector-Machines%EF%BC%89/</id>
    <published>2021-07-25T00:25:24.000Z</published>
    <updated>2023-03-09T10:50:55.512Z</updated>
    
    <content type="html"><![CDATA[<p>@[toc]<br>在机器学习中，有一种分类问题，这种分类问题只有两个预测结果，是或否，即：</p><script type="math/tex; mode=display">f:\mathbb R^D\rightarrow \{0,1\}</script><p>为了计算方便，我们使用0，1来表示两种分类的结果，这种分类问题被称为<strong>二元分类</strong>（Binary Classification）。本章节就是主要介绍用<strong>支持向量机</strong>（Support Vector Machine，SVM）来解决这种分类问题。<br>支持向量机给我们提供了一个用几何的方式的视角看待监督式机器学习。在原先的章节中，我们使用概率模型来理解机器学习问题：用极大似然估计和贝叶斯推断对模型进行优化。支持向量机利用的是另一个角度，这种角度需要大量的代数知识，如内积、投影等。另外，由于用支持向量机解的优化问题没有一个解析解，所以我们需要利用之前学到的各种的优化方法，这可以作为之前学到的知识的一种实践。<br>在支持向量机的视角下的机器学习问题与概率视角下的机器学习问题略有不同，前者的模型是由数据分布的概率视角得出的。后者是设计一个函数，然后再训练的过程中不断优化，这是基于几何理解的。<br>接下来我们将从两个视角看待SVM：几何视角和损失函数视角。同时，为了提高模型的泛化能力，线性分类子应该允许一些错误的分类。之后我们还利用拉格朗日乘子得到对偶版本的SVM，这让我们可以利用另一个角度看待SVM。我们还介绍SVM的核方法，以及解非线性核SVM的优化问题。</p><h1 id="分离超平面（Separating-Hyperplanes）"><a href="#分离超平面（Separating-Hyperplanes）" class="headerlink" title="分离超平面（Separating Hyperplanes）"></a>分离超平面（Separating Hyperplanes）</h1><p>对于两点的相似程度，我们可以使用内积来表示$\langle x_i,x_j\rangle$。而一个分类问题的本质就是将数据集在一个平面上表示，然后将数据所在的空间划分成两个子空间。为了方便起见，我们考虑一个简单的分类问题：</p><script type="math/tex; mode=display">f:\mathbb R^D\rightarrow \mathbb R, \ x\in \mathbb R^D\\ x\mapsto f(x):=\langle w,x\rangle+b</script><p>其中的参数为：$w\in\mathbb R^D,b\in \mathbb R$.我们原先提到，超平面实际上就是仿射子空间，所以我们假设一个超平面在一个二分类问题中将两类数据分离到两个子空间中：</p><script type="math/tex; mode=display">\{x\in\mathbb R^D:f(x)=0\}</script><p>在下图中，我们可以知道w是超平面的法向量，b是超平面的截距。<br><img src="https://img-blog.csdnimg.cn/20210720074318957.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>证明：<br>假设有两个点在超平面上$x_a,x_b$:</p><script type="math/tex; mode=display">f(x_a)-f(x_b)=\langle w,x_a\rangle+b-(\langle w,x_b\rangle + b)=\langle w, x_a-x_b\rangle</script><p>由于超平面的方程为$\langle w,x\rangle +b=0$,而选取的两个点在超平面上，所以$f(x_a),f(x_b)=0$,所以：</p><script type="math/tex; mode=display">\langle w, x_a-x_b\rangle=0</script><p>所以，w与超平面相互垂直。<br>对于一个二分类问题，数据点在超平面的上方为一类，下方为另一类，所以：</p><script type="math/tex; mode=display">y_n=\left\{\begin{aligned}1,\quad\langle w,x_n\rangle+b\ge0 \\-1\quad \langle w,x_n\rangle+b <0 \end{aligned}\right.</script><p>上式也可以直接整理到一个式子中：$y_n(\langle w,x_n\rangle+b)\ge 0$.这就是分类问题的分类器。</p><h1 id="原始支持向量机（Primal-Support-Vector-Machine）"><a href="#原始支持向量机（Primal-Support-Vector-Machine）" class="headerlink" title="原始支持向量机（Primal Support Vector Machine）"></a>原始支持向量机（Primal Support Vector Machine）</h1><p>对于一个线性可分的数据集，有时候能够将两类数据分开的超平面不止一个，我们需要找到其中的较好的一个超平面，其中的一个想法就是最大化两类数据到超平面的距离，这样能够提高模型的泛化能力。（这样想，如果一个分类器离数据点很近，那么只要这个数据点有一点波动，就可能导致数据点的类别变化）</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://img-blog.csdnimg.cn/20210720104357340.png">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">    Figure 12.3  Possible separating hyperplanes. There are many linearclassifiers (green lines) that separate orange crosses from blue discs.</div></center><br>## 间隔的概念（Concept of the Margin）我们假设有一个样本点$x_a$是这一类数据中离超平面最近的点, 这个样本点在超平面上的正交投影为$x_a'$,如下图所示。我们可以发现$x_a$与$x_a'$之间的距离向量与$w$相互平行，所以这个距离向量可以用$r\frac{w}{\|w\|}$表示，其中的r为比例参数，然后根据向量加法：$$x_a = x_a'+r\frac{w}{\|w\|}$$对于r，我们还可以认为是$x_a$在$w$上的投影的坐标。<center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://img-blog.csdnimg.cn/20210720103533239.png">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">Figure 12.4 Vector addition to express distance to hyperplane    </div></center><br>我们需要尽量最大化这个距离向量，所以我们假设这个距离向量的模不应该小于r(即这个数据点到其投影点的距离不应该小于$|r|$)，所以有：$$y_n(\langle w,x_n\rangle+b)\ge r$$由于我们并不关心$w$的大小，只需要求他的方向，所以可以假设$\|w\|=1$。将上面的条件组合成一个约束优化问题：$$\max_{w,b,r}\underbrace{r}_{margin}\\s.t. \quad \underbrace{y_n(\langle w, x_n\rangle+b\ge r)}_{data fitting},\ \underbrace{\|w\|=1}_{normalization},r>0$$这也就是说我们想最大化间隔r，同时保证数据在超平面的正确的方向。<center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://img-blog.csdnimg.cn/20210720111704696.png">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">Figure 12.5Derivation of themargin: r</div></center><blockquote><p>when the margin is large, the “complexity” of the function class is low, and hence learning is possible</p></blockquote><h2 id="间隔的传统推导（Traditional-Derivation-of-the-Margin）"><a href="#间隔的传统推导（Traditional-Derivation-of-the-Margin）" class="headerlink" title="间隔的传统推导（Traditional Derivation of the Margin）"></a>间隔的传统推导（Traditional Derivation of the Margin）</h2><p>我们之前在推导边缘的时候，因为我们不关心$w$的大小，只关心它的方向，所以我们就假设$|w|=1$.在本节中，我们将使用不同的假设推导边缘最大化问题。假设数据集中的一类离超平面最近的点为$x_a$,距离为1,即$\langle w,x_a\rangle +b=1$， 所以我们可以重新调整超平面，使得这个点在移动后的超平面上，如图12.5. 有因为这个数据点的投影$x’_a$在超平面上，所以：</p><script type="math/tex; mode=display">\langle w,x_a'\rangle +b = 0</script><p>之后将$x_a = x_a’+r\frac{w}{|w|}$带入到上式：</p><script type="math/tex; mode=display">\langle w, x_a-r\frac{w}{\|w\|}\rangle+b=0</script><p>再根据内积的双线性的性质：</p><script type="math/tex; mode=display">\langle w,x_a\rangle +b-r\frac{\langle w,w\rangle}{\|w\|}=0</script><p>由于我们之前假设$\langle w,x_a\rangle +b=1$,有因为$\langle w,w\rangle=|w|^2$,全部带入上式：</p><script type="math/tex; mode=display">r = \frac{1}{\|w\|}</script><p>由于在计算的时候w也是未知的，所以我们并不能通过上式将r推导出来，但是我们可以将这个变量作为中间变量，所以接下来的章节我们将会使用$\frac{1}{|w|}$代替$r$.当然这个r 也可以看成数量点向超平面的投影误差。 这样我们可以发现，这个假设$r=1$与之前的假设$|w|=1$是一致的。<br>于是，我们原先的约束问题可以转换成：</p><script type="math/tex; mode=display">\max_{w,b}\frac{1}{\|w\|}\\s.t. \quad y_n(\langle w,x_n\rangle+b\ge1) \quad for \ all \quad n=1,\cdots,N</script><p>为了计算方便，我们将上式中的求最大值转换成求最小值：</p><script type="math/tex; mode=display">\min_{w,b}\frac12{\|w\|}^2\\s.t. \quad y_n(\langle w,x_n\rangle+b\ge1) \quad for \ all \quad n=1,\cdots,N</script><p>上式就是<strong>硬边界支持向量机</strong>（hard margin SVM）。之所以称为“硬”，是因为这个边界不允许任何数据点违反边界条件。</p><h2 id="为什么将间隔设为1（Why-We-Can-Set-the-Margin-to-1）"><a href="#为什么将间隔设为1（Why-We-Can-Set-the-Margin-to-1）" class="headerlink" title="为什么将间隔设为1（Why We Can Set the Margin to 1）"></a>为什么将间隔设为1（Why We Can Set the Margin to 1）</h2><p>我们需要证明：</p><script type="math/tex; mode=display">\begin{aligned}&\max _{\boldsymbol{w}, b, r} \underbrace{r}_{\text {margin }} \\&\text { subject to } \quad \underbrace{y_{n}\left(\left\langle\boldsymbol{w}, \boldsymbol{x}_{n}\right\rangle+b\right) \geqslant r}_{\text {data fitting }}, \underbrace{\|\boldsymbol{w}\|=1}_{\text {normalization }}, \quad r>0\end{aligned}</script><p>与</p><script type="math/tex; mode=display">\min _{\boldsymbol{w}, b} \underbrace{\frac{1}{2}\|\boldsymbol{w}\|^{2}}_{\text {margin }}\\{\text { subject to }} \underbrace{y_{n}\left(\left\langle\boldsymbol{w}, \boldsymbol{x}_{n}\right\rangle+b\right) \geqslant 1}_{\text {data fitting }} .</script><p>是等价的。后者是利用了假设$r=1$.以下证明不严格，主要用于描述证明思路。<br>假设一个超平面的方程为：$wx+b=r$，将右边归一化之后得：$\frac{w}{r}x+\frac{b}{r}=1$,于是可以令:$w’=\frac{w}{r},\ b’=\frac{b}{r}$于是:$|w’|=\frac 1r |w|$,由于原命题中有一个假设：$|w|=1$,所以可以得到：$|w’|=\frac 1r$.带入原命题中，可以得到与要证明的命题一致的形式：</p><script type="math/tex; mode=display">\min _{\boldsymbol{w'}, b} \underbrace{\frac{1}{2}\|\boldsymbol{w'}\|^{2}}_{\text {margin }}\\{\text { subject to }} \underbrace{y_{n}\left(\left\langle\boldsymbol{w'}, \boldsymbol{x}_{n}\right\rangle+b\right) \geqslant 1}_{\text {data fitting }} .</script><p>或者是说，两个参数同时变化相当于对超平面的平移，但是无论怎么平移，方程都是指向同一个超平面的。（几何间隔与函数间隔）</p><h2 id="软间隔支持向量机：几何视角（Soft-Margin-SVM-Geometric-View）"><a href="#软间隔支持向量机：几何视角（Soft-Margin-SVM-Geometric-View）" class="headerlink" title="软间隔支持向量机：几何视角（Soft Margin SVM: Geometric View）"></a>软间隔支持向量机：几何视角（Soft Margin SVM: Geometric View）</h2><p>由于测量误差等的因素，很难保证数据点都准确。所以我们希望能够允许部分的数据点被错误分类，这种允许一些错误分类的支持向量机称为<strong>软间隔支持向量机</strong>。<br>在几何视角下，我们需要介绍一个关键变量：<strong>松弛变量</strong>（slack variable）</p><p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://img-blog.csdnimg.cn/img_convert/f500ab634f2592cb2887e5669816d165.png">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">Figure 12.7 松弛变量描述的是被错误分类的点到对应的间隔超平面的距离，x+是被错误分类的数据点</div></center><br><br></p><p>我们为每一组数据$(x_i,y_i)$引入一个松弛变量$ \xi_i$这样允许一组数据在间隔以内，甚至是在超平面的错误的一边。我们将松弛变量加入到硬间隔支持向量机中：</p><script type="math/tex; mode=display">\min_{w,b,\xi}\frac 12\|w\|^2+C\sum^N_{n=1}\xi_n\\s.t.\quad y_n(\langle w,x_n\rangle +b)\ge1-\xi_n,\quad \xi_n\ge0</script><p>其中，$C$被称为<strong>正则化系数</strong>， $|w|^2$被称为<strong>正则项</strong>。这个定义与之前的好像略有不同，可以认为是在原先的正则化式子中同时除以了一个正则化系数$\lambda$.上面这个式子就是<strong>软间隔支持向量机</strong>（Soft Margin SVM）.</p><blockquote><p>注意到式中的b没有正则化，因为未正则化的b使理论分析复杂化并且降低了计算效率。<br>The unregularized term b complicates theoretical analysis (Steinwart and Christmann, 2008, chapter 1) and decreases computational efficiency (Fan et al., 2008).<strong>（？）</strong><br><strong>公式理解</strong>：$1-\xi$是错误分类的数据点距超平面的距离。</p></blockquote><h2 id="软间隔SVM：损失函数视角（Soft-Margin-SVM-Loss-Function-View）"><a href="#软间隔SVM：损失函数视角（Soft-Margin-SVM-Loss-Function-View）" class="headerlink" title="软间隔SVM：损失函数视角（Soft Margin SVM: Loss Function View）"></a>软间隔SVM：损失函数视角（Soft Margin SVM: Loss Function View）</h2><p>在SVM中，我们假设类就是超平面：</p><script type="math/tex; mode=display">f(x)=\langle w,x\rangle+b</script><p>现在我们要找到对应的损失函数，在之前的章节中的线性规划问题中使用的平方损失函数在分类问题中并不适合，所以我们需要找到其他的损失函数。<br>有一个候选函数就是<strong>0-1损失函数</strong>（zero-one loss）。当样本被错误分类的时候，函数值为1，否则为0，这个函数标识为$\boldsymbol 1(f(x)\ne y_n)$。但是使用这个损失函数就需要解决一个组合优化问题，难度很大。<br>还有一种损失函数为<strong>合页损失函数</strong>（hinge loss）：</p><script type="math/tex; mode=display">\ell = \max\{0,1-t\},\quad where \quad t=yf(x)=y(\langle w,x\rangle+b)</script><p>也就是当预测结果在正确的方向且$t\ge1$时， 函数值为0.其他情况为非零，也可以将上式写成：</p><script type="math/tex; mode=display">\ell =\left\{\begin{aligned}&0\quad &if\quad y\ge1 \\&1-t\quad &if\quad t<1\end{aligned}\right.</script><p>对于硬间隔SVM：</p><script type="math/tex; mode=display">\ell=\left\{\begin{aligned}&0\quad &if\quad t\ge 1\\&\infin\quad &if \quad t<1\end{aligned}\right.</script><p>损失函数在图中的表示为：</p><p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://img-blog.csdnimg.cn/img_convert/b8279f9e6cb07969b873bed32897a8a7.png">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">Figure 12.8 合页损失函数是0-1损失函数的凸上界</div></center><br><br></p><p>将合页损失函数带到原先的优化问题中：</p><script type="math/tex; mode=display">\min_{w,b}\underbrace {\frac 12\|w\|^2}_{regularizer}+\underbrace{C\sum^N_{n=1}\max\{0,1-y_n(\langle w,x_n\rangle + b)\}}_{error\ term}</script><p>由上可以知道，最大间隔实际上就是正则化。上述的无约束优化问题的解可以直接用梯度下降法求解，与之前的约束优化问题的结果是一致的。这是因为：</p><script type="math/tex; mode=display">\min_{t}\max\{0,1-t\}</script><p>等价于：</p><script type="math/tex; mode=display">\min_{\xi,t}\quad\xi\\s.t. \quad \xi\ge0,\xi\ge1-t</script><p>将上式带入无约束优化问题中，经过整理可以得到与软间隔SVM一致的形式。</p><h1 id="对偶支持向量机（Dual-Support-Vector-Machine）"><a href="#对偶支持向量机（Dual-Support-Vector-Machine）" class="headerlink" title="对偶支持向量机（Dual Support Vector Machine）"></a>对偶支持向量机（Dual Support Vector Machine）</h1><p>原先我们提到的支持向量机的参数数量是由特征的数量决定的。在这部分，我们介绍对偶支持向量机，他的参数数量是由训练集数据的数量决定，这样能够有效处理特征多，数据少的数据集。另外， 对偶支持向量机能够很好地引入核函数。在这里地对偶主要指<strong>凸对偶</strong>（convex duality）</p><h2 id="利用拉格朗日乘子解决凸对偶（Convex-Duality-via-Lagrange-Multipliers）"><a href="#利用拉格朗日乘子解决凸对偶（Convex-Duality-via-Lagrange-Multipliers）" class="headerlink" title="利用拉格朗日乘子解决凸对偶（Convex Duality via Lagrange Multipliers）"></a>利用拉格朗日乘子解决凸对偶（Convex Duality via Lagrange Multipliers）</h2><p>将之前的约束优化问题利用拉格朗日乘子转化成非约束优化问题，其中$\alpha,\gamma$是拉格朗日乘子</p><script type="math/tex; mode=display">\begin{aligned}\mathfrak{L}(\boldsymbol{w}, b, \xi, \alpha, \gamma)=& \frac{1}{2}\|\boldsymbol{w}\|^{2}+C \sum_{n=1}^{N} \xi_{n} \\& \underbrace{-\sum_{n=1}^{N} \alpha_{n}\left(y_{n}\left(\left\langle\boldsymbol{w}, \boldsymbol{x}_{n}\right\rangle+b\right)-1+\xi_{n}\right)}_{\text {constraint (12.26b) }} \underbrace{-\sum_{n=1}^{N} \gamma_{n} \xi_{n}}_{\text {constraint }(12.26 \mathrm{c})}\end{aligned}</script><p>将拉格朗日函数对各个参数进行求导：</p><script type="math/tex; mode=display">\begin{aligned}\frac{\partial \mathfrak{L}}{\partial \boldsymbol{w}} &=\boldsymbol{w}^{\top}-\sum_{n=1}^{N} \alpha_{n} y_{n} \boldsymbol{x}_{n}^{\top}, \\\frac{\partial \mathfrak{L}}{\partial b} &=-\sum_{n=1}^{N} \alpha_{n} y_{n} \\\frac{\partial \mathfrak{L}}{\partial \xi_{n}} &=C-\alpha_{n}-\gamma_{n}\end{aligned}</script><p>将第一个式子设为0,得到：</p><script type="math/tex; mode=display">w=\sum^N_{n=1}\alpha_ny_nx_n</script><p>于是可以知道原始SVM的权重向量就是数据集的线性组合。这印证了我们原先提到的<strong>表示定理</strong>（representer theorem）：最小经验风险的解就在由数据定义的子空间中。</p><blockquote><p>表示会定理也给支持向量机这个名字提供了另一种解释。当$x_n$对应的$\alpha_n$为0的时候，说明这个数据点对解没有贡献，而当它大于0的时候，就被称为<strong>支持向量</strong>，它支撑起了超平面。</p></blockquote><p>将$w$的式子带入到上面的拉格朗日函数中：</p><script type="math/tex; mode=display">\begin{aligned}\mathfrak{D}(\xi, \alpha, \gamma)=& \frac{1}{2} \sum_{i=1}^{N} \sum_{j=1}^{N} y_{i} y_{j} \alpha_{i} \alpha_{j}\left\langle\boldsymbol{x}_{i}, \boldsymbol{x}_{j}\right\rangle-\sum_{i=1}^{N} y_{i} \alpha_{i}\left\langle\sum_{j=1}^{N} y_{j} \alpha_{j} \boldsymbol{x}_{j}, \boldsymbol{x}_{i}\right\rangle \\&+C \sum_{i=1}^{N} \xi_{i}-b \sum_{i=1}^{N} y_{i} \alpha_{i}+\sum_{i=1}^{N} \alpha_{i}-\sum_{i=1}^{N} \alpha_{i} \xi_{i}-\sum_{i=1}^{N} \gamma_{i} \xi_{i}\end{aligned}</script><p>再令$\frac{\partial \mathfrak{L}}{\partial b}=-\sum<em>{n=1}^{N} \alpha</em>{n} y_{n}=0$带入，由于内积是对称函数而且具有双线性，所以上式中的前两项是可以合并的。于是得到：</p><script type="math/tex; mode=display">\mathfrak{D}(\xi, \alpha, \gamma)=-\frac{1}{2} \sum_{i=1}^{N} \sum_{j=1}^{N} y_{i} y_{j} \alpha_{i} \alpha_{j}\left\langle x_{i}, x_{j}\right\rangle+\sum_{i=1}^{N} \alpha_{i}+\sum_{i=1}^{N}\left(C-\alpha_{i}-\gamma_{i}\right) \xi_{i}</script><p>又再令$\frac{\partial \mathfrak{L}}{\partial \xi<em>{n}} =C-\alpha</em>{n}-\gamma_{n}=0$,又由于拉格朗日乘子$\gamma_i\ge0$,所以$\alpha_i\le C$,于是原先的双系数拉格朗日就转换成单系数拉格朗日：</p><script type="math/tex; mode=display">\begin{array}{ll}\min _{\boldsymbol{\alpha}} & \frac{1}{2} \sum\limits_{i=1}^{N} \sum\limits_{j=1}^{N} y_{i} y_{j} \alpha_{i} \alpha_{j}\left\langle\boldsymbol{x}_{i}, \boldsymbol{x}_{j}\right\rangle-\sum\limits_{i=1}^{N} \alpha_{i} \\\text { subject to } & \sum\limits_{i=1}^{N} y_{i} \alpha_{i}=0 \\0 \leqslant \alpha_{i} \leqslant C & \text { for all } i=1, \ldots, N\end{array}</script><p>这就是<strong>对偶支持向量机</strong>（Dual SVM）,它对应的约束被称为“<strong>框型约束</strong>”（box constraints）拉格朗日乘子被限制在一个方形的区域内（$[0,C]$）.这种与坐标轴平行的约束，在数值计算的过程中非常高效。<br>当我们得到$\alpha$之后，可以利用表示定理将最优的$w$求出来。假设这个参数为$w^*$</p><blockquote><p>在 L2 正则化问题上：<br>表示定理是指任意一个 L2 正则化的问题，其最佳 w* 都可以用 βn 与 Zn 线性组合得到。</p></blockquote><p>假设数据点$x_n$在边界上， 所以有$\langle w^*, x_n\rangle+b=y_n$，所以参数b的解为：</p><script type="math/tex; mode=display">b^*=y_n-\langle w^*,x_n\rangle</script><p>当假设不成立的时候，需要计算所有支持向量的上式右边式子的绝对值，然后找到中位数，这里省略。</p><h2 id="对偶支持向量机：凸包视角（Dual-SVM-Convex-Hull-View）"><a href="#对偶支持向量机：凸包视角（Dual-SVM-Convex-Hull-View）" class="headerlink" title="对偶支持向量机：凸包视角（Dual SVM: Convex Hull View）"></a>对偶支持向量机：凸包视角（Dual SVM: Convex Hull View）</h2><p>另一种理解支持向量机的方式需要借助一种几何参数。我们将拥有同样标签的数据点限制在我们构造的凸包中，如下图所示。<br><img src="https://img-blog.csdnimg.cn/34dc2628007e4a438705f2b5c2f5fabf.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>现在我们对凸包进行一个直观的解释。假设空间中有两个不相等的数据点$x<em>1,x_2$，现在有两个参数$\alpha_1, \alpha_2$,且$\alpha_1+\alpha_2=1$，所以$\alpha_1x</em>!+\alpha<em>2x_2$表示的就是$x_1,x_2$之间的数，现在加上另一个数据点及参数$x_3,\alpha_3$,这时候$\sum\limits^3</em>{i=1}\alpha_i=1$,这时候，三个点的线性组合的数据点在一个二维的区域内。这个区域就称为<strong>凸包</strong>（convex hull）。<br>通常，构建一个凸包，可以利用一个非负的权重$\alpha_n\ge0$,对应数据$x_n$,于是，凸包可以表示为：</p><script type="math/tex; mode=display">\operatorname{conv}(X)=\left\{\sum^N_{n=1}\alpha_nx_n\right\}, \quad with \ \sum^N_{n=1}\alpha_n=1,\alpha_n\ge0</script><p>假设数据是可以分离的，那么这些数据对应的凸包就不会重合，我们找到两类数据中距离另一类最近的数据点$c,d$,如上图所示，定义两个凸包之间的距离为：</p><script type="math/tex; mode=display">w:=c-d</script><p>想要这两个数据点尽可能接近，等价于以下的优化问题：</p><script type="math/tex; mode=display">\arg \min_w\|w\|=\arg \min_w\frac 12\|w\|^2</script><p>由于c点在正凸包中，所以c点可以表示为：</p><script type="math/tex; mode=display">c=\sum_{n:y_n=+1}\alpha^+_nx_n</script><p>同样的，d点可以表示为：</p><script type="math/tex; mode=display">d=\sum_{n:y_n=-1}a_n^-x_n</script><p>其中，$n:y_n=-1$标签为-1的坐标索引。将两式带入到优化方程中：</p><script type="math/tex; mode=display">\min_\alpha\frac12\left\|\sum_{n:y_n=+1}\alpha^+_nx_n-\sum_{n:y_n=+1}\alpha^+_nx_n\right\|</script><p>对于参数$\alpha$:</p><script type="math/tex; mode=display">\sum_{n:y_n=+1}\alpha^+_nx_n=1,\quad \sum_{n:y_n=-1}a_n^-x_n=1</script><p>由于：</p><script type="math/tex; mode=display">\begin{aligned}\sum_{n=1}^{N} y_{n} \alpha_{n} &=\sum_{n: y_{n}=+1}(+1) \alpha_{n}^{+}+\sum_{n: y_{n}=-1}(-1) \alpha_{n}^{-} \\&=\sum_{n: y_{n}=+1} \alpha_{n}^{+}-\sum_{n: y_{n}=-1} \alpha_{n}^{-}=1-1=0\end{aligned}</script><p>所以,优化问题的约束条件为：</p><script type="math/tex; mode=display">\sum_{n=1}^Ny_n\alpha_n=0</script><p>这里得到的约束优化问题与之前的对偶硬间隔支持向量机中的约束优化问题一致。</p><blockquote><p>想要得到软间隔的支持向量机的约束优化问题，我们需要利用<strong>缩小包</strong>（reduce hull），这对参数的规模进行了限制</p></blockquote><h1 id="核方法（Kernels）"><a href="#核方法（Kernels）" class="headerlink" title="核方法（Kernels）"></a>核方法（Kernels）</h1><p>在对偶SVM中，内积只是在样本之间，而在样本与参数之间没有内积的关系，所以可以使用一个特征$\phi(x)$将式中的内积代替。这样问题就具有了模块性，使得我们能够将特征表示方法和分类方法分开考虑。<br>由于有些数据并非是线性可分的，所以需要$\phi(x)$是非线性函数，但是我们不是去定义一个这样的非线性的函数，然后计算它的内积，而是定义一个相似函数$k(x_i,x_j)$,在这里这个相似函数称为<strong>核函数</strong>（Kernel Function）,核函数的定义为：<br>对于一个非线性特征映射$\phi(\cdot)$</p><script type="math/tex; mode=display">k:\mathcal X\times\mathcal X\rightarrow\mathbb R</script><p>存在一个<strong>希尔伯特空间</strong>（Hilbert space）$\mathcal H$有：<script type="math/tex">\phi:\mathcal X\rightarrow \mathcal H</script>.特征映射的定义为：</p><script type="math/tex; mode=display">k(x_i,x_j)=\langle \phi(x_i),\phi(x_j)\rangle_\mathcal H</script><p>每一个核函数都对应着唯一一个<strong>再生核希尔伯特空间</strong>（reproducing kernel Hilbert space）。在这种关系中，$\phi(x)=k(\cdot,x)$被称为<strong>规范特征图</strong>（Canonical Feature Map）.这种将一个内积转换成核函数的方法称为<strong>核方法</strong>（Kernel Trick）。这种方法避免了显式的非线性特征映射。<br>由数据内积或者是将数据带入到核函数$k(\cdot,\cdot)$得到的矩阵$K\in\mathbb R^{N\times N}$被称为<strong>克莱姆矩阵</strong>（Cram Matrix）,有时候也直接被称为<strong>核矩阵</strong>（Kernel Matrix）,核函数需要时对称且半正定的，这样核矩阵才能是对称和半正定的，对此核矩阵的定义为：</p><script type="math/tex; mode=display">\forall z\in \mathbb R^N:z^\top Kz\ge0</script><p>一些比较常用的核函数为：多项式核函数，高斯径向基核函数，有理二次核函数。下图是利用不同的核函数进行分类的结果：<br><img src="https://img-blog.csdnimg.cn/51546caf200e49b59e74ea817a13e844.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>注意函数的假设类仍旧是线性的，图中的非线性边界来源于核函数.</p><blockquote><p>这个“核”有很多定义，在这里的核是来源于再生核希尔伯特空间。我们之前提到过的核空间代表的是零空间。还有一种就是在密度估计中的光滑核函数。</p></blockquote><p>由于特征$\phi(x)$在数学上与核函数$k(x_i,x_j)$等价，所以我们常常选用一些比内积更好计算的核函数。例如，假设我们使用多项式核函数，当数据较多时，这时候即使是多项式的次数比较低，也会导致大量的特征($x_1,x_2,x_3 \rightarrow x_1<em>x_2, x_1</em>x_3\cdots$),但是使用核函数只需要对每一个输入进行一次乘法就可以了。<br>核方法的另一个优势是不需要将输入的数据表示为多元实数。而对于核函数的选择以及核函数的参数需要通过嵌套交叉验证的方式选择。</p><h1 id="数值解（Numerical-Solution）"><a href="#数值解（Numerical-Solution）" class="headerlink" title="数值解（Numerical Solution）"></a>数值解（Numerical Solution）</h1><p>在这部分，我们对原先提到的内容进行回顾。<br>首先我们是从损失函数的角度对支持向量机进行了解释，我们使用的合页损失函数$\max{0,1-t}$,但是这个损失函数是一个不可微的函数，于是我们采用次梯度（subgradient）的方法，得到损失函数的梯度：</p><script type="math/tex; mode=display">g(t)=\left\{\begin{aligned}&-1,\quad&t<1\\&[-1,0]&t=1\\&0&t>1 \end{aligned}\right.</script><p>这样我们就可以使用之前学过的一些优化算法进行优化了。<br>要想将原始支持向量机转换成二次规划的标准形式，我们假设内积为点乘，同时将原先所有的优化变量全部移到等式左边：</p><script type="math/tex; mode=display">\min_{w,b,\xi}\frac 12\|w\|^2+C\sum^N_{n=1}\xi_n\\s.t.\quad \left\{\begin{aligned}&-y_nx_n^\top w-y_nb-\xi_n\le-1 \\&-\xi_n\le0\end{aligned}\right.</script><p>将上式矩阵化（将变量$w,x_n,b$放到向量中）：</p><script type="math/tex; mode=display">\begin{aligned}&\min _{\boldsymbol{w}, b, \boldsymbol{\xi}} \quad \frac{1}{2}\left[\begin{array}{l}\boldsymbol{w} \\b \\\boldsymbol{\xi}\end{array}\right]^{\top}\left[\begin{array}{cc}\boldsymbol{I}_{D} & \mathbf{0}_{D, N+1} \\\mathbf{0}_{N+1, D} & \mathbf{0}_{N+1, N+1}\end{array}\right]\left[\begin{array}{c}\boldsymbol{w} \\b \\\boldsymbol{\xi}\end{array}\right]+\left[\begin{array}{ll}\mathbf{0}_{D+1,1} & C \mathbf{1}_{N, 1}\end{array}\right]^{\top}\left[\begin{array}{l}\boldsymbol{w} \\b \\\boldsymbol{\xi}\end{array}\right] \\&\text { subject to }\left[\begin{array}{ccc}-\boldsymbol{Y} \boldsymbol{X} & -\boldsymbol{y} & -\boldsymbol{I}_{N} \\\mathbf{0}_{N, D+1} & -\boldsymbol{I}_{N}\end{array}\right]\left[\begin{array}{c}\boldsymbol{w} \\b \\\boldsymbol{\xi}\end{array}\right] \leqslant\left[\begin{array}{c}-\mathbf{1}_{N, 1} \\\mathbf{0}_{N, 1}\end{array}\right]\end{aligned}</script><p>这其中$\boldsymbol 0,\boldsymbol1, \boldsymbol I,\boldsymbol Y, \boldsymbol X$分别代表零矩阵，全一矩阵，单位矩阵，标签组成的对角矩阵，样本矩阵。<br>而对于对偶支持向量机，想要将其表示为标准形式，我们首先需要表示核函数矩阵$K$,其中的每一个元素为$K<em>{ij}=k(x_i,x_j)$,如果我们有明确的特征表示$x_i$则我们可以定义$K</em><br>{ij}\langle x_i,x_j\rangle$,为了方便，我们将有标签组成的对角矩阵表示为$Y=diag(y)$,这时，对偶支持向量机可以写为：</p><script type="math/tex; mode=display">\min_\alpha\frac12\alpha^\top YKY\alpha\boldsymbol 1^\top_{N.1}\alpha\\s.t.\quad \begin{bmatrix}y^\top\\-y^\top\\-I_N\\I_n\end{bmatrix}\alpha\le\begin{bmatrix}\boldsymbol 0_{N+2,1}\\C\boldsymbol 1_{N,1}\end{bmatrix}</script><p>为了将式子表示为标准形式，所以将等式写成了两个不等式：</p><script type="math/tex; mode=display">Ax=b\Leftrightarrow AX\le b\quad and\quad AX\ge b</script><p>正是由于支持向量机能够清晰描述为优化问题，这使得许多的基于数值优化的技术能够被应用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;@[toc]&lt;br&gt;在机器学习中，有一种分类问题，这种分类问题只有两个预测结果，是或否，即：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;f:\mathbb R^D\rightarrow \{0,1\}&lt;/script&gt;&lt;p&gt;为了计算</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>机器学习中的数学ch11：基于高斯混合模型的密度估计（Density Estimation with Gaussian Mixture Models）</title>
    <link href="http://example.com/2021/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6ch11%EF%BC%9A%E5%9F%BA%E4%BA%8E%E9%AB%98%E6%96%AF%E6%B7%B7%E5%90%88%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%AF%86%E5%BA%A6%E4%BC%B0%E8%AE%A1%EF%BC%88Density-Estimation-with-Gaussian-Mixture-Models%EF%BC%89/"/>
    <id>http://example.com/2021/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6ch11%EF%BC%9A%E5%9F%BA%E4%BA%8E%E9%AB%98%E6%96%AF%E6%B7%B7%E5%90%88%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%AF%86%E5%BA%A6%E4%BC%B0%E8%AE%A1%EF%BC%88Density-Estimation-with-Gaussian-Mixture-Models%EF%BC%89/</id>
    <published>2021-07-05T02:09:14.000Z</published>
    <updated>2023-03-09T10:49:43.071Z</updated>
    
    <content type="html"><![CDATA[<p>@[toc]<br>在本章节中，我们会介绍关于密度估计的几个主要的概念，例如：<strong>期望最大化算法</strong>（expectation maximization (EM) algorithm）。<br>当我们使用数据进行模型训练的时候，我们需要将数据按照一些方法表示出来，最常见的方法就是将数据点本身代表数据，如下图：<br><img src="https://img-blog.csdnimg.cn/20210703073427339.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>但是当数据集很大的时候，这种方法就不是很有效了（在上图这种多模型数据中的表现也不好）。在密度估计中，我们使用参数族（例如高斯分布、贝塔分布等）中的密度来表示数据。例如，我们可以找到数据集的均值和方差，然后利用高斯模型表示这些数据，我们可以认为数据集就是从这些模型中抽样出来的。<br>但是 ，在实践过程中，这些模型有时候不能很好地表示这些数据，也就是说这些模型的具有<strong>有限的建模能力</strong>（have limited modeling capabilities）。所以，我们介绍一种更通用的数据模型：<strong>混合模型</strong>（mixture model）。<br>混合模型可以将一个概率分布用K种不同的基本分布的<strong>凸组合</strong>（convex combination）表示：</p><script type="math/tex; mode=display">p(x)=\sum^K_{k=1}\pi_k p_k(x)\\   0\le \pi_k\le 1,\quad \sum^K_{k=1}\pi_k=1</script><p>其中，$p_k$为基本分布（高斯分布，贝塔分布等），$\pi_k$为<strong>混合权重</strong>（mixture weight），混合权重能够保证混合模型的概率密度分布的总积分仍旧是1。通过将基本模型进行混合，混合模型能够很好地表示一些多模型数据（如上图中数据）。<br>在本章中，主要讨论<strong>高斯混合模型</strong>（Gaussian mixture models (GMMs)）。我们的目标是通过最大化模型参数的似然来训练GMMs。这里我们不会项之前那样找到一个闭型（closed-form，解析解）的极大似然估计的解，而是找到一组相互独立的联立方程（dependent simultaneous equation），解这些方程只能通过迭代的方式。</p><h1 id="高斯混合模型（Gaussian-Mixture-Model）"><a href="#高斯混合模型（Gaussian-Mixture-Model）" class="headerlink" title="高斯混合模型（Gaussian Mixture Model）"></a>高斯混合模型（Gaussian Mixture Model）</h1><p>高斯混合模型是一个密度模型，在这个模型中，我们将K个高斯分布组合起来，即$\mathcal N(x|\mu_k,\Sigma_k)$:</p><script type="math/tex; mode=display">p(x|\theta)= \sum^K_{k=1}\pi_k\mathcal N(x|\mu_k.\Sigma_k)\\0\le \pi_k\le1,\sum^K_{k=1}\pi_k=1</script><p>其中，$\theta := {\mu_k.\Sigma_k,\pi_k:k = 1,\cdots,K}$为模型参数的整合参数。这个混合模型能够在数据处理的时候提供更高的灵活度。下图是一个高斯混合模型的曲线图：<br><img src="https://img-blog.csdnimg.cn/20210703084107518.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210703084128185.png" alt="在这里插入图片描述"></p><h1 id="利用极大似然估计进行参数学习（Parameter-Learning-via-Maximum-Likelihood）"><a href="#利用极大似然估计进行参数学习（Parameter-Learning-via-Maximum-Likelihood）" class="headerlink" title="利用极大似然估计进行参数学习（Parameter Learning via Maximum Likelihood）"></a>利用极大似然估计进行参数学习（Parameter Learning via Maximum Likelihood）</h1><p>假设有一个从未知分布$p(x)$中抽样得到的独立同分布的数据集$\mathcal X={x_1,\cdots,x_N}$，我们的目标是找到能够更好地表示这个未知分布的GMM的参数$\theta$。这里我们使用极大似然估计求解参数，由于数据都是独立同分布的，所以我们可以对似然函数进行分解：</p><script type="math/tex; mode=display">p(\mathcal X|\theta)=\prod^N_{n=1}p(x_n|\theta),\quad p(x_n|\theta)=\sum^K_{k=1}\pi_k\mathcal N(x_n|\mu_k,\Sigma_k)</script><p>其中的每一个$p(x_n|\theta)$都是一个高斯混合密度，所以对应的自然对数似然为：</p><script type="math/tex; mode=display">\log p(\mathcal X|\theta)=\sum^N_{n=1}\log p(x_n|\theta)=\underbrace{\sum^N_{n=1}\log \sum^K_{k=1}\pi_k \mathcal N(x_n|\mu_k,\Sigma_k)}_{=: \mathcal L}</script><p>我们的目标就是找到能够最小化这个自然对数似然的模型参数，我们原先讨论极大似然估计的解的时候，是将这个似然函数对参数球偏导，然后将这个偏导设为0，求解出参数的值。但是在这里我们不能求出一个闭型的解。</p><blockquote><p><strong>不能求出闭型的解的原因？</strong><br>原先我们讨论的是单个高斯分布，所以对应的自然对数概率分布为：</p><script type="math/tex; mode=display">\log \mathcal N(x|\mu,\Sigma)=-\frac D2\log (2\pi)-\frac 12\log\det(\Sigma)-\frac 12(x-\mu)^\top \Sigma^{-1}(x-\mu)</script><p>这个简单的形式能够让我们找到闭型的解，但是对于混合函数，其中的log后面的K次求和没有办法拆开，所以也就很难找到闭型的解了。</p></blockquote><p>所以我们使用迭代的方式找到模型的最佳参数$\theta_{ML}$,这个方法就是<strong>期望最大化算法</strong>（expectation maximization (EM) algorithm），EM的关键思想就是更新其中一个参数，而保持其他参数固定。<br>由于函数的局部最优解出的梯度都是0，所以可以将$\mathcal L$对参数分别进行求偏导，然后将这些偏导设为0，这是最优化自然对数似然的必要条件：</p><script type="math/tex; mode=display">\begin{aligned}&\frac{\partial \mathcal{L}}{\partial \boldsymbol{\mu}_{k}}=\mathbf{0}^{\top} \Longleftrightarrow \sum_{n=1}^{N} \frac{\partial \log p\left(\boldsymbol{x}_{n} \mid \boldsymbol{\theta}\right)}{\partial \boldsymbol{\mu}_{k}}=\mathbf{0}^{\top}, \\&\frac{\partial \mathcal{L}}{\partial \boldsymbol{\Sigma}_{k}}=\mathbf{0} \Longleftrightarrow \sum_{n=1}^{N} \frac{\partial \log p\left(\boldsymbol{x}_{n} \mid \boldsymbol{\theta}\right)}{\partial \boldsymbol{\Sigma}_{k}}=\mathbf{0} \\&\frac{\partial \mathcal{L}}{\partial \pi_{k}}=0 \Longleftrightarrow \sum_{n=1}^{N} \frac{\partial \log p\left(\boldsymbol{x}_{n} \mid \boldsymbol{\theta}\right)}{\partial \pi_{k}}=0\end{aligned}</script><p>由于$\mathcal L$是一个复合函数，所以可以使用链式法则进行求偏导：</p><script type="math/tex; mode=display">\frac{\partial\log p(x_n|\theta)}{\partial \theta}= \frac {1}{p(x_n|\theta)}\frac{\partial p(x_n|\theta)}{\partial \theta}</script><p>其中：$p(x<em>n|\theta)=\sum^K</em>{k=1}\pi_k\mathcal N(x_n|\mu_k,\Sigma_k)$；  $\theta := {\mu_k.\Sigma_k,\pi_k:k = 1,\cdots,K}$.接下来主要介绍求解上述的几个等式。但是在求解之前我们介绍一个很重要的概念：<strong>责任</strong>（responsibilities）</p><h2 id="责任（Responsibilities）"><a href="#责任（Responsibilities）" class="headerlink" title="责任（Responsibilities）"></a>责任（Responsibilities）</h2><p>我们将第k个混合成分对第n个数据点的<strong>责任</strong>定义为：</p><script type="math/tex; mode=display">r_{nk}:=\frac{\pi_k\mathcal N(x_n|\mu_k,\Sigma_k)}{\sum^K_{j=1}\pi_j\mathcal N(x_n|\mu_j,\Sigma_j)}</script><p>这个第k个混合成分（Mixture Component）对数据点$x<em>n$的责任$r</em>{nk}$与下面的似然函数呈比例：</p><script type="math/tex; mode=display">p(x_n|\pi_k,\mu_k,\Sigma_k)= \pi_k\mathcal N(x_n|\mu_k,\Sigma_k)</script><p>如果一个数据点与其中的混合成分越匹配（模型对应的部分能够很好地表示数据），那么相对应的责任也就越大。一个数据点的责任可以使用一个规范化的概率向量表示：$r<em>n:=[r</em>{n1,\cdots,r<em>{nK}}]^\top\in \mathbb R^K, \sum_kr</em>{nk}=1,r_{nk}\ge0$。（？ $r_n$满足Boltzmann/Gibbs分布）<br>可以将责任理解为数据点在各个混合成分中，所占有的比例，也就是各混合成分得到这个数据点的概率（一个不是很准确的理解就是，这个数据在各个混合成分之间的分量）.<br>接下来确定模型参数的时候，都需要依赖于这个责任，我们先改变一个参数，而保持其他的参数不变，然后计算对应的责任，之后不断将这两个步骤进行迭代，知道得到一个局部最优解。其实，正是二者与责任的高度相关性，使得最终的解没有一个闭型的解。</p><h2 id="更新均值（Updating-the-Means）"><a href="#更新均值（Updating-the-Means）" class="headerlink" title="更新均值（Updating the Means）"></a>更新均值（Updating the Means）</h2><p><strong>定理</strong>：（GMM均值的更新）GMM的均值参数$\mu_k,k=1,\cdots,K$为：</p><script type="math/tex; mode=display">\mu^{new}_{k}=\frac{\sum^N_{n=1}r_{nk}x_n}{\sum^N_{n=1}r_{nk}}</script><p>由于更新一个混合模型的参数需要所有混合模型的均值、协方差矩阵和混合权重，所以我们不能一次性为所有的$\mu_k$找到闭型的解。（我们需要同步更新？像梯度下降法那样？）<br><strong>证明</strong>：这里对定理进行简单的证明，但是不做详细说明<br>结合之前的结论，我们求解似然函数对均值的偏导：</p><script type="math/tex; mode=display">\begin{aligned}\frac{\partial p\left(\boldsymbol{x}_{n} \mid \boldsymbol{\theta}\right)}{\partial \boldsymbol{\mu}_{k}} &=\sum_{j=1}^{K} \pi_{j} \frac{\partial \mathcal{N}\left(\boldsymbol{x}_{n} \mid \boldsymbol{\mu}_{j}, \boldsymbol{\Sigma}_{j}\right)}{\partial \boldsymbol{\mu}_{k}}=\pi_{k} \frac{\partial \mathcal{N}\left(\boldsymbol{x}_{n} \mid \boldsymbol{\mu}_{k}, \boldsymbol{\Sigma}_{k}\right)}{\partial \boldsymbol{\mu}_{k}} \\&=\pi_{k}\left(\boldsymbol{x}_{n}-\boldsymbol{\mu}_{k}\right)^{\top} \boldsymbol{\Sigma}_{k}^{-1} \mathcal{N}\left(\boldsymbol{x}_{n} \mid \boldsymbol{\mu}_{k}, \boldsymbol{\Sigma}_{k}\right)\end{aligned}</script><p>将上述的似然函数带入到对代价函数的偏导中：</p><script type="math/tex; mode=display">\begin{aligned}\frac{\partial \mathcal{L}}{\partial \boldsymbol{\mu}_{k}} &=\sum_{n=1}^{N} \frac{\partial \log p\left(\boldsymbol{x}_{n} \mid \boldsymbol{\theta}\right)}{\partial \boldsymbol{\mu}_{k}}=\sum_{n=1}^{N} \frac{1}{p\left(x_{n} \mid \theta\right)} \frac{\partial p\left(\boldsymbol{x}_{n} \mid \boldsymbol{\theta}\right)}{\partial \boldsymbol{\mu}_{k}} \\&=\sum_{n=1}^{N}\left(\boldsymbol{x}_{n}-\boldsymbol{\mu}_{k}\right)^{\top} \boldsymbol{\Sigma}_{k}^{-1}\underbrace{\frac{\pi_{k} \mathcal{N}\left(\boldsymbol{x}_{n} \mid \boldsymbol{\mu}_{k}, \boldsymbol{\Sigma}_{k}\right)}{\sum_{j=1}^{K} \pi_{j} \mathcal{N}\left(x_{n} \mid \mu_{j}, \Sigma_{j}\right)}}_{=r_{nk}} = \sum^N_{n=1}  r_{n k}\left(\boldsymbol{x}_{n}-\boldsymbol{\mu}_{k}\right)^{\top} \boldsymbol{\Sigma}_{k}^{-1}\end{aligned}</script><p>为了求解$\mu^{new}_{k}$,需要求解$\frac{\partial \mathcal L(\mu^{new_k})}{\partial \mu_k}=0^\top$:</p><script type="math/tex; mode=display">\sum^N_{n=1}r_{nk}x_n=\sum^N_{n=1}r_{nk}\mu_k^{new}\Leftrightarrow \mu^{new}_k=\frac{1}{N_k}\sum^N_{n=1}r_{nk}x_n</script><p>我们定义第k个混合元素对数据集的总贡献为：</p><script type="math/tex; mode=display">N_k:=\sum^N_{n=1}r_{nk}</script><p>得证。</p><p>这个均值更新的过程还可以使用<strong>重要性加权的蒙特卡罗估计</strong>（importance-weighted Monte Carlo estimate）理解。数据点$x<em>n$的重要性权值就是所有混合成份对数据点的责任(存疑where the importance weights of data point $x_n$ are the responsibilities $r</em>{nk}$ of the kth cluster for $x_n, k = 1, \cdots K$.)。<br>可以将均值的更新过程想象成均值点被各个数据点拉着移动，而每个数据点对均值点的力的大小就是责任，如下图：</p><p><div align="center"><br><img src="https://img-blog.csdnimg.cn/20210704073859551.png"></div></p><p>也可以将更新过程理解为在下式分布中的所有的数据点的期望值：</p><script type="math/tex; mode=display">r_k:=[r_{1k},\cdots,r_{Nk}]^\top/N_k</script><p>这也是一个规范化的概率向量：</p><script type="math/tex; mode=display">\mu_k\leftarrow \mathbb E_{rk}[\mathcal X]</script><h2 id="更新协方差（Updating-the-Covariances）"><a href="#更新协方差（Updating-the-Covariances）" class="headerlink" title="更新协方差（Updating the Covariances）"></a>更新协方差（Updating the Covariances）</h2><p><strong>定理</strong>（更新GMM的协方差）更新协方差参数：</p><script type="math/tex; mode=display">\Sigma^{new}_k=\frac1N_k\sum^N_{n=1}r_{nk}(x_n-\mu_k)(x_n-\mu_k)^\top</script><p>证明过程（原书p356）比较麻烦，这里略过.<br>与更新均值相似，更新协方差可以理解为是中心化数据$\tilde \mathcal X_k:={x_1-\mu_k,\cdots.x_N-\mu_k}$的平方的重要性加权期望值。</p><h2 id="更新混合权重（Updating-the-Mixture-Weights）"><a href="#更新混合权重（Updating-the-Mixture-Weights）" class="headerlink" title="更新混合权重（Updating the Mixture Weights）"></a>更新混合权重（Updating the Mixture Weights）</h2><p><strong>定理</strong>：</p><script type="math/tex; mode=display">\pi^{new}_k=\frac{N_k}{N},\quad k=1,\cdots,K</script><p>其中，N是数据点的个数。<br><strong>证明</strong>：<br>略（原书p358）</p><p>关于权重的更新即为第k个混合成分全部责任与数据点的个数的比。因为$N=\sum<em>kN_k$也可以理解为所有混合成分的的所有责任的总和，所以$\pi_k$可以理解为第k个混合成分对于整个数据集的相对重要性。<br>由于$N_k=\sum^N</em>{i=1}r_{nk}$的更新等式依赖于责任，所以更新这个式子需要依赖于其他的所有参数：$\pi_j,\mu_j,\Sigma_j,j=1,\cdots,K$</p><h2 id="实例（Example）"><a href="#实例（Example）" class="headerlink" title="实例（Example）"></a>实例（Example）</h2><p><strong>初始化</strong><br>假设一个一维数据集$\mathcal X={-3,-2.5,-1,0,2,4,5}$,现在有一个由三个成分混合而成的GMM，混合成份分别为：</p><script type="math/tex; mode=display">\begin{aligned}p_1(x) &= \mathcal N(x|-4,1) \\p_2(x) &= \mathcal N(x|0,0.2)\\ p_3(x) &= \mathcal N(x|8,3)\end{aligned}</script><p>初始化权重为：$\pi_1=\pi_2=\pi_3=\frac13$,在坐标中表示为：<br><img src="https://img-blog.csdnimg.cn/20210704094533886.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>责任</strong>：</p><script type="math/tex; mode=display">\left[\begin{array}{ccc}1.0 & 0.0 & 0.0 \\1.0 & 0.0 & 0.0 \\0.057 & 0.943 & 0.0 \\0.001 & 0.999 & 0.0 \\0.0 & 0.066 & 0.934 \\0.0 & 0.0 & 1.0 \\0.0 & 0.0 & 1.0\end{array}\right] \in \mathbb{R}^{N \times K} .</script><p>第n行告诉我们对$x_n$的所有混合成分的责任，责任之和为1，列告诉我们一个混合成分对所有的数据集的责任的情况。<br><strong>更新均值</strong><br>经计算，均值的变化为：</p><script type="math/tex; mode=display">\begin{aligned}& \mu_1:-4\rightarrow -2.7\\& \mu_2:0\rightarrow -0.4\\& \mu_3:8\rightarrow3.7\end{aligned}</script><p>变化形式表现在图中为：；<br><img src="https://img-blog.csdnimg.cn/2021070410003747.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>可以看到第一个混合成分和第三个混合成分朝着数据域的方向上移动。<br><strong>协方差更新</strong></p><script type="math/tex; mode=display">\begin{aligned}&\sigma^2_1:1\rightarrow 0.14\\& \sigma^2_2:0.2\rightarrow0.44\\& \sigma_3^2:3\rightarrow1.53\end{aligned}</script><p>这些变化表现在图像上为：<br><img src="https://img-blog.csdnimg.cn/20210704101115459.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>权重参数更新</strong></p><script type="math/tex; mode=display">\pi_1:\frac13\rightarrow0.29\\\pi_2:\frac13\rightarrow0.29\\\pi_3:\frac 13\rightarrow0.42</script><p><img src="https://img-blog.csdnimg.cn/20210704101407676.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>注意到图像中的各个峰值发生了变化。经过这一系列的更新，得到的模型能够更好地拟合给定的数据。</p><h1 id="期望最大化算法（EM-Algorithm）"><a href="#期望最大化算法（EM-Algorithm）" class="headerlink" title="期望最大化算法（EM Algorithm）"></a>期望最大化算法（EM Algorithm）</h1><p>由于之前提到的参数更新的过程依赖于责任$r_{nk}$,而责任又与这些参数呈复杂的依赖关系，使得上述的更新过程没有一个闭型的解。接下来我们介绍一种解决参数的问题的迭代方案——<strong>期望最大化算法</strong>（The expectation maximization algorithm）。这其实是一种参数学习的泛化迭代方案。在高斯混合模中，我们选择参数的初始化值$\mu_k,\Sigma_k,\pi_k$,不断改变这些参数，直到他们收敛于<strong>期望步</strong>（E-step）和<strong>极大步</strong>（M-step）之间的不断迭代。</p><blockquote><p><strong>期望步</strong>：评估责任$r_{nk}$(属于k混合成分的的数据点n的后验概率)<br><strong>极大步</strong>：用更新后的责任重新估计参数</p></blockquote><p>由于EM算法每进行一次迭代都会导致似然函数值上升，所以可以利用这个特性直接检查自然对数似然或者参数。一个实例化的步骤如下：<br><img src="https://img-blog.csdnimg.cn/20210704103243446.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>迭代过程中的变化情况：<br><img src="https://img-blog.csdnimg.cn/20210704103427675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>现在我们对开篇的时候的数据进行处理：<br><img src="https://img-blog.csdnimg.cn/20210704104233277.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我们观察迭代的最终结果：<br><img src="https://img-blog.csdnimg.cn/20210704104324146.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt><br>由上图可以直到，左边的一簇数据可以由一个单一的成分进行表示，但是右边的一簇数据是由两个成分混合儿而成的，所以这两个混合成分对这一簇的数据的责任在0.5左右。</p><h1 id="潜变量角度（Latent-Variable-Perspective）"><a href="#潜变量角度（Latent-Variable-Perspective）" class="headerlink" title="潜变量角度（Latent-Variable Perspective）"></a>潜变量角度（Latent-Variable Perspective）</h1><p>我们使用一个离散型的潜变量模型来理解GMM。这样就可以将原先提到的责任的概念解释为后验概率分布了。其实，这个潜变量就是用来描述一个数据点在各个混合成分中的占有情况（表现为概率）。</p><h2 id="生成过程和概率模型（Generative-Process-and-Probabilistic-Model）"><a href="#生成过程和概率模型（Generative-Process-and-Probabilistic-Model）" class="headerlink" title="生成过程和概率模型（Generative Process and Probabilistic Model）"></a>生成过程和概率模型（Generative Process and Probabilistic Model）</h2><p>想要得到对应的概率模型，我们需要弄清楚数据的生成过程。<br>假设一个混合模型由K个成分组成，而且每一个数据只能够由唯一的一个混合成分生成，这里我们引入一个定义域由0，1组成的随机变量$z_k\in{0,1}$,这个随机变量表示第k个混合成份是否生成了该模型。所以：</p><script type="math/tex; mode=display">p(x|z_k=1)=\mathcal N(x|\mu_k,\Sigma_k)</script><p>其中，$z:=[z_1,\cdots,z_K]^\top$,其中包含$K-1$个0和$1$个1.例如，$z=[z_1,z_2z,_3]^\top=[0,1,0]^\top$表示该数据是由第二个混合元素生成的。<br><img src="https://img-blog.csdnimg.cn/20210704171437698.png" alt="在这里插入图片描述"><br>在实际过程中，$z_k$可能是未知的，也就是可能是由不同的高斯模型混合按照不同的比例混合而成的。所以假设一个关于潜变量的先验分布：</p><script type="math/tex; mode=display">p(z)=\pi=[\pi_1,\cdots,\pi_K]^\top,\sum^K_{k=1}\pi_k=1</script><p>其中，$\pi_k=p(z_k=1)$表示该数据点由第k个成分生成的概率（类比为混合比例）。<br>潜变量的建模过程实际上对应着数据的生成过程，下面是单个数据的生成过程：</p><p><div align="center"><br><img src="https://img-blog.csdnimg.cn/20210705070333595.png"></div></p><p>生成关系为：</p><script type="math/tex; mode=display">z_{(i)}\sim p(z)\\x^{(i)}\sim p(x|z^{(i)}=1)</script><p>这种数据的采样依赖于图模型中的父节点的采样，这种采样称为<strong>原始采样</strong>(Ancestral Sampling)<br>通常一个概率模型是由数据和潜变量的联合分布定义的，结合前面的知识，我们可以得到所有K个成分的联合分布：</p><script type="math/tex; mode=display">p(x,z_k=1)=p(x|z_k=1)p(z_k=1)=\pi_k\mathcal N(x|\mu_k,\Sigma_k)</script><p>对于所有的$k=1,\cdots ,K$:</p><script type="math/tex; mode=display">p(\boldsymbol{x}, \boldsymbol{z})=\left[\begin{array}{c}p\left(\boldsymbol{x}, z_{1}=1\right) \\\vdots \\p\left(\boldsymbol{x}, z_{K}=1\right)\end{array}\right]=\left[\begin{array}{c}\pi_{1} \mathcal{N}\left(\boldsymbol{x} \mid \boldsymbol{\mu}_{1}, \boldsymbol{\Sigma}_{1}\right) \\\vdots \\\pi_{K} \mathcal{N}\left(\boldsymbol{x} \mid \boldsymbol{\mu}_{K}, \boldsymbol{\Sigma}_{K}\right)\end{array}\right]</script><h2 id="似然（Likelihood）"><a href="#似然（Likelihood）" class="headerlink" title="似然（Likelihood）"></a>似然（Likelihood）</h2><p>想要得到似然函数$p(x|\theta)$,我们需要将潜变量消去，由于我们原先定义的潜变量是离散型的，所以只需要连加就可以将潜变量消掉：</p><script type="math/tex; mode=display">p(z|\theta)=\sum_zp(x|\theta,z)p(z|\theta), \quad \theta:=\{\mu_k,\Sigma_k,\pi_k:k=1,\dots,K\}</script><p>采样的图模型为：(N个样本点)</p><p><div align="center"><br><img src="https://img-blog.csdnimg.cn/20210705072428252.png"></div></p><p>结合之前的知识，我们可以得到：</p><script type="math/tex; mode=display">p(x|\theta)=\sum^K_{k=1}\pi_k\mathcal N(x|\mu_k,\Sigma_k)</script><p>所以对于给定的数据集$\mathcal X$的似然函数为：</p><script type="math/tex; mode=display">p(\mathcal X|\theta)=\prod^N_{n=1}p(x_n|\theta)=\prod^N_{n=1}\sum^K_{k=1}\pi_k\mathcal N(x_n|\mu_k,\Sigma_k)</script><p>这个与原先的概率模型一致</p><h2 id="后验分布（Posterior-Distribution）"><a href="#后验分布（Posterior-Distribution）" class="headerlink" title="后验分布（Posterior Distribution）"></a>后验分布（Posterior Distribution）</h2><p>根据贝叶斯公式，我们得到潜变量的后验分布：</p><script type="math/tex; mode=display">p(z_k=1|x)=\frac{p(z_k)p(x|z_k=1)}{p(x)}</script><p>将之前的结论带入：</p><script type="math/tex; mode=display">p(z_k|x)=\frac{p(z_k)p(x|z_k)}{\sum^K_{j=1}p(z_j)p(x|z_j)}=\frac{\pi_k\mathcal N(x|\mu_k,\Sigma_k)}{\sum^K_{j=1}\pi_j\mathcal N(x|\mu_j,\Sigma_j)}</script><p>可以发现，这就是我们之前提到的<strong>责任</strong></p><h2 id="拓展到整个数据集（Extension-to-a-Full-Dataset）"><a href="#拓展到整个数据集（Extension-to-a-Full-Dataset）" class="headerlink" title="拓展到整个数据集（Extension to a Full Dataset）"></a>拓展到整个数据集（Extension to a Full Dataset）</h2><p>我们原先讨论的是单个数据，现在考虑一个数据集$\mathcal X:={x_1,\cdots,x_N}$每一个数据点都有自己的潜变量:</p><script type="math/tex; mode=display">z_n=[z_{n1},\cdots,z_{nK}]^\top\in\mathbb R^K</script><p>由于所有的数据都是独立同分布的，所以可以将条件分布分解为连积的形式：</p><script type="math/tex; mode=display">p(x_1,\cdots,x_N|z_1,\cdots,z_N)=\prod^N_{n=1}p(x_n|z_n)</script><p>后验分布：</p><script type="math/tex; mode=display">\begin{aligned}p\left(z_{n k}=1 \mid \boldsymbol{x}_{n}\right) &=\frac{p\left(\boldsymbol{x}_{n} \mid z_{n k}=1\right) p\left(z_{n k}=1\right)}{\sum_{j=1}^{K} p\left(\boldsymbol{x}_{n} \mid z_{n j}=1\right) p\left(z_{n j}=1\right)} \\&=\frac{\pi_{k} \mathcal{N}\left(\boldsymbol{x}_{n} \mid \boldsymbol{\mu}_{k}, \boldsymbol{\Sigma}_{k}\right)}{\sum_{j=1}^{K} \pi_{j} \mathcal{N}\left(\boldsymbol{x}_{n} \mid \boldsymbol{\mu}_{j}, \boldsymbol{\Sigma}_{j}\right)}=r_{n k}\end{aligned}</script><p>这还是第k个混合元素的责任。</p><h2 id="期望最大化算法重新回顾（EM-Algorithm-Revisited）"><a href="#期望最大化算法重新回顾（EM-Algorithm-Revisited）" class="headerlink" title="期望最大化算法重新回顾（EM Algorithm Revisited）"></a>期望最大化算法重新回顾（EM Algorithm Revisited）</h2><p>EM算法是一种用于求解极大似然估计的迭代算法，可以从潜变量的角度推导得来。对于一个给定的模型参数$\theta^{(t)}$,在期望步时，计算自然对数似然的期望：</p><script type="math/tex; mode=display">Q(\theta|\theta^{(t)})=\mathbb E_{z|x,\theta^{(t)}}[\log p(x,z|\theta)]=\int \log p(x,z|\theta)p(z|x,\theta^{(t)})dz</script><p>之后的极大步算则一个最大化上式的参数用于更新。但是EM算法并不一定会收敛于极大似然估计的解，有时候会收敛于局部最优解。可以采用不同的初始化值，这样可以减少得到局部最优解的风险。</p><h1 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h1><p><strong>核密度估计</strong>（Kernel Density Estimation）:<br>核密度估计是一种非参数密度估计，其实我们熟悉的直方图就是一种非参数估计，其中直方图的间距不合适可能会导致过拟合或者欠拟合。对于一个数据集，核密度估计的分布为：</p><script type="math/tex; mode=display">p(x)=\frac{1}{Nh}\sum^N_{n=1}k(\frac{x-x_n}{h})</script><p>其中，k为<strong>核函数</strong>（Kernel Function），就是一个非负且积分值为1的函数。$h&gt;0$是一个<strong>光滑参数</strong>（smoothing/bandwidth parameter）这个与直方图的面元（直方图的柱子的宽度，bin size）大小类似。核函数通常的选择就是高斯函数或者时均匀分布函数。同时，核密度估计与直方图密切相关，但是核密度估计是光滑的，直方图不是。<br><img src="https://img-blog.csdnimg.cn/20210705100827193.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;@[toc]&lt;br&gt;在本章节中，我们会介绍关于密度估计的几个主要的概念，例如：&lt;strong&gt;期望最大化算法&lt;/strong&gt;（expectation maximization (EM) algorithm）。&lt;br&gt;当我们使用数据进行模型训练的时候，我们需要将数据按照一些</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MML ch 10 主成分分析降维（Dimensionality Reduction with Principal Component Analysis）</title>
    <link href="http://example.com/2021/07/02/MML-ch-10-%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90%E9%99%8D%E7%BB%B4%EF%BC%88Dimensionality-Reduction-with-Principal-Component-Analysis%EF%BC%89/"/>
    <id>http://example.com/2021/07/02/MML-ch-10-%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90%E9%99%8D%E7%BB%B4%EF%BC%88Dimensionality-Reduction-with-Principal-Component-Analysis%EF%BC%89/</id>
    <published>2021-07-02T04:38:46.000Z</published>
    <updated>2023-03-09T10:49:04.460Z</updated>
    
    <content type="html"><![CDATA[<p>@[toc]<br>对于一些高维的数据，分析难度大，而且想要对这些数据进行可视化几乎是不可能的，并且想要存储这些数据的代价也是及其昂贵的，所以我们想要找到一种能够将数据的维度降低的方法。这其中，<strong>主成分分析法</strong>（principal component analysis (PCA)）是最常用的方法之一。</p><h1 id="问题设置（Problem-Setting）"><a href="#问题设置（Problem-Setting）" class="headerlink" title="问题设置（Problem Setting）"></a>问题设置（Problem Setting）</h1><p>在PCA中，我们希望能够找到一个一个向量的投影向量$\tilde x_n$,与原向量尽可能相近。<br>对于一个独立均匀分布的数据集$\mathcal X={x_1,\cdots,x_N}, x_n\in \mathbb R^D$,它的均值为0， 对应的数据方差矩阵为：</p><script type="math/tex; mode=display">S=\frac 1N \sum^N_{n=1}x_nx^\top</script><p>压缩之后表示为：</p><script type="math/tex; mode=display">z_n = B^\top x_n\in \mathbb R^M</script><p>其中，B为投影矩阵，定义为：</p><script type="math/tex; mode=display">B := [b_1,\cdots,b_M]\in \mathbb R^{D\times M}</script><p>假设$b_i$为正交规范基，则$b_i^\top b_j=0, i\ne j;b_i^\top b_i=1$.我们希望找到一个M维的子空间$U\subseteq \mathbb R^D,\operatorname{dim}(U)=M &lt; D$,向其中的投影的向量与原先的向量最相似，因为压缩造成的损失最小。我们将投影的数据表示为$\tilde x_n\in U$,对应的坐标为$z_n$(基向量为$b_1,\cdots,b_M$)<br><img src="https://img-blog.csdnimg.cn/20210615092117707.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>PCA的目标是最小化平方重构误差（the Squared Reconstruction Error）$| x_n-\tilde x_n|^2$.<br>从数据压缩的角度来看，我们先是将源数据压缩到一个更低维度的空间中，对应下图的$z$，然后将压缩的信息复原，对应下图中的$\tilde x$; $z$控制着多少信息能够从$x$到$\tilde x$.在PCA中，我们考虑原始数据与低维数据之间的线性关系，所以有以下关系：<br>$z = B^\top x;\tilde x = Bz$。将PCA看成是一个数据压缩的过程，所以可以认为第一个箭头是<strong>编码器</strong>(encoder)，第二个箭头是<strong>解码器</strong>(decoder)<br><img src="https://img-blog.csdnimg.cn/20210615162848433.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p>Graphical illustration of PCA. In PCA, we find a compressed version z of original data x. The compressed data can be reconstructed into $\tilde x$, which lives in the original data space, but has an intrinsic lower-dimensional representation than $x$.</p></blockquote><h1 id="最大化方差的角度看PCA（Maximum-Variance-Perspective）"><a href="#最大化方差的角度看PCA（Maximum-Variance-Perspective）" class="headerlink" title="最大化方差的角度看PCA（Maximum Variance Perspective）"></a>最大化方差的角度看PCA（Maximum Variance Perspective）</h1><p>在下图中，我们丢弃了数据关于$x_2$的信息，这样做能够达到降维的效果，而且使得数据的损失最小化，是源数据与降维之后的数据尽可能相似。假设忽略$x_1$的信息，则得到的数据就很不相似了，也就是说这个降维操作导致了很多的信息损失。通过观察可以发现，数据在两个维度上的分散程度不一样。当数据在一个维度上越分散，说明这个维度上所包含的信息也就越多，而方差可以表示数据分散程度的大小，所以从方差的角度理解<code>PCA就是找到低维空间中数据方差最大的维度</code>。<br><img src="https://img-blog.csdnimg.cn/20210615092117707.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>为了运算方便，我们对数据进行一个<strong>均值归一化</strong>（Mean Normalization）,因为我们要研究的是方差，而对数据整体的几何运算并不会影响数据的方差</p><script type="math/tex; mode=display">\mathbb V_z[z]=\mathbb V_x[B^\top(x-\mu)]=\mathbb V_x[B^\top x - B^\top \mu]=\mathbb V_x[B^\top x]</script><p>这时候对应的低维空间的数据的均值也是0:$\mathbb E_z[z]=\mathbb E_x[\boldsymbol B^\top \boldsymbol x]=\boldsymbol B^\top \mathbb E_x[\boldsymbol x]=\boldsymbol 0$。</p><blockquote><p>$\boldsymbol B$是投影矩阵，将源数据投影到主成分上，从而实现降维。</p><p><img src="https://img-blog.csdnimg.cn/20210615165552555.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="最大方差的方向（Direction-with-Maximal-Variance）"><a href="#最大方差的方向（Direction-with-Maximal-Variance）" class="headerlink" title="最大方差的方向（Direction with Maximal Variance）"></a>最大方差的方向（Direction with Maximal Variance）</h2><p>为了找到数据在低维空间中的最大的方差，我们先找到一个向量$b_1\in \mathbb R^D$,数据在这个向量上的投影的方差最大,也就是要最大化$z\in \mathbb R^M$中第一个坐标$z_1$的方差：</p><script type="math/tex; mode=display">V_1 := \mathbb V[z_1]=\frac1N\sum^N_{n=1}z^2_{1n}</script><p>我们将$z_{1n}$表示为数据($x_n\in \mathbb R^D$)在低维空间（$z_n\in \mathbb R^M$）的第一个坐标。$z_n$的第一个成分为：</p><script type="math/tex; mode=display">z_{1n}=b_1^\top x_n</script><p>这是$x_n$在$b_1$张成的一维子空间中的正交投影，将上面二式联立：</p><script type="math/tex; mode=display">V_1=\frac1N\sum^N_{n=1}(b_1^\top x_n)^2=\frac 1N \sum^N_{n=1}b_1^\top x_n x_n^\top b_1=b_1^\top\begin{pmatrix}\frac 1N\sum\limits^N_{n=1}x_nx_n^\top \end{pmatrix}b_1=b_1^\top Sb_1</script><p>其中， S为数据协方差矩阵。由上式可知，正交基（$b_i$）会对最终的方差的结果产生影响,所以这里要求这些基向量为规范正交基（$|b_1|^2=1$），这样问题就转换成一个约束问题：</p><script type="math/tex; mode=display">\max_{b_1}b_1^\top Sb_1,\quad s.t.\ \|b_1\|^2 = 1</script><p>利用拉格朗日方法：</p><script type="math/tex; mode=display">\mathfrak L(b_1,\lambda)=b_1^\top Sb_1+\lambda_1(1-b_1^\top b_1)</script><p>对上式分别求偏导：</p><script type="math/tex; mode=display">\frac{\partial \mathfrak L}{\partial b_1}=2b_1^\top S-2\lambda_1 b_1^\top,\quad \frac{\partial \mathfrak L}{\partial \lambda_1}=1-b_1^\top b_1</script><p>令偏微分的结果为0：</p><script type="math/tex; mode=display">\begin{aligned}Sb_1&=\lambda_1 b_1 \\b_1^\top b_1 &= 1\end{aligned}</script><p>由上式可以知道，$\lambda_1$是方差S的一个特征值，$b_1$是一个特征向量，利用这个式子，我们可以将问题转化成：</p><script type="math/tex; mode=display">V_1=b_1^\top Sb_1 = \lambda_1b_1^\top b_1 = \lambda_1</script><p>所以我们需要找到一个特征值最大的特征向量,这样源数据在投影之后的方差最大，这个特征向量称为<strong>主成分</strong>（Principal Component）我们可以得到投影数据点：</p><script type="math/tex; mode=display">\tilde x_n=b_1 z_{1n}=b_1b_1^\top x_n\in \mathbb R^D</script><p>注意这里的投影点上的数据是高纬度空间中的数据，但是实际上存储的时候只需要用低纬度的空间信息就可以表示了。</p><h2 id="M维子空间下的最大方差（M-dimensional-Subspace-with-Maximal-Variance）"><a href="#M维子空间下的最大方差（M-dimensional-Subspace-with-Maximal-Variance）" class="headerlink" title="M维子空间下的最大方差（M-dimensional Subspace with Maximal Variance）"></a>M维子空间下的最大方差（M-dimensional Subspace with Maximal Variance）</h2><p>$m-1$个主成分对应的是$S$的$m-1$个特征向量，这些特征向量对应着最大的$m-1$个特征值。由于$S = \frac1N \sum\limits_{n=1}^Nx_nx_n^\top$,所以S是一个对称矩阵，所以由谱定理可以得知，这些特征向量能够形成$\mathbb R^D$空间下的$m-1$维子空间的正交规范特征基。想要找到这些正交基，可以使用向量减法：</p><script type="math/tex; mode=display">\tilde X := X=\sum^{m-1}_{i=1}b_ib_i^\top X=X-B_{m-1}X</script><p>其中，数据点的列向量$X=[x<em>1,\cdots,x_N]\in \mathbb R^{D\times N}$(这里使用列向量是为了计算方便),投影矩阵$B</em>{m-1}:=\sum\limits^{m-1}_{i=1}b_ib_i^\top$<br>所以想要找到第m个主成分，我们需要最大化方差;</p><script type="math/tex; mode=display">V_m=\mathbb V[z_m]=\frac1N \sum^N_{n=1}(b^\top_m \hat x_n)^2=b^\top_m \hat Sb_m,\quad s.t. \ \|b_m\|^2=1</script><p>其中，$\hat S$表示为数据集在正交变换之后（$\hat\mathcal X$）的方差.<br>假设我们已经知道了$\hat S$的特征向量，设$b_i$为S的特征向量：</p><script type="math/tex; mode=display">\begin{aligned}\hat Sb_i &= \frac 1N \hat X \hat X^\top b_i=\frac1N(X-B_{m-1}X)(X-B_{m-1}X)^\top b_i\\&=(S-SB_{m-1}-B_{m-1}S+B_{m-1}SB_{m-1})b_i,\end{aligned}\quad (*)</script><p>由于$b_i$都是这个子空间下的规范正交基（ONB），所以：</p></blockquote><script type="math/tex; mode=display">\boldsymbol B_{m-1}\boldsymbol b_i=\left\{\begin{aligned}\boldsymbol b_i, \quad i< m \\ \boldsymbol0, \quad i\ge m\end{aligned}\right.\\</script><p>当$i&lt;m$时，说明$b_i$是子空间下的一个正交基，由于是规范正交基，所以与其他基向量的乘积为0，与自身相乘仍为自身。当$i\ge m$时，说明$b_i$不是子空间下的正交基，这时候，这$b_i$与其他的所有的正交基相互垂直，所以与他们的乘积也就为0.<br>由上面的关系可以得到：</p><script type="math/tex; mode=display">\hat S b_i=(S-B_{m-1}S)b_i=Sb_i=\lambda_ib_i\\\hat Sb_m = Sb_m=\lambda_mb_m</script><p>这可以知道正交投影之后的向量的特征向量的是一致的。<br>当$i&lt;m$时，$B_{m-1}$的关系式带入到（*）中：</p><script type="math/tex; mode=display">\hat{\boldsymbol{S}} b_{i}=\left(\boldsymbol{S}-\boldsymbol{S} \boldsymbol{B}_{m-1}-\boldsymbol{B}_{m-1} \boldsymbol{S}+\boldsymbol{B}_{m-1} \boldsymbol{S} \boldsymbol{B}_{m-1}\right) \boldsymbol{b}_{i}=\mathbf{0}=0 \boldsymbol{b}_{i}</script><p>所以可以发现$b<em>1,\cdots,b</em>{m-1}$张成于$\hat S$的零空间<br>由$\hat Sb_m = Sb_m=\lambda_mb_m$和$b^\top_mb_m=1$,可以得到数据在m维上的正交投影的方差为：</p><script type="math/tex; mode=display">V_m=b_m^\top S b_m=\lambda_mb^\top_mb_m=\lambda_m</script><p>由上式可以看到数据方差于对应的特征值之间的关系。<br><img src="https://img-blog.csdnimg.cn/20210616085600867.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>由上表可知，在200 个特征值中，仅有少数的特征值是显著大于0的，所以方差只存在于少数的主成分之中。<br>为了评估PCA造成的信息损失，我们有以下标准：<br>M个主成分所能包含的最大方差：</p><script type="math/tex; mode=display">V_m=\sum^M_{m=1}\lambda_m</script><p>其中的$\lambda_m$是前M个最大的特征值<br>因数据压缩导致的方差损失：</p><script type="math/tex; mode=display">J_m:=\sum^D_{j=M+1}\lambda_i=V_D-V_m</script><p>或者使用相对方差捕获率（the relative variance captured）$\frac{V_M}{V_D}$，或者是压缩方差损失$1-\frac{V_M}{V_D}$</p><h1 id="投影的角度看待PCA-Projection-Perspective"><a href="#投影的角度看待PCA-Projection-Perspective" class="headerlink" title="投影的角度看待PCA(Projection Perspective)"></a>投影的角度看待PCA(Projection Perspective)</h1><p>我们可以将PCA理解为找到一个子空间，源数据在上面的正交投影与源数据最为相似，也就是正交投影的数据与源数据的欧几里得距离最小。<br><img src="https://img-blog.csdnimg.cn/20210616213629430.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="问题设置和问题目标（Setting-and-Objective）"><a href="#问题设置和问题目标（Setting-and-Objective）" class="headerlink" title="问题设置和问题目标（Setting and Objective）"></a>问题设置和问题目标（Setting and Objective）</h2><p>假设一个规范正交基$B=(b_1,\cdots,b_D)\in \mathbb R^D$,所以在这个空间中的所有的向量都可以看成是这些正交基的线性组合：</p><script type="math/tex; mode=display">x=\sum_{d=1}^D\zeta_db_d=\sum^M_{m=1}\zeta_mb_m+\sum^D_{j=M+1}\zeta_jb_j,\quad \zeta \in \mathbb R</script><p>在一个低维的子空间中($U\subseteq \mathbb R^D, \operatorname{dim}(U)=M$):</p><script type="math/tex; mode=display">\tilde x = \sum^M_{m=1}z_mb_m\in U\in\mathbb R^D</script><p>我们的目标就是最小化两种向量之间的欧几里得距离$|x-\tilde x|$,这个最小化的向量所在的空间被称为<strong>主子空间</strong>（Principal Subspace）,标记为：</p><script type="math/tex; mode=display">\tilde x_n:=\sum^M_{m=1}z_{mn}b_m=Bz_n\in \mathbb R^D,\quad z_n := [z_{1n},\cdots,z_{Mn}]^\top\in \mathbb R^M</script><p>$z_n$为投影矩阵的坐标。<br>描述PCA之后的损失的量度为<strong>重构误差</strong>（Reconstruction Error）:</p><script type="math/tex; mode=display">J_m:=\frac 1N \sum^N_{n=1}\| x_n-\tilde x_n\|^2</script><h2 id="找到最优化坐标（Finding-Optimal-Coordinates）"><a href="#找到最优化坐标（Finding-Optimal-Coordinates）" class="headerlink" title="找到最优化坐标（Finding Optimal Coordinates）"></a>找到最优化坐标（Finding Optimal Coordinates）</h2><p>想要找到最优化的坐标，需要找到原向量在基向量空间中的正交映射.如下图所示，我的目标也可以理解为找到最小的$\tilde x-x$,由图中可以知道最小的时候是向量正交投影到基向量上的时候。<br><img src="https://img-blog.csdnimg.cn/20210624160905266.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>接下来我们从数学的角度理解这个结论。<br>对于一个规范正交基$b=(b<em>1,\cdots,b_M),U \subseteq \mathbb R^D$,假设最优的坐标为$z</em>{1n},\cdots,z_{Mn}$,对应投影$\tilde x_n,n=1,\cdots,N$。为了找到各个维度（坐标）下的最佳的坐标，我们需要将目标函数对坐标进行求导</p><script type="math/tex; mode=display">\begin{aligned}&\frac {\partial J_M}{\partial z_{in}}=\frac{\partial J_M}{\partial\tilde x_n}\frac{\partial \tilde x_n}{\partial z_{in}} \\ &\frac{\partial J_M}{\partial \tilde x_n}-\frac{2}{N}(x_n-\tilde x_n)^\top\in \mathbb R^{1\times D}\end {aligned}</script><p>因为：</p><script type="math/tex; mode=display">\tilde x_n:=\sum^M_{m=1}z_{mn}b_m=Bz_n\in \mathbb R^D</script><p>所以有：</p><script type="math/tex; mode=display">\frac {\partial J_M}{\partial z_{in}}=-\frac 2N(x_n-\tilde x_n)^\top b_i=-\frac 2N (x_n-\sum_{m=1}^Mz_{mn}b_m)^\top b_i\overset{b_ib_j=0}{=}-\frac{2}{N}(x_n^\top b_i-z_{in}b^\top_ib_i)=-\frac2N(x_n^\top b_i-z_{in})</script><p>将上面的偏微分设为0，可以得到最优情况下的坐标：</p><script type="math/tex; mode=display">z_{in}=x_n^\top b_i=b_i^\top x_n,\quad i=1\cdots M,n=1,\cdots ,N</script><p>这就说明最优坐标就是将原始数据做正交投影到目标向量空间中的坐标。</p><p><img src="https://img-blog.csdnimg.cn/2021062417503110.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p>现在我们稍微复习一下向基向量的正交投影：<br>一个向量向正交基$(b_1,\cdots,b_D)\in \mathbb R^D$进行正交投影</p><script type="math/tex; mode=display">\tilde x=b_j(\underbrace{ b_j^\top b_j}_{ONB,=I})^{-1}b_j^\top x=b_j b_j^\top x \in \mathbb R^D</script><p>其中，$b_j^\top x$是正交投影之后的坐标</p></blockquote><p>在新的坐标系下，虽然$\tilde x\in \mathbb R^D$，但是我们只需要用前M个坐标，因为在这个坐标系下剩下的坐标都是0.</p><h2 id="找到主子空间的基向量（Finding-the-Basis-of-the-Principal-Subspace）"><a href="#找到主子空间的基向量（Finding-the-Basis-of-the-Principal-Subspace）" class="headerlink" title="找到主子空间的基向量（Finding the Basis of the Principal Subspace）"></a>找到主子空间的基向量（Finding the Basis of the Principal Subspace）</h2><p>为了找到主子空间的基向量，我们需要对原先的代价函数的形式进行一些改造。：</p><script type="math/tex; mode=display">\tilde x _n = \sum_{m=1}^Mz_{mn}b_m=\sum _{m=1}^M(x_n^\top b_m)b_m</script><p>根据点积的对称性：</p><script type="math/tex; mode=display">\tilde x _n=(\sum^M_{m=1}b_mb_m^\top)x_n</script><blockquote><p>补充（原因）</p></blockquote><p>原先提到原始数据可以用基向量线性组合表示，所以(这里可以理解为将原向量分解为投影向量和位移向量)</p><script type="math/tex; mode=display">\begin{aligned}\boldsymbol{x}_{n} &=\sum_{d=1}^{D} z_{d n} \boldsymbol{b}_{d} \stackrel{(10.32)}{=} \sum_{d=1}^{D}\left(\boldsymbol{x}_{n}^{\top} \boldsymbol{b}_{d}\right) \boldsymbol{b}_{d}=\left(\sum_{d=1}^{D} b_{d} \boldsymbol{b}_{d}^{\top}\right) \boldsymbol{x}_{n} \\&=\left(\sum_{m=1}^{M} \boldsymbol{b}_{m} \boldsymbol{b}_{m}^{\top}\right) \boldsymbol{x}_{n}+\left(\sum_{j=M+1}^{D} \boldsymbol{b}_{j} \boldsymbol{b}_{j}^{\top}\right) \boldsymbol{x}_{n}\end{aligned}</script><p>所以位移向量（displacement vector）为：</p><script type="math/tex; mode=display">\begin{aligned} x_n-\tilde x_n&=(\sum_{j=M+1}^Db_jb_j^\top)x_n\\&=\sum^D_{j=M+1}(x_n^\top b_j)b_j\end{aligned}</script><p>其中，$\sum_{j=M+1}^Db_jb_j^\top$为投影矩阵。<br><img src="https://img-blog.csdnimg.cn/20210625194024145.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>这里可以看出，位移矩阵是在垂直于主子空间的空间中。</p><blockquote><p><strong>低秩近似</strong>（(Low-Rank Approximation）：<br>由之前的讨论得知，投影矩阵为:</p><script type="math/tex; mode=display">\sum_{m=1}^Mb_mb^\top_m=BB^\top</script><p>由此，原先的平均平方重构误差可以写为：</p><script type="math/tex; mode=display">\frac 1N\sum^N_{n=1}\|x_n-\tilde x\|^2=\frac 1N \sum_{n=1}^N\|x_n-BB^\top x_n\|^2=\frac 1N \sum^N_{n=1}\|(I-BB^\top)x_n\|^2</script><p>所以可以将PCA理解为找到与单位矩阵最接近的$BB^\top$的$M$秩逼近。</p></blockquote><p>现在我们能够重构损失函数：</p><script type="math/tex; mode=display">J_M=\frac 1N\sum^N_{n=1}\|x_n-\tilde x_n\|^2=\frac 1N \sum^N_{n=1}\Vert\sum_{j=M+1}^D(b_j^\top x_n)b_j\|^2</script><p>我们将平方范数展开，并结合$b_j$是来源于规范正交基，可以得到下式：</p><script type="math/tex; mode=display">J_M=\frac 1N \sum^N_{n=1}\sum^D_{j=M+1}(b_j^\top x_n)^2=\frac {1}{N}\sum^N_{n=1}\sum_{j=M+1}^D b_j^\top x_nb^\top_j x_n=\frac 1N \sum^N_{n=1}\sum^D_{j=M+1}b_j^\top x_n x_n^\top b_j</script><blockquote><p>补充推导过程</p></blockquote><p>由于点乘的对称性，我们可以知道$b^\top_jx_n=x^\top_nb_j$,带入上式：</p><script type="math/tex; mode=display">\begin{aligned}J_{M} &=\sum_{j=M+1}^{D} \boldsymbol{b}_{j}^{\top} \underbrace{\left(\frac{1}{N} \sum_{n=1}^{N} \boldsymbol{x}_{n} \boldsymbol{x}_{n}^{\top}\right)}_{=: \boldsymbol{S}} \boldsymbol{b}_{j}=\sum_{j=M+1}^{D} \boldsymbol{b}_{j}^{\top} \boldsymbol{S} \boldsymbol{b}_{j} \\&=\sum_{j=M+1}^{D} \operatorname{tr}\left(\boldsymbol{b}_{j}^{\top} \boldsymbol{S} \boldsymbol{b}_{j}\right)=\sum_{j=M+1}^{D} \operatorname{tr}\left(\boldsymbol{S} \boldsymbol{b}_{j} \boldsymbol{b}_{j}^{\top}\right)=\operatorname{tr}(\underbrace{\left(\sum_{j=M+1}^{D} \boldsymbol{b}_{j} \boldsymbol{b}_{j}^{\top}\right)}_{\text {projection matrix }} \boldsymbol{S})\end{aligned}</script><p>由上可知，损失函数可以被理解为源数据在主子空间的正交补上的方差。这也对应这主成分分析是在最小化我们忽略的维度上的误差。等价的来说也就是我们需要保留方差最大的那几个维度。所以当我们投影到M维主子空间的时候，所对应的重构误差为：</p><script type="math/tex; mode=display">J_M=\sum^D_{j=M+1}\lambda_j</script><blockquote><p>为什么是这个？</p></blockquote><p>其中的$\lambda$数据协方差的奇异值。所以想要最小化这个重构误差，就需要选择$D-M$个最小的特征值，这些特征值对应的是主子空间的正交基的特征向量。这也就是说，主子空间所对应的特征向量的特征值是协方差矩阵中的最大的M个特征值。</p><blockquote><p>这一节有很多问题，待补充。。。</p></blockquote><h1 id="特征向量计算以及低秩逼近（Eigenvector-Computation-and-Low-Rank-Approximations）"><a href="#特征向量计算以及低秩逼近（Eigenvector-Computation-and-Low-Rank-Approximations）" class="headerlink" title="特征向量计算以及低秩逼近（Eigenvector Computation and Low-Rank Approximations）"></a>特征向量计算以及低秩逼近（Eigenvector Computation and Low-Rank Approximations）</h1><p>为了计算方差矩阵的特征值，我们可以采用特征值分解或者是奇异值分解，前者可以直接计算出矩阵的特征值和特征向量。而使用SVD的可行性，是因为方差矩阵是对称并且能够分解为$XX^\top$所以，方差矩阵的特征值就是$X$的奇异值的平方。</p><script type="math/tex; mode=display">S=\frac 1N \sum^N_{n=1}x_nx_n^\top  = \frac 1N XX^\top,\quad X=[x_1,\cdots , x_N]\in \mathbb R^{D\times N}</script><p>矩阵$X$对应的SVD为：</p><script type="math/tex; mode=display">\underbrace X_{D\times N}=\underbrace U_{D\times D}\underbrace\Sigma_{D\times N}\underbrace {V^\top}_{N\times N}</script><p>其中U和V都是正交矩阵，$\Sigma$为对角矩阵，主对角线上的元素为奇异值$\sigma_{ii}\ge 0$.将这个式子带入到方差矩阵中：</p><script type="math/tex; mode=display">S=\frac 1N XX^\top=\frac 1NU\Sigma\underbrace{V^\top V}_{=I_N}\Sigma^\top U^\top=\frac 1N U\Sigma\Sigma^\top U^\top</script><blockquote><p>SVD分解之后的两端的矩阵是酉矩阵（$V^\top=V^{-1}$）：<br>Specifically, the singular value decomposition of an m\times n complex matrix M is a factorization of the form $\mathbf {U\Sigma V^{*}}$, where U is an $m\times m$ complex unitary matrix, $\mathbf{\Sigma}$ is an $m\times n$ rectangular diagonal matrix with non-negative real numbers on the diagonal, and V is an $n\times n$ complex <u>unitary matrix</u>(酉矩阵).</p></blockquote><p>所以U的列向量是$XX^\top$的特征向量，也是方差矩阵的特征向量。其中特征值与奇异值的关系为：</p><script type="math/tex; mode=display">\lambda_d=\frac{\sigma^2_d}{N}</script><p>S的特征值和X的奇异值的关系对应的是原先的最大方差视角和奇异值分解之间的关系。</p><blockquote><p>如何理解？</p></blockquote><h2 id="用低秩逼近的PCA-PCA-Using-Low-Rank-Matrix-Approximations"><a href="#用低秩逼近的PCA-PCA-Using-Low-Rank-Matrix-Approximations" class="headerlink" title="用低秩逼近的PCA(PCA Using Low-Rank Matrix Approximations)"></a>用低秩逼近的PCA(PCA Using Low-Rank Matrix Approximations)</h2><p>PCA需要找出前N个最大特征值所对应的特征向量，实现这个目标可以采用低秩逼近的方式。</p><blockquote><p>Eckart-Young theorem:就是评估低秩逼近之后造成的损失<br><img src="https://img-blog.csdnimg.cn/20210626104053635.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></blockquote><p>由Eckart-Young theorem：</p><script type="math/tex; mode=display">\tilde X_M:=\operatorname{argmin}_{\operatorname{rk(A)\le M}}\|X-A\|_2\in \mathbb R^{D\times N}</script><p>所以，对应的低秩逼近就是找出前M大的奇异值：</p><script type="math/tex; mode=display">\tilde X_M=\underbrace {U_M}_{D\times M}\underbrace{\Sigma_M}_{M\times M}\underbrace{V_M^\top}_{M\times N}\in \mathbb R^{D\times N}</script><p>其中，$\Sigma$包含X的前M个最大的奇异值。</p><h2 id="实际方面（Practical-Aspects）"><a href="#实际方面（Practical-Aspects）" class="headerlink" title="实际方面（Practical Aspects）"></a>实际方面（Practical Aspects）</h2><p>我们可以直接采用特征多项式求解出特征值和特征多项式，但是由Abel-Ruffini theorem，五阶或者五阶以上的多项式方程没有几何解。所以在解决大于$4\times 4$的矩阵的时候会遇到这个问题。<br>由于在主成分分析中，我们会只需要前M大的特征向量和特征多项式，所以计算出所有的特征向量和特征值然后再舍弃一些特征值是很没有必要的。在一些极端的情况下，我们只需要第一个特征向量，这时候使用<strong>幂迭代</strong>（Power iteration）效率会非常高。</p><blockquote><p><strong>幂迭代</strong><br>首先先随机选取一个不在S的零空间的向量$x_0$,然后按照下式进行迭代：</p><script type="math/tex; mode=display">x_{k+1}=\frac{Sx_k}{\|Sx_k\|},\quad k=0,1,\cdots</script><p>这个式子总是有$|x_k|=1$,最终这个式子会收敛于最大的特征值所对应的特征向量。当S为不可逆的时候，应该保证$x_0 \ne 0$<br><br>In mathematics, power iteration (also known as the power method) is an eigenvalue algorithm: given a diagonalizable matrix A, the algorithm will produce a number \lambda , which is the greatest (in absolute value) eigenvalue of A, and a nonzero vector v, which is a corresponding eigenvector of $\lambda$ , that is, $Av=\lambda v$. The algorithm is also known as the Von Mises iteration.<br><br><br>Power iteration is a very simple algorithm, but it may converge slowly. The most time-consuming operation of the algorithm is the multiplication of matrix A by a vector, so it is effective for a very large sparse matrix with appropriate implementation.</p></blockquote><h1 id="高维PCA（PCA-in-High-Dimensions）"><a href="#高维PCA（PCA-in-High-Dimensions）" class="headerlink" title="高维PCA（PCA in High Dimensions）"></a>高维PCA（PCA in High Dimensions）</h1><p>想要对数据使用PCA，需要求解出数据的协方差矩阵，对于一个D维的数据，如果使用特征多项式（$|\lambda E-A|=0$）的时间复杂度为$O(D^3)$.所以需要找到一种更加高效的方法解决这个问题。<br>下面我们讨论数据的个数远小于数据维度的情况，即$N\ll D$<br>假设一组中心化（均值为0）的数据集$x_1,\cdots,x_N,\ \ x_n\in\mathbb R^{D\times D}$，对应的协方差矩阵为：</p><script type="math/tex; mode=display">S=\frac 1N XX^\top\in\mathbb R^{D\times D},\quad X=[x_1,\cdots,x_N]\in\mathbb R^{D\times N}</script><p>由于我们假设$N\ll D$所以数据点的数量远小于数据的维度，也就是说数据的秩为N，则有$D-N+1$个特征值为0，接下来我们探究将D维协方差矩阵转换成N维，且对应的特征值都是正数。所以有特征向量的等式：</p><script type="math/tex; mode=display">Sb_m=\lambda_m b_m,\quad m=1,\cdots M</script><p>其中b是主子空间的基向量，现在将S的定义带入：</p><script type="math/tex; mode=display">Sb_m =\frac 1N XX^\top b_m=\lambda_m b_m</script><p>现在等式两边同时乘以$X^\top\in \mathbb R^{N\times D}$</p><script type="math/tex; mode=display">\frac 1N \underbrace {X^\top X}_{N\times N}\underbrace{X^\top b_m}_{=:c_m}=\lambda_m X^\top b_m\Leftrightarrow\frac 1N X^\top Xc_m=\lambda_mc_m</script><p>所以可以发现协方差矩阵的特征值为$\lambda_m$对应的特征向量为$c_m$</p><blockquote><p>印证原先提到的：$XX^\top$的非零特征值等于$X^\top X$的非零特征值</p></blockquote><p>现在我们得到了映射之后的特征值和特征向量，现在我们需要找到源数据的特征值和特征向量。现在对上式两边同时左乘$X$：</p><script type="math/tex; mode=display">\underbrace{\frac 1NXX^\top}_SXc_m=\lambda_mXc_m</script><p>这样我们得到了源数据(X是酉矩阵？)，这仍旧是S的特征向量。</p><h1 id="PCA在实践中的关键步骤-Key-Steps-of-PCA-in-Practice"><a href="#PCA在实践中的关键步骤-Key-Steps-of-PCA-in-Practice" class="headerlink" title="PCA在实践中的关键步骤(Key Steps of PCA in Practice)"></a>PCA在实践中的关键步骤(Key Steps of PCA in Practice)</h1><ol><li><strong>减去数据均值</strong>（Key Steps of PCA in Practice）</li><li>这一步将所有数据减去数据的均值，使得处理后的数据的均值为0，这一步不是必须的，但是减小遇到数值问题的风险。</li><li><strong>规范化</strong>（Standardization）：</li><li>将数据除以数据的标准偏差$\sigma_d$</li><li><strong>协方差矩阵的特征值分解</strong>（Eigendecomposition of the covariance matrix）</li><li>由于协方差是对称的，根据谱定理，我们能够找到特征向量的规范正交基</li><li><strong>投影</strong>（Projection）</li><li>将数据点$x_*\in \mathbb R^D$投影到主子空间中：</li><li><script type="math/tex; mode=display">x^{(d)}\leftarrow\frac{x_*^{(d)}-\mu_d}{\sigma_d}\quad d = 1,\cdots,D</script>10.其中，$x^{(d)}<em>*$代表的是$x</em>*$的第d个成分，所以对应的投影为：<script type="math/tex; mode=display">\tilde x_*=BB^\top x_*</script>对应的坐标为：<script type="math/tex; mode=display">z_*=B^\top x_*</script>其中B由数据协方差矩阵最大的几个特征值所对应的特征向量组成。注意PCA返回的是坐标，而不是投影向量。<br>要得到原始数据的投影，我们需要将投影之后的数据进行“反规范化”：<script type="math/tex; mode=display">\tilde x^{(d)}_*\leftarrow \tilde x^{(d)}_*\sigma_d+\mu_d,\quad d= 1,\cdots, D</script><img src="https://img-blog.csdnimg.cn/20210629075518708.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><blockquote><p><strong>MNIST数字：重构</strong>（MNIST Digits: Reconstruction）<br>由下图可知，当主成分为一的时候，图像就是一个可以识别的数字了，随着主成分的增加，图像变得清晰了些<br><img src="https://img-blog.csdnimg.cn/20210629075830290.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>下图中展示了图像信息损失和主成分数量之间的关系：</p><script type="math/tex; mode=display">\frac 1N \sum^N_{n=1}\|x_n-\tilde x_n\|^2=\sum^D_{i=M+1}\lambda_i</script><p><img src="https://img-blog.csdnimg.cn/20210629080209101.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这也印证之前提到的，大多数的信息只存在于少量的主成分之中。</p></blockquote></li></ol><h1 id="用潜变量看待PCA-Latent-Variable-Perspective"><a href="#用潜变量看待PCA-Latent-Variable-Perspective" class="headerlink" title="用潜变量看待PCA(Latent Variable Perspective)"></a>用潜变量看待PCA(Latent Variable Perspective)</h1><p>原先讨论PCA的时候没有使用概率方面的理论，这样能够帮助我们避开一些由概率论引起的数学上的困难，但是用概率论的能够帮助我们更好地理解PCA，而且在处理带有噪音的数据的时候，概率论中的似然函数提供了分析方式。</p><blockquote><p>Observational Noise. The error between the true value in a system and its observed value due to imprecision in measurement. Also called Measurement Noise.<br><strong>观测噪音</strong>（Observation Noise）实际上就是我们所说的测量误差，由仪器等因素导致的于真实值的偏差。</p></blockquote><p>通过介绍连续的潜变量$z\in \mathbb R^M$, 我们能够将PCA用<strong>概率潜变量模型</strong>(probabilistic latent-variable model)来描述，这被称为<strong>概率主成分分析</strong>（probabilistic PCA ， PPCA）</p><h2 id="生成过程及概率模型（Generative-Process-and-Probabilistic-Model）"><a href="#生成过程及概率模型（Generative-Process-and-Probabilistic-Model）" class="headerlink" title="生成过程及概率模型（Generative Process and Probabilistic Model）"></a>生成过程及概率模型（Generative Process and Probabilistic Model）</h2><p>我们考虑一个线性降维，对于一个连续随机变量$z\in \mathbb R^M$以及一个标准正态先验$p(z)=\mathcal N(0, I)$, 潜变量以及观测值之间的关系为：</p><script type="math/tex; mode=display">x=Bz+\mu+\epsilon\in \mathbb R^D</script><p>其中$\epsilon \sim \mathcal N(0,\sigma^2I)$为高斯观测噪音，而$B\in \mathbb R^{D\times M},\quad \mu \in \mathbb R^D$是潜变量到观测变量的线性/仿射映射。所以，潜变量于观测值之间的联系方式为：</p><script type="math/tex; mode=display">p(x|z,B,\mu,\sigma^2)=\mathcal N(x|Bz+\mu, \sigma^2I)</script><p>整体来说，PPCA的生成过程为：</p><script type="math/tex; mode=display">\begin{aligned} z&\sim \mathcal N(z|0,I)\\ x_n|z_n&\sim\mathcal N(x|Bz_n+\mu,\sigma^2I)\end{aligned}</script><p>想要得到获得这些参数，需要一些典型数据，想要得到这样的数据可以使用<strong>祖先抽样</strong>（Ancestral sampling）</p><blockquote><p><img src="https://img-blog.csdnimg.cn/20210701100758830.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Ancestral sampling 实际上就是通过采样解决条件概率问题。</p></blockquote><p>在这里，先采样得到潜变量$z$,然后再从潜变量中采样得到预测数据。于是，上面的生辰过程可以写成:</p><script type="math/tex; mode=display">p(x,z|B,\mu,\sigma^2)=p(x|z,B,\mu,\sigma^2)p(x)</script><p>对应的图模型：</p><p><div align="center"><br><img src="https://img-blog.csdnimg.cn/20210701101258115.png"></div></p><blockquote><p>Graphical model for probabilistic PCA. The observations $x_n$ explicitly depend on corresponding latent variables $z_n \sim \mathcal N(0,I)$ The model parameters $B;\mu$ and the likelihood parameter $\sigma$ are shared across the dataset.<br><img src="https://img-blog.csdnimg.cn/20210701101627104.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>可以将潜变量用于生成新的数据（<u>补充理解</u>）<br><img src="https://img-blog.csdnimg.cn/20210701101827655.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="似然以及联合分布（Likelihood-and-Joint-Distribution）"><a href="#似然以及联合分布（Likelihood-and-Joint-Distribution）" class="headerlink" title="似然以及联合分布（Likelihood and Joint Distribution）"></a>似然以及联合分布（Likelihood and Joint Distribution）</h2><p>由原先的概率论部分，我们知道可以采用积分将潜变量消掉：</p><script type="math/tex; mode=display">p(x|B,\mu,\sigma^2)=\int p(x|z,B,\mu,\sigma^2)p(z)dz=\int \mathcal N(x|Bz+\mu,\sigma^2I)\mathcal N(z|0,I)dz</script><p>还是由原先的知识，我们可以知道这个积分的结果是高斯分布，其均值及方差为：</p><script type="math/tex; mode=display">\begin{aligned}\mathbb E_x[x]&=\mathbb E_z[Bz+\mu]+\mathbb E_\epsilon[\epsilon]=\mu \\ \mathbb V[x]&=\mathbb V_z[Bz+\mu]+\mathbb V_\epsilon[\epsilon]=\mathbb V_z[Bz]+\sigma^2I\\&=B\mathbb V_z[z]B^\top+\sigma^2I=BB^\top+\sigma^2I\end{aligned}</script><p>先前我们不适用条件概率分布的原因是极大似然估计以及极大似然后验估计需要的似然函数可以是数据以及模型参数的函数，但是不能是潜变量的函数，这里是用积分消去潜变量之后才用的。<br><br><strong>潜变量以及模型参数的关系</strong>（需要补充）</p></blockquote><p>因为潜变量$z$的线性/仿射变换$x=Bz$是联合高斯分布，现在已知一些边际概率分布:$p(z)=\mathcal N(z|0,I);p(x)=\mathcal N(x|\mu,BB^\top +\sigma^2I)$.所以对应<strong>交叉协方差</strong>（cross-covariance）为：</p><script type="math/tex; mode=display">\operatorname{Cov}[x,z]=\operatorname{Cov}_z[Bz+\mu]=B\operatorname{Cov}_z[z,z]=B</script><p>所以潜变量以及观测到的随机变量之间的联合分布为：</p><script type="math/tex; mode=display">p\left(\boldsymbol{x}, \boldsymbol{z} \mid \boldsymbol{B}, \boldsymbol{\mu}, \sigma^{2}\right)=\mathcal{N}\left(\left[\begin{array}{l}\boldsymbol{x} \\\boldsymbol{z}\end{array}\right] \mid\left[\begin{array}{l}\boldsymbol{\mu} \\\mathbf{0}\end{array}\right],\left[\begin{array}{cc}\boldsymbol{B} \boldsymbol{B}^{\top}+\sigma^{2} \boldsymbol{I} & \boldsymbol{B} \\\boldsymbol{B}^{\top} & \boldsymbol{I}\end{array}\right]\right)</script><p>其中均值向量的长度为$D+M$,协方差矩阵的大小为$(D+M)\times (D+M)$</p><h2 id="后验分布（Posterior-Distibution）"><a href="#后验分布（Posterior-Distibution）" class="headerlink" title="后验分布（Posterior Distibution）"></a>后验分布（Posterior Distibution）</h2><p>由前面提到的联合概率分布$p(x,z|B,\mu,\sigma^2)$可以求得后验分布$p(z|x)$(参数求解方式在概率论那一章有提及)</p><script type="math/tex; mode=display">\begin{aligned}p(\boldsymbol{z} \mid \boldsymbol{x}) &=\mathcal{N}(\boldsymbol{z} \mid \boldsymbol{m}, \boldsymbol{C}) \\\boldsymbol{m} &=\boldsymbol{B}^{\top}\left(\boldsymbol{B} \boldsymbol{B}^{\top}+\sigma^{2} \boldsymbol{I}\right)^{-1}(\boldsymbol{x}-\boldsymbol{\mu}) \\\boldsymbol{C} &=\boldsymbol{I}-\boldsymbol{B}^{\top}\left(\boldsymbol{B} \boldsymbol{B}^{\top}+\sigma^{2} \boldsymbol{I}\right)^{-1} \boldsymbol{B}\end{aligned}</script><p>注意后验协方差与数据无关，协方差矩阵C告诉我们<u>（？）嵌入的可信度（？p343）</u><br>我们可以利用这个后验分布得到数据对应的潜变量，然后再利用潜变量得到重构向量$\tilde x<em>*\sim p(x|z</em>*,B,\mu,\sigma^2)$.将这个过程重复多次，我们能够得到潜变量的后验分布以及其暗含的观测数据</p><h1 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h1><p>现在我们想想之前做了什么。我们使用两个角度看待PCA，一个是投影的角度（最小化重构误差），一个是最大化方差的角度，除此之外还有其他的角度。我们先将高维数据$x\in \mathbb R^D$用矩阵$B^\top$转换成用低维表示的数据$z\in \mathbb R^M$,其中B由协方差矩阵的最大的特征值所对应的特征向量组成。得到低阶矩阵之后，我们可以利用投影矩阵$BB^\top$将数据复原到源数据的维度:$x\approx\tilde x=Bz=BB^\top x\in\mathbb R^D$.<br>当然我们还将PCA看成一个<strong>线性自动编码机</strong>(Linear Auto-encoder)<br><img src="https://img-blog.csdnimg.cn/20210702083437356.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>由此可以得到重构误差：</p><script type="math/tex; mode=display">\frac 1N \sum^N_{n=1}\|x_n-\tilde x_n\|^2=\frac 1N\sum^N_{n=1}\|x_n-BB^\top x_n\|</script><p>如果我们将线性映射转换成非线性映射，我们就会得到非线性自动编码机。当编码器是神经网络的时候，这个被称为<strong>认知网络或推理网络</strong>（recognition network or inference network），编码器称为<strong>生成器</strong>(Generator)。<br>还有一种对PCA的理解涉及到<strong>信息论</strong>（information theory），就是将编码当成原始数据的压缩版本。当我们将压缩的信息还原，这并不能得到与原始一摸一样的数据，我们称这个压缩过程为有损失的。所以我们的目标就是尽可能将原始数据与压缩数据之间的相关性最大化。这种关系称为<strong>交互信息</strong>（the mutual information）。<br>在讨论PPCA的时候，我们默认模型的参数（$B,\mu$,似然参数$\sigma^2$）都是已知的，这些参数为：（我们将$D$维数据投影到$M$维子空间中）</p><script type="math/tex; mode=display">\begin{aligned}\mu_{Ml} &=\frac 1N \sum^N_{n=1}x_n\\ B_{ML}&=T(\Lambda-\sigma^2I)^{\frac 12}R\\ \sigma^2_{ML}&=\frac{1}{D-M}\sum^D_{j=M+1}\lambda_j\end{aligned}</script><p>其中，$T\in \mathbb R^{D\times M}$包含协方差矩阵的M个特征向量，$\Lambda=\operatorname{diag}(\lambda<em>1,\cdots,\lambda_M)\in \mathbb R^{M\times M}$是一个对角矩阵，包含主子空间所对应的特征向量所对应的特征值。$R\in \mathbb R^{M\times M}$是一个随意的正交矩阵。$B</em>{ML}$是极大似然的解。$\sigma_{ML}^2$是主子空间的正交补上的平均方差，可以认为是正交映射之后造成的损失。<br>当处理一个无噪音的数据的时候，也就是$\sigma \rightarrow 0$,这时候PPCA与PCA得到的结构是一致的。由于协方差矩阵是对称的，所以可以被正交化，所以存在一个矩阵T包含S的特征向量：</p><script type="math/tex; mode=display">S=T\Lambda T^{-1}</script><p>数据的协方差矩阵就是高斯似然函数（$p(x|B,\mu,\sigma^2)$）的协方差矩阵,也就是$BB^\top+\sigma^2I$。当$\sigma\rightarrow 0$时，两种PCA的数据方差相等，所以有：</p><script type="math/tex; mode=display">\operatorname{Cov}[\mathcal X]=T\Lambda T^{-1}=BB^\top\Leftrightarrow B=T\Lambda^{\frac 12}R</script><p>所以实际上，这些PCA都是在对数据的协方差矩阵进行分解。</p><blockquote><p>接触下来的内容难度较大，理解不够透彻，后续补充</p></blockquote><ol><li>iterative expectation maximization (EM) algorithm</li><li>Bayesian PCA</li><li>Markov chain Monte Carlo /variational inference.</li><li>independent component analysis </li><li>blind-source separation</li><li>deep auto-encoder</li><li>Gaussian process latent-variable model (GP-LVM)</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;@[toc]&lt;br&gt;对于一些高维的数据，分析难度大，而且想要对这些数据进行可视化几乎是不可能的，并且想要存储这些数据的代价也是及其昂贵的，所以我们想要找到一种能够将数据的维度降低的方法。这其中，&lt;strong&gt;主成分分析法&lt;/strong&gt;（principal compon</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>机器学习中的数学：线性回归Linear Regression</title>
    <link href="http://example.com/2021/06/15/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6%EF%BC%9A%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92Linear-Regression/"/>
    <id>http://example.com/2021/06/15/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6%EF%BC%9A%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92Linear-Regression/</id>
    <published>2021-06-15T01:12:40.000Z</published>
    <updated>2023-03-09T10:48:22.852Z</updated>
    
    <content type="html"><![CDATA[<p>@[toc]<br>回归的目的就是找到一个函数$f$,将输入的数据$\boldsymbol x\in \mathbb R^n$映射成$f(\boldsymbol x)\in \mathbb R$.数据的观测噪音为：$y_n=f(x_n)+\epsilon$,其中$\epsilon$是一个独立均匀分布的随机变量，描述数据噪音。</p><blockquote><p>噪音理解成预测值与观测值的偏差，准不准确？</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210527102646532.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="问题描述（Problem-Formulation）"><a href="#问题描述（Problem-Formulation）" class="headerlink" title="问题描述（Problem Formulation）"></a>问题描述（Problem Formulation）</h1><p>因为观测噪音的缘故，我们使用概率模型，并且用一个似然函数对噪音进行建模。具体来说，我们考虑以下回归问题的的似然函数：</p><script type="math/tex; mode=display">p(y|\boldsymbol x)=\mathcal N(y|f(\boldsymbol x),\sigma^2)</script><p>其中，$\boldsymbol x\in \mathbb R^n$是输入值,$y\in \mathbb R$为噪音函数值（目标）<br>$\boldsymbol x$与$y$之间的关系为：</p><script type="math/tex; mode=display">y= f(\boldsymbol x)+\epsilon</script><p>其中，$\epsilon \sim\mathcal N(0,\sigma^2)$是一个独立均匀的高斯分布。</p><blockquote><p>Our objective is to find a function that is close (similar) to <u>the unknown function $f$ </u>that generated the data and that generalizes well.</p><p>假设在线性模型的条件下：</p><script type="math/tex; mode=display">p(y|\boldsymbol x,\boldsymbol \theta)=\mathcal N(y|\boldsymbol x^\top\boldsymbol\theta,\sigma^2)\Leftrightarrow y=\boldsymbol x^\top\boldsymbol\theta+\epsilon,\quad \epsilon \sim \mathcal N(0,\sigma^2)</script><p>Why?<br><img src="https://img-blog.csdnimg.cn/20210527104841262.png" alt="在这里插入图片描述"></p></blockquote><p>这里说明一下线性模型的意思，线性代表的是输入数据的线性组合，所以对于$y=\phi^\top(\boldsymbol x)\boldsymbol\theta$,即使$\phi^\top(\boldsymbol x)$是非线性函数，这个模型也是线性模型。</p><h1 id="参数估计（Parameter-Estimation）"><a href="#参数估计（Parameter-Estimation）" class="headerlink" title="参数估计（Parameter Estimation）"></a>参数估计（Parameter Estimation）</h1><p>给定一个训练集$\mathcal D :={(x_1,y_1),\cdots,(x_N,y_N)$,包含$N$个输入$x_n\in \mathbb R^D$和观测值$y_n\in \mathbb R,n=1,\cdots, N$.<br>用概率图模型（Probabilistic graphical model）可以表示为：</p><p><div align="center"><br><img src="https://img-blog.csdnimg.cn/20210527154036716.png"> </div></p><p>又因为每一个样本又是相互独立的，所以可以将似然方程进行分解：</p><script type="math/tex; mode=display">p(\mathcal Y|\mathcal X,\boldsymbol\theta)=p(y_1,\cdots,y_N|\boldsymbol x_1,\cdots,\boldsymbol x_N,\boldsymbol\theta)=\prod^N_{n=1}p(y_n|\boldsymbol x_n,\boldsymbol\theta) = \prod^N_{n=1}\mathcal N(y_n|\boldsymbol x_n^\top\boldsymbol\theta,\sigma^2)</script><p>接下来详细介绍获取最优化参数的方法。</p><h2 id="极大似然估计（Maximum-Likelihood-Estimation）"><a href="#极大似然估计（Maximum-Likelihood-Estimation）" class="headerlink" title="极大似然估计（Maximum Likelihood Estimation）"></a>极大似然估计（Maximum Likelihood Estimation）</h2><p>我们可以通过极大似然估计得到参数：</p><script type="math/tex; mode=display">\boldsymbol \theta_{ML}=\arg \max_\theta p(\mathcal Y|\mathcal X,\boldsymbol\theta)</script><p>上面的似然概率不是参数$\theta$的分布，而是函数。极大似然估计的目的就是最大化训练数据的概率分布。<br>在实际过程中，我们常常采用似然对数转换（Log-Transformation）的方式，将问题转化成最小化负对数似然：</p><script type="math/tex; mode=display">-\log p(\mathcal Y|\mathcal X,\boldsymbol\theta)=-\log \prod_{n=1}^N p(y_n|\boldsymbol x_n,\boldsymbol\theta)=-\sum^N_{n=1}\log p(y_n|\boldsymbol x_n,\boldsymbol\theta)</script><p>这样做可以将原先的乘积转换成和，</p><blockquote><p><strong>What does this suppose means?</strong><br>More specifically, numerical underflow will be a problem when we multiply N probabilities, where N is the number of data points, since we cannot represent very small numbers, such as $10^{256}$.</p></blockquote><p>由于在线性规划中，似然概率分布满足高斯分布（噪音项$\epsilon$满足高斯分布），所以可以得到：</p><blockquote><p>?？需要补充<br>Note that:</p><script type="math/tex; mode=display">p(y|x,\theta)=\mathcal N(y|x^\top\theta,\sigma^2)=\frac{1}{\sqrt{2\pi \sigma^2}}e^{-\frac{(y-x^\top)^2}{2\sigma^2}}</script></blockquote><script type="math/tex; mode=display">\log p(y_n|\boldsymbol x_n,\boldsymbol\theta)=-\frac{1}{2\sigma^2}(y_n-\boldsymbol x_n^\top\boldsymbol\theta)^2+\operatorname {const}</script><p>于是得到损失函数：</p><script type="math/tex; mode=display">\begin{aligned}\mathcal{L}(\boldsymbol{\theta}) &:=\frac{1}{2 \sigma^{2}} \sum_{n=1}^{N}\left(y_{n}-\boldsymbol{x}_{n}^{\top} \boldsymbol{\theta}\right)^{2} \\&=\frac{1}{2 \sigma^{2}}(\boldsymbol{y}-\boldsymbol{X} \boldsymbol{\theta})^{\top}(\boldsymbol{y}-\boldsymbol{X} \boldsymbol{\theta})=\frac{1}{2 \sigma^{2}}\|\boldsymbol{y}-\boldsymbol{X} \boldsymbol{\theta}\|^{2}\end{aligned}</script><p>我们将$\boldsymbol X:=[x_1,x_2,\cdots,x_N]^\top\in \mathbb R^{N\times D}$定义为<strong>设计矩阵</strong>（Design Matrix）<br>可以通过求导求解损失函数的最小值：</p><script type="math/tex; mode=display">\begin{aligned}\frac{\mathrm{d} \mathcal{L}}{\mathrm{d} \boldsymbol{\theta}} &=\frac{\mathrm{d}}{\mathrm{d} \boldsymbol{\theta}}\left(\frac{1}{2 \sigma^{2}}(\boldsymbol{y}-\boldsymbol{X} \boldsymbol{\theta})^{\top}(\boldsymbol{y}-\boldsymbol{X} \boldsymbol{\theta})\right) \\&=\frac{1}{2 \sigma^{2}} \frac{\mathrm{d}}{\mathrm{d} \boldsymbol{\theta}}\left(\boldsymbol{y}^{\top} \boldsymbol{y}-2 \boldsymbol{y}^{\top} \boldsymbol{X} \boldsymbol{\theta}+\boldsymbol{\theta}^{\top} \boldsymbol{X}^{\top} \boldsymbol{X} \boldsymbol{\theta}\right) \\&=\frac{1}{\sigma^{2}}\left(-\boldsymbol{y}^{\top} \boldsymbol{X}+\boldsymbol{\theta}^{\top} \boldsymbol{X}^{\top} \boldsymbol{X}\right) \in \mathbb{R}^{1 \times D}\end{aligned}</script><p>（$\frac {d\boldsymbol X^\top B\boldsymbol X}{d\boldsymbol X}=(B+B^\top)\boldsymbol X$）<br>令上式等于0：</p><script type="math/tex; mode=display">\begin{aligned}\frac{\mathrm{d} \mathcal{L}}{\mathrm{d} \boldsymbol{\theta}}=\mathbf{0}^{\top} {\longrightarrow} \boldsymbol{\theta}_{\mathrm{ML}}^{\top} \boldsymbol{X}^{\top} \boldsymbol{X}=\boldsymbol{y}^{\top} \boldsymbol{X} \\ \Longleftrightarrow \boldsymbol{\theta}_{\mathrm{ML}}^{\top}=\boldsymbol{y}^{\top} \boldsymbol{X}\left(\boldsymbol{X}^{\top} \boldsymbol{X}\right)^{-1} \\ \Longleftrightarrow \boldsymbol{\theta}_{\mathrm{ML}}=\left(\boldsymbol{X}^{\top} \boldsymbol{X}\right)^{-1} \boldsymbol{X}^{\top} \boldsymbol{y} .\end{aligned}</script><p><img src="https://img-blog.csdnimg.cn/2021052906543623.png" alt="在这里插入图片描述"></p><blockquote><p>Normal equation is derived by MLE.——Ng</p><h3 id="基于特征的极大似然估计（Maximum-Likelihood-Estimation-with-Features）"><a href="#基于特征的极大似然估计（Maximum-Likelihood-Estimation-with-Features）" class="headerlink" title="基于特征的极大似然估计（Maximum Likelihood Estimation with Features）"></a>基于特征的极大似然估计（Maximum Likelihood Estimation with Features）</h3><p>当遇到更复杂的数据时，一次函数模型有时候很难很好地拟合数据，但是由于线性回归模型只是对”参数的线性”(“linear in the parameters”),所以可以在线性回归模型中对非线性模型进行拟合。这就是说我们可以先将输入值进行非线性变换之后，再放到线性模型中。<br>In Ng’s courses he said this is Linear regression with higher order features. We can alse use SVM to derive new features.</p></blockquote><script type="math/tex; mode=display">p(y|\boldsymbol x,\theta)=\mathcal N(y|\phi^\top(x)\boldsymbol\theta,\sigma^2)\Longleftrightarrow y=\phi^\top(x)\boldsymbol\theta+\epsilon=\sum^{K-1}_{k=0}\theta_k\phi_k(x)+\epsilon</script><p>其中，$\phi:\mathbb R^D\rightarrow\mathbb R^K$是一个对$x$的（非）线性变换，$\phi_k:\mathbb R^D\rightarrow\mathbb R$是特征向量的第k个分量。</p><p>一个实例：<br>一种对输入数据常用的变换如下</p><script type="math/tex; mode=display">\phi(x)=\left[\begin{array}{c}\phi_{0}(x) \\\phi_{1}(x) \\\vdots \\\phi_{K-1}(x)\end{array}\right]=\left[\begin{array}{c}1 \\x \\x^{2} \\x^{3} \\\vdots \\x^{K-1}\end{array}\right] \in \mathbb{R}^{K}</script><p>所以：</p><script type="math/tex; mode=display">f(x)=\sum\limits^{K-1}_{k=0}\theta_kx^k=\phi^\top(x)\boldsymbol\theta</script><p>现在看看参数$\theta$在线性回归模型下的极大似然估计：</p><script type="math/tex; mode=display">\Phi:=\left[\begin{array}{c}\phi^{\top}\left(x_{1}\right) \\\vdots \\\phi^{\top}\left(x_{N}\right)\end{array}\right]=\left[\begin{array}{ccc}\phi_{0}\left(x_{1}\right) & \cdots & \phi_{K-1}\left(x_{1}\right) \\\phi_{0}\left(x_{2}\right) & \cdots & \phi_{K-1}\left(x_{2}\right) \\\vdots & & \vdots \\\phi_{0}\left(x_{N}\right) & \cdots & \phi_{K-1}\left(x_{N}\right)\end{array}\right] \in \mathbb{R}^{N \times K}</script><p>where $\Phi<em>{i j}=\phi</em>{j}\left(\boldsymbol{x}<em>{i}\right)$ and $\phi</em>{j}: \mathbb{R}^{D} \rightarrow \mathbb{R}$.<br>这个矩阵被称为<strong>特征矩阵</strong>（feature matrix）或<strong>设计矩阵</strong>(design matrix)<br>有了上面这个矩阵，我们可以将线性回归模型：</p><script type="math/tex; mode=display">p(y|\boldsymbol x,\boldsymbol \theta)=\mathcal N(y|\boldsymbol x^\top\boldsymbol\theta,\sigma^2)\Leftrightarrow y=\boldsymbol x^\top\boldsymbol\theta+\epsilon,\quad \epsilon \sim \mathcal N(0,\sigma^2)</script><blockquote><p>从这个式子中可以看出，预测值的结果主要分布于均值的周围</p></blockquote><p>写成：</p><script type="math/tex; mode=display">-\log p(\mathcal Y|\mathcal X,\boldsymbol\theta)=\frac{1}{2\sigma^2}(y-\Phi\boldsymbol\theta)^\top(y-\Phi\boldsymbol\theta)+\operatorname{const}</script><p>将两式子进行比较，发现二者只是将$\phi$欢成了$\Phi$,所以直接利用模型的结论，得到$\theta$的估计值：</p><script type="math/tex; mode=display">\theta_{ML}=(\Phi^\top\Phi)^{-1}\Phi^\top y</script><blockquote><p>需要讨论$\Phi$的可逆性<br>这个是不是支持向量机中的多项式核函数？</p><script type="math/tex; mode=display">(x_1\times x_2 + r)^d</script><p>其中，r为多项式的参数，d为多项式的次数，$x_1、x_2$为观测值</p><h3 id="噪声方差（Estimating-the-Noise-Variance）"><a href="#噪声方差（Estimating-the-Noise-Variance）" class="headerlink" title="噪声方差（Estimating the Noise Variance）"></a>噪声方差（Estimating the Noise Variance）</h3><p>我们之前的讨论都是假定$\sigma^2$是已知的，但是实际上可以利用极大似然估计的方式对噪声方差进行估计，所有的步骤与之前一致：<br>将$p(\mathcal y|\mathcal x,\theta,\sigma^2)=\frac{1}{\sigma\sqrt{2\pi}}e^{-\frac{1}{2}(\frac{x-\mu}{\sigma})^2}$带入到似然函数中：</p><script type="math/tex; mode=display">\begin{array}{l}\log p\left(\mathcal{Y} \mid \mathcal{X}, \boldsymbol{\theta}, \sigma^{2}\right)=\sum\limits_{n=1}^{N} \log \mathcal{N}\left(y_{n} \mid \phi^{\top}\left(\boldsymbol{x}_{n}\right) \boldsymbol{\theta}, \sigma^{2}\right) \\=\sum\limits_{n=1}^{N}\left(-\frac{1}{2} \log (2 \pi)-\frac{1}{2} \log \sigma^{2}-\frac{1}{2 \sigma^{2}}\left(y_{n}-\phi^{\top}\left(\boldsymbol{x}_{n}\right) \boldsymbol{\theta}\right)^{2}\right) \\=-\frac{N}{2} \log \sigma^{2}-\frac{1}{2 \sigma^{2}} \underbrace{\sum_{n=1}^{N}\left(y_{n}-\boldsymbol{\phi}^{\top}\left(\boldsymbol{x}_{n}\right) \boldsymbol{\theta}\right)^{2}}_{=: s}+\text { const. }\end{array}</script><p>对$\sigma^2$求偏导：</p><script type="math/tex; mode=display">\begin{aligned}& \frac{\partial \log p\left(\mathcal{Y} \mid \mathcal{X}, \boldsymbol{\theta}, \sigma^{2}\right)}{\partial \sigma^{2}}=-\frac{N}{2 \sigma^{2}}+\frac{1}{2 \sigma^{4}} s=0 \\\Longleftrightarrow & \frac{N}{2 \sigma^{2}}=\frac{s}{2 \sigma^{4}}\end{aligned}</script></blockquote><p>所以得到$\sigma^2$的极大似然估计的结果为：</p><script type="math/tex; mode=display">\sigma^2=\frac{s}{N}=\frac{1}{N}\sum^N_{n-1}(y_n-\phi^\top(\boldsymbol x_n)\theta)^2</script><blockquote><p>the maximum likelihood estimate of the noise variance is <strong>the empirical mean of the squared distances</strong> between the noise-free function values $\phi^\top(x_n)\theta$and the corresponding noisy observations $y_n$ at input locations $x_n$.</p></blockquote><h2 id="线性回归中的过拟合（Overfitting-in-Linear-Regression）"><a href="#线性回归中的过拟合（Overfitting-in-Linear-Regression）" class="headerlink" title="线性回归中的过拟合（Overfitting in Linear Regression）"></a>线性回归中的过拟合（Overfitting in Linear Regression）</h2><p>我们可以使用均方根误差（root mean square error，RMSE）来衡量一个模型的好坏：</p><script type="math/tex; mode=display">\sqrt{\frac{1}{N}\|y-\Phi\boldsymbol\theta\|^2}=\sqrt{\frac{1}{N}\sum^N_{n=1}(y_n-\phi^\top(x_n)\boldsymbol\theta)^2}</script><p>噪声参数$\sigma^2$不是一个自由模型参数，所以没有直接加到上式，所以没有包含到上面，这样做的好处就是能够使得计算前后的量纲保持一致。<br>当多项式的次数小于训练样本数量的时候，可以得到一个唯一的极大似然估计值，当大于的时候，需要求解一个欠定方程组（有无穷多解的方程组），这样得到无穷多的估计值。<br>采用不同级别的多项式模型拟合10个数据的结果如下图：<br><img src="https://img-blog.csdnimg.cn/20210529085722190.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>各个模型的均方根误差：<br><img src="https://img-blog.csdnimg.cn/20210529085737340.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>注意一点，训练集的RMSE不会增加。</p><h2 id="极大后验估计（Maximum-A-Posteriori-Estimation）"><a href="#极大后验估计（Maximum-A-Posteriori-Estimation）" class="headerlink" title="极大后验估计（Maximum A Posteriori Estimation）"></a>极大后验估计（Maximum A Posteriori Estimation）</h2><p>当出现过拟合的时候，参数的数值会变得很大，为了解决这个问题，我们可以使用先验分布$p(\theta)$。这个先验分布标明了参数值在什么范围内是合理的。例如一个高斯先验$p(\theta)=\mathcal N(0,1)$,这个信息中暗示了参数的范围应该在$[-2,2]$之间（$\mu\pm2\sigma$）.当数据集可用的时候，我们需要去找能够最大化后验分布$p(\theta|\mathcal X,\mathcal Y)$的参数值$\theta$,这个过程称为<strong>极大后验估计</strong>（Maximum a Posteriori Estimation,MAP）,后验分布可以利用贝叶斯公式求解：</p><script type="math/tex; mode=display">p(\theta|\mathcal X,\mathcal Y)=\frac{p(\mathcal Y|\mathcal X, \theta)p(\theta)}{p(\mathcal Y|\mathcal X)}</script><blockquote><p><img src="https://img-blog.csdnimg.cn/20210606102552583.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></blockquote><p>要求出参数向量$\theta_{MAP}$,我们需要遵循与极大似然估计一致的方法，首先，先自然对数转换（log-transform）：</p><script type="math/tex; mode=display">\log p(\theta|\mathcal X,\mathcal Y)=\log p(\mathcal Y|\mathcal X,\theta)+\log p(\theta)+\operatorname{const}</script><p>其中，$\operatorname {const}$中包含独立于$\theta$的项。可以看到，后验似然估计是参数先验（在输入数据之前的对参数的认知）和依赖于数据的似然之间的折中。<br>要求的参数向量，我们要：</p><script type="math/tex; mode=display">\theta_{MAP}\in\arg \min_\theta\{-\log p(\mathcal Y|\mathcal X,\theta)-\log p(\theta)\}</script><p>将负对数后验对$\theta$进行求导：</p><script type="math/tex; mode=display">-\frac{\mathrm{d} \log p(\boldsymbol{\theta} \mid \mathcal{X}, \mathcal{Y})}{\mathrm{d} \boldsymbol{\theta}}=-\frac{\mathrm{d} \log p(\mathcal{Y} \mid \mathcal{X}, \boldsymbol{\theta})}{\mathrm{d} \theta}-\frac{\mathrm{d} \log p(\boldsymbol{\theta})}{\mathrm{d} \theta}</script><blockquote><p>第一项是之前提到的负自然对数似然的梯度：</p><script type="math/tex; mode=display">\begin{aligned}\frac{\mathrm{d} \mathcal{L}}{\mathrm{d} \theta} &=\frac{\mathrm{d}}{\mathrm{d} \theta}\left(\frac{1}{2 \sigma^{2}}(y-X \theta)^{\top}(y-X \theta)\right) \\&=\frac{1}{2 \sigma^{2}} \frac{\mathrm{d}}{\mathrm{d} \theta}\left(y^{\top} y-2 y^{\top} X \theta+\theta^{\top} \boldsymbol{X}^{\top} \boldsymbol{X} \theta\right) \\&=\frac{1}{\sigma^{2}}\left(-\boldsymbol{y}^{\top} \boldsymbol{X}+\boldsymbol{\theta}^{\top} \boldsymbol{X}^{\top} \boldsymbol{X}\right) \in \mathbb{R}^{1 \times D}\end{aligned}</script></blockquote><p>利用参数的一个（共轭）高斯先验$p(\theta)=\mathcal N(0,b^2\boldsymbol I)$:</p><script type="math/tex; mode=display">-\log p(\theta \mid \mathcal{X}, \mathcal{Y})=\frac{1}{2 \sigma^{2}}(y-\Phi \theta)^{\top}(y-\Phi \theta)+\frac{1}{2 b^{2}} \theta^{\top} \theta+\text { const }</script><blockquote><p>这里有点疑问，利用了</p><script type="math/tex; mode=display">p(y|\boldsymbol x,\theta)=\mathcal N(y|\phi^\top(x)\boldsymbol\theta,\sigma^2)\Longleftrightarrow y=\phi^\top(x)\boldsymbol\theta+\epsilon=\sum^{K-1}_{k=0}\theta_k\phi_k(x)+\epsilon</script><p>？？</p></blockquote><p>上式右边的第一个式子来源于自然对数似然，第二个式子来源于自然对数先验。所以自然对数先验对$\theta$的先验为：</p><script type="math/tex; mode=display">-\frac{d\log p(\theta|\mathcal X,\mathcal Y)}{d\theta}=\frac{1}{\sigma^2}(\theta^\top\Phi^\top\Phi-y^\top\Phi)+\frac{1}{b^2}\theta^\top</script><p>将梯度设置为0：</p><script type="math/tex; mode=display">\begin{aligned}& \frac{1}{\sigma^{2}}\left(\theta^{\top} \Phi^{\top} \Phi-y^{\top} \Phi\right)+\frac{1}{b^{2}} \theta^{\top}=0^{\top} \\\Longleftrightarrow & \theta^{\top}\left(\frac{1}{\sigma^{2}} \Phi^{\top} \Phi+\frac{1}{b^{2}} I\right)-\frac{1}{\sigma^{2}} y^{\top} \Phi=0^{\top} \\\Longleftrightarrow & \theta^{\top}\left(\Phi^{\top} \Phi+\frac{\sigma^{2}}{b^{2}} I\right)=y^{\top} \Phi \\\Longleftrightarrow & \theta^{\top}=y^{\top} \Phi\left(\Phi^{\top} \Phi+\frac{\sigma^{2}}{b^{2}} I\right)^{-1}\end{aligned}</script><p>整理得：</p><script type="math/tex; mode=display">\theta_{MAP}=(\Phi^\top\Phi+\frac{\sigma^2}{b^2}I)^{-1}\Phi^\top y</script><p>与极大似然估计的结果：$\theta_{ML}=(\Phi^\top\Phi)^{-1}\Phi^\top y$相比较，只是在逆当中多了一项$\frac{\sigma^2}{b^2}I$，这一项保证了$\Phi^\top\Phi+\frac{\sigma^2}{b^2}I$是一个对称严格正定的。也就是说这个矩阵是可逆的，而且是线性方程的唯一解。同时他也反应了<strong>正则项</strong>(regularizer)的影响的大小</p><blockquote><p>虽然先验能够让高次多项式变得更加光滑，但也是仅仅将过拟合的边界向后推移了，想要解决过拟合的问题需要其他的方法。<br><img src="https://img-blog.csdnimg.cn/20210529160218756.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="极大后验估计作为正则化"><a href="#极大后验估计作为正则化" class="headerlink" title="极大后验估计作为正则化"></a>极大后验估计作为正则化</h3><p>带正则项的最小二乘的损失函数为：</p><script type="math/tex; mode=display">\|\boldsymbol y-\boldsymbol\Phi\boldsymbol\theta\|^2+\lambda\|\boldsymbol\theta\|_2^2</script><p>这里的范数采用的是$p$-范数,当$p$的值越小，得到的结果中$\theta=0$的个数就越多。当$p=1$时，被称为<strong>最小绝对收缩和选择算子</strong>（least absolute shrinkage and selection operator，LASSO）<br><img src="https://img-blog.csdnimg.cn/20210608202819264.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></blockquote><p>上式中的正则项可以理解为极大后验估计中的<strong>高斯自然对数先验</strong>（negative log-Gaussian prior），具体来说，对于一个正态分布$p(\boldsymbol\theta)=\mathcal N(\boldsymbol0,b^2\boldsymbol I)$的高斯自然对数先验为：</p><script type="math/tex; mode=display">-\log p(\boldsymbol\theta)=\frac{1}{2b^2}\|\boldsymbol \theta\|^2_2+\operatorname{const}</script><p>这里的正则项为$\frac{1}{2b^2}$与极大后验估计的先验一致。这样看来，正则化后的最小二乘损失函数包含的项与负自然对数似然和负自然对数先验有紧密关系，所以最小化最小二乘损失函数的过程与极大后验估计一致.<br>最小化带正则项的最小二乘损失函数（regularized least-squares loss function）：</p><script type="math/tex; mode=display">\boldsymbol\theta_{RLS}=(\boldsymbol\Phi^\top\boldsymbol\Phi+\lambda \boldsymbol I)^{-1}\boldsymbol\Phi^\top \boldsymbol y</script><p>这个与极大后验估计一致，这里的正则项为$\lambda=\frac{\sigma^2}{b^2}$,其中，$\sigma^2$是噪声方差，$b^2$为（各向同性）高斯先验方差$p(\boldsymbol\theta)=\mathcal N(\boldsymbol0,b^2\boldsymbol I)$<br>至此，我们讨论的都是点估计得到$\theta^*$，以对目标函数进行优化。接下来我们讨论使用贝叶斯推断，通过获得所有合理的参数的均值得到优化结果。</p><h1 id="贝叶斯线性回归（Bayesian-Linear-Regression）"><a href="#贝叶斯线性回归（Bayesian-Linear-Regression）" class="headerlink" title="贝叶斯线性回归（Bayesian Linear Regression）"></a>贝叶斯线性回归（Bayesian Linear Regression）</h1><p>先前讨论的是采用极大似然估计和极大后验估计来估计模型的参数，极大似然估计容易出现过拟合的现象，尤其是在训练集比较小的时候。极大后验估计使用一个概率先验来解决这个问题。而贝叶斯回归不求出单一的参数，而是选择求所有合理的参数的均值。</p><h2 id="模型（Model）"><a href="#模型（Model）" class="headerlink" title="模型（Model）"></a>模型（Model）</h2><script type="math/tex; mode=display">\begin{aligned}&prior \quad p(\boldsymbol\theta)=\mathcal N(\boldsymbol m_0,\boldsymbol S_0)\\ & likelihood\quad p(y|\boldsymbol x,\boldsymbol\theta)=\mathcal (y|\phi^\top(x)\boldsymbol\theta,\sigma)\end{aligned}</script><p>对应的图模型：</p><p><div align="center"></div></p><image src="https://img-blog.csdnimg.cn/20210531102756290.png"><p>已观测变量与未观测变量的联合概率分布为：</p><script type="math/tex; mode=display">p(y,\boldsymbol\theta|x)=p(y|\theta,x)p(\boldsymbol\theta)</script><blockquote><p>推导过程</p><script type="math/tex; mode=display">p(y,\theta|x)=\frac{p(y|\theta,x)p(\theta ,x)}{p(x)}=p(y|\theta,x)\cdot p(\theta|x)</script><p>所以x与$\theta$是相互独立的？应该是$\theta$与验证数据无关</p></blockquote><h2 id="预测先验（Prior-Predictions）"><a href="#预测先验（Prior-Predictions）" class="headerlink" title="预测先验（Prior Predictions）"></a>预测先验（Prior Predictions）</h2><p>预测的最终目的不是获得模型的参数，而是获得预测值，在贝叶斯回归中，预测值是所有合理参数的预测值的均值：</p><script type="math/tex; mode=display">p(y_*|x_*)=\int p(y_*|\boldsymbol x_*,\boldsymbol\theta)p(\boldsymbol\theta)d\boldsymbol\theta=\mathbb E_\theta[p(y_*|\boldsymbol x_*,\boldsymbol\theta)]</script><blockquote><p>连续概率分布的均值，样品值乘以样品出现的概率，将他们之和加起来，得到均值</p><p>我们选取一个$\theta$的（共轭）高斯先验作为模型，于是可以知道预测结果也是高斯分布，对于一个先验分布$p(\boldsymbol\theta)=\mathcal N(\boldsymbol m_0,\boldsymbol S_0)$,对应的预测结果的分布为：</p><script type="math/tex; mode=display">p(y_*|\boldsymbol x_*)=\mathcal N(\boldsymbol\phi^\top(\boldsymbol x_*)\boldsymbol m_0,\phi^\top(\boldsymbol x_*)\boldsymbol S_0\phi(\boldsymbol x_*)+\sigma^2)</script><p>贝叶斯回归模型为：</p><script type="math/tex; mode=display">p(\theta) =\mathcal N(m_0,S_0)\\ p(y|x,\theta)=\mathcal N(y|\phi^\top\theta,\sigma^2)</script><p>x与y的对应关系为：$y^<em>=\phi^\top(x^</em>)\theta$<br>所以对应y的均值为：$\phi^\top m<em>0$<br>由$\mathbb V_Y[y]=\mathbb V_X[Ax+b]=\mathbb V_X[Ax]=A\mathbb V_X A^\top=A\Sigma A^\top$:<br>y的对应的方差为：$\phi^\top(x</em><em>)S<em>0\phi(x</em></em>)$,加上噪声项即为上式</p></blockquote><p>上式中的$\sigma^2$是由于测量误差导致的不确定分布。<br>这里预测值是高斯分布是因为高斯共轭和边际化的性质。由于高斯噪音是相互独立的，所以：</p><script type="math/tex; mode=display">\mathbb V[y_*]=\mathbb V_\boldsymbol\theta[\phi^\top(x_*)\boldsymbol\theta]+\mathbb V_\epsilon[\epsilon]</script><p>如果我们考虑无噪音函数：$f(\boldsymbol x<em>*)=\phi^\top(x</em>*)\boldsymbol\theta$</p><script type="math/tex; mode=display">p(f(x_*))=\mathcal N(\phi^\top(x_*)m_0,\phi^\top(x_*)S_0\phi(x_*))</script><p>这个式子与原先式子不同之处在于少了噪音项$\sigma^2$<br><strong>函数分布</strong>（Distribution over Functions）：<br>我们可以用一系列的参数$\theta_i$表示参数分布$p(\boldsymbol\theta)$,而每一个参数对应一个函数$f(\cdot)=\boldsymbol\theta^\top_i\phi(\cdot)$于是可以得到对应函数的分布$p(f(\cdot))$</p><blockquote><p>p305 没弄清楚<br><img src="https://img-blog.csdnimg.cn/2021053117070927.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>置信区间和置信边界</p></blockquote><h2 id="后验分布（Posterior-Distribution）"><a href="#后验分布（Posterior-Distribution）" class="headerlink" title="后验分布（Posterior Distribution）"></a>后验分布（Posterior Distribution）</h2><p>利用贝叶斯公式可以计算参数的后验分布：</p><script type="math/tex; mode=display">p(\theta|\mathcal X,\mathcal Y)=\frac{p(\mathcal Y|\mathcal X, \theta)p(\theta)}{p(\mathcal Y|\mathcal X)}</script><p>其中$\mathcal X$是训练的输入值，$\mathcal Y$是训练目标。<br>其中的边际似然（marginal likelihood/evidence）与参数无关：</p><script type="math/tex; mode=display">p(\mathcal Y|\mathcal X)=\int p(\mathcal Y|\mathcal X, \theta)p(\theta)d\theta=\mathbb E_\theta[p(\mathcal Y|\mathcal X,\theta)]</script><p>边际似然可以被看成是所有合理参数下预测值的均值。<br><strong>参数后验</strong>：</p><script type="math/tex; mode=display">\begin{aligned}p(\boldsymbol\theta|\mathcal X, \mathcal Y) & =\mathcal N(\boldsymbol\theta |\boldsymbol m_N,\boldsymbol S_N)\\ \boldsymbol S_N &=(\boldsymbol S_0^{-1}{+\sigma^{-2}}\Phi^\top\Phi)^{-1}\\\boldsymbol m_N&=\boldsymbol S_N(\boldsymbol S_0^{-1}\boldsymbol m_0+\sigma^{-2}\Phi^\top \boldsymbol y)\end{aligned}</script><p>其中的N代表的是训练集的大小。<br><strong>证明</strong>：</p><blockquote><p>证明思路类似是用两种方式将参数后验表示出来，然后将对应部分的进行对比，得到想要的参数。</p></blockquote><p>由贝叶斯公式可以得知，后验概率分布与似然概率分布和先验概率分布成比例</p><script type="math/tex; mode=display">\begin{array}{ll}\text { Posterior } & p(\boldsymbol{\theta} \mid \mathcal{X}, \mathcal{Y})=\frac{p(\mathcal{Y} \mid \mathcal{X}, \boldsymbol{\theta}) p(\boldsymbol{\theta})}{p(\mathcal{Y} \mid \mathcal{X})} \\\text { Likelihood } & p(\mathcal{Y} \mid \mathcal{X}, \boldsymbol{\theta})=\mathcal{N}\left(\boldsymbol{y} \mid \boldsymbol{\Phi} \boldsymbol{\theta}, \sigma^{2} \boldsymbol{I}\right) \\\text { Prior } & p(\boldsymbol{\theta})=\mathcal{N}\left(\boldsymbol{\theta} \mid \boldsymbol{m}_{0}, \boldsymbol{S}_{0}\right)\end{array}</script><p>现在考虑自然对数先验与自然对数似然之和：</p><script type="math/tex; mode=display">\begin{aligned}&\log \mathcal N(y|\Phi\theta,\sigma^2 I)+\log \mathcal N(\theta|m_0,S_0)\\&=-\frac{1}{2}(\sigma^{-2}(y-\Phi\theta)^\top(y-\Phi\theta)+(\theta-m_0)^\top S_0^{-1}(\theta-m_0))+\operatorname{const}\end{aligned}</script><p>其中的const包含一些独立于$\theta$的项。<br>将上式进行展开：（将式子中的二次项一次项进行整合）</p><script type="math/tex; mode=display">\begin{aligned}&-\frac{1}{2}\left(\sigma^{-2} \boldsymbol{y}^{\top} \boldsymbol{y}-2 \sigma^{-2} \boldsymbol{y}^{\top} \Phi \theta+\boldsymbol{\theta}^{\top} \sigma^{-2} \boldsymbol{\Phi}^{\top} \boldsymbol{\Phi} \boldsymbol{\theta}+\boldsymbol{\theta}^{\top} \boldsymbol{S}_{0}^{-1} \boldsymbol{\theta}\right.\\&\left.-2 m_{0}^{\top} S_{0}^{-1} \theta+\boldsymbol{m}_{0}^{\top} \boldsymbol{S}_{0}^{-1} \boldsymbol{m}_{0}\right) \\=&-\frac{1}{2}\left(\boldsymbol{\theta}^{\top}\left(\sigma^{-2} \boldsymbol{\Phi}^{\top} \boldsymbol{\Phi}+\boldsymbol{S}_{0}^{-1}\right) \boldsymbol{\theta}-2\left(\sigma^{-2} \Phi^{\top} y+S_{0}^{-1} m_{0}\right)^{\top} \theta\right)+\mathrm{const}\end{aligned}</script><p>我们可以发现上式与$\theta$呈二次关系。</p><blockquote><p>The fact that the unnormalized log-posterior distribution is a (negative) quadratic form implies that the posterior is Gaussian</p></blockquote><script type="math/tex; mode=display">p(\theta|\mathcal X,\mathcal Y)=\exp(\log p(\theta|\mathcal X,\mathcal Y))\propto \exp(\log p(\mathcal Y|\mathcal X,\theta)+\log p(\theta))\\ \propto \exp(-\frac{1}{2}(\theta^\top(\sigma^{-2}\Phi^\top\Phi+S_0^{-1})\theta-2(\sigma^{-2}\Phi^\top y+S_0^{-1}m_0)^\top \theta))</script><p>最后需要从上式中找到均值和方差矩阵($\mathcal N(\theta|m_N,S_N)$)：</p><script type="math/tex; mode=display">\log \mathcal{N}\left(\boldsymbol{\theta} \mid \boldsymbol{m}_{N}, \boldsymbol{S}_{N}\right)=-\frac{1}{2}\left(\boldsymbol{\theta}-\boldsymbol{m}_{N}\right)^{\top} \boldsymbol{S}_{N}^{-1}\left(\boldsymbol{\theta}-\boldsymbol{m}_{N}\right)+ const\\=-\frac{1}{2}\left(\theta^{\top} S_{N}^{-1} \theta-2 m_{N}^{\top} S_{N}^{-1} \theta+\boldsymbol{m}_{N}^{\top} \boldsymbol{S}_{N}^{-1} \boldsymbol{m}_{N}\right)</script><p>通过比较上面二式可以得到：</p><script type="math/tex; mode=display">\begin{array}{c}S_{N}^{-1}=\Phi^{\top} \sigma^{-2} \boldsymbol{I} \Phi+S_{0}^{-1} \\\Longleftrightarrow \boldsymbol{S}_{N}=\left(\sigma^{-2} \boldsymbol{\Phi}^{\top} \boldsymbol{\Phi}+\boldsymbol{S}_{0}^{-1}\right)^{-1} \\ \\\boldsymbol{m}_{N}^{\top} \boldsymbol{S}_{N}^{-1}=\left(\sigma^{-2} \boldsymbol{\Phi}^{\top} \boldsymbol{y}+\boldsymbol{S}_{0}^{-1} \boldsymbol{m}_{0}\right)^{\top} \\\Longleftrightarrow \boldsymbol{m}_{N}=\boldsymbol{S}_{N}\left(\sigma^{-2} \boldsymbol{\Phi}^{\top} \boldsymbol{y}+\boldsymbol{S}_{0}^{-1} \boldsymbol{m}_{0}\right)\end{array}</script><blockquote><p><strong>完全平方的一般方法</strong>（General Approach to Completing the Squares）<br>对于一个等式($A$是一个堆成正定矩阵)：</p><script type="math/tex; mode=display">x^\top A^\top x-2a^\top x+const_1</script><p>可以得到：</p><script type="math/tex; mode=display">(x-\mu)^\top \Sigma(x-\mu)+const_2</script><p>其中，$\Sigma := A;\mu := \Sigma^{-1}a;const_2 = const_1-\mu^\top\Sigma\mu$<br><strong>这部分需要补充</strong></p></blockquote><h2 id="后验预测（Posterior-Predictions）"><a href="#后验预测（Posterior-Predictions）" class="headerlink" title="后验预测（Posterior Predictions）"></a>后验预测（Posterior Predictions）</h2><script type="math/tex; mode=display">\begin{aligned}p\left(y_{*} \mid \mathcal{X}, \mathcal{Y}, \boldsymbol{x}_{*}\right) &=\int p\left(y_{*} \mid \boldsymbol{x}_{*}, \boldsymbol{\theta}\right) p(\boldsymbol{\theta} \mid \mathcal{X}, \mathcal{Y}) \mathrm{d} \boldsymbol{\theta} \\&=\int \mathcal{N}\left(y_{*} \mid \phi^{\top}\left(\boldsymbol{x}_{*}\right) \boldsymbol{\theta}, \sigma^{2}\right) \mathcal{N}\left(\boldsymbol{\theta} \mid \boldsymbol{m}_{N}, \boldsymbol{S}_{N}\right) \mathrm{d} \boldsymbol{\theta} \\&=\mathcal{N}\left(y_{*} \mid \phi^{\top}\left(\boldsymbol{x}_{*}\right) \boldsymbol{m}_{N}, \boldsymbol{\phi}^{\top}\left(\boldsymbol{x}_{*}\right) \boldsymbol{S}_{N} \phi\left(\boldsymbol{x}_{*}\right)+\sigma^{2}\right)\end{aligned}</script><p>右式中的第一个分布式利用训练得到的参数和输入值计算之后得到的结果的分布（$y^<em>=\phi(x^</em>)\theta$）,第二个分布是用训练集训练得到的参数$\theta$,$\phi^\top(x<em>*)S_N\phi(x</em>*)$表示关于后验的不确定性.<br>上式可以等价地写成</p><script type="math/tex; mode=display">\mathbb E_{\theta|\mathcal X,\mathcal Y}[p(y_*|x_*,\theta)]</script><blockquote><p><strong>分布方程</strong>（Distribution over Functions）<br>当我们使用积分将参数$\theta$消掉时，我们得到了一个分布函数：如果我们从$\theta<em>i \sim p(\theta|\mathcal X, \mathcal Y)$中取样，我们可以得到方程$\theta^\top_i\phi(\cdot)$。均值方程为所有预测值的期望$\mathbb E</em>\theta[f(\cdot)|\theta,\mathcal X,\mathcal Y]=m^\top_N\phi(\cdot)$,函数的方差为$\phi^\top(\cdot) S_N\phi(\cdot)$<br>从$p(\theta)=\mathcal N(0,\frac14I)$中对参数进行抽样,表示为第三张图：<br><img src="https://img-blog.csdnimg.cn/20210610124325373.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>无噪音函数值的均值和方差</strong>（Mean and Variance of Noise-Free Function Values）<br>在很多情况下，我们并不关心(含噪音的)预测值的分布$p(y<em>*|\mathcal X, \mathcal Y,x</em><em>)$。我们更关注于无噪音的函数值$f(x_</em>)=\phi^\top(x_*)\theta$,可以得到该函数的均值和方差：</p><script type="math/tex; mode=display">\begin{aligned}\mathbb{E}\left[f\left(\boldsymbol{x}_{*}\right) \mid \mathcal{X}, \mathcal{Y}\right]=& \mathbb{E}_{\boldsymbol{\theta}}\left[\phi^{\top}\left(\boldsymbol{x}_{*}\right) \boldsymbol{\theta} \mid \mathcal{X}, \mathcal{Y}\right]=\phi^{\top}\left(\boldsymbol{x}_{*}\right) \mathbb{E}_{\boldsymbol{\theta}}[\boldsymbol{\theta} \mid \mathcal{X}, \mathcal{Y}] \\&=\phi^{\top}\left(\boldsymbol{x}_{*}\right) \boldsymbol{m}_{N}=\boldsymbol{m}_{N}^{\top} \phi\left(\boldsymbol{x}_{*}\right), \\\mathbb{V}_{\boldsymbol{\theta}}\left[f\left(\boldsymbol{x}_{*}\right) \mid \mathcal{X}, \mathcal{Y}\right] &=\mathbb{V}_{\boldsymbol{\theta}}\left[\phi^{\top}\left(\boldsymbol{x}_{*}\right) \boldsymbol{\theta} \mid \mathcal{X}, \mathcal{Y}\right] \\&=\phi^{\top}\left(\boldsymbol{x}_{*}\right) \mathbb{V}_{\boldsymbol{\theta}}[\boldsymbol{\theta} \mid \mathcal{X}, \mathcal{Y}] \phi\left(\boldsymbol{x}_{*}\right) \\&=\phi^{\top}\left(\boldsymbol{x}_{*}\right) \boldsymbol{S}_{N} \phi\left(\boldsymbol{x}_{*}\right)\end{aligned}</script><p>我们可以发现均值与含噪音观测的均值一致，因为噪音的均值为0，因为噪音的方差为$\sigma^2$,所以当预测含噪音的函数值时，需要加上，无噪音的时候则不需要。<br><strong>还是没能很好地理解噪音这个概念</strong></p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210610130744637.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>上图是由参数后验得到的后验分布。由上图可知，当多项式为低阶的时候，参数的分布不会很分散。而对于高阶的贝叶斯回归模型，后验概率的不确定性很大，这个信息对于<strong>决策系统</strong>（decision-making system）很重要。</p><h2 id="边际似然的计算（Computing-the-Marginal-Likelihood）"><a href="#边际似然的计算（Computing-the-Marginal-Likelihood）" class="headerlink" title="边际似然的计算（Computing the Marginal Likelihood）"></a>边际似然的计算（Computing the Marginal Likelihood）</h2><p>在本节中，我们介绍参数为共轭高斯先验的贝叶斯线性回归的边际似然的计算。<br>考虑以下参数形成的过程：</p><script type="math/tex; mode=display">\begin{aligned}\theta&\sim \mathcal N(m_0,S_0)\\y_n|x_n, \theta&\sim\mathcal N(x_n^\top\theta,\sigma^2),\quad n=1,\dots,N\end{aligned}</script><p>则对应的边际似然为：</p><script type="math/tex; mode=display">\begin{aligned} p(\mathcal Y|\mathcal X)&=\int p(\mathcal Y|\mathcal X, \theta)p(\theta)d\theta\\&=\int \mathcal N(y|X\theta,\sigma^2I)\mathcal N(\theta|m_0,S_0)d\theta\end{aligned}</script><p>上面这个式子可以理解为参数先验下的似然的期望：$\mathbb E_\theta[p(\mathcal Y|\mathcal X,\theta)]$<br>计算边际似然需要两个步骤，首先先确定边际似然是高斯分布，然后计算出这个高斯分布的均值和方差。<br>由高斯分布的性质，两个高斯分布的乘积仍旧是高斯分布。<br>下面开始计算这个高斯分布的均值和方差：</p><script type="math/tex; mode=display">\mathbb E[\mathcal Y|\mathcal X]=\mathbb E_{\theta,\epsilon}[X\theta+\epsilon]=X\mathbb E_\theta[\theta]=Xm_0,\quad \epsilon \sim \mathcal N(0,\sigma^2I)</script><p>方差为：</p><script type="math/tex; mode=display">\begin{aligned}\operatorname{Cov}[\mathcal Y|\mathcal X]&=\operatorname{Cov}_{\theta,\epsilon}[X\theta+\epsilon]=\operatorname{Cov}[X\theta]+\sigma^2I\\ &=X\operatorname{Cov}_\theta[\theta]X^\top+\sigma^2I=XS_0X^\top+\sigma^2I\end{aligned}</script><p>所以，边际似然为：</p><script type="math/tex; mode=display">\begin{aligned}p(\mathcal{Y} \mid \mathcal{X})=&(2 \pi)^{-\frac{N}{2}} \operatorname{det}\left(\boldsymbol{X} \boldsymbol{S}_{0} \boldsymbol{X}^{\top}+\sigma^{2} \boldsymbol{I}\right)^{-\frac{1}{2}} \\& \cdot \exp \left(-\frac{1}{2}\left(\boldsymbol{y}-\boldsymbol{X} \boldsymbol{m}_{0}\right)^{\top}\left(\boldsymbol{X} \boldsymbol{S}_{0} \boldsymbol{X}^{\top}+\sigma^{2} \boldsymbol{I}\right)^{-1}\left(\boldsymbol{y}-\boldsymbol{X} \boldsymbol{m}_{0}\right)\right)\\&=\mathcal N(y|Xm_0,XS_0X^\top+\sigma^2I)\end{aligned}</script><blockquote><p>与之前的内容进行联系，为什么形式是这样的？</p></blockquote><h2 id="用正交投影解释极大似然估计（Maximum-Likelihood-as-Orthogonal-Projection）"><a href="#用正交投影解释极大似然估计（Maximum-Likelihood-as-Orthogonal-Projection）" class="headerlink" title="用正交投影解释极大似然估计（Maximum Likelihood as Orthogonal Projection）"></a>用正交投影解释极大似然估计（Maximum Likelihood as Orthogonal Projection）</h2><p>考虑一个简单的线性规划模型：</p><script type="math/tex; mode=display">y=x\theta+\epsilon,\quad \epsilon \sim \mathcal N(0,\sigma^2)</script><p>由原先的提到的极大似然估计，得到斜率参数：</p><script type="math/tex; mode=display">\theta_{ML}=(X^\top X)^{-1}X^\top y=\frac{X^\top y}{X^\top X}\in \mathbb R</script><p>其中，$X\in \mathbb R^N$和$y\in \mathbb R^N$为训练集中的元素(都是向量，所以$X^\top X$为标量，这也是将这一项放到分母的原因)。<br>所以对应的目标为：</p><script type="math/tex; mode=display">X\theta_{ML}=X\frac{X^\top y}{X^\top X}=\frac{XX^\top}{X^\top X}y</script><p>所以可以理解为，我们的目标是找到$y=X\theta$的解。由原先的线性代数和解析几何，可以将上式理解为<u>y在X张成的一维子空间的正交投影</u>，其中$\frac{XX^\top}{X^\top X}$为投影矩阵,$\theta<em>{ML}$为y在一维子空间中的正交投影的坐标，$X\theta</em>{ML}$为$y$在这个子空间中的正交投影。<br>所以，极大似然估计的解得到的是在$X$子空间中找到一个与观测值$y$最接近的向量。这里的距离表示$y_n$和 $x_n\theta$的最短（平方）距离<br><img src="https://img-blog.csdnimg.cn/20210615071428677.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>在广义的线性规划中：</p><script type="math/tex; mode=display">y=\phi^\top(x)\theta+\epsilon,\quad \epsilon \sim \mathcal N(0,\sigma^2)</script><p>其中,$\phi(x)\in \mathbb R^K$,利用极大似然估计得到参数结果：</p><script type="math/tex; mode=display">\boldsymbol y\approx \Phi\theta_{ML}\\\theta_{ML}=(\Phi^\top\Phi)^{-1}\Phi^\top \boldsymbol y</script><p>上式实际上就是一个往特征矩阵$\Phi$张成的K维子空间的投影。若将特征矩阵$\Phi$构造成规范正交，这时候$\Phi$就形成了一个规范正交基。因为$\Phi^\top\Phi=I$所以，对应的投影为：</p><script type="math/tex; mode=display">\Phi(\Phi^\top\Phi)^{-1}\Phi^\top \boldsymbol y = \Phi\Phi^\top \boldsymbol y=\begin{pmatrix} \sum\limits^K_{k=1}\phi_k\phi_k^\top\end{pmatrix}\boldsymbol y</script><p>所以极大似然的投影这时候就是y向基向量$\phi_k$的投影的和。</p><blockquote><p>这部分需要深入理解一下，为什么？<br>the coupling between different features has disappeared due to the orthogonality of the basis.</p><p><strong>Further Reading:</strong><br>1.In deffenrent cases we may choose deffenrent model functions which corresponding to the likelihood function<br>2.<strong>generalized linear models</strong>:there is a a smooth and invertible function $\sigma(\cdot)$(which could be nonlinear), so that $y = \sigma(f(x))$,where $f(x)=\theta^\top \phi(x)$ which also $f(x)=\sigma\circ f$. The first one is activate function, and the later one is linear function model. This can form a neural network model.<br>$y=\sigma(Ax+b)$,where A is <strong>weight matrix</strong>, b is <strong>bias vector</strong> so:</p><script type="math/tex; mode=display">\begin{aligned} x_{k+1}&=f_k(x_k)\\f_k(x_k)&=\sigma_k(A_kx_k+b_k)\end{aligned}</script><p>This is a K-layer deep neural network($f_{K-1}\circ\cdots\circ f_0$)</p></blockquote></image>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;@[toc]&lt;br&gt;回归的目的就是找到一个函数$f$,将输入的数据$\boldsymbol x\in \mathbb R^n$映射成$f(\boldsymbol x)\in \mathbb R$.数据的观测噪音为：$y_n=f(x_n)+\epsilon$,其中$\epsi</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>机器学习中的数学: When Models Meet Data</title>
    <link href="http://example.com/2021/05/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6-When-Models-Meet-Data/"/>
    <id>http://example.com/2021/05/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6-When-Models-Meet-Data/</id>
    <published>2021-05-26T02:51:34.000Z</published>
    <updated>2023-03-09T10:48:23.791Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Data-Models-and-Learning"><a href="#Data-Models-and-Learning" class="headerlink" title="Data, Models, and Learning"></a>Data, Models, and Learning</h1><p>The title contains three major components of a machine learning system.</p><h2 id="Data-as-Vectors"><a href="#Data-as-Vectors" class="headerlink" title="Data as Vectors"></a>Data as Vectors</h2><p>First, we need to make information as number, so as to we can use it as training data.</p><h2 id="Models-as-Functions"><a href="#Models-as-Functions" class="headerlink" title="Models as Functions"></a>Models as Functions</h2><p>There are two main school relative to the machine learning, function and probabilistic model. The former one gives a specific value, the later one would give the distribution of the result.<br><img src="https://img-blog.csdnimg.cn/20210517101400415.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>And in order to value a model, we use cost function or loss function to discribe it.</p><h1 id="经验风险最小化（Empirical-Risk-Minimization）"><a href="#经验风险最小化（Empirical-Risk-Minimization）" class="headerlink" title="经验风险最小化（Empirical Risk Minimization）"></a>经验风险最小化（Empirical Risk Minimization）</h1><p>本节主要探讨几个问题：那些函数可以被用作预测函数？如何衡量一个模型的好坏？如何让一个从已知训练集中训练出来的模型很好地预测未见得数据？在找合适的模型时，应该遵循什么样的步骤？</p><h2 id="假设函数的种类（Hypothesis-Class-of-Functions）"><a href="#假设函数的种类（Hypothesis-Class-of-Functions）" class="headerlink" title="假设函数的种类（Hypothesis Class of Functions）"></a>假设函数的种类（Hypothesis Class of Functions）</h2><p>我们训练的目的是找到一个参数列表$\theta^*$,使得函数的输出结果能够更接近真实值，即：</p><script type="math/tex; mode=display">f(x_n,\theta^*)\approx y_n\quad for \ all\ \ a = 1,\cdots,N</script><p>在本节中使用$\hat y_n=f(x_n,\theta^*)$代表模型的预测值。</p><h2 id="代价函数-Loss-Function-for-Training"><a href="#代价函数-Loss-Function-for-Training" class="headerlink" title="代价函数(Loss Function for Training)"></a>代价函数(Loss Function for Training)</h2><p><strong>经验风险</strong>（empirical risk）：真实值与预测值的偏差</p><p>对于一个给定的训练集${(x_1,y_1),\cdots,(x_N,y_N) }$,实例矩阵（example matrix）：$\boldsymbol X :=[x_1,\cdots,x_N]^\top\in \mathbb R^{N\times D}$,标签矩阵$y:=[y_1,\cdots,y_N]^\top\in \mathbb R^N$,对应的平均损失为：</p><script type="math/tex; mode=display">R_{emp}(f,\boldsymbol X, y)=\frac{1}{N}\sum\limits^N_{n-1} l(y_n,\hat y_n)</script><p>我们希望模型不仅仅能够很好地拟合训练数据，还希望模型能够很好地预测数据，所以能够找到一个<strong>期望风险</strong>（Expected Risk）</p><script type="math/tex; mode=display">\bold R_{true}(f)=\boldsymbol{\mathbb E_{x,y}}[l(y,f(\boldsymbol x))]</script><h2 id="正则化减小过拟合-Regularization-to-Reduce-Overfitting"><a href="#正则化减小过拟合-Regularization-to-Reduce-Overfitting" class="headerlink" title="正则化减小过拟合(Regularization to Reduce Overfitting)"></a>正则化减小过拟合(Regularization to Reduce Overfitting)</h2><p>如果有足够的参数，给定地模型一般能够很好地拟合测试数据，但是预测数据却与实际数据有较大的偏差，这时候就是模型发生了<strong>过拟合</strong>。<br>一般情况下，已知的数据分为测试数据和训练数据，分别用于测试和训练模型。</p><blockquote><p>Regularization is a way to compromise between accurate solution of empirical risk minimization and the size or complexity of the solution.<br>对于一个最小二乘问题：$\min\limits_\theta\frac{1}{N}|y-X\theta|^2$,加上正则项则是：</p><script type="math/tex; mode=display">\min\limits_\theta\frac{1}{N}\|y-X\theta\|^2+\lambda \|\theta\|</script></blockquote><h2 id="用交叉验证评估泛化性能-Cross-Validation-to-Assess-the-Generalization-Performance"><a href="#用交叉验证评估泛化性能-Cross-Validation-to-Assess-the-Generalization-Performance" class="headerlink" title="用交叉验证评估泛化性能(Cross-Validation to Assess the Generalization Performance)"></a>用交叉验证评估泛化性能(Cross-Validation to Assess the Generalization Performance)</h2><p>我们将已知数据进行拆分，一部分用于模型训练，一部分用于模型性能测试，这个称为<strong>验证集</strong>（validation set）。但是如果训练数据太少，可能导致得不到好的模型，如果训练数据太少可能导致噪声估计。所以应该对已有的数据进行合理的划分，这就有<strong>K-折交叉验证</strong>（K-fold cross-validation）<br><img src="https://img-blog.csdnimg.cn/20210518102941859.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>这样得到的<strong>期望泛化误差</strong>（expected generalization error）为：</p><script type="math/tex; mode=display">\mathbb E_\mathcal V[R(f,\mathcal V)]\approx\frac{1}{K}\sum^K_{k=1}R(f^{(k)},\mathcal V^{(k)})</script><p>其中，$R(f^{(k)},\mathcal V^{(k)})$为预测值与真实值之间的误差。<br>但是这个方法有几个缺点，首先是不合理的数据划分可能会导致的几个不好的结果，与之前的训练集和测试集之间的大小关系导致不同后果一致。同时需要对模型进行K次训练，可能需要大量的计算资源。</p><blockquote><p>Evaluating the quality of the model, depending on these hyperparameters, may result in a number of training runs that is exponential in the number of model parameters. </p></blockquote><h1 id="参数估计（Parameter-Estimation）"><a href="#参数估计（Parameter-Estimation）" class="headerlink" title="参数估计（Parameter Estimation）"></a>参数估计（Parameter Estimation）</h1><h2 id="最大似然估计（Maximum-Likelihood-Estimation）"><a href="#最大似然估计（Maximum-Likelihood-Estimation）" class="headerlink" title="最大似然估计（Maximum Likelihood Estimation）"></a>最大似然估计（Maximum Likelihood Estimation）</h2><p>定义一个关于参数的函数，去评估模型对数据的拟合的好坏。一般使用<strong>负对数似然</strong>（negative log-likelihood）：</p><script type="math/tex; mode=display">\mathcal L_x(\boldsymbol\theta)=-\log p(\boldsymbol x|\boldsymbol\theta)</script><p>在上式中，样品值是固定的，变化的是参数,这个函数彰显的是给定参数的情况下，取得样品值的概率。<br>假设两个相互独立且均匀分布的数据集，$\mathcal X={x_1,\cdots,x_N }$,$\mathcal Y={y_1,\cdots,y_N }$,他们的似然方程可以呗分解为：</p><script type="math/tex; mode=display">p(\mathcal Y|\mathcal X,\theta)=\prod^N_{n=1}p(y_n|\boldsymbol x_n,\boldsymbol\theta)</script><p>但是从优化的角度来看，和比乘积更容易处理：</p><script type="math/tex; mode=display">\mathcal L(\theta)=-\log p(\mathcal Y|\mathcal X, \theta)=-\sum^N_{n=1}\log p(y_n|x_n,\theta)</script><blockquote><p>hence should be interpreted as observed and fixed, this interpretation is incorrect.</p></blockquote><h2 id="最大后验估计（Maximum-A-Posteriori-Estimation）"><a href="#最大后验估计（Maximum-A-Posteriori-Estimation）" class="headerlink" title="最大后验估计（Maximum A Posteriori Estimation）"></a>最大后验估计（Maximum A Posteriori Estimation）</h2><p>如果我们有关于参数的先验知识，这样可以利用贝叶斯公式更新后验概率，以对参数进行估计。这个与之前提到的正则项类似，在似然概率之后乘以一个对参数的先验概率分布。</p><blockquote><p>这部分需要补充</p></blockquote><h2 id="模型拟合（Model-Fitting）"><a href="#模型拟合（Model-Fitting）" class="headerlink" title="模型拟合（Model Fitting）"></a>模型拟合（Model Fitting）</h2><p>拟合的意思就是优化模型的参数，以最小化代价函数。<br><strong>参数化</strong>（arametrization）：一种描述模型的方式。</p><script type="math/tex; mode=display">y = ax+b\rightarrow \theta:=\{a,b\}</script><p><img src="https://img-blog.csdnimg.cn/20210521104544345.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>书中使用$M_\theta$表示参数化的模型，$M^<em>$为真实值，上图中的红线可以认为是代价函数。<br><em>*拟合的三种结果</em></em>：<br><img src="https://img-blog.csdnimg.cn/20210521104758825.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p>泛化线性模型(generalized generalized linear)：<br>In statistics, the generalized linear model (GLM) is a flexible generalization of ordinary linear regression that allows for response variables that have error distribution models other than a normal distribution.<br>连接函数（Link Function）：<br>The link function provides the relationship between the linear predictor and the mean of the distribution function.</p></blockquote><h2 id="贝叶斯推断（Bayesian-Inference）"><a href="#贝叶斯推断（Bayesian-Inference）" class="headerlink" title="贝叶斯推断（Bayesian Inference）"></a>贝叶斯推断（Bayesian Inference）</h2><p>之前提到的极大似然估计和极大后验估计最后都是在解决一个优化问题，通过解决这个优化问题，我们可以得到模型参数，利用这个参数我们可以得到预测值的分布$p(x|\theta^*)$<br>由于仅仅是关注于部分数据的后验分布会损失部分的信息，而损失的信息可能对决策系统至关重要，所以得到一个完成数据的后验分布十分重要</p><blockquote><p>这部分需要补充，关于信息损失</p></blockquote><p>对于一个数据集$\mathcal X$、一个参数先验$p(\theta)$和一个似然方程的后验分布为：</p><script type="math/tex; mode=display">p(\theta|\mathcal X)=\frac{p(\mathcal X|\theta)p(\theta)}{p(\mathcal X)},\quad p(\mathcal X)=\int p(\mathcal X|\theta)p(\theta)d\theta</script><p>利用参数的后验分布，我们可以将对参数的不确定性转移到数据上,也就是我们的预测值不再依赖于参数了：</p><script type="math/tex; mode=display">p(\boldsymbol x)=\int p(\boldsymbol x|\boldsymbol\theta)p(\boldsymbol\theta)d\boldsymbol\theta=\mathbb E_\boldsymbol\theta[p(\boldsymbol x|\boldsymbol\theta)]</script><p>上式说明，预测值是所有参数下的预测值的均值。</p><h2 id="潜变量模型（Latent-Variable-Models）"><a href="#潜变量模型（Latent-Variable-Models）" class="headerlink" title="潜变量模型（Latent-Variable Models）"></a>潜变量模型（Latent-Variable Models）</h2><blockquote><p>Mathematical models that aim to explain observed variables in terms of latent variables are called <strong>latent variable models</strong></p><p><strong>潜变量</strong>（Latent-Variable）<br>These could in principle be measured, but may not be for practical reasons. In this situation, the term hidden variables is commonly used (reflecting the fact that the variables are meaningful, but not observable).</p></blockquote><p>想要简化模型，最简单的方法就是减少模型的参数的数量。但是利用潜变量模型（expectation maximization (EM) algorithm），可以更加规范地简化模型。<br>潜变量模型能够帮助我们描述从参数中获取预测值地过程：<br>将数据表示为$\boldsymbol x$,模型的参数表示为$\boldsymbol\theta$,潜变量表示为$z$,我们可以得到条件分布：</p><script type="math/tex; mode=display">p(\boldsymbol x|\boldsymbol z,\boldsymbol\theta)</script><p>想要得到给定模型参数下的预测数据，我们需要消去潜变量：</p><script type="math/tex; mode=display">p(x|\theta)=\int p(x|z,\theta)p(z)dz</script><p>注意到似然方程与潜变量无关，有了上面这个式子，我们可以直接使用极大似然估计来进行参数估计。<br>用上式带入到贝叶斯公式中：</p><script type="math/tex; mode=display">p(\theta|\mathcal X)=\frac{p(\mathcal X|\theta)p(\theta)}{p(\mathcal X)}</script><p>其中，$\mathcal X$为给定的数据集。这样得到了后验概率分布，可以用于贝叶斯推断。<br>与上式类似，我们可以得到潜变量的后验分布：</p><script type="math/tex; mode=display">p(z|\mathcal X)=\frac{p(\mathcal X|z)p(z)}{p(\mathcal X)},\quad p(\mathcal X|z)=\int p(\mathcal X|z,\theta)p(\theta)d\theta</script><p>但是还是遇到了积分。而且同时将参数和潜变量消掉也非常困难。<br>下面这个式子相对好计算：</p><script type="math/tex; mode=display">p(z|\mathcal X,\theta)=\frac{p(\mathcal X|z,\theta)p(z)}{p(\mathcal X|\theta)}</script><blockquote><p>补充一下这部分？含义？</p></blockquote><h1 id="有向图模型（Directed-Graphical-Models-Bayesian-networks）"><a href="#有向图模型（Directed-Graphical-Models-Bayesian-networks）" class="headerlink" title="有向图模型（Directed Graphical Models/Bayesian networks）"></a>有向图模型（Directed Graphical Models/Bayesian networks）</h1><p>将一个随机变量表示为一个有向图的节点，随机变量之间的关系表示为有向图的边，这样可以很好的得出随机变量之间的关系，而且可以将随机变量之间的关系变换转换成有向图的操作.</p><h2 id="图的语义（Graph-Semantics）"><a href="#图的语义（Graph-Semantics）" class="headerlink" title="图的语义（Graph Semantics）"></a>图的语义（Graph Semantics）</h2><p>下图表示的是a、b、c三个随机变量，边代表条件概率分布，例如a、b节点，代表$p(b|a)$<br><img src="https://img-blog.csdnimg.cn/20210524173813873.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>所以，一个联合概率分布可以表示为：</p><script type="math/tex; mode=display">p(\boldsymbol x)=\prod^K_{k=1}p(x_k|Pa_k)</script><p>其中，$Pa_k$表示节点$x_k$的父节点。<br>对于一个重复N次的伯努利实验的联合概率分布为：<br><img src="https://img-blog.csdnimg.cn/20210524174426163.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>图(b)是一种更加紧凑的表示方法，图 (c)中的$\alpha 、\beta$是潜变量$\mu$的<strong>超参数</strong>（Hyperparameter）也是$\mu$的一个超前驱（hyperprior）</p><h2 id="条件概率分布和d-分离（有向分离）（Conditional-Independence-and-d-Separation）"><a href="#条件概率分布和d-分离（有向分离）（Conditional-Independence-and-d-Separation）" class="headerlink" title="条件概率分布和d-分离（有向分离）（Conditional Independence and d-Separation）"></a>条件概率分布和d-分离（有向分离）（Conditional Independence and d-Separation）</h2><p>假设一个互不相交的节点集，$\mathcal A,\mathcal B,\mathcal C$,在$\mathcal C$下，$\mathcal A$与$\mathcal B$条件独立，表示为：</p><script type="math/tex; mode=display">\mathcal A \perp \!\!\!\perp\mathcal B\ |\ \mathcal C</script><p><code>有向分离</code>(d-separation)的基本思想：通过贝叶斯网中看两个事件的关系（两个事件是否条件独立），从而简化概率计算。（利用两时间的相互独立的性质）<br>当三个节点满足下面地条件之一的时候，则表示$\mathcal A,\mathcal B$是d-分离的。<br><img src="https://img-blog.csdnimg.cn/2021052515431295.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210525154505655.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p>下面的参考博客中有对应结论的推导</p></blockquote><p><a href="https://blog.csdn.net/ybdesire/article/details/78998398?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162190960216780264053425%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=162190960216780264053425&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-78998398.first_rank_v2_pc_rank_v29&amp;utm_term=d%E5%88%86%E7%A6%BB&amp;spm=1018.2226.3001.4187">参考</a><br>这里两种情况：</p><ol><li>若$\mathcal C$不观测，则$P(\mathcal X, \mathcal Y)=\Sigma_\mathcal Z(\mathcal X,\mathcal Y,\mathcal Z)$,只有$P(\mathcal X,\mathcal Y)=P(\mathcal X)P(\mathcal Y)$才能说明$\mathcal X,\mathcal Y$相互独立，也就是$X,Y$<code>有向独立</code>（d-separation）</li><li>若观测$\mathcal C$,则使用条件概率公式$P(\mathcal X,\mathcal Y|\mathcal C)=\frac{P(\mathcal X)P(\mathcal C|\mathcal X)P(\mathcal Y|\mathcal C)}{P(\mathcal C)}$,只有满足$P(\mathcal X,\mathcal Y|\mathcal C)=P(\mathcal X|\mathcal Z)P(\mathcal Y|\mathcal C)$才能说明$\mathcal X,\mathcal Y$相互独立，也就是$\mathcal X,\mathcal Y$<code>有向独立</code>（d-separation）</li></ol><h1 id="模型选择（Model-Selection）"><a href="#模型选择（Model-Selection）" class="headerlink" title="模型选择（Model Selection）"></a>模型选择（Model Selection）</h1><p>越复杂的模型能够表示的数据之间的关系就越多，例如一个二次函数模型，除了能够表示线性关系之外，还可以表示数据之间的二次关系。虽然复杂的模型能够表示更多的数据关系，但是有时候因为数据量比较小，可能会导致<code>过拟合</code>的现象。我们还需要知道如何评估模型在泛化数据下的性能。</p><h2 id="嵌套交叉验证（Nested-Cross-Validation）"><a href="#嵌套交叉验证（Nested-Cross-Validation）" class="headerlink" title="嵌套交叉验证（Nested Cross-Validation）"></a>嵌套交叉验证（Nested Cross-Validation）</h2><p><img src="https://img-blog.csdnimg.cn/20210526093453995.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>将数据分为三个部分，第一部分用于训练模型，第二部分用于计算误差：</p><script type="math/tex; mode=display">\mathbb E_\mathcal V[\boldsymbol R(\mathcal V| M)]\approx = \frac{1}{K}\sum^K_{k=1}\boldsymbol R(\mathcal V^{(k)}|M)</script><p>其中$\boldsymbol R$代表的是<strong>经验风险</strong>(empirical risk)<br>计算所有模型的经验风险，然后选取经验风险最小的模型作为最终模型，然后利用测试数据计算模型的泛化误差。</p><h2 id="贝叶斯模型选择（Bayesian-Model-Selection）"><a href="#贝叶斯模型选择（Bayesian-Model-Selection）" class="headerlink" title="贝叶斯模型选择（Bayesian Model Selection）"></a>贝叶斯模型选择（Bayesian Model Selection）</h2><p>简单的模型较复杂的模型不容易出现过拟合的现象，所以在能够合理拟合数据的情况下，应该尽可能选取简单的模型，这被称为<strong>奥卡姆剃刀</strong>（Occam’s razor）。在贝叶斯概率的应用过程中，定量地体现了一个“自动奥卡姆剃刀”</p><blockquote><p><img src="https://img-blog.csdnimg.cn/20210526095407220.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="贝叶斯推断中的奥卡姆剃刀"><br>上图中，横坐标表示所有的可能的数据集，纵坐标表示模型对对应数据的拟合程度。我们会选用拟合程度更好的模拟作为最终的模型。</p></blockquote><p>下图是数据生成过程：<br><img src="https://img-blog.csdnimg.cn/20210526101506995.png" div align="left"><br>第一个表示模型的先验概率，表示模型被选取的概率，第二个表示模型对应的参数的分布，最后一个是模型的生成数据。</p><p>用贝叶斯网可以表示为：<br><img src="https://img-blog.csdnimg.cn/20210526101352294.png" div align="left"><br>我们可以利用贝叶斯公式计算后验分布：</p><script type="math/tex; mode=display">p(M_k|\mathcal D)\propto p(M_k)p(\mathcal D|M_k)，\quad(*)</script><p>其中的后验分布不依赖于参数$\boldsymbol\theta_i$,因为：</p><script type="math/tex; mode=display">p(\mathcal D|M_k)=\int p(\mathcal D|\boldsymbol \theta_k)p(\boldsymbol \theta_k|M_k)d\boldsymbol \theta_k</script><p>这个式子被称为<strong>边际似然</strong>（marginal likelihood）<br>利用(*)式，可以得到极大后验估计：</p><script type="math/tex; mode=display">M^*=\operatorname {arg}\max_{M_k}p(M_k|\mathcal D)</script><blockquote><p>似然与边际似然有些不同点，前者更容易出现过拟合的现象，后者因为参数被边际化掉了，出现过拟合的现象更小。而且边际似然中嵌套着模型复杂度和数据拟合之间的一个折中。</p></blockquote><h2 id="模型比较中的贝叶斯因子（Bayes-Factors-for-Model-Comparison）"><a href="#模型比较中的贝叶斯因子（Bayes-Factors-for-Model-Comparison）" class="headerlink" title="模型比较中的贝叶斯因子（Bayes Factors for Model Comparison）"></a>模型比较中的贝叶斯因子（Bayes Factors for Model Comparison）</h2><p>在给定数据集$\mathcal D$和两个模型$M_1,M_2$,想要计算后验分布$p(M_1|\mathcal D) \&amp; \  p(M_2|\mathcal D)$</p><script type="math/tex; mode=display">\underbrace{\frac{p\left(M_{1} \mid \mathcal{D}\right)}{p\left(M_{2} \mid \mathcal{D}\right)}}_{\text {posterior odds(后验相对风险) }}=\frac{\frac{p\left(\mathcal{D} \mid M_{1}\right) p\left(M_{1}\right)}{p(\mathcal{D})}}{\frac{p\left(\mathcal{D} \mid M_{2}\right) p\left(M_{2}\right)}{p(\mathcal{D})}}=\underbrace{\frac{p\left(M_{1}\right)}{p\left(M_{2}\right)}}_{\text {prior odds }} \underbrace{\frac{p\left(\mathcal{D} \mid M_{1}\right)}{p\left(\mathcal{D} \mid M_{2}\right)}}_{\text {Bayes factor }}</script><blockquote><p>???<br><img src="https://img-blog.csdnimg.cn/20210526104142218.png" alt="在这里插入图片描述"></p></blockquote><p>如果选择每一个模型的概率相等，即$\frac {p(M_1)}{p(M_2)}=1$,则可以根据贝叶斯因子与1的关系，选择模型。</p><blockquote><p><strong>信息准则</strong>（information criteria）：<br><strong>Akaike information criterion</strong>：$\log p(x|\theta)-M$corrects for the bias of the maximum likelihood estimator by addition of a penalty term to compensate for the overfitting of more complex models with lots of parameters.<br>其中，M表示参数的个数<br><strong>Bayesian information criterion (BIC)</strong></p><script type="math/tex; mode=display">\log p(x)=\log\int p(x|\boldsymbol\theta)p(\boldsymbol\theta)d\boldsymbol\theta\approx\log p(x|\boldsymbol\theta)-\frac{1}{2}M\log N</script><p>这里N表示数据集，M表示参数个数<br><u><strong>这部分遇到的时候在详细学习</strong></u></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Data-Models-and-Learning&quot;&gt;&lt;a href=&quot;#Data-Models-and-Learning&quot; class=&quot;headerlink&quot; title=&quot;Data, Models, and Learning&quot;&gt;&lt;/a&gt;Data, Models</summary>
      
    
    
    
    
  </entry>
  
</feed>
