<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>Java学习笔记 - Hexo</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Hexo"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Hexo"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Java学习学习[廖雪峰博客](https:&amp;#x2F;&amp;#x2F;www.liaoxuefeng.com&amp;#x2F;wiki&amp;#x2F;1252599548343744)笔记      基本运算符逻辑运算符||：短路或；&amp;amp;&amp;amp;：短路与（一些非法的语句会被忽略）；！：逻辑非 其中逻辑运算符只能操作布尔型数据。（注意一点，在Java中不能用1、0来代替True、False，因为前者是整型后者是布尔型）逻辑运算与短路运算的结果"><meta property="og:type" content="article"><meta property="og:title" content="Java学习笔记"><meta property="og:url" content="https://baymine.github.io/2021/01/09/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><meta property="og:site_name" content="Hexo"><meta property="og:description" content="Java学习学习[廖雪峰博客](https:&amp;#x2F;&amp;#x2F;www.liaoxuefeng.com&amp;#x2F;wiki&amp;#x2F;1252599548343744)笔记      基本运算符逻辑运算符||：短路或；&amp;amp;&amp;amp;：短路与（一些非法的语句会被忽略）；！：逻辑非 其中逻辑运算符只能操作布尔型数据。（注意一点，在Java中不能用1、0来代替True、False，因为前者是整型后者是布尔型）逻辑运算与短路运算的结果"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://baymine.github.io/img/og_image.png"><meta property="article:published_time" content="2021-01-09T13:32:23.000Z"><meta property="article:modified_time" content="2023-03-08T11:43:03.329Z"><meta property="article:author" content="John Doe"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://baymine.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://baymine.github.io/2021/01/09/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},"headline":"Java学习笔记","image":["https://baymine.github.io/img/og_image.png"],"datePublished":"2021-01-09T13:32:23.000Z","dateModified":"2023-03-08T11:43:03.329Z","author":{"@type":"Person","name":"John Doe"},"publisher":{"@type":"Organization","name":"Hexo","logo":{"@type":"ImageObject"}},"description":"Java学习学习[廖雪峰博客](https:&#x2F;&#x2F;www.liaoxuefeng.com&#x2F;wiki&#x2F;1252599548343744)笔记      基本运算符逻辑运算符||：短路或；&amp;&amp;：短路与（一些非法的语句会被忽略）；！：逻辑非 其中逻辑运算符只能操作布尔型数据。（注意一点，在Java中不能用1、0来代替True、False，因为前者是整型后者是布尔型）逻辑运算与短路运算的结果"}</script><link rel="canonical" href="https://baymine.github.io/2021/01/09/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head><body class="is-1-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">Hexo</a></div><div class="navbar-menu"><div class="navbar-end"></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-12"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-01-09T13:32:23.000Z" title="1/9/2021, 9:32:23 PM">2021-01-09</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-03-08T11:43:03.329Z" title="3/8/2023, 7:43:03 PM">2023-03-08</time></span></div></div><h1 class="title is-3 is-size-4-mobile">Java学习笔记</h1><div class="content"><h1 id="Java学习"><a href="#Java学习" class="headerlink" title="Java学习"></a>Java学习</h1><font color="#999AAA">学习[廖雪峰博客](https://www.liaoxuefeng.com/wiki/1252599548343744)笔记
</font>




<h2 id="基本运算符"><a href="#基本运算符" class="headerlink" title="基本运算符"></a>基本运算符</h2><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>||：短路或；&amp;&amp;：短路与（一些非法的语句会被忽略）；！：逻辑非</p>
<p>其中逻辑运算符只能操作布尔型数据。（注意一点，在Java中不能用1、0来代替True、False，因为前者是整型后者是布尔型）<br>逻辑运算与短路运算的结果是一致的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">x</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="type">boolean</span> <span class="variable">y</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="type">short</span> <span class="variable">z</span> <span class="operator">=</span> <span class="number">42</span>;</span><br><span class="line">		<span class="comment">//if(y == true)</span></span><br><span class="line">		<span class="keyword">if</span> (( z++==<span class="number">42</span> ) &amp;&amp; ( y = <span class="literal">true</span> )) z++;<span class="comment">//注意z++是先进行判断之后才自增的！！，所以本语句是可以被执行的</span></span><br><span class="line">		<span class="keyword">if</span> (( x = <span class="literal">false</span>) || (++z == <span class="number">45</span> )) z++;</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">"z="</span> + z);</span><br><span class="line">        <span class="comment">//Output:46</span></span><br></pre></td></tr></table></figure></p>
<h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>左移相当于*2，但是有限度（最左边的数为1的时候，结果会变成负数）右移前右边的位根据数字的符号决定（1的话就用1来填，否则就用0来填）<br>&gt;&gt;&gt;：无符号位移操作</p>
<blockquote>
<p>最高效的方式计算2 * 8：2&lt;&lt;3 or 8 &lt;&lt; 1</p>
</blockquote>
<p>位运算符:&amp;(and)、 |(or)、 ^(xor)、 ~(not)</p>
<h3 id="交换两变量的值"><a href="#交换两变量的值" class="headerlink" title="交换两变量的值"></a>交换两变量的值</h3><p>方式一：定义一个临时变量<br>方式二：先将两数合并，然后再分离<br>   （:可能超出存储范围；有局限性）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num1 = num1 + num2;</span><br><span class="line">num2 = num1 - num2;</span><br><span class="line">num1 = num1 - num2;</span><br></pre></td></tr></table></figure><br>方式三：（运用位运算符关系：m = k ^ n = (m ^ n) ^ n）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num1 = num1 ^ num2;</span><br><span class="line">num2 = num1 ^ num2;</span><br><span class="line">num1 = num1 ^ num2;</span><br></pre></td></tr></table></figure></p>
<h3 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h3><p>表达式1和表达式2要求是一致的，二者能够统一成一个类型（因为它的结果是会被赋值给单个变量的）</p>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>需要包含三点：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.导入对应的类（utility）</span></span><br><span class="line"><span class="keyword">import</span>  java.util.Scanner;<span class="comment">//注意最后的分号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IO</span>{</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>{</span><br><span class="line">    	<span class="comment">//2.创建scanner变量</span></span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);<span class="comment">//创建scanner传入：System.in、System.out分别代表标准输入和输出。</span></span><br><span class="line">		System.out.println(<span class="string">"Input Your name: "</span>);</span><br><span class="line">        <span class="comment">//3.访问输入变量中的成员</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> scanner.nextLine();<span class="comment">//传入的是字符串类型，注意这种类型转换是自动的</span></span><br><span class="line">		System.out.println(<span class="string">"Input Your age: "</span>);</span><br><span class="line">		<span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> scanner.nextInt();<span class="comment">//传入的是整型（注意next之后的语句）</span></span><br><span class="line">		System.out.printf(<span class="string">"Hi, %s,you are %d\n"</span>,name,age);</span><br></pre></td></tr></table></figure></p>
<h3 id="条件判断语句"><a href="#条件判断语句" class="headerlink" title="条件判断语句"></a>条件判断语句</h3><h4 id="判等语句”-“："><a href="#判等语句”-“：" class="headerlink" title="判等语句”==“："></a>判等语句”==“：</h4><p> 这种判断运算符可以用来判断了两个值类型的变量是否相等，但是对于引用型变量就变成判断两个变量是否指向同一个对象。要判断引用类型的变量内容是否相等需要使用<strong>equals（）方法</strong>（注意这是变量类型String下面的一种方法）<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IO</span> {    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>{        </span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="literal">null</span>;        </span><br><span class="line">        <span class="comment">//注意当s1为null时，直接调用equals方法会导致NullPointException错误，       </span></span><br><span class="line">        <span class="comment">//为了避免这种情况，就利用短路运算，规避这种错误        </span></span><br><span class="line">        <span class="keyword">if</span> (s1 != <span class="literal">null</span> &amp;&amp; s1.equals(<span class="string">"hello"</span>)){            </span><br><span class="line">            System.out.println((<span class="string">"hello"</span>));       </span><br><span class="line">        }   </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<h4 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意switch语句具有穿透性，所以每一项都需要以break结尾，且不能有大括号，判断语句也可以是字符串，是比较其中的内容是否相等</span></span><br><span class="line"><span class="keyword">switch</span>（option）{</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">        ....</span><br><span class="line">        <span class="keyword">break</span>;   </span><br><span class="line">        </span><br><span class="line"> <span class="comment">//java12</span></span><br><span class="line"> <span class="keyword">case</span> <span class="string">"***"</span> -&gt; ....;<span class="comment">//当具有多条语句的时候，需要用大括号括起来，其不需要break</span></span><br><span class="line"> <span class="comment">//还可以直接返回参数</span></span><br><span class="line"> <span class="type">int</span> <span class="variable">opt</span> <span class="operator">=</span> <span class="keyword">switch</span>(fruit){......}</span><br><span class="line"> <span class="keyword">yield</span> code;<span class="comment">//这个是switch语句的返回值，作为默认返回的方式</span></span><br></pre></td></tr></table></figure>
<h4 id="for-语句"><a href="#for-语句" class="headerlink" title="for 语句"></a>for 语句</h4><p> esp.（for each 循环）</p>
<h1 id="eg："><a href="#eg：" class="headerlink" title="eg："></a>eg：</h1> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] ns = {...};<span class="comment">//数组初始化</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> n : ns){....}<span class="comment">//数组遍历</span></span><br><span class="line"><span class="comment">//但是这种方式没有办法拿到数组的索引</span></span><br></pre></td></tr></table></figure>
<h2 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h2><h3 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h3><p>java标准库提供了Arrays.toString()，可以用来快速打印数组内容</p>
<h3 id="数组的排序"><a href="#数组的排序" class="headerlink" title="数组的排序"></a>数组的排序</h3><p>调用Java的内置排序功能</p>
<blockquote>
<p>import java.util.Arrays;<br>Arrays.sort(Arrays_name);//排序算法的调用</p>
</blockquote>
<p>注意一点，数组的第一个元素就是指向该数组的指针</p>
<h3 id="访问多维数组"><a href="#访问多维数组" class="headerlink" title="访问多维数组"></a>访问多维数组</h3><p>初始化的方式与C语言的一致，利用Java标准库输出：</p>
<blockquote>
<p>Arrays.deepToString</p>
<p>注意一点，在多维数组中，.length表示的多为数组中的数组的个数</p>
</blockquote>
<h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><p>NULL</p>
<h2 id="面对对象编程"><a href="#面对对象编程" class="headerlink" title="面对对象编程"></a>面对对象编程</h2><h3 id="面对对象基础"><a href="#面对对象基础" class="headerlink" title="面对对象基础"></a>面对对象基础</h3><p> 简单来说就是我们都是一类（class）人，但是每个我们都是不同的实例（instance），各有各的性格特点<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Class_Name</span>{</span><br><span class="line">	<span class="keyword">public</span> member_name;<span class="comment">//public表示外部可以访问;这些是类的字段（Field）</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">//创建实例</span></span><br><span class="line"><span class="type">Class_Name</span> <span class="variable">instanceName</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Class_Name</span>();</span><br><span class="line"><span class="comment">//访问实例的字段</span></span><br><span class="line">instanceName.field;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h4 id="类方法："><a href="#类方法：" class="headerlink" title="类方法："></a>类方法：</h4><h5 id="private-方法"><a href="#private-方法" class="headerlink" title="private 方法"></a>private 方法</h5><p>为了避免外部代码直接去访问field，可以用private修饰field，这样可以拒绝外部的访问。但是外部代码想要访问，就需要借助方法（method）<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">Person</span>{</span><br><span class="line">	<span class="keyword">private</span> String name;<span class="comment">//实例（instance）</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">	<span class="keyword">private</span> String nickName；</span><br><span class="line"></span><br><span class="line">	<span class="comment">//下面是private的方法</span></span><br><span class="line">	<span class="comment">//访问内部字段</span></span><br><span class="line">	<span class="keyword">public</span> String getName{</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getAge</span><span class="params">()</span>{</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.age;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//同时可以检查输入的值是否合法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>{<span class="comment">//这里是方法参数</span></span><br><span class="line">	<span class="comment">//发现违法输入，抛出异常</span></span><br><span class="line">		<span class="keyword">if</span>(name == <span class="literal">null</span> || name.isBlank()){</span><br><span class="line">			<span class="keyword">throw</span> IllegalArgumentException(<span class="string">"Invalid name"</span>); </span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="comment">//如果没有冲突，则可以忽略this，如：return name；</span></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//下面是可变参数的一个示例。（类型...）</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNickName</span><span class="params">(String... names)</span>{<span class="comment">//参数也可以写成：String[] names</span></span><br><span class="line">		<span class="built_in">this</span>.nickName = names;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//调用方式:varianName.setNickName(" *** " ," **** ");</span></span><br><span class="line">	<span class="comment">/*注意：前几个方法的参数是以复制后形式传入的，而这个方法的参数若是数组</span></span><br><span class="line"><span class="comment">	的话，就是以引用的方式传入的，所以在外部代码中，之前传入的数组的会导</span></span><br><span class="line"><span class="comment">	致内部数组的变化（类似于传值、传址）</span></span><br><span class="line"><span class="comment">	**引用类型参数的传递，调用放的变量，和接受方的变量，指向的是同一个对象。双方任意一方修改这个对象都会影响对方**</span></span><br><span class="line"><span class="comment">	之前的复制参数的传递方式成为参数绑定机制</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">//第一private相当于对变量进行了封装，而public这作为外部的接口。</span></span><br><span class="line"><span class="comment">//这里注意一下this指针的运用，用于在类内部指代内部本身。（屋子内的物品分布的地图）</span></span><br></pre></td></tr></table></figure></p>
<h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><p> <strong>之前些的这部分写得太烂了，这部分最后是重写的（我终于知道在代码中加太多注释的话，在复习的会哭的）</strong></p>
<p> 在类定义的时候定义一个构造方法，这可以在创建实例的时候顺便将字段都初始化了<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在类中，定义一个与类名相同的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ClassName</span> <span class="params">(type instanceName1, type instanceName2)</span>;<span class="comment">//参变量是需要初始化的变量</span></span><br><span class="line"><span class="comment">//定义的同时初始化</span></span><br><span class="line"><span class="type">className</span> <span class="variable">varianName</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">className</span>(initialValue1,initialValue2);</span><br><span class="line"><span class="comment">//Java的构造函数与C语言类似（几乎一致）</span></span><br><span class="line"><span class="comment">//默认构造函数</span></span><br><span class="line"><span class="keyword">public</span> ClassName</span><br><span class="line"><span class="comment">//没有初始化的字段：引用类型-&gt;null; 数值类型-&gt;默认值，int-&gt;0;boolean -&gt;false;</span></span><br><span class="line"><span class="comment">//可以在类定义当中定义多个构造方法，调用的时候会根据传入的参数的个数匹配至相应的构造方法</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ClassName</span>();<span class="comment">//这个时候就会调用默认的构造方法</span></span><br><span class="line"><span class="comment">//一种方法可以调用另一种方法，这里用到this指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在类定义的内部：</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span>{</span><br><span class="line">	<span class="built_in">this</span>(name,<span class="number">18</span>);<span class="comment">//这里调用了另外一个方法</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<p>&lt;hr style=” border:solid; width:100px; height:1px;” color=#000000 size=1”&gt;<br>构造方法就是为了能够在定义变量的时候方便初始化。作用就像是C++中的结构体的构造函数，但是Java中的构造方法与C++中的有一些不同。</p>
<blockquote>
<p>和普通方法相比，构造方法没有返回值（也没有void），调用构造方法，必须用new操作符。</p>
</blockquote>
<p>下面是运用实例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> {</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> {</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    }</span><br><span class="line">	<span class="comment">//默认构造函数</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>{};</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.age;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用：直接初始化了成员变量</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">"Xiao Ming"</span>, <span class="number">15</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h5 id="方法重载（Overload）（同名但拥有不同的参数类型的方法）"><a href="#方法重载（Overload）（同名但拥有不同的参数类型的方法）" class="headerlink" title="方法重载（Overload）（同名但拥有不同的参数类型的方法）"></a>方法重载（Overload）（同名但拥有不同的参数类型的方法）</h5><p>允许出现<strong>同名但拥有不同的参数类型的方法</strong>，但是这些方法的返回值应该具有相同的返回值。这样使得调用变得更加方便。注意重载的方法应该完成相似的功能。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继续之前的案例</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">setName</span><span class="params">(String name)</span>{</span><br><span class="line">	<span class="built_in">this</span>.name = name;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//方法重载</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">steName</span><span class="params">(String name, String familyName)</span>{</span><br><span class="line">	<span class="built_in">this</span>.name = name + <span class="string">" "</span> + familyName;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>继承就是在原有的类的字段和方法上进行拓展，形成一个新的类，Java中运用关键字<strong>extends</strong>来实现继承。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>{...}<span class="comment">//超类（super class）、父类（parent class）、基类（base class）</span></span><br><span class="line"><span class="comment">//对原先的类进行继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">person</span>{...}<span class="comment">//子类（subclass）、拓展类（extended class）</span></span><br><span class="line"><span class="comment">//注意子类中不能定义父类中重名的字段！</span></span><br></pre></td></tr></table></figure></p>
<h5 id="继承树"><a href="#继承树" class="headerlink" title="继承树"></a>继承树</h5><p>这类的继承结构就像是树的结构，所有定义的类都有对应的父类，上例中，Person的父类就是Object（这个类就相当于树中的头节点，没有父类），同样与树类似，每一个类只有一个父节点（除了Object），及只能继承自一个类。</p>
<h5 id="protected（仅能被继承树中的成员所访问的变量）"><a href="#protected（仅能被继承树中的成员所访问的变量）" class="headerlink" title="protected（仅能被继承树中的成员所访问的变量）"></a>protected（仅能被继承树中的成员所访问的变量）</h5><p>父类中private的字段是没有办法被子类访问的，但是protected的字段可以被所有的子类所访问（继承树内部）。</p>
<h5 id="super-子类构造方法时使用"><a href="#super-子类构造方法时使用" class="headerlink" title="super(子类构造方法时使用)"></a>super(子类构造方法时使用)</h5><p>当在子类中引用父类的字段时，就可以用super指代（联想到this是指代自己，super是指代父类）一般情况下，super.name、this.name、name(name 为父类中的一个字段)都是一样的，编译器会自动定位字段的位置。但是在子类中需要生成构造函数的时候，情况就发生变化了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*在Java中任何类的构造方法必须是调用父类的构造方法，在没有明确调用父类的构造方法时候，</span></span><br><span class="line"><span class="comment">会默认一个super（），但是父类中并没有无参数的构造方法，这时候就会报错。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Class Student <span class="keyword">extends</span> <span class="title class_">Person</span>{</span><br><span class="line">	<span class="keyword">protected</span> <span class="type">int</span> score;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name,<span class="type">int</span> age,<span class="type">int</span> score)</span>{</span><br><span class="line">		<span class="built_in">super</span>()；<span class="comment">//自动调用父类的构造方法,出错</span></span><br><span class="line">		<span class="comment">//这个时候只需要调用父类中已经定义的构造方法即可</span></span><br><span class="line">		<span class="built_in">this</span>.score = score;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*所以当父类没有默认的构造方法时，必须写明调用super（），以便定位到合适的构造方法中。</span></span><br><span class="line"><span class="comment">（回忆之前所的，当自己定义一个构造方法时，原有的默认构造方法就被覆盖了）</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><br>还有一点，子类是不会继承父类的任何构造方法。</p>
<h5 id="阻止继承（sealed）"><a href="#阻止继承（sealed）" class="headerlink" title="阻止继承（sealed）"></a>阻止继承（sealed）</h5><p>只要一个class没有final修饰符，任何类都可以从该类中继承。但是为了防止继承被滥用，Java15中允许使用 <strong>sealed</strong>类型，通过<strong>permits</strong>明确可以继承的子类名称<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Shape</span> <span class="keyword">permits</span> Rect, Circle{...}<span class="comment">//permits之后时允许继承的子类</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>sealed类在Java 15中目前是预览状态，要启用它，必须使用参数—enable-preview和—source 15</p>
</blockquote>
<h5 id="向上转型-amp-向下转型"><a href="#向上转型-amp-向下转型" class="headerlink" title="向上转型&向下转型"></a>向上转型&amp;向下转型</h5><p>这种向上向下的关系是针对继承树的，总的来说，字符/方法少的不能向字符/方法多的转型，否则Java虚拟机就会报<strong>ClassCastException</strong>.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向下转型实例</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>()<span class="comment">//Person类型p1指向Students实例</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> (Student) p1;<span class="comment">//向下转型,出现错误，因为原先的类中可能不存在子类中的方法</span></span><br><span class="line"><span class="comment">//向上转型实例</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();<span class="comment">//向下转型</span></span><br></pre></td></tr></table></figure><br>为了避免在向下转型的过程中出现错误，可以用<strong>instanceof</strong>实现判断一个变量所指向的实例是否是指定类型，或者是这个类型的子类。（A is instance of ClassName?True or False?）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">	<span class="keyword">if</span>(p <span class="keyword">instanceof</span> Student){</span><br><span class="line">		<span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> (Student) p;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//在java14中可以在判断语句中直接转型为制定变量（预览功能，启用需要参数）</span></span><br><span class="line">	<span class="comment">//这样写更加整洁</span></span><br><span class="line">	<span class="keyword">if</span>(p <span class="keyword">instanceof</span> Student s){</span><br><span class="line">		System.out.println(s.getname);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></table></figure><br>最后在使用继承的时候要注意逻辑的一致性，继承的双方应该是包含和被包含的关系，而不是有交集的关系。</p>
<h5 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h5><h6 id="覆写"><a href="#覆写" class="headerlink" title="覆写"></a>覆写</h6><p>父类的方法可以被子类的完全相同的方法所覆写（修改相应方法的功能）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类的方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>{</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>{</span><br><span class="line">		System.out.println(<span class="string">"  "</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="comment">//子类对父类方法进行覆写</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>{</span><br><span class="line">	<span class="meta">@override</span><span class="comment">//帮助检查是否正确进行了覆写（非必须）</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span> <span class="params">()</span>{</span><br><span class="line">		System.out.println(<span class="string">"***"</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="comment">//重载（overload）：对一个方法进行补充性修改，名称一致，但是参数、功能可以发生变化</span></span><br><span class="line"><span class="comment">//覆写(override):对一个方法的功能进行修改，相应的功能名称都应该相同</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注意一点，Java调用方法的过程中，调用的是所指向的类的对应的方法，这意味着所调用的方法与所对应的父类无关</span></span><br><span class="line"><span class="comment">这样在定义一个函数的时候，由于传入的参数类型不确定，这就导致所调用的方法也是不确定的。</span></span><br><span class="line"><span class="comment">（Java中定义的类型和所指向的类型可以是不一致的）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Run</span><span class="params">(Person p)</span>{</span><br><span class="line">	<span class="comment">//这时候无法确定是Person的方法还是Student的方法</span></span><br><span class="line">	p.run();</span><br><span class="line">}</span><br><span class="line"><span class="comment">//利用这个特点，可以通过传入不同类型的参数，以实现调用不同的功能的方法</span></span><br><span class="line"><span class="comment">//的目的,这样就实现了功能的拓展，而又不需要修改基于父类的代码</span></span><br></pre></td></tr></table></figure><br>  所有的类都最终继承自Object，这就意味着在必要情况下可以覆写Object的方法。其有一下几个重要方法：</p>
<ol>
<li>toString():将instance输出为String</li>
<li>equals():判断两个instance是否逻辑相等</li>
<li>hashCode():计算一个instance的哈希值</li>
</ol>
<p>在子类中，想要调用父类的方法，可以用super来调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Student <span class="keyword">extends</span> <span class="title class_">Person</span>{</span><br><span class="line">	<span class="meta">@override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>{</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">super</span>.hello()+<span class="string">"!"</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//当一个方法不想让子类进行覆写的时候，在方法前加上final关键字</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">hello_1</span><span class="params">()</span>{</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Hello, "</span>+name;</span><br><span class="line">	}<span class="comment">//子类进行覆写会导致编译错误</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">//不希望被继承的类</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ClassName</span>{...}</span><br><span class="line"><span class="comment">//不希望被修改的字段,常出现在构造方法中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">"***"</span>;</span><br><span class="line"><span class="comment">//提一下：在方法的参数当中出现三个英文句号，代表参数个数不确定，依照输入参数的个数来确定</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">totalTax</span><span class="params">(Income... incomes)</span>{...}</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h5 id="抽象类-amp-接口"><a href="#抽象类-amp-接口" class="headerlink" title="抽象类&接口"></a>抽象类&amp;接口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当父类方法只是定义方法签名，本身没有实际的意义，这时候应该将父类方法声明为抽象方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>{</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//这样的类运行时会报错，需要将类本身也声明为抽象类型,此类方法无法被实例化（无法用于定义变量）</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span>{</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h6 id="面向抽象编程"><a href="#面向抽象编程" class="headerlink" title="面向抽象编程"></a>面向抽象编程</h6><p>上层类只是定义规范，对于方法的实现并不关心，这相当于对方法的实现过程进行了封装。<br>实现方法就是用抽象类型去引用具体子类的实例。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br></pre></td></tr></table></figure></p>
<h6 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h6><p>当一个抽象类中没有字段，所有的方法都是抽象类，这个时候应该将将这个类定义为接口：<strong>Interface</strong><br>在接口中所有的方法都是默认是public abstract，所以这两个修饰符在定义方法的时候都不写出来，当一个类去实现接口的时候需要使用<strong>implements</strong>关键字。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span>{...}<span class="comment">//定义一个接口，接口中不能有字段</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Person</span>{...}<span class="comment">//实现一个接口</span></span><br><span class="line"><span class="comment">//在Java中一个类只能继承自唯一的一个类，但是可以实现多个方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Run</span>,Walk{...}<span class="comment">//实现两个接口</span></span><br><span class="line"><span class="comment">//一个接口还可以继承自另一个接口，这就相当于拓展了接口的方法</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Teacher</span> <span class="keyword">extends</span> <span class="title class_">Person</span>{....}</span><br></pre></td></tr></table></figure><br> 当实现一个接口的时候，需要覆写接口中所有的方法，但是可以不用覆写default方法，这实际上就是一种默认的方法功能，可以“不初始化”。<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span>{</span><br><span class="line">	<span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>{...}<span class="comment">//无法访问字段</span></span><br><span class="line">}		</span><br></pre></td></tr></table></figure></p>
<h5 id="静态字段和静态方法"><a href="#静态字段和静态方法" class="headerlink" title="静态字段和静态方法"></a>静态字段和静态方法</h5><h6 id="静态字段"><a href="#静态字段" class="headerlink" title="静态字段"></a>静态字段</h6><p>用static修饰，独立于实例，在任何一个实例当中修改都会修改静态字段的值，这就是说所有实例中的同一个静态字段都是同一个字段（在同一个存储空间当中）。所以在访问静态字段的时候，最好是使用类名来访问：<strong>类名.静态字段</strong></p>
<h6 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h6><p>调用静态方法不需要实例变量，直接通过类名即可。</p>
<blockquote>
<p>静态方法属于类而不属于实例，所以在静态方法内部是无法访问this变量，也无法访问实例字段，只能访问静态字段</p>
<h6 id="接口的静态字段"><a href="#接口的静态字段" class="headerlink" title="接口的静态字段"></a>接口的静态字段</h6><p>接口的静态字段必须是final类型的，又因为接口的字段只能是public static final类型的，所以这样的修饰符是可以省略的。</p>
<h6 id="包"><a href="#包" class="headerlink" title="包"></a>包</h6><p>为了避免因为类名相同的而导致的冲突，在Java中定义了一种名字空间，成为包（package），一个类的完成类名是：<strong>包名.类名</strong>，没有写包名的类会使用默认包，这样容易造成名字冲突，所以建议将包名写出来。（注意，<strong>包没有父子关系</strong>，这也就是说com.apache和com.apache.abc是不同的包）</p>
<h6 id="包的作用域"><a href="#包的作用域" class="headerlink" title="包的作用域"></a>包的作用域</h6><p>位于同一个包的类可以访问包的作用域的字段和方法（允许访问package的没有public、private修饰的class、以及没有public、protected、private修饰的字段和方法。注意这里的意思是能访问，不是只能访问，public修饰的方法在同一个包情况下当然可以被访问）</p>
<h6 id="调用其他的class：import"><a href="#调用其他的class：import" class="headerlink" title="调用其他的class：import"></a>调用其他的class：import</h6><p>package_sample<br>└─ bin<br>     ├─ hong<br>     │  └─ Person.class<br>    │  ming<br>    │  └─ Person.class<br>    └─ mr<br>          └─ jun<br>               └─ Arrays.class</p>
</blockquote>
<p>假设一个包的结构如上图。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用方法①:直接完成写出类名</span></span><br><span class="line">mr.jun.<span class="type">Arrays</span> <span class="variable">arrays</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">mr</span>.jun.Arrays();</span><br><span class="line"><span class="comment">//调用方法②：用import语句,导入对应的包</span></span><br><span class="line"><span class="keyword">import</span> mr.jun.Arrays;<span class="comment">//导入这个包下的Arrays类</span></span><br><span class="line"><span class="keyword">import</span> mr.jun.*;<span class="comment">//导入这个包下的所有的类（不推荐，可能引起混乱）</span></span><br><span class="line"><span class="comment">//导入一个类的静态字段和静态方法</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.*;<span class="comment">//导入system类中的所有静态方法</span></span><br><span class="line">out.println(<span class="string">"..."</span>);<span class="comment">//可用√</span></span><br></pre></td></tr></table></figure><br>在编译器遇到一个类名称的时候，按照一下顺序查找这个类<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[是否是完整的类名]--是--&gt;B(直接根据完整类名查找这个类)</span><br><span class="line">A--否--&gt;C(查找当前package是否存在这个类名)</span><br><span class="line">C--&gt;D(查找import的包)--&gt;E(查找java.lang包)</span><br></pre></td></tr></table></figure><br>如果没有找到最后就报错。<br>在编写class 的时候，编译器会自动import两个包：导入当前包的其他class、默认：import java.lang.*.导入的包的名称不能相同，如有重名，另一个应该到写入完整的类名。为了避免冲突，要注意能和java.lang和JDK常用类的类名重名<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个语句应该就是在声明包的位置</span></span><br><span class="line"><span class="keyword">package</span> com.itranswarp.sample;</span><br><span class="line"></span><br><span class="line"><span class="comment">//导入包，写明包的具体位置</span></span><br><span class="line"><span class="keyword">import</span> com.itranswarp.world.Person;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">		<span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">"小明"</span>);</span><br><span class="line">		System.out.println(p1.hello());</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<h5 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h5><div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th>作用范围</th>
<th>补充</th>
</tr>
</thead>
<tbody>
<tr>
<td>public</td>
<td>只要有class的访问权限，定义位public的方法和字段就可以被访问</td>
<td>相当于一个对外的接口</td>
</tr>
<tr>
<td>private</td>
<td>无法被其他类访问，但是可以通过嵌套类（nested class）访问</td>
<td>用方法内的public方法访问private方法，使外部可以访问方法内部的private方法</td>
</tr>
<tr>
<td>protected</td>
<td>字段和方法能被子类及其子类访问</td>
<td>限制访问范围只能在继承树中才访问</td>
</tr>
<tr>
<td>package</td>
<td>同一个包内能访问对应的方法字段</td>
<td>有点像名字空间</td>
</tr>
<tr>
<td>局部变量</td>
<td>在方法内部定义的变量成为局部变量</td>
<td>在范围之外就会失效，像形参之类的</td>
</tr>
<tr>
<td>final</td>
<td>class：防止被继承<br>字段：防止被重新赋值<br>局部变量：防止重新赋值<br>方法：防止被覆写</td>
<td>就相当于静态变量</td>
</tr>
</tbody>
</table>
</div>
<p><em>注意事项：</em> 1.尽可能少地对外暴露字段和方法，也就是说要尽可能减少public地使用<br>2.将方法定义位package有利于测试，测试类和被测试类只要在同一个包中，测试代码就可以访问被测试类的权限方法<br>3.一个.java类只能有一个public类，且文件名和public类必须相同。</p>
<h5 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h5><p>在其他类中定义的类称为内部类。<br>①：Inner Class（内部类）：依托于外部类，能够访问外部类的private字段和方法。<br>创建方法：Outer.Inner inner = outer.new Inner();<br>编译后：Outer编译位Outer.class,内部类编译为Outer$Inner.class</p>
<p>②：Anonymous Class（匿名类）在其他类的内部实例化<br>创建方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>(){<span class="comment">//这里是定义了一个接口</span></span><br><span class="line">	<span class="comment">//方法</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">//继承自普通类</span></span><br><span class="line">HashMap&lt;String, String&gt;map2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(){};</span><br></pre></td></tr></table></figure><br>编译后：main$1.class(main是public修饰的)<br>③：Static Nested Class（静态内部类）用static修饰，无法应用Outer.this，可以访问private修饰的变量</p>
<h5 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h5><p>模块申明了依赖关系，只有声明依赖关系之后才能将需要的类导入<br>(While need it, learn it)</p>
<h4 id="Java核心类"><a href="#Java核心类" class="headerlink" title="Java核心类"></a>Java核心类</h4><h1 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h1><h2 id="在命令行中运行Java程序"><a href="#在命令行中运行Java程序" class="headerlink" title="在命令行中运行Java程序"></a>在命令行中运行Java程序</h2><p>可以在执行语句后面加上参数列表，在程序中将会被保存至args参数列表中，用下标索引的方式可以直接访问传入的参数。</p>
</div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/02/25/%E3%80%8A%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%83%A8%E5%88%86-STL-%E9%93%BE%E8%A1%A8-%E6%A0%91/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">《算法笔记》数据结构部分(STL&amp;链表&amp;树)</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/01/09/%E3%80%8AComputer-Systems-A-Programmer-Perspective-3rd-ed%E3%80%8B/"><span class="level-item">《Computer Systems: A Programmer Perspective 3rd ed》</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><!--!--><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">Hexo</a><p class="is-size-7"><span>&copy; 2024 John Doe</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><!--!--><script data-pjax src="/js/main.js" defer></script><!--!--></body></html>