<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>《算法笔记》数据结构部分(STL&amp;链表&amp;树) - Baymine&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Baymine&#039;s Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Baymine&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="C++ STL栈123456789101112#include &amp;lt;stack&amp;gt;using namespace std;&amp;#x2F;&amp;#x2F;定义一个栈stack &amp;lt;typename&amp;gt; name;&amp;#x2F;&amp;#x2F;stack函数实例stack.push(x);&amp;#x2F;&amp;#x2F;将元素x加入到栈中stack.top();&amp;#x2F;&amp;#x2F;获取栈顶元素stack.pop();&amp;#x2F;&amp;#x2F;将栈顶元素弹出stack.empty();&amp;#x2F;&amp;#x2F;判断栈是否为空"><meta property="og:type" content="blog"><meta property="og:title" content="《算法笔记》数据结构部分(STL&amp;链表&amp;树)"><meta property="og:url" content="https://baymine.github.io/2021/02/25/%E3%80%8A%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%83%A8%E5%88%86-STL-%E9%93%BE%E8%A1%A8-%E6%A0%91/"><meta property="og:site_name" content="Baymine&#039;s Blog"><meta property="og:description" content="C++ STL栈123456789101112#include &amp;lt;stack&amp;gt;using namespace std;&amp;#x2F;&amp;#x2F;定义一个栈stack &amp;lt;typename&amp;gt; name;&amp;#x2F;&amp;#x2F;stack函数实例stack.push(x);&amp;#x2F;&amp;#x2F;将元素x加入到栈中stack.top();&amp;#x2F;&amp;#x2F;获取栈顶元素stack.pop();&amp;#x2F;&amp;#x2F;将栈顶元素弹出stack.empty();&amp;#x2F;&amp;#x2F;判断栈是否为空"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://img-blog.csdnimg.cn/20210401083819611.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70"><meta property="og:image" content="https://img-blog.csdnimg.cn/20210223093952989.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70#pic_center"><meta property="og:image" content="https://img-blog.csdnimg.cn/20210223094002206.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70#pic_center"><meta property="article:published_time" content="2021-02-25T02:46:43.000Z"><meta property="article:modified_time" content="2023-03-08T11:44:22.495Z"><meta property="article:author" content="John Doe"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://img-blog.csdnimg.cn/20210401083819611.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://baymine.github.io/2021/02/25/%E3%80%8A%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%83%A8%E5%88%86-STL-%E9%93%BE%E8%A1%A8-%E6%A0%91/"},"headline":"《算法笔记》数据结构部分(STL&链表&树)","image":[],"datePublished":"2021-02-25T02:46:43.000Z","dateModified":"2023-03-08T11:44:22.495Z","author":{"@type":"Person","name":"John Doe"},"publisher":{"@type":"Organization","name":"Baymine's Blog","logo":{"@type":"ImageObject","url":"https://baymine.github.io/img/logo.svg"}},"description":"C++ STL栈123456789101112#include &lt;stack&gt;using namespace std;&#x2F;&#x2F;定义一个栈stack &lt;typename&gt; name;&#x2F;&#x2F;stack函数实例stack.push(x);&#x2F;&#x2F;将元素x加入到栈中stack.top();&#x2F;&#x2F;获取栈顶元素stack.pop();&#x2F;&#x2F;将栈顶元素弹出stack.empty();&#x2F;&#x2F;判断栈是否为空"}</script><link rel="canonical" href="https://baymine.github.io/2021/02/25/%E3%80%8A%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%83%A8%E5%88%86-STL-%E9%93%BE%E8%A1%A8-%E6%A0%91/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style><link rel="alternate" href="/atom.xml" title="Baymine's Blog" type="application/atom+xml">
</head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Baymine&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-02-25T02:46:43.000Z" title="2/25/2021, 10:46:43 AM">2021-02-25</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-03-08T11:44:22.495Z" title="3/8/2023, 7:44:22 PM">2023-03-08</time></span><span class="level-item">an hour read (About 8168 words)</span></div></div><h1 class="title is-3 is-size-4-mobile">《算法笔记》数据结构部分(STL&amp;链表&amp;树)</h1><div class="content"><h1 id="C-STL"><a href="#C-STL" class="headerlink" title="C++ STL"></a>C++ STL</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个栈</span></span><br><span class="line">stack &lt;<span class="keyword">typename</span>&gt; name;</span><br><span class="line"></span><br><span class="line"><span class="comment">//stack函数实例</span></span><br><span class="line">stack.<span class="built_in">push</span>(x);<span class="comment">//将元素x加入到栈中</span></span><br><span class="line">stack.<span class="built_in">top</span>();<span class="comment">//获取栈顶元素</span></span><br><span class="line">stack.<span class="built_in">pop</span>();<span class="comment">//将栈顶元素弹出</span></span><br><span class="line">stack.<span class="built_in">empty</span>();<span class="comment">//判断栈是否为空，返回值类型为空</span></span><br><span class="line">stack.<span class="built_in">size</span>();<span class="comment">//返回栈内元素</span></span><br></pre></td></tr></table></figure>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队列的定义</span></span><br><span class="line">queue&lt; <span class="keyword">typename</span> &gt; name;</span><br><span class="line"></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line"><span class="comment">//queue函数实例</span></span><br><span class="line">Q.<span class="built_in">push</span>(x);<span class="comment">//将元素x入队</span></span><br><span class="line">Q.<span class="built_in">front</span>();<span class="comment">//获取队首元素</span></span><br><span class="line">Q.<span class="built_in">back</span>();<span class="comment">//获取队尾元素</span></span><br><span class="line">Q.<span class="built_in">pop</span>();<span class="comment">//将队首元素出队</span></span><br><span class="line">Q.<span class="built_in">empty</span>();<span class="comment">//判断队列是否为空</span></span><br><span class="line">Q.<span class="built_in">size</span>();<span class="comment">//队列中元素的个数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="优先队列（Priority-queue）"><a href="#优先队列（Priority-queue）" class="headerlink" title="优先队列（Priority_queue）"></a>优先队列（Priority_queue）</h3><p>优先队列就是按照元素的优先级来确定对首部的元素的队列，它是由堆实现的，这种优先级的规则可以自定义。优先队列可以用于计算哈夫曼树最短路径权值，可以对Dijkstra算法进行优化，还可以解决一些贪心问题。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	priority_queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">	q.<span class="built_in">push</span>(<span class="number">3</span>);<span class="comment">//将3入队</span></span><br><span class="line">	q.<span class="built_in">empty</span>();<span class="comment">//检查队列是否为空</span></span><br><span class="line">	q.<span class="built_in">pop</span>();<span class="comment">//将优先级最高的元素出队</span></span><br><span class="line">	q.<span class="built_in">size</span>();<span class="comment">//队列的大小</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//第一个参数是元素类型，第二个是承载底层数据结构堆的容器，第三个是参数的比较类，less&lt;int&gt;表示数字越大优先级越高</span></span><br><span class="line">	priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt;q_1;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//当想以结构体中的数据作为优先级的时候，应该堆操作符进行重载</span></span><br><span class="line"><span class="comment">//使用时直接将相应的结构体定义的变量直接入队即可</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">fruit</span> {</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> price;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//价格高的优先级高</span></span><br><span class="line">	<span class="comment">//由于队列默认将优先级高的放在队首，如果将小于号重载为大于号，最后会将规则反向</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt; (fruit f1, fruit f2) {</span><br><span class="line">		<span class="keyword">return</span> f1.price &lt; f2.price;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以将比较函数写在结构体外面</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span>{	</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(fruit f1, fruit f2)</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> f1.price &gt; f2.price;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line">priority_queue&lt;fruit, vector&lt;<span class="type">int</span>&gt;, cmp&gt;p_2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当结构体数据较大应该使用引用来提高效率</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">friend bool operator &lt; (const fruit&amp; f1, const fruit&amp; f2) {</span></span><br><span class="line"><span class="comment">	....</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
<h2 id="pair采用方法"><a href="#pair采用方法" class="headerlink" title="pair采用方法"></a>pair采用方法</h2><p>pair可以用于快速定义一个相当于拥有两个变量的结构体。使用pair需要添加函数头utility.当然map函数头中包含前者。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个pair变量，并初始化</span></span><br><span class="line">pair&lt;typename1, typename2&gt;<span class="built_in">name</span>(initial1, initial2);</span><br><span class="line"><span class="comment">//定义一个临时pair变量</span></span><br><span class="line">name = <span class="built_in">make_pair</span>(initial1, initial2);</span><br></pre></td></tr></table></figure></p>
<h3 id="pair函数的操作"><a href="#pair函数的操作" class="headerlink" title="pair函数的操作"></a>pair函数的操作</h3><p><strong>比较两个pair函数</strong>:可以直接用比较符，规则是先比较第一个的大小，当相等时比较第二个元素的大小<br><strong>常见用途</strong>：1.代替二元结构体机器构造函数。2.作为map的键值进行插入。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	map&lt;string, <span class="type">int</span>&gt;mp;<span class="comment">//定义一个哈希表</span></span><br><span class="line">	<span class="comment">//往哈希表中插入两个对键值</span></span><br><span class="line">	mp.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">"hey"</span>, <span class="number">5</span>));</span><br><span class="line">	mp.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;string, <span class="type">int</span>&gt;(<span class="string">"Hei"</span>, <span class="number">10</span>));</span><br><span class="line">	<span class="comment">//利用迭代器遍历哈希表</span></span><br><span class="line">	<span class="keyword">for</span>(map&lt;string, <span class="type">int</span>&gt;::iterator it = mp.<span class="built_in">begin</span>();it != mp.<span class="built_in">end</span>();++it){</span><br><span class="line">		cout&lt;&lt;it-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h2><p>需要包含文件头vector 和using namespace std;<br>定义方式：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">typename</span>&gt; vector_name;</span><br></pre></td></tr></table></figure><br>操作：<br>1.获取元素的最后一个元素<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector_name.<span class="built_in">end</span>()<span class="number">-1</span>;<span class="comment">//注意end是指向最后一个元素的下一位</span></span><br><span class="line">vector_name.<span class="built_in">back</span>();</span><br><span class="line">vector_name.<span class="built_in">rbegine</span>();</span><br><span class="line">vector_name.<span class="built_in">at</span>(vector_name.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br></pre></td></tr></table></figure></p>
<h2 id="集合set"><a href="#集合set" class="headerlink" title="集合set"></a>集合set</h2><p>集合是一种内部有序且不含重复元素的容器。当数据加入到集合中是，会自动去重和排序，默认排序是从小到大。要使用集合需要加上set函数头，并且使用std名字空间。</p>
<p>定义方式：(其实容器定义的方式都大同小异)</p>
<blockquote>
<p>迭代器不是指针，是类模板，表现的像指针。他只是模拟了指针的一些功能，通过重载了指针的一些操作符，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.452ex;" xmlns="http://www.w3.org/2000/svg" width="20.49ex" height="2.149ex" role="img" focusable="false" viewbox="0 -750 9056.4 950"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mo" transform="translate(1055.8,0)"><path data-c="3E" d="M84 520Q84 528 88 533T96 539L99 540Q106 540 253 471T544 334L687 265Q694 260 694 250T687 235Q685 233 395 96L107 -40H101Q83 -38 83 -20Q83 -19 83 -17Q82 -10 98 -1Q117 9 248 71Q326 108 378 132L626 250L378 368Q90 504 86 509Q84 513 84 520Z"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(2111.6,0)"><g data-mml-node="mo"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">、</text></g></g><g data-mml-node="mo" transform="translate(3333.8,0)"><path data-c="2217" d="M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(4056,0)"><g data-mml-node="mo"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">、</text></g></g><g data-mml-node="mo" transform="translate(5278.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mo" transform="translate(6278.4,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(7056.4,0)"><g data-mml-node="mo"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">、</text></g></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(8056.4,0)"><g data-mml-node="mo"><path data-c="2014" d="M0 248V285H999V248H0Z"/></g></g></g></g></svg></mjx-container>等封装了指针<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="keyword">typename</span>&gt; name;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>访问方式：（集合只能通过迭代器访问）<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义迭代器</span></span><br><span class="line">set&lt;<span class="keyword">typename</span>&gt;::iterator it;</span><br><span class="line"></span><br><span class="line"><span class="comment">//除了vector和string之外，其他的STL都不支持*（it+1）的访问方式</span></span><br><span class="line"><span class="comment">//枚举</span></span><br><span class="line">set&lt;<span class="type">int</span>&gt;st;</span><br><span class="line"><span class="comment">//initialize</span></span><br><span class="line">.......</span><br><span class="line"><span class="keyword">for</span>(set&lt;<span class="type">int</span>&gt;::iterator it = st.<span class="built_in">begin</span>(); it != st.<span class="built_in">end</span>();it++){</span><br><span class="line">	<span class="built_in">visit</span>(*it);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><br>set常用的函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">insert</span>(x);<span class="comment">//将x加入set，并实现递增排序和去重(O(logN))</span></span><br><span class="line"><span class="built_in">find</span>(value);<span class="comment">//找到对应value的迭代器(O(logN))</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">erase</span>(it);<span class="comment">//删除迭代器所指的元素，可以通过find函数找到对应的迭代器</span></span><br><span class="line"><span class="built_in">erase</span>(value);<span class="comment">//删除值为value的元素。时间复杂度O(logN)</span></span><br><span class="line"><span class="built_in">erase</span>(first, last);<span class="comment">//删除区间元素，删除区间为[first, last)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">size</span>();<span class="comment">//set中元素的个数O（1）</span></span><br><span class="line"><span class="built_in">clear</span>();<span class="comment">//delete all elements within the set </span></span><br></pre></td></tr></table></figure><br>使用unordered_set,只进行去重而不进行排序，速度比set要快很多。</p>
<h2 id="字符串类型String"><a href="#字符串类型String" class="headerlink" title="字符串类型String"></a>字符串类型String</h2><p>string类型将字符串数组的一些常用操作封装起来，使用时需要添加文件头string（注意一点string和string.h是不一样的），还需要std的名字空间。<br>初始化<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//define &amp; initializing</span></span><br><span class="line">string str = <span class="string">"abc"</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Access</span></span><br><span class="line"><span class="comment">//1.By subindex</span></span><br><span class="line">str[<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<p>想要输入或者输出字符串，只能使用cin和cout。需要用printf输出，可以使用c_str()函数将string类型转换成字符串数组<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,str.<span class="built_in">c_str</span>());</span><br></pre></td></tr></table></figure><br>通过迭代器访问<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//define. It no needs typename </span></span><br><span class="line">string::iterator it;</span><br><span class="line"><span class="keyword">for</span>(string::iterator it = str.<span class="built_in">begin</span>(); it != str.<span class="built_in">end</span>();++it){</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%c"</span>, *it);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><br>string和vector一样，能够直接通过对迭代器加减某数字实现访问。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.<span class="built_in">begin</span>() + <span class="number">3</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="函数实例"><a href="#函数实例" class="headerlink" title="函数实例"></a>函数实例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//连接两string类型</span></span><br><span class="line">str3 = str2 + str1;</span><br><span class="line">str1 += str2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按照字典序比较两string类型的大小</span></span><br><span class="line">str1 &gt;= str2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回string类型的长度</span></span><br><span class="line">str.<span class="built_in">size</span>();</span><br><span class="line">str.<span class="built_in">length</span>();</span><br></pre></td></tr></table></figure>
<p>insert()函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str.<span class="built_in">insert</span>(pos,string);<span class="comment">//在str的第pos位插入stringO(N)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//str的3号位插入str2</span></span><br><span class="line">(prototype-&gt;)<span class="built_in">insert</span>(it,it2,it3);<span class="comment">//串[it2, it3)插入到it对应的位置上</span></span><br><span class="line">str.<span class="built_in">insert</span>(str.<span class="built_in">begin</span>() + <span class="number">3</span>, str2.<span class="built_in">begin</span>(), str2.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><br>erase()删除<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除单个元素</span></span><br><span class="line"><span class="built_in">erase</span>(it);<span class="comment">//删除元素的迭代器</span></span><br><span class="line"><span class="built_in">erase</span>(fist,last);<span class="comment">//删除区间[first, last)的元素</span></span><br><span class="line"><span class="built_in">erase</span>(pos,length);<span class="comment">//pos开始删除length个字符个数</span></span><br><span class="line"><span class="built_in">clear</span>();<span class="comment">//清空</span></span><br></pre></td></tr></table></figure><br>其他<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">substr</span>(pos,len);<span class="comment">//冲pos开始获取长度为len的子串</span></span><br><span class="line">string::npos; <span class="comment">//一个常数等于-1或者是unsigned_int的最大值，用于find函数失配的返回值</span></span><br><span class="line"><span class="built_in">find</span>(str2);<span class="comment">//找到str2在字符串中第一次出现的位置，找不到返回string::npos.时间复杂度O(nm)</span></span><br><span class="line"></span><br><span class="line">str.<span class="built_in">replace</span>(pos, len, str2);<span class="comment">//将str从pos位开始长度为len的子串替换成str2</span></span><br><span class="line">str.<span class="built_in">replace</span>(it1,it2,str2);<span class="comment">//把迭代器范围内[it1,it2)的子串换成str2</span></span><br></pre></td></tr></table></figure></p>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h3 id="链表的概念"><a href="#链表的概念" class="headerlink" title="链表的概念"></a>链表的概念</h3><p>链表的物理地址是可以是不连续的，但是链表逻辑上是连续的。链表包含两个部分，一个用于存储数据，一个用于存储下一个节点的内存地址，以保证逻辑上的连续。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链表的结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>{</span><br><span class="line">	<span class="keyword">typename</span> data;<span class="comment">//数据域</span></span><br><span class="line">	node* next;<span class="comment">//指针域</span></span><br><span class="line">};</span><br></pre></td></tr></table></figure></p>
<h3 id="链表节点的空间分配"><a href="#链表节点的空间分配" class="headerlink" title="链表节点的空间分配"></a>链表节点的空间分配</h3><p>为链表节点分配空间可以利用两种函数：malloc(C语言) 和new(C++)。但是在空间分配之后，需要队空间进行释放，否则在一些情况下就会导致<strong>内存泄漏</strong>（在一些大型程序中，可能会导致弃用的空间一直被占用，而使得无法申请新的空间）。</p>
<h4 id="malloc函数"><a href="#malloc函数" class="headerlink" title="malloc函数"></a>malloc函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typename</span>* p = (<span class="keyword">typename</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">typename</span>));</span><br><span class="line"><span class="comment">/*整个过程就是malloc函数申请一个于数据类型大小一致的空间，这个时</span></span><br><span class="line"><span class="comment">候返回的指针是void类型，然后将他强制转化成int类型，并分配给</span></span><br><span class="line"><span class="comment">typename指针。申请失败的时候会返回空指针</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//释放内存</span></span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="comment">//本质上就是将p指针指向空地址，原先的地址占用状态被修改</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="new运算符（推荐使用）"><a href="#new运算符（推荐使用）" class="headerlink" title="new运算符（推荐使用）"></a>new运算符（推荐使用）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//申请一个节点空间</span></span><br><span class="line"><span class="keyword">typename</span>* p = <span class="keyword">new</span> <span class="keyword">typename</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取消对该节点的占用</span></span><br><span class="line"><span class="built_in">delete</span>(p;</span><br></pre></td></tr></table></figure>
<h3 id="链表的基本操作"><a href="#链表的基本操作" class="headerlink" title="链表的基本操作"></a>链表的基本操作</h3><h4 id="创建链表（运用for语句实现）"><a href="#创建链表（运用for语句实现）" class="headerlink" title="创建链表（运用for语句实现）"></a>创建链表（运用for语句实现）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传入的数组为每个节点的数据域的值</span></span><br><span class="line"><span class="comment">//尾插法：需要一个链表最后一个节点的指针。</span></span><br><span class="line"><span class="function">node* <span class="title">create</span> <span class="params">(<span class="type">int</span> Array[])</span></span>{</span><br><span class="line">	node *p, *pre, *head;</span><br><span class="line">	head = <span class="keyword">new</span> node;<span class="comment">//创建头节点</span></span><br><span class="line">	head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	pre = head;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i){</span><br><span class="line">		<span class="comment">//创建新结点：1.申请空间；2.完成指针域和数据域的赋值</span></span><br><span class="line">		p = <span class="keyword">new</span> node;</span><br><span class="line">		p-&gt;data = Array[i];</span><br><span class="line">		p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//更新状态指针</span></span><br><span class="line">		pre-&gt;next = p;</span><br><span class="line">		pre = p;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">]</span><br><span class="line"><span class="comment">//注意一点在删除一个节点的时候需要有一个指向该节点的指针，以便后续删除该节点</span></span><br></pre></td></tr></table></figure>
<h3 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h3><p>静态链表的主要原理就是Hash。它利用数组的下标作为相应节点的地址，适用于节点地址是比较小的整数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态链表节点的定义方式</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>{</span><br><span class="line">	<span class="keyword">typename</span> data;</span><br><span class="line">	<span class="type">int</span> next;<span class="comment">//注意这里的地址是一个整型变量</span></span><br><span class="line">}node[size];</span><br></pre></td></tr></table></figure><br>需要注意一点：因为静态链表是由数组实现的，所以就可能需要对其进行排序，但是如果这时候结构体类型名和结构体变量名相同（是允许的），sort函数就与出现编译错误。<br>（例题：A1032）<br>静态链表的使用步骤：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义静态链表</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>{</span><br><span class="line">	<span class="type">int</span> address;</span><br><span class="line">	<span class="keyword">typename</span> data;</span><br><span class="line">	<span class="type">int</span> next;</span><br><span class="line">	XXX;<span class="comment">//节点的某些性质</span></span><br><span class="line">}node[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化静态链表:将性质量定义为正常情况达不到的数字</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAXN; ++i){</span><br><span class="line">	node[i].XXX = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//标记（针对性质操作）</span></span><br><span class="line"><span class="comment">//可以针对性质进行统计，标记</span></span><br><span class="line"><span class="type">int</span> p = begin, count = <span class="number">0</span>;<span class="comment">//用于开始遍历和统计</span></span><br><span class="line"><span class="keyword">while</span>(p != <span class="number">-1</span>){</span><br><span class="line">	XXX = <span class="number">1</span>;</span><br><span class="line">	count++;</span><br><span class="line">	p = node[p]-&gt;next;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//简化操作</span></span><br><span class="line"><span class="comment">//由于静态链表直接采用地址映射的方式，这可能会导致地址</span></span><br><span class="line"><span class="comment">//不是连续的，此时应该将有效节点转移到左端，可以通过排</span></span><br><span class="line"><span class="comment">//序（sort函数）来实现（结合初始化的值）</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><h3 id="深度优先搜索（DFS）"><a href="#深度优先搜索（DFS）" class="headerlink" title="深度优先搜索（DFS）"></a>深度优先搜索（DFS）</h3><p>深度优先遍历会优先解决一种情况下的所有情况之后，再去解决其他的情况。如果能将一个事件的各个情况写成树形结构，就可以很容易地通过这种方法解决。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">有n 件物品，每件物品的重量为w[i］，价值为c[i］。现在需要选出若干件物品放入一个容</span></span><br><span class="line"><span class="comment">量为V 的背包中，使得在选入背包的物品重量和不超过容量V 的前提下，让背包中物品的价</span></span><br><span class="line"><span class="comment">值之和最大，求最大价值。(l&lt;n&lt;20)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">30</span>;</span><br><span class="line"><span class="type">int</span> n;<span class="comment">//物品数量</span></span><br><span class="line"><span class="type">int</span> V;<span class="comment">//背包容量</span></span><br><span class="line"><span class="type">int</span> maxValue = <span class="number">0</span>;<span class="comment">//最大的价值</span></span><br><span class="line"><span class="type">int</span> w[maxn], c[maxn];<span class="comment">//分别为单个物品的重量个价值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//参数分别为物品编号，总质量，总价值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> sumW, <span class="type">int</span> sumC)</span></span>{</span><br><span class="line">	<span class="keyword">if</span> (index == n) {<span class="comment">//完成对所有物品的选用</span></span><br><span class="line">		<span class="keyword">if</span> (sumW &lt;= V &amp;&amp; sumC &gt; maxValue) {<span class="comment">//检查当前方案是否满足条件</span></span><br><span class="line">			maxValue = sumC;<span class="comment">//更新最大价值</span></span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//对index号的物品，有两种结果，放入背包或是不放入背包</span></span><br><span class="line">	<span class="built_in">DFS</span>(index + <span class="number">1</span>, sumW, sumC);<span class="comment">//不放入背包</span></span><br><span class="line">	<span class="built_in">DFS</span>(index + <span class="number">1</span>, sumW + w[index], sumC + c[index]);<span class="comment">//放入背包</span></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;V);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) {</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;w[i]);<span class="comment">//重量</span></span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) {</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;c[i]);<span class="comment">//价值</span></span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">DFS</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//从第零件物品开始，此时的价值和重量都是0</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, maxValue);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><br>注意到在加入index号的物品时，总重量发生变化，这可能会导致结果不满足条件，<u>如果能在进入递归之前能够进行检查，能够减少一些不必要的递归</u><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在递归之前加上判断条件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS_A</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> sumW, <span class="type">int</span> sumC)</span> </span>{</span><br><span class="line">	<span class="keyword">if</span>(index == n)<span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">DFS_A</span>(index + <span class="number">1</span>, sumW, sumC);</span><br><span class="line">	<span class="comment">//检查质量是否满足要求，以确定是否进入递归</span></span><br><span class="line">	<span class="keyword">if</span> (sumW + w[index] &lt;= V) {</span><br><span class="line">		<span class="keyword">if</span> (sumC + c[index] &gt; maxValue)maxValue = sumC + c[index];</span><br><span class="line">		<span class="built_in">DFS_A</span>(index + <span class="number">1</span>, sumW + w[index], sumC + c[index]);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></table></figure><br>深度优先遍历的方法可以用于解决获取最优“子序列”的问题，也就是满足基本条件下的最优序列。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">问题描述：给定N个整数，从中选择K个数，使这K个数之和恰好等于给定的整数X，求出元素</span></span><br><span class="line"><span class="comment">平方和最大的结果</span></span><br><span class="line"><span class="comment">算法思想：利用一个数组，将已经选择的整数放入其中，当选择index号数字时，将</span></span><br><span class="line"><span class="comment">这个数字加入到数组中，进入递归，之后再将这个数字取出，进入不选择index号数</span></span><br><span class="line"><span class="comment">的递归。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k, x, maxSumSqu = <span class="number">-1</span>, A[maxn];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;temp, ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS_BSqu</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> nowK, <span class="type">int</span> sum, <span class="type">int</span> sumSqu)</span> </span>{</span><br><span class="line">	<span class="keyword">if</span> (nowK == k &amp;&amp; sum == x) {</span><br><span class="line">		<span class="keyword">if</span> (sumSqu &gt; maxSumSqu) {</span><br><span class="line">			maxSumSqu = sumSqu;</span><br><span class="line">			ans = temp;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (index == n || nowK &gt; k || sum &gt; x)<span class="keyword">return</span>;</span><br><span class="line">	temp.<span class="built_in">push_back</span>(A[index]);</span><br><span class="line">	<span class="built_in">DFS_BSqu</span>(index + <span class="number">1</span>, nowK + <span class="number">1</span>, sum + A[index], sumSqu + A[index] * A[index]);</span><br><span class="line">	temp.<span class="built_in">pop_back</span>();</span><br><span class="line">	<span class="built_in">DFS_BSqu</span>(index + <span class="number">1</span>, nowK, sum, sumSqu);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="广度优先"><a href="#广度优先" class="headerlink" title="广度优先"></a>广度优先</h3><p>广度优先类似于先解决简单的问题（离起点最近）然后再一步步深入。广度优先会先遍历所有的情况，对于求最优解的情况有优势。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">问题描述：给定一个n*m大小的迷宫，其中*代表不可通过的墙</span></span><br><span class="line"><span class="comment">壁，而“.”代表平地，S表示起点，T代表终点。移动过程中，如</span></span><br><span class="line"><span class="comment">果当前位置是（x,y）（下标从0开始），且每次只能往前上下</span></span><br><span class="line"><span class="comment">左右移动，求从起点到终点的最小步数。</span></span><br><span class="line"><span class="comment">算法思想：可以将迷宫当作树型结构，将迷宫的起点作为树的</span></span><br><span class="line"><span class="comment">根节点现在问题转换成找到迷宫终点所在树的层数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> x, y;<span class="comment">//记录当前的位置</span></span><br><span class="line">	<span class="type">int</span> step;<span class="comment">//步数（层数）</span></span><br><span class="line">}S,T,Node;<span class="comment">//分别为起点，重点，临时节点</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;<span class="comment">//分别为行，列</span></span><br><span class="line"><span class="type">char</span> maze[maxn][maxn];<span class="comment">//迷宫信息</span></span><br><span class="line"><span class="type">bool</span> inq[maxn][maxn] = { <span class="literal">false</span> };<span class="comment">//检查此位置是否遍历过</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//增量数组，XY组合表示一个节点上下左右四个方向的位置</span></span><br><span class="line"><span class="type">int</span> X[<span class="number">4</span>] = { <span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span> };</span><br><span class="line"><span class="type">int</span> Y[<span class="number">4</span>] = { <span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span> };</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查（x,y）这个位置是否应该入队</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">test</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>{</span><br><span class="line">	<span class="comment">//超出边界</span></span><br><span class="line">	<span class="keyword">if</span> (x &gt;= n || x &lt; <span class="number">0</span> || y &gt;= m || y &lt; <span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="comment">//遇到墙壁</span></span><br><span class="line">	<span class="keyword">if</span> (maze[x][y] == <span class="string">'*'</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="comment">//检查是否入队。入队则是之前访问过的位置</span></span><br><span class="line">	<span class="keyword">if</span> (inq[x][y] == <span class="literal">true</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//表示该位置有效</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BFS</span><span class="params">()</span> </span>{</span><br><span class="line">	queue&lt;node&gt;q;</span><br><span class="line">	q.<span class="built_in">push</span>(S);<span class="comment">//将起点加入到队列中</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断当前访问的位置（出队的位置）是否为终点</span></span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) {</span><br><span class="line">		node top = q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="comment">//该位置为终点，直接返回此时的深度</span></span><br><span class="line">		<span class="keyword">if</span> (top.x == T.x &amp;&amp; top.y == T.y) {</span><br><span class="line">			<span class="keyword">return</span> top.step;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="comment">//检查该位置4个方向上的情况</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) {</span><br><span class="line">			<span class="type">int</span> newX = top.x + X[i];</span><br><span class="line">			<span class="type">int</span> newY = top.y + Y[i];</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">test</span>(newX, newY)) {</span><br><span class="line">				<span class="comment">//新节点，更新相关的信息</span></span><br><span class="line">				Node.x = newX, Node.y = newY;</span><br><span class="line">				Node.step = Node.step + <span class="number">1</span>;</span><br><span class="line">				q.<span class="built_in">push</span>(Node);</span><br><span class="line">				inq[newX][newY] = <span class="literal">true</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>{</span><br><span class="line">	<span class="comment">//迷宫规格</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="comment">//传入迷宫信息</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) {</span><br><span class="line">		<span class="built_in">getchar</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) {</span><br><span class="line">			maze[i][j] = <span class="built_in">getchar</span>();</span><br><span class="line">		}</span><br><span class="line">		maze[i][m + <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;S.x, &amp;S.y, &amp;T.x, &amp;T.y);</span><br><span class="line">	S.step = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="built_in">BFS</span>());</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>值得注意的一点，当将一个元素push入队的时候，其本质就是将该元素的一个副本入队，所以，队列中的元素和原数据来源是相互独立的。</p>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>二叉树可以通过递归的方式定义，也就是可以将二叉树的子树看作一个新的二叉树。注意一点，二叉树的左右节点是由严格区分的。</p>
<h3 id="二叉树的存储和操作"><a href="#二叉树的存储和操作" class="headerlink" title="二叉树的存储和操作"></a>二叉树的存储和操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树结构体的定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>{</span><br><span class="line">	<span class="keyword">typename</span> data;</span><br><span class="line">	node* lchild;</span><br><span class="line">	node* rchild;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">node* root = <span class="literal">NULL</span>;<span class="comment">//建树之前根节点不存在，将其设为NULL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//新建节点:申请空间，赋值，初始化，返回节点地址</span></span><br><span class="line"><span class="function">node* <span class="title">newNode</span><span class="params">(<span class="type">int</span> v)</span></span>{</span><br><span class="line">	node* Node = <span class="keyword">new</span> node;</span><br><span class="line">	Node-&gt;data = v;</span><br><span class="line">	Node-&gt;lchild = Node-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> Node;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//搜索节点:检查特殊情况和满足条件的情况，然后用同样的方法检查其他的节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">search</span><span class="params">(node* root, <span class="type">int</span> x, <span class="type">int</span> newdata)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>)<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(root-&gt;data == x)root-&gt;data = newdata;</span><br><span class="line">	<span class="built_in">search</span>(root-&gt;lchild, x, newdata);</span><br><span class="line">	<span class="built_in">search</span>(root-&gt;rchild, x, newdata);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树节点的插入,注意这里输入的参数是引用型的，因为要对这个树进行修改</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(node* &amp;root, <span class="type">int</span> x)</span></span>{</span><br><span class="line">	<span class="comment">//查找失败，这就是要插入节点的地方</span></span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>){</span><br><span class="line">		root = <span class="built_in">newNode</span>(x);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(根据条件检查检索的方向)<span class="built_in">insert</span>(root-&gt;lchild,x);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">insert</span>(root-&gt;rchild,x);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树的建立</span></span><br><span class="line"><span class="function">node* <span class="title">Create</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> n)</span></span>{</span><br><span class="line">	node* root = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i){</span><br><span class="line">		<span class="built_in">insert</span>(root,data[i]);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p><img src="https://img-blog.csdnimg.cn/20210401083819611.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*中序遍历（非递归）：先找到最左边的节点，在寻找的过程中将途中的节点加入到栈中，当遇到根节点的时候，</span></span><br><span class="line"><span class="comment">取出栈顶元素（这一步相当于回溯），访问其右节点，然后继续原先的循环</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrderWithoutRecursion2</span><span class="params">(BTNode* root)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">//空树</span></span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">//树非空</span></span><br><span class="line">	BTNode* p = root;</span><br><span class="line">	stack&lt;BTNode*&gt; s;</span><br><span class="line">	<span class="keyword">while</span> (!s.<span class="built_in">empty</span>() || p)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (p)</span><br><span class="line">		{</span><br><span class="line">			s.<span class="built_in">push</span>(p);</span><br><span class="line">			p = p-&gt;lchild;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			p = s.<span class="built_in">top</span>();</span><br><span class="line">			s.<span class="built_in">pop</span>();</span><br><span class="line">			cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">4</span>) &lt;&lt; p-&gt;data;</span><br><span class="line">			p = p-&gt;rchild;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">先序遍历（非递归）：在访问头节点的同时先将右节点加入到栈中，然后再继续访问左子树。当没有左孩子的时候</span></span><br><span class="line"><span class="comment">访问右节点，表现为取出栈顶元素，进行访问</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrderWithoutRecursion</span><span class="params">(BTNode* root)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>)<span class="keyword">return</span>;</span><br><span class="line">	stack&lt;BTNode*&gt;s;</span><br><span class="line">	BTNode* p = root;</span><br><span class="line">	s.<span class="built_in">push</span>(root);</span><br><span class="line">	<span class="keyword">while</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">visit</span>(p);</span><br><span class="line">		<span class="keyword">if</span>(p-&gt;rchild)s.<span class="built_in">push</span>(p-&gt;rchild);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(p-&gt;lchild)p = p-&gt;lchild;</span><br><span class="line">		<span class="keyword">else</span>{<span class="comment">//访问右子树</span></span><br><span class="line">			p = s.<span class="built_in">top</span>();</span><br><span class="line">			s.<span class="built_in">pop</span>();</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">后序遍历（非递归）：后序遍历有一个问题，需要当前访问的节点是父节点的左孩子还是右孩子，如果是左孩子，就访问</span></span><br><span class="line"><span class="comment">右孩子，否则访问头节点。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postOrderWithoutRecursion</span><span class="params">(BTNode* root)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>)<span class="keyword">return</span>;</span><br><span class="line">	stack&lt;BTNode*&gt;s;</span><br><span class="line">	BTNode* pCur, *pLastVisit;</span><br><span class="line"></span><br><span class="line">	pCur = root;</span><br><span class="line">	pLastVisit = <span class="literal">NULL</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//Find out the leftmost element of the tree.</span></span><br><span class="line">	<span class="keyword">while</span>(pCur){</span><br><span class="line">		s.<span class="built_in">push</span>(pCur);</span><br><span class="line">		pCur = pCur-&gt;lchild;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">while</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">	{</span><br><span class="line">		pCur = s.<span class="built_in">top</span>();</span><br><span class="line">		s.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//访问头节点的条件：无右孩子或者是右孩子已经被访问</span></span><br><span class="line">		<span class="keyword">if</span>(pCur-&gt;rchild == <span class="literal">NULL</span> || pCur-&gt;rchild == pLastVisit){</span><br><span class="line">			<span class="built_in">visit</span>(pCur);</span><br><span class="line">			pLastVisit = pCur;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span>{</span><br><span class="line">			s.<span class="built_in">push</span>(pCur);</span><br><span class="line">			pCur = pCur-&gt;rchild;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//找到右子树的最左边的节点</span></span><br><span class="line">			<span class="keyword">while</span>(pCur){</span><br><span class="line">				s.<span class="built_in">push</span>(pCur);</span><br><span class="line">				pCur = pCur-&gt;lchild;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归版</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">xOrder</span><span class="params">(node* root)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>)<span class="keyword">return</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//'* = printf("%d\n",root-&gt;data);</span></span><br><span class="line">	*<span class="comment">//前序遍历</span></span><br><span class="line">	<span class="built_in">xOrder</span>(root-&gt;lchild);</span><br><span class="line">	*<span class="comment">//中序遍历</span></span><br><span class="line">	<span class="built_in">xOrder</span>(root-&gt;rchild);</span><br><span class="line">	*<span class="comment">//后序遍历</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//层次遍历:每次完成一个节点的遍历，就需要检查其是否为叶子节点，否则加入到队列中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LayerOrder</span><span class="params">(node* root)</span></span>{</span><br><span class="line">	queue&lt;node*&gt;q;</span><br><span class="line">	q.<span class="built_in">push</span>(root);</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>()){</span><br><span class="line">		node* now = q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d"</span>,now-&gt;data);</span><br><span class="line">		<span class="keyword">if</span>(now-&gt;lchild != <span class="literal">NULL</span>)q.<span class="built_in">push</span>(now-&gt;lchhild);</span><br><span class="line">		<span class="keyword">if</span>(now-&gt;rchild != <span class="literal">NULL</span>)q.<span class="built_in">push</span>(now-&gt;rchild);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果还想要直到当前节点所在的层数，可以在结构体中做好标记</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>{</span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">	<span class="type">int</span> layer;</span><br><span class="line">	node* lchild;</span><br><span class="line">	node* rchild;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LayerOrder</span><span class="params">(node* root)</span></span>{</span><br><span class="line">	queue&lt;node*&gt;<span class="number">1</span>;</span><br><span class="line">	root-&gt;layer = <span class="number">1</span>;</span><br><span class="line">	q.<span class="built_in">push</span>(root);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>()){</span><br><span class="line">		node* now = q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d"</span>,now-&gt;data);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//更新节点信息之后，再将节点入队</span></span><br><span class="line">		<span class="keyword">if</span>(now-&gt;lchild != <span class="literal">NULL</span>){</span><br><span class="line">			now-&gt;lchild-&gt;layer = now-&gt;layer + <span class="number">1</span>;</span><br><span class="line">			q.<span class="built_in">push</span>(now-&gt;lchild);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(now-&gt;rchild != <span class="literal">NULL</span>){</span><br><span class="line">			now-&gt;rchild-&gt;layer = now-&gt;layer + <span class="number">1</span>;</span><br><span class="line">			q.<span class="built_in">push</span>(now-&gt;rchild);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="树的静态实现-非二叉树"><a href="#树的静态实现-非二叉树" class="headerlink" title="树的静态实现(非二叉树)"></a>树的静态实现(非二叉树)</h3><p>实现静态写法是为了避免指针可能带来的错误。主要的思想就是将树的孩子节点存储在一个向量（“变长数组”）中。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>{</span><br><span class="line">	<span class="keyword">typename</span> data;</span><br><span class="line">	vector&lt;node&gt; child;<span class="comment">//??</span></span><br><span class="line">}Node[maxn];</span><br><span class="line"><span class="comment">//如果不需要数据域，可以用如下方法定义</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;child[maxn];<span class="comment">//这里定义了maxn个向量</span></span><br></pre></td></tr></table></figure></p>
<h3 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先序遍历：先访问节点，之后递归地遍历其孩子节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(<span class="type">int</span> root)</span></span>{</span><br><span class="line">	<span class="built_in">visit</span>(root);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; Node[root].child.<span class="built_in">size</span>();++i){</span><br><span class="line">		<span class="built_in">PreOrder</span>(Node[root].child[i]);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="comment">//层序遍历：先访问头节点，然后将孩子节点入队，直到队列为空</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LayerOrder</span><span class="params">(<span class="type">int</span> root)</span></span>{</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt;Q;</span><br><span class="line">	Q.<span class="built_in">push</span> (root);</span><br><span class="line">	<span class="keyword">while</span>(!Q.<span class="built_in">empty</span>()){</span><br><span class="line">		<span class="type">int</span> front = Q.<span class="built_in">front</span>();</span><br><span class="line">		Q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="built_in">visit</span>(Q);</span><br><span class="line">		<span class="comment">//下面是访问该节点所有孩子节点的方法</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; Node[front].child.<span class="built_in">size</span>();++i){</span><br><span class="line">			Q.<span class="built_in">push</span>(Node[front].child[i]);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h3><p>二叉查找树是节点按照一定规律排列的树，根节点的数据域大于或者小于左右孩子节点的数据域。同时二叉查找树还可以是一个空树。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉查找树的操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//新建一个节点：申请空间，赋值初始化，返回节点地址</span></span><br><span class="line"><span class="function">node* <span class="title">newNode</span><span class="params">(<span class="type">int</span> v)</span></span>{</span><br><span class="line">	node* Node = <span class="keyword">new</span> node;</span><br><span class="line">	Node-&gt;data = v;</span><br><span class="line">	Node-&gt;lchild = Node -&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> Node;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找二叉查找树中数据域为x的节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">search</span> <span class="params">(node* root, <span class="type">int</span> x)</span></span>{</span><br><span class="line">	<span class="comment">//递归出口</span></span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>){</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"search failed\n"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//根据当前节点值得情况，决定递归方向</span></span><br><span class="line">	<span class="keyword">if</span>(x == root-&gt;data)<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,root-&gt;data);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(x &lt; root-&gt;data) <span class="built_in">search</span>(root-&gt;lchild, x);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">search</span>(root-&gt;rchild, x);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入一个数据域为x的新节点（注意这里的root是需要引用，后续修改）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span> <span class="params">(node* &amp;root, <span class="type">int</span> x)</span></span>{</span><br><span class="line">	<span class="comment">//当查找失败的时候，这个地方即为节点插入的位置</span></span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>){</span><br><span class="line">		root = <span class="built_in">newNode</span>(x);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//由数据域的情况决定递归的方向</span></span><br><span class="line">	<span class="keyword">if</span>(x == root-&gt;data)<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(x &lt; root-&gt;data)<span class="built_in">insert</span>(root-&gt;lchild, x);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">insert</span>(root-&gt;rchild, x);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉查找树的建立</span></span><br><span class="line"><span class="function">node* <span class="title">Crate</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> n)</span></span>{</span><br><span class="line">	node* root = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//将数组数据找到一个合适的地方插入</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)<span class="built_in">insert</span>(root,data[i]);</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉查找树的删除</span></span><br><span class="line"><span class="comment">//可以用根节点的前去或者后继来代替被删除的头节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//找到极值点的过程就是不断向左或者向右的过程，直到遇到空节点</span></span><br><span class="line"><span class="comment">//找到以root为头节点的最大全职的节点</span></span><br><span class="line"><span class="function">node* <span class="title">findMax</span><span class="params">(node* root)</span></span>{</span><br><span class="line">	<span class="keyword">while</span>(root-&gt;child != <span class="literal">NULL</span>)root = root -&gt; rchild;</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//找到权值最小的节点</span></span><br><span class="line"><span class="function">node* <span class="title">findMin</span><span class="params">(node* root)</span></span>{</span><br><span class="line">	<span class="keyword">while</span>(root-&gt;lchild != <span class="literal">NULL</span>)root = root-&gt;lchild;</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除节点：想用前驱后者后继节点覆盖要删除的节点，然后问题就转换成删除前驱或后继节点</span></span><br><span class="line"><span class="comment">//先找到想要删除的节点，然后判断节点的类型，然后再进行相应的递归操作</span></span><br><span class="line"><span class="comment">//删除以root为根节点的权值为x的节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteNode</span><span class="params">(node* &amp;root, <span class="type">int</span> x)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>)<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">//找到需要删除的节点</span></span><br><span class="line">	<span class="keyword">if</span>(root-&gt;data == x){</span><br><span class="line">		<span class="comment">//当需要删除的节点为叶节点，直接删除</span></span><br><span class="line">		<span class="keyword">if</span>(root-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; root-&gt;rchild == <span class="literal">NULL</span>)root = <span class="literal">NULL</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//左孩子非空，则用右孩子的极值替换该节点，然后删除该极值节点</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;lchild != <span class="literal">NULL</span>){</span><br><span class="line">			node* pre = <span class="built_in">findMax</span>(root-&gt;lchild);</span><br><span class="line">			root-&gt;data = pre-&gt;data;</span><br><span class="line">			<span class="built_in">deleteNode</span>(root-&gt;lchild,pre-&gt;data);</span><br><span class="line">		}</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//右孩子非空，操作同上</span></span><br><span class="line">		<span class="keyword">else</span>{</span><br><span class="line">			node* next = <span class="built_in">findMin</span>(root-&gt;rchild);</span><br><span class="line">			root-&gt;data = next -&gt; data;</span><br><span class="line">			<span class="built_in">deleteNode</span>(root-&gt;rchild, next-&gt;data);</span><br><span class="line">		}</span><br><span class="line">	<span class="comment">//寻找需要删除的节点</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;data &gt; x)<span class="built_in">deleteNode</span>(root-&gt;lshild,x);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">deleteNode</span>(root-&gt;rchild, x);</span><br><span class="line">	}	</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>对于删除节点的操作，可以进行优化，主要里利用极值节点坑定没有左子树或右子树的性质，将该极值节点的子树直接连接到该极值节点的父节点上即可。<br>加入一直删除前驱或者后继，就会导致最后树变得十分不平衡，解决这个方法可以采取交替删除前驱后继或者是记录子树高度，优先在高度更高的的子树中删除节点。</p>
<h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>平衡二叉树是左右子树高度相差不超过1的二叉树。这样的结构可以保证在大多数操作下保持O(logn)的性能。因为当二叉树严重失衡时，二叉树退化成链表，此时操作的时间复杂度变为O(n)。在平衡二叉树中，右子树与左子树的高度之差称为该节点的<strong>平衡因子</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//节点结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>{</span><br><span class="line">	<span class="type">int</span> v, height;<span class="comment">//节点权值和子树高度</span></span><br><span class="line">	node* lchild, *rchild; </span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成一个新的节点</span></span><br><span class="line"><span class="function">node* <span class="title">newNode</span><span class="params">(<span class="type">int</span> v)</span></span>{</span><br><span class="line">	node* Node = <span class="keyword">new</span> node;<span class="comment">//申请节点空间</span></span><br><span class="line">	Node-&gt;v = v;<span class="comment">//节点权值</span></span><br><span class="line">	Node-&gt;height = <span class="number">1</span>;<span class="comment">//该节点本身的高度</span></span><br><span class="line">	Node-&gt;lchild = Node-&gt;rchild = <span class="literal">NULL</span>;<span class="comment">//初始化孩子节点</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取当前树的高度:从结构体变量中获取</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getHeight</span><span class="params">(node* root)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> root-&gt;height;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算平衡因子:左子树高度减去右子树高度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getBalanceFactor</span><span class="params">(node* root)</span></span>{</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">getHeight</span>(root-&gt;lchild) - <span class="built_in">getHeight</span>(root-&gt;rchild);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新当前节点的高度:孩子节点的最大高度加上节点本身</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateHeight</span><span class="params">(node* root)</span></span>{</span><br><span class="line">	root-&gt;height = <span class="built_in">max</span>(<span class="built_in">getHeight</span>(root-&gt;lchild), <span class="built_in">getHeight</span>(root-&gt;rchild)) + <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//ALV的查找操作与二叉排序树的操作完全一致</span></span><br></pre></td></tr></table></figure>
<p>对于ALV的插入操作，要根据树的结构做出相应的不同的操作。（BF：Balance Factor）<br>树型| 判定条件|调整方法|<br>—|———-|————-<br>LL| BF(root) = 2;BF(root-&gt;lchild) = 1|对root进行右旋|<br>LR|BF(root) = 2;BF(root-&gt;lchild) = -1|先对root-&gt;lchild进行左旋后对root进行右旋<br>RR|BF(root) = -2;BF(root-&gt;lchild) = -1|对root进行左旋<br>RL|BF(root) = -2;BF(root-&gt;lchild) = 1|先对右子树进行右旋，再对root左旋<br>通过表格，可以总结：L代表根节点是正数，R代表孩子节点的负数。<br>下图时LL和LR型的树的调整示意图<br><img src="https://img-blog.csdnimg.cn/20210223093952989.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210223094002206.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>注意到LR型是将LR先左旋转换成LL型的二叉树然后再执行右旋的，所以LR型的二叉树的调整可以由基本的左旋右旋组合而来。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左旋:将右孩子的左孩子连接到头节点处，其原先的左孩子连接到原先的头节点的右孩子处</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">L</span><span class="params">(node*&amp; root)</span></span>{</span><br><span class="line">	node* temp = root-&gt;rchild;</span><br><span class="line">	root-&gt;rchild = temp-&gt;lchild;</span><br><span class="line">	temp-&gt;lchild = root;</span><br><span class="line">	<span class="comment">//跟新调整之后的节点高度</span></span><br><span class="line">	<span class="built_in">updateHeight</span>(root);</span><br><span class="line">	<span class="built_in">uodateHeight</span>(temp);</span><br><span class="line">	root = temp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//右旋</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">R</span><span class="params">(node*&amp; root)</span></span>{</span><br><span class="line">	node* temp = root-&gt;lchild;</span><br><span class="line">	root-&gt;lchild = temp-&gt;rchild;</span><br><span class="line">	temp-&gt;rchild = root;</span><br><span class="line">	<span class="built_in">updateHeight</span>(root);</span><br><span class="line">	<span class="built_in">uodateHeight</span>(temp);</span><br><span class="line">	root = temp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入节点：找到插入的位置，判断插入后树的类型，然后再做相应的操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span> <span class="params">(node*&amp;root,<span class="type">int</span> v)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>){</span><br><span class="line">		root = <span class="built_in">newNode</span>(v);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//节点小，则在左子树中插入</span></span><br><span class="line">	<span class="keyword">if</span>(v &lt; root-&gt;v){</span><br><span class="line">		<span class="built_in">insert</span>(root-&gt;lchild,v);</span><br><span class="line">		<span class="comment">//更新节点信息，</span></span><br><span class="line">		<span class="built_in">updateHeight</span>(root);</span><br><span class="line">		<span class="comment">//L</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">getBalanceFactor</span>(root) == <span class="number">2</span>){</span><br><span class="line">			<span class="comment">//LL</span></span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">getBalanceFactor</span>(root-&gt;lchild)==<span class="number">1</span>) <span class="built_in">R</span>(root);</span><br><span class="line">			<span class="comment">//LR</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">getBalanceFactor</span>(root-&gt;lchild)==<span class="number">-1</span>){</span><br><span class="line">			<span class="built_in">L</span>(root-&gt;lchild);</span><br><span class="line">			<span class="built_in">R</span>(root);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span>{</span><br><span class="line">		<span class="comment">//从右子树中插入节点</span></span><br><span class="line">		<span class="built_in">insert</span>(root-&gt;rchild,v);</span><br><span class="line">		<span class="built_in">updateHeight</span>(root);</span><br><span class="line">		<span class="comment">//R</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">getBalanceFactor</span>(root) == <span class="number">-2</span>){</span><br><span class="line">			<span class="comment">//RR</span></span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">getBalanceFactor</span>(root-&gt;rchild)==<span class="number">-1</span>)<span class="built_in">L</span>(root);</span><br><span class="line">			<span class="comment">//RL</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">getBalanceFactor</span>(root-&gt;rchild) == <span class="number">1</span>){</span><br><span class="line">				<span class="built_in">R</span>(root-&gt;rchild);</span><br><span class="line">				<span class="built_in">L</span>(root);</span><br><span class="line">			}<span class="comment">//else if</span></span><br><span class="line">		}<span class="comment">//if</span></span><br><span class="line">	}<span class="comment">//else</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">//AVL树的建立</span></span><br><span class="line"><span class="function">node* <span class="title">Create</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> n)</span></span>{</span><br><span class="line">	node* root = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)<span class="built_in">insert</span>(root,data[i]);</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><blockquote>
<p>在计算机科学中，并查集（英文：Disjoint-set data structure，直译为不交集数据结构）是一种数据结构，用于处理一些不交集（Disjoint sets，一系列没有重复元素的集合）的合并及查询问题。并查集支持如下操作：<br>查询：查询某个元素属于哪个集合，通常是返回集合内的一个“代表元素”。这个操作是为了判断两个元素是否在同一个集合之中。<br>合并：将两个集合合并为一个。<br>添加：添加一个新集合，其中有一个新元素。添加操作不如查询和合并操作重要，常常被忽略。</p>
</blockquote>
<p>以下是并查集得一些基本操作。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> father[N];</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initialSet</span><span class="params">(<span class="type">int</span> father[], <span class="type">int</span> N)</span> </span>{</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) {</span><br><span class="line">		father[i] = i;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找:根节点的父节点就是其本身</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findFather</span><span class="params">(<span class="type">int</span> x)</span> </span>{</span><br><span class="line">	<span class="keyword">while</span> (x != father[x]) {</span><br><span class="line">		x = father[x];</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//递归版本</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findFatherRe</span><span class="params">(<span class="type">int</span> x)</span> </span>{</span><br><span class="line">	<span class="comment">//递归出口</span></span><br><span class="line">	<span class="keyword">if</span> (x == father[x])<span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">findFather</span>(father[x]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//并查集合并：先判断两节点是否再同一并查集中（判断根节点是否相同），然后再将其中一个根节点的父节点指向另一个根节点</span></span><br><span class="line"><span class="comment">//这样能能够保证并查集是个树型结构，不会出现环</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>{</span><br><span class="line">	<span class="type">int</span> faA = <span class="built_in">findFather</span>(a);</span><br><span class="line">	<span class="type">int</span> faB = <span class="built_in">findFather</span>(b);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//当二者不是统一并查集时合并</span></span><br><span class="line">	<span class="keyword">if</span> (faA != faB){</span><br><span class="line">		father[faA] = father[faB];</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//路径压缩：将搜索的时间复杂度由O(n)变为O(1)，其实就是将所有节点的父节点全部指向根节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findFatherPatheShorten</span><span class="params">(<span class="type">int</span> x)</span></span>{</span><br><span class="line">	<span class="type">int</span> a = x;<span class="comment">//找到根节点，同时保存初始节点</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//找到根节点</span></span><br><span class="line">	<span class="keyword">while</span> (x != father[x]) {</span><br><span class="line">		x = father[x];</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//将该节点的父节点指向根节点，并保存该节点原先的父节点的信息</span></span><br><span class="line">	<span class="keyword">while</span> (a != father[a]) {</span><br><span class="line">		<span class="type">int</span> z = a;</span><br><span class="line">		a = father[a];</span><br><span class="line">		father[z] = x;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归版本</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findFatherRSRec</span><span class="params">(<span class="type">int</span> v)</span> </span>{</span><br><span class="line">	<span class="keyword">if</span> (v == father[v])<span class="keyword">return</span> v;</span><br><span class="line">	<span class="keyword">else</span>{</span><br><span class="line">		<span class="type">int</span> F = <span class="built_in">findFather</span>(father[v]);</span><br><span class="line">		father[v] = F;</span><br><span class="line">		<span class="keyword">return</span> F;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>堆本质上就是满足父节点大于（或小于）孩子节点的二叉树。所有节点存储在一个数组当中，这样i节点的孩子节点分别为$2<em>i<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.452ex;" xmlns="http://www.w3.org/2000/svg" width="2.262ex" height="2.149ex" role="img" focusable="false" viewbox="0 -750 1000 950"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">和</text></g></g></g></svg></mjx-container>2</em>i+1$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> heap[maxn], n = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span> </span>{</span><br><span class="line">	<span class="type">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//向下调整O(logn)：从low到high。找出该节点得该子节点中最大得节点，然后于该节点进行比较，若孩子节点较大，则与孩子节点进行交换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">downAdjust</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high)</span> </span>{</span><br><span class="line">	<span class="type">int</span> i = low, j = i * <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">while</span> (j &lt;= high) {</span><br><span class="line">		<span class="comment">//找出孩子节点中较大的</span></span><br><span class="line">		<span class="keyword">if</span> (j + <span class="number">1</span> &lt;= high &amp;&amp; heap[j + <span class="number">1</span>] &gt; heap[j]) ++j;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//与父节点进行比较</span></span><br><span class="line">		<span class="keyword">if</span> (heap[j] &gt; heap[i]) {</span><br><span class="line">			<span class="built_in">swap</span>(heap[j], heap[i]);</span><br><span class="line">			i = j;</span><br><span class="line">			j = i * <span class="number">2</span>;<span class="comment">//这里只去检查被调整的元素是否满足堆的条件，因为为改动的节点应该是满足堆的要求的</span></span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span>{</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//建堆O(n):从最后一个非叶节点往后进行循环，这是对原先数组进行了排序，以满足堆的要求</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createHeap</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span>; i &gt;= <span class="number">1</span>; --i)<span class="built_in">downAdjust</span>(i, n);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除堆顶元素O(logn)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteTop</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="comment">//将最后一个元素代替堆顶元素，然后减少节点数量</span></span><br><span class="line">	heap[<span class="number">1</span>] = heap[n--];</span><br><span class="line">	<span class="built_in">downAdjust</span>(<span class="number">1</span>, n);<span class="comment">//改动了这个节点就从这个节点进行调整</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//向上调整：当插入一个节点的时候，这个节点被放到最后，逐个与其父节点比较，直到该节点小于父节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upAdjust</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high)</span></span>{</span><br><span class="line">	<span class="type">int</span> i = high, j = i / <span class="number">2</span>;<span class="comment">//high就是最后一个节点，即插入的节点</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//父节点在范围之内</span></span><br><span class="line">	<span class="keyword">while</span> (j &gt;= low) {</span><br><span class="line">		<span class="keyword">if</span> (heap[j] &lt; heap[i]) {</span><br><span class="line">			<span class="built_in">swap</span>(heap[j], heap[i]);</span><br><span class="line">			i = j;</span><br><span class="line">			j = i / <span class="number">2</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加元素，借用上面的函数:加入节点，然后进行相应的调整</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span> </span>{</span><br><span class="line">	heap[++n] = x;</span><br><span class="line">	<span class="built_in">upAdjust</span>(<span class="number">1</span>, n);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//堆排序:将头节点与最后一个节点进行交换，然后对堆进行调整</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="built_in">createHeap</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt; <span class="number">1</span>; i--){</span><br><span class="line">		<span class="built_in">swap</span>(heap[i], heap[<span class="number">1</span>]);</span><br><span class="line">		<span class="built_in">downAdjust</span>(<span class="number">1</span>, i - <span class="number">1</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<h3 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h3><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.iwiki.eu.org/wiki/File:Huffman_algorithm.gif">哈夫曼树构建过程</a><br>用语言描述就是，先将队列中权值最小的两个节点合并成新的节点，加入到队列中，然后一直按照这个规律执行，直到队列中只剩下一个节点。这个时候头节点的权值就是最短路径权值<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下是求一个实例的最短路径的权值的算法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;<span class="type">long</span> <span class="type">long</span>, vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;, greater&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> temp, x, y, ans = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"&amp;d"</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) {</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;temp);</span><br><span class="line">		q.<span class="built_in">push</span>(temp);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (q.<span class="built_in">size</span>()&gt;<span class="number">1</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="comment">//获取前两个最大节点</span></span><br><span class="line">		x = q.<span class="built_in">top</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		y = q.<span class="built_in">top</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//将节点合并之后再入队</span></span><br><span class="line">		q.<span class="built_in">push</span>(x + y);</span><br><span class="line">		<span class="comment">//统计最短路径权值</span></span><br><span class="line">		ans += x + y;</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><br>哈夫曼编码是一种用于无损数据压缩的熵编码（权编码）算法，它可以根据数据的一些特点（如出现频率）来制定相应长度的编码从而达到数据压缩的目的。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>《算法笔记》数据结构部分(STL&amp;链表&amp;树)</p><p><a href="https://baymine.github.io/2021/02/25/《算法笔记》数据结构部分-STL-链表-树/">https://baymine.github.io/2021/02/25/《算法笔记》数据结构部分-STL-链表-树/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>John Doe</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2021-02-25</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2023-03-08</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="notification is-danger">You need to set <code>install_url</code> to use ShareThis. Please set it in <code>_config.yml</code>.</div></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">Like this article? Support the author with</h3><div class="buttons is-centered"><a class="button donate" href="/" target="_blank" rel="noopener" data-type="afdian"><span class="icon is-small"><i class="fas fa-charging-station"></i></span><span>Afdian.net</span></a><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>Alipay</span><span class="qrcode"><img src="/" alt="Alipay"></span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="buymeacoffee"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>Buy me a coffee</span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="patreon"><span class="icon is-small"><i class="fab fa-patreon"></i></span><span>Patreon</span></a><div class="notification is-danger">You forgot to set the <code>business</code> or <code>currency_code</code> for Paypal. Please set it in <code>_config.yml</code>.</div><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>Wechat</span><span class="qrcode"><img src="/" alt="Wechat"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/02/27/%E3%80%8A%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%8B%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E7%AE%97%E6%B3%95%E5%88%9D%E6%AD%A5%EF%BC%88%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3%EF%BC%89/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">《算法笔记》第四章：算法初步（算法思想）</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/01/09/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="level-item">Java学习笔记</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div class="notification is-danger">You forgot to set the <code>shortname</code> for Disqus. Please set it in <code>_config.yml</code>.</div></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="York Cao"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">York Cao</p><p class="is-size-6 is-block">Data Engineer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Beijing</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">41</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">8</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/Baymine" target="_blank" rel="me noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Github" href="https://github.com/Baymine"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-06-03T02:56:51.000Z">2024-06-03</time></p><p class="title"><a href="/2024/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%95%99%E8%82%B2%E7%BC%BA%E5%A4%B1%E7%9A%84%E4%B8%80%E8%AF%BE/">计算机教育缺失的一课</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-05-29T13:26:01.000Z">2024-05-29</time></p><p class="title"><a href="/2024/05/29/Clickhouse%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E6%97%A5%E8%AE%B0/">Clickhouse源码阅读日记</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-01-05T08:48:47.000Z">2023-01-05</time></p><p class="title"><a href="/2023/01/05/GeePRC-notes/">GeePRC notes</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-12-18T07:04:19.000Z">2022-12-18</time></p><p class="title"><a href="/2022/12/18/C-Memory-Management/">C++ Memory Management</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-12-16T03:53:01.000Z">2022-12-16</time></p><p class="title"><a href="/2022/12/16/MIT6-S081/">MIT6.S081</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/06/"><span class="level-start"><span class="level-item">June 2024</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/05/"><span class="level-start"><span class="level-item">May 2024</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/01/"><span class="level-start"><span class="level-item">January 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/12/"><span class="level-start"><span class="level-item">December 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/11/"><span class="level-start"><span class="level-item">November 2022</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/10/"><span class="level-start"><span class="level-item">October 2022</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/07/"><span class="level-start"><span class="level-item">July 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/06/"><span class="level-start"><span class="level-item">June 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">May 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">April 2021</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">March 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/02/"><span class="level-start"><span class="level-item">February 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">January 2021</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/12/"><span class="level-start"><span class="level-item">December 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C++</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C-primer/"><span class="tag">C++ primer</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/DB/"><span class="tag">DB</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OS/"><span class="tag">OS</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Projects/"><span class="tag">Projects</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/bugs/"><span class="tag">bugs</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/computer-network/"><span class="tag">computer network</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BE%AF%E6%8D%B7C/"><span class="tag">侯捷C++</span><span class="tag">5</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">Subscribe for updates</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div><div class="card widget"><div class="card-content"><div class="notification is-danger">You need to set <code>client_id</code> and <code>slot_id</code> to show this AD unit. Please set it in <code>_config.yml</code>.</div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Baymine&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2024 John Doe</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>