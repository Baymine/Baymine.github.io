
 <!DOCTYPE HTML>
<html lang="en">
<head>
  <meta charset="UTF-8">
  
    <title>《算法笔记》第一部分C/C++语言基础 | Hexo</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="John Doe">
    
    <meta name="description" content="《算法笔记》的笔记第二章： C/C++快速入门


# 前言

在学习之前有一个小插曲，用vi命令打开.c文件的时候总是提示存在交换文件，这让我没有办法修改我的目标文件，经过查询相关资料，我发现只要将对应的交换文件删除就可以了，产生原因可能是因为在退出编辑模式之前退出文件了。应该是shift+dou">
    
    
    
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/pacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/pacman.jpg">
    
    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head>

  <body>
    <header>
      <div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.svg" alt="Hexo" title="Hexo"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Hexo">Hexo</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
					<li>
					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="text" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:example.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2020/12/31/《算法笔记》第一部分C-C-语言基础/" title="《算法笔记》第一部分C/C++语言基础" itemprop="url">《算法笔记》第一部分C/C++语言基础</a>
  </h1>
  <p class="article-author">By
    
      <a href="http://example.com" title="John Doe">John Doe</a>
    </p>
  <p class="article-time">
    <time datetime="2020-12-31T13:30:57.000Z" itemprop="datePublished">2020-12-31</time>
    Updated:<time datetime="2023-03-08T11:38:42.529Z" itemprop="dateModified">2023-03-08</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">Contents</strong>
		<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E3%80%8A%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%8B%E7%9A%84%E7%AC%94%E8%AE%B0"><span class="toc-number">1.</span> <span class="toc-text">《算法笔记》的笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">2.1 基本数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">2.2 顺序结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-%E8%B5%8B%E5%80%BC%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.2.1 赋值语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E8%AF%AD%E5%8F%A5%EF%BC%88scanf-printf%EF%BC%89"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2.2 输入&#x2F;输出语句（scanf&#x2F;printf）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-3-getchar-amp-putchar"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.2.3 getchar &amp; putchar</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-5-typedef"><span class="toc-number">1.2.4.</span> <span class="toc-text">2.2.5 typedef</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-6-%E5%B8%B8%E7%94%A8%E7%9A%84math%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.5.</span> <span class="toc-text">2.2.6 常用的math函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.</span> <span class="toc-text">2.3 选择结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E6%95%B0%E7%BB%84"><span class="toc-number">1.4.</span> <span class="toc-text">2.5 数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-1-%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">1.4.1.</span> <span class="toc-text">2.5.1 一维数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-2-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">1.4.2.</span> <span class="toc-text">2.5.2 冒泡排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-3-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">1.4.3.</span> <span class="toc-text">2.5.3 二维数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-4-memset%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.4.</span> <span class="toc-text">2.5.4 memset函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-5-%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84"><span class="toc-number">1.4.5.</span> <span class="toc-text">2.5.5 字符数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-6-string-h%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-number">1.4.6.</span> <span class="toc-text">2.5.6 string.h头文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-7-sscanf-amp-sprintf"><span class="toc-number">1.4.7.</span> <span class="toc-text">2.5.7 sscanf &amp; sprintf</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.</span> <span class="toc-text">2.6 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-%E6%8C%87%E9%92%88"><span class="toc-number">1.6.</span> <span class="toc-text">2.7 指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Pointers-and-Arrays"><span class="toc-number">1.6.1.</span> <span class="toc-text">Pointers and Arrays</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-8-%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%88struct%EF%BC%89%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.7.</span> <span class="toc-text">2.8 结构体（struct）的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-1-%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F%E4%BB%A5%E5%8F%8A%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F"><span class="toc-number">1.7.1.</span> <span class="toc-text">2.8.1 结构体的定义方式以及访问方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-3-%E7%BB%93%E6%9E%84%E4%BD%93%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.7.2.</span> <span class="toc-text">2.8.3 结构体初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-9-%E8%A1%A5%E5%85%85%E5%86%85%E5%AE%B9"><span class="toc-number">1.8.</span> <span class="toc-text">2.9 补充内容</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-9-1-cin-%E4%B8%8E-cout"><span class="toc-number">1.8.1.</span> <span class="toc-text">2.9.1 cin 与 cout</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-9-2-%E6%B5%AE%E7%82%B9%E6%95%B0%E6%AF%94%E8%BE%83"><span class="toc-number">1.8.2.</span> <span class="toc-text">2.9.2 浮点数比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-10-%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95"><span class="toc-number">1.9.</span> <span class="toc-text">2.10 黑盒测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%E5%86%85%E5%AE%B9"><span class="toc-number">2.</span> <span class="toc-text">补充内容</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84"><span class="toc-number">2.1.</span> <span class="toc-text">动态数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%85%B1%E7%94%9F%E4%BD%93"><span class="toc-number">2.2.</span> <span class="toc-text">C语言的共生体</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F"><span class="toc-number">2.2.1.</span> <span class="toc-text">定义方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%85%B1%E7%94%9F%E4%BD%93%E6%88%90%E5%91%98"><span class="toc-number">2.2.2.</span> <span class="toc-text">访问共生体成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B"><span class="toc-number">2.2.3.</span> <span class="toc-text">实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E4%BD%8D%E5%9F%9F"><span class="toc-number">2.3.</span> <span class="toc-text">C 位域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.4.</span> <span class="toc-text">枚举类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0"><span class="toc-number">2.5.</span> <span class="toc-text">友元函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD"><span class="toc-number">2.6.</span> <span class="toc-text">重载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">2.6.1.</span> <span class="toc-text">函数重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">2.6.2.</span> <span class="toc-text">运算符重载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%EF%BC%88C-PrimerPlus%EF%BC%89"><span class="toc-number">2.7.</span> <span class="toc-text">文件（C++PrimerPlus）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA"><span class="toc-number">2.7.1.</span> <span class="toc-text">文件输入和输出</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%BB%E8%A6%81%E8%AE%B0%E5%BD%95%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">总结（主要记录遇到的问题）</span></a></li></ol>
		</div>
		
		<h1 id="《算法笔记》的笔记"><a href="#《算法笔记》的笔记" class="headerlink" title="《算法笔记》的笔记"></a>《算法笔记》的笔记</h1><font color="#999AAA">第二章： C/C++快速入门


# 前言

<font color="#999AAA">在学习之前有一个小插曲，用vi命令打开.c文件的时候总是提示存在交换文件，这让我没有办法修改我的目标文件，经过查询相关资料，我发现只要将对应的交换文件删除就可以了，产生原因可能是因为在退出编辑模式之前退出文件了。应该是shift+double z，而不是crtl
    **具体的操作方法**：使用ls - al 命令查看文件夹目录，找到交换文件（文件后缀是.swp）然后就用 rm - 文件名 删掉相应的交换文件就可以了
    *PS：我发现当交换文件出现重名的时候，文件的拓展名会到发生变化（.swn 、.swo等）
    PPS：很久没有用我的Ubuntu了，很多的命令都忘记了，所以一些常用的命令需要在这里记下来，以便之后学习的时候复习。*
    vi/vim、cd、ls、mkdir 

</font>

<p>&lt;hr style=” border:solid; width:100px; height:1px;” color=#000000 size=1”&gt;<br>虽然之前学过C/C++但是担心自己有什么遗漏所以还是看了一遍，在这里主要记录的就是自己原先不是很熟悉的内容。</p>
<font color="#999AAA">


<h2 id="2-1-基本数据类型"><a href="#2-1-基本数据类型" class="headerlink" title="2.1 基本数据类型"></a>2.1 基本数据类型</h2><ol>
<li>cin和cout消耗的时间会比scanf和printf多得多。而且在同一个程序当中不应该同时使用cout和printf（会出现问题）</li>
<li>C++标准库中，stdio.h的推荐写法：cstdio（就是去掉后缀，然后在最前面加上c,eg:<math.h> —-&gt; \<cmath>）</cmath></math.h></li>
<li><strong>基本数据类型：</strong><br><font color="#999AAA"><br>i）整型：int  —-&gt;  32bit （10\^9以内使用）||  long long ——&gt; 64 bit(如果long long型赋大于2\^31-1的初值的时候，需要在初值后面加上LL，否则会编译错误)<br>ii)浮点型：（Mantissa：小数部分）<img src="https://img-blog.csdnimg.cn/20201231202429775.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="IEEE标准的浮点表示法"><br>由上图可以知道单精度float有效精度只有6~7位（具体原因之后补充），双精度浮点型double的有效精度为15~16位。书中的建议：（应该是单精度浮点型的精度在大多时候都不够用吧）</font></li>
</ol>
<blockquote>
<p>对于浮点型来说，只需记住一点，不要使用float，碰到浮点型的数据都应该使用double来存贮。</p>
<p><font color="#999AAA"><br>iii）字符型：字符在C语言中使用使用ASCII码统一编码的。（需要记住一点小写字母比大写字母的ASCII码值大32，0的ASCII码为48）<br>（还要记住几个常用的转义字符：\n代表换行,\0代表空字符，其ASCII码为0，\t代表Tab键）<br>这一部分总结来说就是%c会将整型数字转化成相应ASCII码所对应的值。<br>对于字符串型可以转化成字符数组，但是不能赋值给字符变量</font></p>
</blockquote>
<p>3.<strong>强制类型转换</strong></p>
<p><font color="#999AAA">格式：（新类型名）变量名</font></p>
<blockquote>
<p>如果在计算过程中需要类型转换，那么就不能等它算完再在赋值的时候转换</p>
</blockquote>
<p><strong>4.符号常量和const常量</strong></p>
<p><font color="#999AAA"><br>这是定义常量的两种方式（更加推荐后者）<br>格式：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> 标识符 常量<span class="comment">//注意这里最后是没有分号的</span></span></span><br><span class="line"><span class="type">const</span> 数据类型 变量 = 常量；</span><br></pre></td></tr></table></figure><br>宏定义（Macro definition）的陷阱：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAL(x) (x * 2 + 1)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">CAL</span> (a + <span class="number">1</span>));</span><br><span class="line">	<span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：4</span></span><br><span class="line"><span class="comment">//因为宏定义只会将数据原封不动地带进去，实际上的运算过程为：a+1*2+1.</span></span><br><span class="line"><span class="comment">//所以在用宏定义的时候应该将变量全部用括号括起来</span></span><br></pre></td></tr></table></figure><br><strong>5.运算符</strong></font></p>
<p><font color="#999AAA"><br>i）算数运算符没有幂次运算符，<strong>^代表的是位异或</strong>（位运算符可以用来定义无穷大的数）<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实际上就是整型的上限</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = (<span class="number">1</span> &lt;&lt; <span class="number">30</span>) <span class="number">-1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3fffffff</span>;</span><br></pre></td></tr></table></figure><br>位运算符的使用技巧：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.判断两个数字是否异号，利用补码编码的符号位进行异或运算（同0异1）</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">-1</span>, j = <span class="number">1</span>;</span><br><span class="line">(i ^ j &lt; <span class="number">0</span>) = <span class="literal">true</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//2.将编码最后一个1转换成0，可用于求解统计二进制编码中1的个数和判断一个数是不是2的指数</span></span><br><span class="line"><span class="comment">//这个数减去一之后，会向从右开始的第一个数借一位，这使得这一位变成0，然后与运算，</span></span><br><span class="line"><span class="comment">//将不相同的位全部变成0，这样就去掉了最右边的哪一个1</span></span><br><span class="line">n &amp; (n<span class="number">-1</span>);<span class="comment">//可以用于统计1的个数，或者进行相应的运算</span></span><br><span class="line"><span class="comment">//统计一个数的二进制数中1的个数(汉明权重)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="type">uint32_t</span> n)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">		n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">		res++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断一个数是否为2的指数：注意2的指数有一个特点，在二进制编码中只能有一个1</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n &lt;= <span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> (n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p>
<p><font color="#999AAA"><br>ii）条件运算符<br>格式：A ? B : C;</font></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用条件运算符+宏定义判断大小的结构</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br></pre></td></tr></table></figure>
<h2 id="2-2-顺序结构"><a href="#2-2-顺序结构" class="headerlink" title="2.2 顺序结构"></a>2.2 顺序结构</h2><h3 id="2-2-1-赋值语句"><a href="#2-2-1-赋值语句" class="headerlink" title="2.2.1 赋值语句"></a>2.2.1 赋值语句</h3><p>而如果要给多个变量赋<strong>同一个值</strong>，可以使用连续等号的方法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">n = m = <span class="number">5</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-2-2-输入-输出语句（scanf-printf）"><a href="#2-2-2-输入-输出语句（scanf-printf）" class="headerlink" title="2.2.2 输入/输出语句（scanf/printf）"></a>2.2.2 输入/输出语句（scanf/printf）</h3><p>1.scanf函数<br><img src="https://img-blog.csdnimg.cn/20210102212212410.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>注意到字符串类型不需要使用取址运算符，因为字符串类型相当于一个数组，数组名称代表第一个元素的地址。<br>另外，除了%c 外， scanf 对其他格式符（如%d）的输入是以空白符（即空格、 Tab ）为结束判断标志的<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a, a1;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;a1);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>, a, a1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//input:1 2  output:1 2</span></span><br></pre></td></tr></table></figure><br>但是对于%c</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a; <span class="type">char</span> c, str[<span class="number">10</span>];</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%c%s&quot;</span>, &amp;a, &amp;c,str);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;a=%d, c=%c,str=%s&quot;</span>, a, c, str);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//Input:1 2 3</span></span><br><span class="line">	<span class="comment">//Output:a = 1, c=, str = 2</span></span><br><span class="line">	<span class="comment">//可见空格也被当成一个字符了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>scanf()的返回值：<br>输入数字，匹配%d,配置b的值成功，scanf返回成功配置数量1；<br>输入字母，不匹配%d,配置b的值失败，scanf返回成功配置数量0；<br>输入Ctrl+Z，scanf返回-1；</p>
<p>2.printf函数<br><img src="https://img-blog.csdnimg.cn/20210102212936302.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>这里注意一点：在scanf中double的格式符为%lf，而在printf中格式符为%f</strong></p>
<p>接下来介绍三种使用的输出格式：（m为一个具体的数字）</p>
<ol>
<li><strong>%md</strong>  可以使不足 位的 int 型变量以m位进行右对齐输出，其中高位用空格补齐。如果变量本身超过m位，则保持原样。</li>
<li><strong>%0md</strong> 和上面的类似，只不过是用0而不是空格</li>
<li><strong>%.mf</strong>  让浮点数保留m位小数输出，采用”四舍六入五成双“[4]的规则</li>
</ol>
<h3 id="2-2-3-getchar-amp-putchar"><a href="#2-2-3-getchar-amp-putchar" class="headerlink" title="2.2.3 getchar &amp; putchar"></a>2.2.3 getchar &amp; putchar</h3><p>获取和输出一个字符，注意getchar（）是可以识别换行的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">char</span> c1, c2, c3;</span><br><span class="line">	c1 = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line">	c2 = <span class="built_in">getchar</span>();</span><br><span class="line">	c3 = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="built_in">putchar</span>(c1);</span><br><span class="line">	<span class="built_in">putchar</span>(c2);</span><br><span class="line">	<span class="built_in">putchar</span>(c3);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Input:ab(&lt;Enter&gt;)c</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">a</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">c</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2-2-5-typedef"><a href="#2-2-5-typedef" class="headerlink" title="2.2.5 typedef"></a>2.2.5 typedef</h3><p>可以给复杂的数据类型起一个别名<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;<span class="comment">//之后就可以用LL代替long long了</span></span><br></pre></td></tr></table></figure></p>
<h3 id="2-2-6-常用的math函数"><a href="#2-2-6-常用的math函数" class="headerlink" title="2.2.6 常用的math函数"></a>2.2.6 常用的math函数</h3><p>需要#include<math.h></math.h></p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只能是括号中的类型（？）</span></span><br><span class="line"><span class="number">1.</span> fabs（<span class="type">double</span> x）————（<span class="type">float</span> absolute value）给<span class="type">double</span>型变量取绝对值</span><br><span class="line"><span class="number">2.</span> <span class="built_in">floor</span>(<span class="type">double</span> x) &amp; <span class="built_in">ceil</span>(<span class="type">double</span> x) ————（地板和天花板）向下和向上取整</span><br><span class="line"><span class="number">3.</span> <span class="built_in">pow</span>(<span class="type">double</span> r, <span class="type">double</span> p)————（幂函数：power function）返回  r^p</span><br><span class="line"><span class="number">4.</span> <span class="built_in">sqrt</span>(<span class="type">double</span> x) ————（Arithmetic square root）返回算数平方根</span><br><span class="line"><span class="number">5.</span> log（<span class="type">double</span> x） ————（Natural logarithm） 返回以自然对数为底数的对数值</span><br><span class="line"><span class="number">6.</span> <span class="built_in">sin</span>(<span class="type">double</span> x) 、<span class="built_in">cos</span>(<span class="type">double</span> x)、<span class="built_in">tan</span>(<span class="type">double</span> x) ————可以用来精确定义pi的值：acos（<span class="number">-1.0</span>）</span><br><span class="line"><span class="number">7.</span> <span class="built_in">asin</span>(<span class="type">double</span> x) 、<span class="built_in">acos</span>(<span class="type">double</span> x)、<span class="built_in">atan</span>(<span class="type">double</span> x) ————反三角函数</span><br><span class="line"><span class="number">8.</span> <span class="built_in">round</span>(<span class="type">double</span> x) ————（round：用整数表示的, 取整数的, 整数的）四舍五入取整</span><br></pre></td></tr></table></figure>
<p>C语言中没有对任意底数求对数的函数，因此必须使用换底公式来将不是以自然对数为底的对数转换为以e为底的对数，即 </p>
<script type="math/tex; mode=display">log_ab = log_eb/log_ea</script><p>注意：pow()可能导致错误的情况：</p>
<ol>
<li>如果==底数 x 为负数并且指数 y 不是整数==，将会导致 domain error 错误。</li>
<li>如果<u>底数 x 和指数 y 都是0</u>，可能会导致 domain error 错误，也可能没有；这跟库的实现有关。 </li>
<li>如果<u>底数 x 是 0，指数 y是负数</u>，可能会导致 domain error 或 pole error 错误，也可能没有；这跟库的实现有关。 </li>
<li>如果<u>返回值ret 太大或者太小</u>，将会导致 range error 错误。</li>
</ol>
<p>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/yuanbo_shaw/article/details/79511132">https://blog.csdn.net/yuanbo_shaw/article/details/79511132</a></p>
<h2 id="2-3-选择结构"><a href="#2-3-选择结构" class="headerlink" title="2.3 选择结构"></a>2.3 选择结构</h2><p>因为这部分的内容比较熟悉，就跳过了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">	<span class="keyword">case</span> 表达式<span class="number">1</span>：<span class="comment">//相当于switch中的语句的结构，如果匹配，则执行之后的语句</span></span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> 表达式<span class="number">2</span>：</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	.........</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		....</span><br><span class="line"><span class="comment">//注意每个case语句之后是没有大括号的！</span></span><br><span class="line"><span class="comment">//break是用来结束当前switch语句的</span></span><br></pre></td></tr></table></figure>
<p>对于for语句，在C语言中是不允许定义变量的，但是在C++中可以（将代码文件保存为.cpp的格式即可）</p>
<h2 id="2-5-数组"><a href="#2-5-数组" class="headerlink" title="2.5 数组"></a>2.5 数组</h2><h3 id="2-5-1-一维数组"><a href="#2-5-1-一维数组" class="headerlink" title="2.5.1 一维数组"></a>2.5.1 一维数组</h3><ol>
<li>数组的大小必须是整型常量，不能是变量。但是可以自己申请空间以定义数组<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C</span></span><br><span class="line"><span class="type">int</span>* a = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>)*n);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"><span class="comment">//C++</span></span><br><span class="line"><span class="type">int</span>* a = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line"><span class="keyword">delete</span>[] a;</span><br><span class="line"><span class="comment">//释放内存~~~</span></span><br></pre></td></tr></table></figure></li>
<li>当数组没有被初始化值的时候，一般默认是赋值为0，但是有时候有可能被赋值为很大的随机数</li>
<li>给数组赋值的方法：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//这种方法只能用于将数组初始化为0</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123;<span class="number">-1</span>&#125;;<span class="comment">//-1 0 0 0 0  0 0....(测试环境VS2019)</span></span><br><span class="line"><span class="built_in">fill</span> (a, a + <span class="number">10</span>, <span class="number">-1</span>);<span class="comment">//初始化为-1，需要函数头algorithm和using namespace std;</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123;&#125;;<span class="comment">//初始化为0</span></span><br></pre></td></tr></table></figure>
<h3 id="2-5-2-冒泡排序"><a href="#2-5-2-冒泡排序" class="headerlink" title="2.5.2 冒泡排序"></a>2.5.2 冒泡排序</h3><p>本质上就是通过不断地交换减少数组中的逆序数对。在一遍遍历过程中，不断将较大的元素与相邻的元素进行交换。而最大的元素因为总是会比之后的元素更大，所以会被移到最后。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> sorted = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">while</span>(!sorted)&#123;</span><br><span class="line">		sorted = <span class="literal">true</span>;<span class="comment">//优化</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;=n;++i)&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i<span class="number">-1</span>] &gt; a[i])&#123;</span><br><span class="line">				<span class="type">int</span> temp = a[i<span class="number">-1</span>];</span><br><span class="line">				a[i<span class="number">-1</span>] = a[i];</span><br><span class="line">				a[i] = temp;</span><br><span class="line">				sorted = <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-5-3-二维数组"><a href="#2-5-3-二维数组" class="headerlink" title="2.5.3 二维数组"></a>2.5.3 二维数组</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二维数组想要作为参数传入函数中，需要确定二维数组的大小（至少是第二维需要确定）</span></span><br><span class="line"><span class="comment">//二维数组的赋值方式</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">5</span>][<span class="number">6</span>] = &#123;&#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">8</span>,<span class="number">4</span>&#125;,&#123;&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;&#125;;<span class="comment">//剩余部分将会被赋值为0</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：当数组大小较大时（$10^6$数量级），需要将其定义在主函数外面，否则会使程序异常退出。</strong></p>
<p><font color="#999AAA">因为在函数内部申请的局部变量来自于系统栈，允许的空间较小；函数外部申请的全局变量来自静态存储区，允许申请的空间大。[6]</font></p>
<h3 id="2-5-4-memset函数"><a href="#2-5-4-memset函数" class="headerlink" title="2.5.4 memset函数"></a>2.5.4 memset函数</h3><p>menset函数可以给数组中的每一个函数赋值，但是menset使用的是<strong>按字节赋值的</strong>，这就是说一个整型变量的四个字节都会被赋相同的值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//memset（数组名，赋值，sizeof（数组名））；</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> A[<span class="number">5</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">	<span class="built_in">memset</span>(a, <span class="number">1</span>, <span class="built_in">sizeof</span>(A));</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：16843009        16843009        16843009        16843009        16843009[5]</span></span><br><span class="line"><span class="comment">//赋值为0或者-1（0的二进制补码为全0，-1的二进制补码为全1）</span></span><br><span class="line"><span class="comment">//还可以用fill函数对数组进行赋值，但是执行速度较差。</span></span><br></pre></td></tr></table></figure>
<p>这里每个字节的意思是每个字节都设为1，注意不要与每个位赋值弄混淆。因为int是8字节所以，调用menset之后，数组中存储的数字为：0000 0001 0000 0001 0000 0001 0000 0001.（1字节为8位）</p>
<h3 id="2-5-5-字符数组"><a href="#2-5-5-字符数组" class="headerlink" title="2.5.5 字符数组"></a>2.5.5 字符数组</h3><p>输入：（scanf）<br>%c:输入单个字符（<strong>能识别空格与换行并将其输入</strong>）<br>%s:输入字符串并保存在字符数组中（以空格或者换行作为结束标志）<br>（gets）输入一行字符串，以\n作为结束标识。<br>（getchar）获取输入额一个字符<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str2 [<span class="number">5</span>][<span class="number">10</span>];<span class="comment">//定义</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)&#123;</span><br><span class="line">	<span class="built_in">gets</span>(str2 [i]);<span class="comment">//运用这种方法将将输入的第一行赋值给数组的一整列</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出格式类似，运用的函数为puts（与gets类似）</span></span><br></pre></td></tr></table></figure><br>注意：字符串是以‘\0’（ASCII 为 0）作为结尾的，所以存储的长度应该比实际存储长度大一。==还有当用gets或者scanf函数的输入时，会自动在字符串尾部加上‘\0’==，但是当用getchar函数（getchar每次只获取一个字符，所以’\0’作为单独字符需要调用额外的getchar函数）时，一定要在每个字符串后面加上‘否则会出现乱码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">15</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">	str[i] = <span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span>(str);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//Input:T^T</span></span><br><span class="line"><span class="comment">//Output:T^T烫烫烫烫烫烫烫烫烫烫坍G醶?烫烫哎^v€麧</span></span><br><span class="line"><span class="comment">//应该是程序不知道什么地方是结束</span></span><br></pre></td></tr></table></figure></p>
<h3 id="2-5-6-string-h头文件"><a href="#2-5-6-string-h头文件" class="headerlink" title="2.5.6 string.h头文件"></a>2.5.6 string.h头文件</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line">...</span><br><span class="line"><span class="type">char</span> str1[<span class="number">10</span>], str2[<span class="number">10</span>];<span class="comment">//代表字符数组</span></span><br><span class="line"><span class="built_in">strlen</span>(str1)；<span class="comment">//得到第一个&#x27;\0&#x27;之前的字符个数</span></span><br><span class="line"><span class="built_in">strcmp</span>(str1,str2)；<span class="comment">//按照字典序比较（&lt;:返回负整数；=：返回0；&gt;：返回正整数）</span></span><br><span class="line"><span class="built_in">strcpy</span>(tr1,str2);<span class="comment">//str2复制给str1，包含&#x27;\0&#x27;</span></span><br><span class="line"><span class="built_in">strcat</span>(str1,str2);<span class="comment">//(concatenate：把事物连接起来)str2接到str1后面</span></span><br></pre></td></tr></table></figure>
<h3 id="2-5-7-sscanf-amp-sprintf"><a href="#2-5-7-sscanf-amp-sprintf" class="headerlink" title="2.5.7 sscanf &amp; sprintf"></a>2.5.7 sscanf &amp; sprintf</h3><p>（都在stdio.h中）（<font color="#999AAA">补充）</font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个函数的主要用途就是将字符数组的内容转化成整型，放到整型变量中</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> str[<span class="number">100</span>] = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="built_in">sscanf</span>(str, <span class="string">&quot;%d&quot;</span>, &amp;n);<span class="comment">//相当于将str作为输入对象（类似于scanf的屏幕输入）</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, n);</span><br><span class="line"></span><br><span class="line"><span class="comment">//就像printf一样，只不过是将其打印到了一个字符串数组中去了</span></span><br><span class="line"><span class="type">double</span> db = <span class="number">3.1415</span>;</span><br><span class="line"><span class="type">int</span> n1 = <span class="number">12</span>;</span><br><span class="line"><span class="type">char</span> str1[<span class="number">100</span>], str2[<span class="number">100</span>] = <span class="string">&quot;good&quot;</span>;</span><br><span class="line"><span class="built_in">sprintf</span>(str1, <span class="string">&quot;%d:%.2f,%s&quot;</span>, n1, db, str2);<span class="comment">//将这些元素输出给str1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;str1 = %s\n&quot;</span>, str1);</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//    123</span></span><br><span class="line"><span class="comment">//    str1 = 12:3.14,good</span></span><br></pre></td></tr></table></figure>
<h2 id="2-6-函数"><a href="#2-6-函数" class="headerlink" title="2.6 函数"></a>2.6 函数</h2><p><font color="#999AAA">函数这部分也比较熟悉所以大部分省略了</font></p>
<p>1.数组可以作为参数，但是不允许作为返回类型出现</p>
<h2 id="2-7-指针"><a href="#2-7-指针" class="headerlink" title="2.7 指针"></a>2.7 指针</h2><p><img src="https://img-blog.csdnimg.cn/20210104124454965.png#pic_center" alt="在这里插入图片描述"></p>
<blockquote>
<p>指针（英语：Pointer），是编程语言中的一类数据类型及其对象或变量，用来表示或存储一个存储器地址，这个地址的值直接指向（points to）存在该地址的对象的值。</p>
</blockquote>
<p>相关的操作有：<br>&amp; ——取此变量的地址<br>* ———取该地址对应的值<br>指针变量的运算：加（减）代表的是指针指向前一个（后一个）存储块。看下面这个例子<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* x, <span class="type">int</span> y</span><br><span class="line">...</span><br><span class="line">x = &amp;y + <span class="number">3</span>    <span class="comment">//结果是x存储的地址是y的地址+12</span></span><br><span class="line"><span class="comment">//因为一个int类型占4个字节，所以这样总的来说就是向前移动了12个字节</span></span><br></pre></td></tr></table></figure></p>
<p> <strong>在函数中</strong>，想要修改传入的值，就需要传入该变量的地址（传址访问），包括要修改指针变量也是需要将指针变量所对应的地址传进去。<br> <strong>注意：常量是不能被使用取址运算符</strong>。因为引用的对象必须是可以修改的左值，也就是说放常量被引用的时候，它并不能被修改，所以索性就不能被引用了。<br> <strong>在数组中</strong>，一下两种检索方式是等价的<br> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&amp; big_array[ <span class="number">0</span> ] + <span class="function">i * <span class="title">sizeof</span><span class="params">( big_array[ <span class="number">0</span> ])</span></span>;<span class="comment">//对地址直接修改</span></span><br><span class="line">&amp;big_array[ i ] = big_array + i;<span class="comment">//通过指针运算</span></span><br></pre></td></tr></table></figure><br>（以下来自于《C程序语言设计2e》）</p>
<h3 id="Pointers-and-Arrays"><a href="#Pointers-and-Arrays" class="headerlink" title="Pointers and Arrays"></a>Pointers and Arrays</h3><p>注意事项：<br>1.(<em>ip)++这里的括号是必要的，因为单元运算符像\</em>、++结合，是从右向左运算的。（一个准则，当你遇到不熟悉的运算符的时候，将所有可能出错的地方全部加括号）</p>
<p>2.在传参的时候，想要修改传入参数，需要传入参数的地址，例如swap(&amp;a,&amp;b)；</p>
<p>3.int a[num],这是在申请大小为num的数组，索引范围为0 ~ num-1<br><img src="https://img-blog.csdnimg.cn/20210222070754753.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="指针和数组索引"></p>
<h2 id="2-8-结构体（struct）的使用"><a href="#2-8-结构体（struct）的使用" class="headerlink" title="2.8 结构体（struct）的使用"></a>2.8 结构体（struct）的使用</h2><h3 id="2-8-1-结构体的定义方式以及访问方式"><a href="#2-8-1-结构体的定义方式以及访问方式" class="headerlink" title="2.8.1 结构体的定义方式以及访问方式"></a>2.8.1 结构体的定义方式以及访问方式</h3><p><strong>注意在结构体内不能用定义的结构体定义变量，但是可以定义指针类型。</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结构体的定义方式</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">structname</span>&#123;</span><br><span class="line">	<span class="type">int</span> a;<span class="comment">//成员变量</span></span><br><span class="line">	structname b;<span class="comment">//不能定义自己本身（会引起循环定义的问题）</span></span><br><span class="line">	structname* c;<span class="comment">//可以定义自身类型的指针变量</span></span><br><span class="line">&#125;A;<span class="comment">//结构体变量，相当于 structname A；</span></span><br></pre></td></tr></table></figure><br>结构体内元素的访问方式：<br>点运算符：”.“非指针变量的访问方式；<br>指针运算符：”-&gt;“指针变量的访问方式。</p>
<h3 id="2-8-3-结构体初始化"><a href="#2-8-3-结构体初始化" class="headerlink" title="2.8.3 结构体初始化"></a>2.8.3 结构体初始化</h3><p>构造函数是用来初始化结构体的一种函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认情况下构造函数是不显示的</span></span><br><span class="line"><span class="comment">//但是想要自己重新定义构造函数，就不能不经初始化就定义结构体变量</span></span><br><span class="line"><span class="comment">//想要同时实现二者，需要像以下这样定义构造函数</span></span><br><span class="line"><span class="comment">//只要参数个数和类型不完全相同，就可以定义多个构造函数，以适应不同环境下的初始化</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">studentInfo</span>&#123;</span><br><span class="line">	<span class="type">int</span> id;<span class="type">char</span> gender;</span><br><span class="line">	<span class="built_in">studentInfo</span>()&#123;&#125;;<span class="comment">//默认的构造函数</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">studentInfo</span>(<span class="type">char</span> _gender)&#123;<span class="comment">//这里的变量名不能和外部的一样</span></span><br><span class="line">		gender = _gender;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">studentInfo</span>(<span class="type">int</span> _id, <span class="type">char</span> _gender)&#123;</span><br><span class="line">	id = _id;</span><br><span class="line">	gender = _gender;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//初始化方式</span></span><br><span class="line">studentInfo A;</span><br><span class="line">A = <span class="built_in">studentInfo</span>(<span class="number">2021</span>,<span class="string">&quot;girl&quot;</span>);<span class="comment">//调用构造函数初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//C++的另一种构造函数的方式</span></span><br><span class="line"><span class="built_in">studentInfo</span>(<span class="type">int</span> _id, <span class="type">char</span> _gender):<span class="built_in">id</span>(_id),<span class="built_in">gender</span>(_gender)&#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-9-补充内容"><a href="#2-9-补充内容" class="headerlink" title="2.9 补充内容"></a>2.9 补充内容</h2><h3 id="2-9-1-cin-与-cout"><a href="#2-9-1-cin-与-cout" class="headerlink" title="2.9.1 cin 与 cout"></a>2.9.1 cin 与 cout</h3><p>这两个输入输出函数虽然简洁（不用定义类型之类的）但是面对大量数据的时候，效率较低。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&quot;&gt;&gt;&quot;可以看成数据流的方向</span></span><br><span class="line"><span class="comment">//多变量输入</span></span><br><span class="line">cin &gt;&gt; n &gt;&gt; db &gt;&gt; c &gt;&gt; str;</span><br><span class="line"><span class="comment">//多变量输出</span></span><br><span class="line">cout &lt;&lt; n &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; db &lt;&lt; endl;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="2-9-2-浮点数比较"><a href="#2-9-2-浮点数比较" class="headerlink" title="2.9.2 浮点数比较"></a>2.9.2 浮点数比较</h3><p>由于在计算机中采用有限位的二进制编码，因此浮点数在计算机中的存储并不总是精确的[8]。<br>在经过大量运算之后，浮点数的精度可能会发生变化，这就给比较操作（&gt;、&lt;、=）<br>产生了干扰。所以，我们定义一个极小数eps（通常取$10^{-8}$）,只要比较数落在特定的区间内（$\pm esp$）即可。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用宏定义等于</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> esp = <span class="number">1e-8</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Equ(a,b) ((fabs((a)-(b)) &lt; (esp)))</span></span><br></pre></td></tr></table></figure><br>其他的比较运算符的所在区间如下图：<br><img src="https://img-blog.csdnimg.cn/20210105125223616.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMxNTY1Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>还有几点需要注意：</p>
<ol>
<li>经过大量的运算之后，一个变量存储的0可能是一个很小的负数，这时候使用sqrt函数就会报错，这时候就应该运用esp使变量保证在定义域内（*）</li>
<li>某些编译环境中，可能会输出-0.00.这是能将此输出放到字符串中，与“-0.00”比较，如果一致，那就加上esp修正这个值。</li>
</ol>
<h2 id="2-10-黑盒测试"><a href="#2-10-黑盒测试" class="headerlink" title="2.10 黑盒测试"></a>2.10 黑盒测试</h2><h1 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h1><h2 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h2><p>在定义数组之前，若数组大小未知，则需要对数组的空间进行申请<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一维数组</span></span><br><span class="line"><span class="comment">//动态分配，数组长度为m</span></span><br><span class="line"><span class="type">int</span> *array = <span class="keyword">new</span> <span class="type">int</span> [m];</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放内存</span></span><br><span class="line"><span class="keyword">delete</span>[] array; </span><br><span class="line"></span><br><span class="line"><span class="comment">//定义结构体动态数组并初始化</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Mystruct</span>&#123;</span><br><span class="line">	<span class="type">int</span> a, b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Mystruct* structs = <span class="keyword">new</span> Mystruct[<span class="number">100</span>];</span><br><span class="line">	Mystruct initializer = &#123;<span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">	<span class="built_in">fill</span>(structs, structs + <span class="number">100</span>,initializer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="C语言的共生体"><a href="#C语言的共生体" class="headerlink" title="C语言的共生体"></a>C语言的共生体</h2><p>参考：<a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-unions.html">https://www.runoob.com/cprogramming/c-unions.html</a><br>共生体是一种能在相同的内存位置存储不同的数据类型的一种特殊的数据类型。在共生体中能定义很多的不同的成员变量，但是任何时候只能有一个成员带有值。这样做可以节省空间，可以应用于变量不会同时使用的情况。</p>
<blockquote>
<p>通信中的数据包会用到共用体:因为不知道对方会发一个什么包过来，用共用体的话就很简单了，定义几种格式的包，收到包之后就可以直接根据包的格式取出数据。</p>
</blockquote>
<h3 id="定义方式"><a href="#定义方式" class="headerlink" title="定义方式"></a>定义方式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> [<span class="keyword">union</span> <span class="title class_">tag</span>]</span><br><span class="line">&#123;</span><br><span class="line">	member def;</span><br><span class="line">	menber def;</span><br><span class="line">	....</span><br><span class="line">&#125;[<span class="function"><span class="keyword">union</span> <span class="title">variable</span><span class="params">(s)</span>]</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例:成员变量可以是自定义的结构类型</span></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">Data</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">float</span> f;</span><br><span class="line">	<span class="type">char</span> str[<span class="number">20</span>];</span><br><span class="line">&#125;data;</span><br></pre></td></tr></table></figure>
<p>共用体占用的内存应足够存储最大数据类型成员。</p>
<h3 id="访问共生体成员"><a href="#访问共生体成员" class="headerlink" title="访问共生体成员"></a>访问共生体成员</h3><p>想要访问共生体成员需要使用点运算符。但是因为共生体所有的成员共用一个空间，所以在同一时间只能有一个成员变量能够拥有完整的赋值。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据损坏</span></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">Data</span> data;</span><br><span class="line"><span class="comment">//这样只有data.str能够拥有完成的数据</span></span><br><span class="line">data.i = <span class="number">10</span>;<span class="comment">//在后续的赋值过程中对应的内存被占用</span></span><br><span class="line">data.f = <span class="number">220.5</span>;</span><br><span class="line"><span class="built_in">strcopy</span>(data.str, <span class="string">&quot;Union&quot;</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>判断机器是大端机还是小端机<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line">data=<span class="number">0x01020304</span>;</span><br><span class="line"><span class="keyword">if</span>(str==<span class="number">0x01</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;此机器是大端！&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(str==<span class="number">0x04</span>)&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;此机器是小端！&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    cout &lt;&lt;<span class="string">&quot; 暂无法判断此机器类型！&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="C-位域"><a href="#C-位域" class="headerlink" title="C 位域"></a>C 位域</h2><p>C语言提供了一种更好的利用内存空间的方式。这种方式可以告诉编译器你只用这些字节<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> withValidated : <span class="number">1</span>;<span class="comment">//只用一位来存储该变量</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> heightValidated : <span class="number">1</span>;<span class="comment">//后面的数字表示数据占用的空间的大小</span></span><br><span class="line">&#125;status;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> age : <span class="number">3</span>;</span><br><span class="line">&#125;Age;</span><br><span class="line">Age,age = <span class="number">7</span>;<span class="comment">//能够表示的最大值</span></span><br><span class="line">Age.age = <span class="number">8</span>;<span class="comment">//输出的时候为0，溢出</span></span><br></pre></td></tr></table></figure></p>
<h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p>定义格式<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">name</span> &#123;eleName1, eleName2,....&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">DAY</span></span><br><span class="line">&#123;</span><br><span class="line">	MON = <span class="number">1</span>,TUE,WED,THU,FRI,SAT,SUN</span><br><span class="line">&#125;day;<span class="comment">//1,2,3,4,5,6,7</span></span><br><span class="line"><span class="comment">//enum DAY day;</span></span><br><span class="line"></span><br><span class="line">day = WED;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,day);<span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">seasons</span>&#123;</span><br><span class="line">	spring, summer = <span class="number">3</span>, autumn, winter;</span><br><span class="line">&#125;;<span class="comment">//0，3，4，5</span></span><br></pre></td></tr></table></figure></p>
<h2 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h2><blockquote>
<p>在面向对象编程中，友元函数（friend function）是一个指定类（class）的“朋友”，该函数被允许访问该类中private、protected、public的资料成员。普通的函数并不能访问这些资料，然而宣告一个函数成为一个类的友元函数则被允许访问这些资料。<br>友元函数的宣告可以放在类声明的任何地方，不受访问限定关键字private、protected、public的限制。一个相似的概念是友谊类。<br>友谊关键字应该谨慎使用。如果一个拥有private或者protected成员的类，宣告过多的友元函数，可能会降低封装性的价值，也可能对整个设计框架产生影响。</p>
</blockquote>
<p>友元函数在类内部定义，可以在类外部定义。定义时在前面加上一个<code>friend</code>关键字<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">double</span> width;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">double</span> length;</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">printWidth</span><span class="params">(Box box)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printWidth</span><span class="params">(Box box)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; box.width &lt;&lt; endl;<span class="comment">//访问私密成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><blockquote>
<p>C++ 允许在同一作用域中的某个函数和运算符指定多个定义，分别称为函数重载和运算符重载。</p>
</blockquote>
<p>重载函数应该有不同的输入参数，这样能够编译器会根据不同的输入参数确定函数的定义，这个过程叫做<code>重载决策</code></p>
<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">printData</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;整数为: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">double</span>  f)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;浮点数为: &quot;</span> &lt;&lt; f &lt;&lt; endl;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">char</span> c[])</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;字符串为: &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><blockquote>
<p>重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将两个Box类相加</span></span><br><span class="line">Box <span class="keyword">operator</span>+(<span class="type">const</span> Box&amp;, <span class="type">const</span> Box&amp;);</span><br><span class="line">Box box1, box2, box3;</span><br><span class="line">....</span><br><span class="line">box3 = box1 + box2;</span><br></pre></td></tr></table></figure>
<h2 id="文件（C-PrimerPlus）"><a href="#文件（C-PrimerPlus）" class="headerlink" title="文件（C++PrimerPlus）"></a>文件（C++PrimerPlus）</h2><p>文件本身就是一连串的存储在设备当中的字节。</p>
<h3 id="文件输入和输出"><a href="#文件输入和输出" class="headerlink" title="文件输入和输出"></a>文件输入和输出</h3><p>文件输出流的类包含在文件头fstream（fstream.h）中。下面是写入文件的步骤：</p>
<ol>
<li>创建一个ofstream对象</li>
<li>将这个对象链接到特定的文件</li>
<li>用输入输出流控制命令，对文件中的字节进行操作</li>
</ol>
<p>打开一个文件可以用open()方法<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建文件对象</span></span><br><span class="line">ofstream fout;</span><br><span class="line"><span class="comment">//将文件对象与特定文件相互链接</span></span><br><span class="line">fout.<span class="built_in">open</span>(<span class="string">&quot;jar.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者在定义对象的时候初始化链接</span></span><br><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">&quot;jar.txt&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure><br>文件对象在输入或者输出的时候，会对每一个文件对象设立一个缓冲区，这个缓冲区存储输入的字节，当缓冲区满了以后，再将其中的内容转换到文件中。这种以缓冲区为单位一块块地传输字节，极大地提升了文件处理的速度。<br>读取文件中的内容<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ch;</span><br><span class="line">fin &gt;&gt; ch;</span><br><span class="line"><span class="type">char</span> buffer[<span class="number">80</span>];</span><br><span class="line">fin.<span class="built_in">getline</span>(buffer,<span class="number">80</span>);<span class="comment">//getline在string函数头中</span></span><br><span class="line">string line;</span><br><span class="line"><span class="built_in">getline</span>(fin, line);</span><br></pre></td></tr></table></figure><br>可以用close方法，断开文件对象与文件的链接，这样能够保证文件缓冲区就会被刷新，这样保证了文件会被实时更新。<br>下面是对文件的输入操作的实例。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fileio17_16</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string filename;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Enter name for new file: &quot;</span>;</span><br><span class="line">	cin &gt;&gt; filename;</span><br><span class="line"></span><br><span class="line">	<span class="function">ofstream <span class="title">fout</span><span class="params">(filename.c_str())</span></span>;<span class="comment">//将C++的string类型转换成C语言的char数组，返回一个数组指针</span></span><br><span class="line"></span><br><span class="line">	fout &lt;&lt; <span class="string">&quot;For your eyes only!\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Enter your secret number:&quot;</span>;</span><br><span class="line">	<span class="type">float</span> secret;</span><br><span class="line">	cin &gt;&gt; secret;</span><br><span class="line">	fout &lt;&lt; <span class="string">&quot;Your secret number is &quot;</span> &lt;&lt; secret &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	fout.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">	<span class="function">ifstream <span class="title">fin</span><span class="params">(filename.c_str())</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Here are the contents of &quot;</span> &lt;&lt; filename &lt;&lt; <span class="string">&quot;:\n&quot;</span>;</span><br><span class="line">	<span class="type">char</span> ch;</span><br><span class="line">	<span class="keyword">while</span> (fin.<span class="built_in">get</span>(ch))</span><br><span class="line">		cout &lt;&lt; ch;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Done\n&quot;</span>;</span><br><span class="line">	fin.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//return 0;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="总结（主要记录遇到的问题）"><a href="#总结（主要记录遇到的问题）" class="headerlink" title="总结（主要记录遇到的问题）"></a>总结（主要记录遇到的问题）</h1><font color="#999AAA">

<p>1.想直接赋值字符串而不是字符(Solved)</p>
<blockquote>
<p>字符串常量可以作为初值赋给字符型数组，并用%s输出<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="type">char</span> strl[<span class="number">25</span>] = <span class="string">&quot;cser&quot;</span>;</span><br><span class="line">&gt;<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, strl);</span><br><span class="line">&gt;<span class="comment">//对于字符串型可以转化成字符数组，但是不能赋值给字符变量</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>2.用VS2019编译sanf无法通过，出现C4996错误。(Solved)</p>
<blockquote>
<p>在 Visual Studio 中关闭项目的警告：打开项目的 “属性页” 对话框。 选择 “配置属性” “ &gt; c/c + + &gt; 高级” 属性页。编辑 “禁用特定警告” 属性以添加 4996 。 选择 “确定” 以应用所做的更改。</p>
<p>3.浮点型的有效精度（？）<br>4.“四舍六入五成双”规则？<br>5.menset按字节赋值？<br>6.系统栈&amp;静态存储区？<br>7.正则表达式？<br>8.浮点数不总是精确的详细原因</p>
</blockquote>
</font></font></font>  
	</div>
		<footer class="article-footer clearfix">

  <div class="article-tags">
  
  <span></span> <a href="/tags/C/">C++</a>
  </div>




<div class="article-share" id="share">

  <div data-url="http://example.com/2020/12/31/%E3%80%8A%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%8B%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86C-C-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/" data-title="《算法笔记》第一部分C/C++语言基础 | Hexo" data-tsina="" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2021/01/02/Wireshark-Lab-Getting-Started/" title="Wireshark Lab:Getting Started">
  <strong>PREVIOUS:</strong><br/>
  <span>
  Wireshark Lab:Getting Started</span>
</a>
</div>


</nav>

	
</div>  
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">Contents</strong>
  <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E3%80%8A%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%8B%E7%9A%84%E7%AC%94%E8%AE%B0"><span class="toc-number">1.</span> <span class="toc-text">《算法笔记》的笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">2.1 基本数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">2.2 顺序结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-%E8%B5%8B%E5%80%BC%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.2.1 赋值语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E8%AF%AD%E5%8F%A5%EF%BC%88scanf-printf%EF%BC%89"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2.2 输入&#x2F;输出语句（scanf&#x2F;printf）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-3-getchar-amp-putchar"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.2.3 getchar &amp; putchar</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-5-typedef"><span class="toc-number">1.2.4.</span> <span class="toc-text">2.2.5 typedef</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-6-%E5%B8%B8%E7%94%A8%E7%9A%84math%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.5.</span> <span class="toc-text">2.2.6 常用的math函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.</span> <span class="toc-text">2.3 选择结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E6%95%B0%E7%BB%84"><span class="toc-number">1.4.</span> <span class="toc-text">2.5 数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-1-%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">1.4.1.</span> <span class="toc-text">2.5.1 一维数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-2-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">1.4.2.</span> <span class="toc-text">2.5.2 冒泡排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-3-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">1.4.3.</span> <span class="toc-text">2.5.3 二维数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-4-memset%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.4.</span> <span class="toc-text">2.5.4 memset函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-5-%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84"><span class="toc-number">1.4.5.</span> <span class="toc-text">2.5.5 字符数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-6-string-h%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-number">1.4.6.</span> <span class="toc-text">2.5.6 string.h头文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-7-sscanf-amp-sprintf"><span class="toc-number">1.4.7.</span> <span class="toc-text">2.5.7 sscanf &amp; sprintf</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.</span> <span class="toc-text">2.6 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-%E6%8C%87%E9%92%88"><span class="toc-number">1.6.</span> <span class="toc-text">2.7 指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Pointers-and-Arrays"><span class="toc-number">1.6.1.</span> <span class="toc-text">Pointers and Arrays</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-8-%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%88struct%EF%BC%89%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.7.</span> <span class="toc-text">2.8 结构体（struct）的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-1-%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F%E4%BB%A5%E5%8F%8A%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F"><span class="toc-number">1.7.1.</span> <span class="toc-text">2.8.1 结构体的定义方式以及访问方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-3-%E7%BB%93%E6%9E%84%E4%BD%93%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.7.2.</span> <span class="toc-text">2.8.3 结构体初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-9-%E8%A1%A5%E5%85%85%E5%86%85%E5%AE%B9"><span class="toc-number">1.8.</span> <span class="toc-text">2.9 补充内容</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-9-1-cin-%E4%B8%8E-cout"><span class="toc-number">1.8.1.</span> <span class="toc-text">2.9.1 cin 与 cout</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-9-2-%E6%B5%AE%E7%82%B9%E6%95%B0%E6%AF%94%E8%BE%83"><span class="toc-number">1.8.2.</span> <span class="toc-text">2.9.2 浮点数比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-10-%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95"><span class="toc-number">1.9.</span> <span class="toc-text">2.10 黑盒测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%E5%86%85%E5%AE%B9"><span class="toc-number">2.</span> <span class="toc-text">补充内容</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84"><span class="toc-number">2.1.</span> <span class="toc-text">动态数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%85%B1%E7%94%9F%E4%BD%93"><span class="toc-number">2.2.</span> <span class="toc-text">C语言的共生体</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F"><span class="toc-number">2.2.1.</span> <span class="toc-text">定义方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%85%B1%E7%94%9F%E4%BD%93%E6%88%90%E5%91%98"><span class="toc-number">2.2.2.</span> <span class="toc-text">访问共生体成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B"><span class="toc-number">2.2.3.</span> <span class="toc-text">实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E4%BD%8D%E5%9F%9F"><span class="toc-number">2.3.</span> <span class="toc-text">C 位域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.4.</span> <span class="toc-text">枚举类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0"><span class="toc-number">2.5.</span> <span class="toc-text">友元函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD"><span class="toc-number">2.6.</span> <span class="toc-text">重载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">2.6.1.</span> <span class="toc-text">函数重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">2.6.2.</span> <span class="toc-text">运算符重载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%EF%BC%88C-PrimerPlus%EF%BC%89"><span class="toc-number">2.7.</span> <span class="toc-text">文件（C++PrimerPlus）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA"><span class="toc-number">2.7.1.</span> <span class="toc-text">文件输入和输出</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%BB%E8%A6%81%E8%AE%B0%E5%BD%95%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">总结（主要记录遇到的问题）</span></a></li></ol>
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  

  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			<li><a href="/tags/C/" title="C++">C++<sup>1</sup></a></li>
		
			<li><a href="/tags/C-primer/" title="C++ primer">C++ primer<sup>1</sup></a></li>
		
			<li><a href="/tags/DB/" title="DB">DB<sup>1</sup></a></li>
		
			<li><a href="/tags/OS/" title="OS">OS<sup>2</sup></a></li>
		
			<li><a href="/tags/Projects/" title="Projects">Projects<sup>1</sup></a></li>
		
			<li><a href="/tags/bugs/" title="bugs">bugs<sup>1</sup></a></li>
		
			<li><a href="/tags/computer-network/" title="computer network">computer network<sup>2</sup></a></li>
		
			<li><a href="/tags/侯捷C/" title="侯捷C++">侯捷C++<sup>5</sup></a></li>
		
		</ul>
</div>


  <div class="rsspart">
	<a href="" target="_blank" title="rss">RSS</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<div class="social-font clearfix">
		
		
		
		
		
	</div>
		<p class="copyright">Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/A-limon/pacman" target="_blank" title="Pacman">Pacman</a> © 2023 
		
		<a href="http://example.com" target="_blank" title="John Doe">John Doe</a>
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>






  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<!-- <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
</body>
</html>
