<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Baymine&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Baymine&#039;s Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Baymine&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Baymine&#039;s Blog"><meta property="og:url" content="https://baymine.github.io/"><meta property="og:site_name" content="Baymine&#039;s Blog"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://baymine.github.io/img/og_image.png"><meta property="article:author" content="John Doe"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://baymine.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://Baymine.github.io"},"headline":"Baymine's Blog","image":["https://baymine.github.io/img/og_image.png"],"author":{"@type":"Person","name":"John Doe"},"publisher":{"@type":"Organization","name":"Baymine's Blog","logo":{"@type":"ImageObject","url":"https://baymine.github.io/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style><link rel="alternate" href="/atom.xml" title="Baymine's Blog" type="application/atom+xml">
</head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Baymine&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item is-active" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-06-03T02:56:51.000Z" title="6/3/2024, 10:56:51 AM">2024-06-03</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-06-05T07:39:57.313Z" title="6/5/2024, 3:39:57 PM">2024-06-05</time></span><span class="level-item">2 minutes read (About 365 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%95%99%E8%82%B2%E7%BC%BA%E5%A4%B1%E7%9A%84%E4%B8%80%E8%AF%BE/">计算机教育缺失的一课</a></p><div class="content"><h1 id="Shell-工具和脚本"><a href="#Shell-工具和脚本" class="headerlink" title="Shell 工具和脚本"></a>Shell 工具和脚本</h1><ul>
<li>在bash中，单引号中不会替换变量，双引号会<ul>
<li><code>echo '$HOME'</code> 输出 <code>$HOME</code></li>
<li><code>echo "$HOME"</code> 输出 <code>/home/username</code></li>
</ul>
</li>
<li><code>!!</code> 会替换成上一条命令</li>
<li><code>$1</code> 表示函数本身，<code>$2</code> 表示第一个参数，<code>$3</code> 表示第二个参数，依次类推<ul>
<li><code>$?</code> 表示上一条命令的返回值(错误代码)<ul>
<li>0 表示成功; 1 表示失败</li>
</ul>
</li>
<li><code>$#</code> 表示参数个数, <code>$*</code> 表示所有参数, <code>$@</code> 表示所有参数, <code>$$</code> 表示当前进程的进程号</li>
</ul>
</li>
<li><code>/dev/null</code> 是一个特殊的文件，所有写入它的内容都会被丢弃(黑洞文件)</li>
<li>批量创建文件夹 <code>mkdir dir{1..10}</code>，创建文件也可以使用同样的方式。<ul>
<li>大括号内部的实际上可以算是一个组合元素<ul>
<li><code>touch {foo,bar}.{py,cpp,c,java}</code></li>
</ul>
</li>
</ul>
</li>
<li><code>#!/usr/bin/env python</code> 这实际上是在指定这个脚本使用的解释器，这样可以直接使用<code>./script.py</code>来运行脚本，而不需要<code>python script.py</code></li>
<li>查找文件（夹）<ul>
<li><code>find . -name src -type d</code> 查找当前目录下的所有名为<code>src</code>的文件夹</li>
<li><code>find . -name "*.tmp" -exec rm {} \;</code> 查找当前目录下的所有<code>.tmp</code>文件并删除</li>
<li><code>grep -R foobar .</code></li>
</ul>
</li>
<li><code>ls -R</code> 递归列出所有文件</li>
</ul>
<h1 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h1><h1 id="数据整理"><a href="#数据整理" class="headerlink" title="数据整理"></a>数据整理</h1><ul>
<li><code>sed</code>: Stream Editor<ul>
<li>支持使用正则表达式进行查询修改： <code>sed 's/old-text/new-text/g' filename</code></li>
</ul>
</li>
<li><code>sort</code>: 将内容进行排序 , <code>uniq -c</code>: 统计重复行的次数<ul>
<li><code>sort filename | uniq -c</code></li>
</ul>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-05-29T13:26:01.000Z" title="5/29/2024, 9:26:01 PM">2024-05-29</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-06-05T12:30:41.095Z" title="6/5/2024, 8:30:41 PM">2024-06-05</time></span><span class="level-item">9 minutes read (About 1300 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/05/29/Clickhouse%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E6%97%A5%E8%AE%B0/">Clickhouse源码阅读日记</a></p><div class="content"><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><h2 id="列（Columns）"><a href="#列（Columns）" class="headerlink" title="列（Columns）"></a>列（Columns）</h2><h2 id="字段（Field）"><a href="#字段（Field）" class="headerlink" title="字段（Field）"></a>字段（Field）</h2><blockquote>
<p>src\Core\Field.h</p>
</blockquote>
<p>字段实现是一个联合类， <code>std::aligned_union_t</code>，而一行数据在此文件当中定义为<code>using Row = std::vector&lt;Field&gt;;</code></p>
<blockquote>
<p>Field 中并没有足够的关于一个表（table）的特定数据类型的信息。比如，UInt8、UInt16、UInt32 和 UInt64 在 Field 中均表示为 UInt64。</p>
</blockquote>
<p>在代码当中，<code>createConcrete</code> 是一个模板函数，用于在给定的存储空间中创建一个具体的对象。小类型可能会被存储为更宽的类型，例如 char 可能会被存储为 UInt64。</p>
<h2 id="块（Block）"><a href="#块（Block）" class="headerlink" title="块（Block）"></a>块（Block）</h2><blockquote>
<p>If we have a <code>Block</code>, we have data (in the <code>IColumn</code> object), we have information about its type (in <code>IDataType</code>) that tells us how to deal with that column, and we have the column name. </p>
</blockquote>
<p>这个类的成员变量当中有一个由<code>IColumn</code>指针组成的向量，还有一个由map组成的索引，用于存储列名到列索引的映射。同时还包含一个块信息的结构体。</p>
<h2 id="MaterializedView"><a href="#MaterializedView" class="headerlink" title="MaterializedView"></a>MaterializedView</h2><p><code>MaterializedView</code>是一种特殊的表，它根据预定义的SELECT查询语句存储数据。当插入新数据到源表时，这些数据也会被插入到<code>MaterializedView</code>中。</p>
<p><code>MaterializedView</code>的主要用途是预计算复杂的查询。例如，你可能有一个包含大量数据的表，你需要对这个表进行一些复杂的聚合查询。如果每次需要结果时都运行这些查询，可能会非常慢。相反，你可以创建一个<code>MaterializedView</code>，它根据你的查询预先计算结果。然后，你可以直接查询<code>MaterializedView</code>，这通常会比直接查询原始表快得多。</p>
<h1 id="编程范式"><a href="#编程范式" class="headerlink" title="编程范式"></a>编程范式</h1><h2 id="NOLINT"><a href="#NOLINT" class="headerlink" title="// NOLINT"></a>// NOLINT</h2><p>在代码中添加 NOLINT 注释是一种指示，通常用于告诉静态代码分析工具或代码审查工具不要对特定行或块发出警告或错误报告。</p>
<p><code>例如在使用reinterpret_cast的时候</code></p>
<h2 id="类名称：-Helper"><a href="#类名称：-Helper" class="headerlink" title="类名称：*Helper"></a>类名称：<em>*</em>Helper</h2><p>通常是一个模板类的特化，可以是一个中间表示，其中实现了<em>*</em>（类名）的一些功能，作为统一的处理方式</p>
<p><code>例如：template &lt;typename T&gt; class ColumnVectorHelper;</code></p>
<h2 id="类名称：-Dummy"><a href="#类名称：-Dummy" class="headerlink" title="类名称：*Dummy"></a>类名称：<em>*</em>Dummy</h2><p>在C++编程中，如果一个类被命名为含有”Dummy”的名称，比如IColumnDummy，这通常意味着该类是一个占位符类（Placeholder Class）或者是一个模拟类（Mock Class）。</p>
<p><code>例如：class IColumnDummy : public IColumn;</code></p>
<h2 id="在数组第一个元素前预留一个空间（-1th）"><a href="#在数组第一个元素前预留一个空间（-1th）" class="headerlink" title="在数组第一个元素前预留一个空间（-1th）"></a>在数组第一个元素前预留一个空间（-1th）</h2><p>这个设计在将偏移量数组转换为大小数组时提供了性能优势。在处理这种转换时，通常需要计算当前元素的大小，即下一个元素的偏移量减去当前元素的偏移量。有了额外的 0 值的 -1th 元素，计算第一个元素的大小时，可以直接用 0 减去第一个元素的偏移量，而不需要特殊处理。这样简化了代码，减少了条件分支，并可能提高计算速度。</p>
<p><code>在链表插入的过程中使用dummy_header也是类似的设计</code></p>
<blockquote>
<p>1.在高性能计算或大数据处理中，避免条件分支可以显著提高循环的效率，因为现代处理器对分支预测有困难，尤其是在分支密集的情况下。<br>2.在处理向量数据或使用单指令多数据（SIMD）指令时，if 语句可能导致向量操作的分裂<br>3.分支惩罚</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://clickhouse.com/docs/zh/development/architecture#lie-columns">对于 String 列和 Array 列，则由两个向量组成：其中一个向量连续存储所有的 String 或数组元素，另一个存储每一个 String 或 Array 的起始元素在第一个向量中的偏移。</a></p>
</blockquote>
<p>在这种场景下，偏移数组可能需要转换成大小数组，这个时候可以利用到这种优化</p>
</blockquote>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="loop-vectorization-循环向量化"><a href="#loop-vectorization-循环向量化" class="headerlink" title="loop vectorization(循环向量化)"></a>loop vectorization(循环向量化)</h2><p>循环向量化是一种编译器优化技术，用于将循环转换为向量化指令，以便在单个指令中处理多个数据元素。这种技术可以提高程序的性能，因为它可以利用现代处理器的SIMD指令集，同时减少循环的迭代次数。</p>
<p><code>例如：for (int i = 0; i &lt; n; ++i) { c[i] = a[i] + b[i]; }</code></p>
<h1 id="语言-语法"><a href="#语言-语法" class="headerlink" title="语言/语法"></a>语言/语法</h1><h2 id="C-11-using-引入构造函数"><a href="#C-11-using-引入构造函数" class="headerlink" title="C++11 using 引入构造函数"></a>C++11 using 引入构造函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINE_FIELD_VECTOR(X) \</span></span><br><span class="line"><span class="meta">struct X : public FieldVector \</span></span><br><span class="line"><span class="meta">{ \</span></span><br><span class="line"><span class="meta">    using FieldVector::FieldVector; \</span></span><br><span class="line"><span class="meta">}</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">using</span> FieldVector::FieldVector;：这是 C++<span class="number">11</span> 引入的 <span class="keyword">using</span> 声明，它引入了基类（FieldVector）的构造函数到派生类（X）的作用域中。</span><br><span class="line">(第一个FieldVector是类名，第二个是构造函数的函数名称，这引入了所有的构造函数)</span><br><span class="line"></span><br><span class="line">这意味着 X 类可以使用 FieldVector 的所有构造函数，而无需重复定义。</span><br><span class="line">这有助于避免构造函数的代码重复，并保持代码简洁。</span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-01-05T08:48:47.000Z" title="1/5/2023, 4:48:47 PM">2023-01-05</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-01-16T11:35:05.596Z" title="1/16/2023, 7:35:05 PM">2023-01-16</time></span><span class="level-item">4 minutes read (About 538 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/01/05/GeePRC-notes/">GeePRC notes</a></p><div class="content"><h2 id="项目大纲"><a href="#项目大纲" class="headerlink" title="项目大纲"></a>项目大纲</h2><ul>
<li><p>codec.go</p>
<ul>
<li>报文Header</li>
<li>消息体编码解码的接口 Codec<ul>
<li>读取报头</li>
<li>读取主体</li>
<li>写入报头的方法</li>
</ul>
</li>
<li>Codec的构造函数</li>
<li>可选用的编码方式<ul>
<li>存储在一个map中<ul>
<li>不同的编码方式调用不同的codec构造函数</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>gob.go</p>
<ul>
<li>gob结构体</li>
<li>GobCodec实现接口codec</li>
</ul>
</li>
<li><p>server.go</p>
<ul>
<li>Option<ul>
<li>标识<ul>
<li>Magic number</li>
</ul>
</li>
<li>编码方式</li>
<li>默认的Option</li>
</ul>
</li>
</ul>
</li>
<li><p>main.go</p>
<ul>
<li>创建一个监听者<ul>
<li>通过一个协程在执行</li>
<li>协程中的得到的地址通过管道通知主线程</li>
</ul>
</li>
<li>确定编码方式</li>
<li>发送接收<ul>
<li>创建报头</li>
<li>写入<ul>
<li>cc.Write()</li>
</ul>
</li>
<li>接收回应<ul>
<li>cc.ReadHeader()</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="bug"><a href="#bug" class="headerlink" title="bug"></a>bug</h2><p>day5, go run main.go:<br>rpc server: register Foo.Sum<br>rpc server debug path: /debug/geerpc<br>call Foo.Sum error:rpc server: request handle timeout: expect within 10ns<br>exit status 1</p>
<h2 id="Chanllenge"><a href="#Chanllenge" class="headerlink" title="Chanllenge"></a>Chanllenge</h2><h3 id="网络粘包"><a href="#网络粘包" class="headerlink" title="网络粘包"></a>网络粘包</h3><p>执行 <code>go test -v</code> 会有一定概率出现测试卡死无响应的bug<br><a target="_blank" rel="noopener" href="https://github.com/geektutu/7days-golang/issues/26">issue</a></p>
<h2 id="Great-designs"><a href="#Great-designs" class="headerlink" title="Great designs"></a>Great designs</h2><h3 id="使用通道实现超时判断"><a href="#使用通道实现超时判断" class="headerlink" title="使用通道实现超时判断"></a>使用通道实现超时判断</h3><p>在goroutine中，完成一步之后往管道内传入<code>struct {}{}</code>这样，在goroutine外部就可以接收到这些信息，这样外部就知道goroutine内部某个函数完成了，<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">callChannel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>{})</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>{</span><br><span class="line">  err := call(args)</span><br><span class="line">  callChannel &lt;- <span class="keyword">struct</span>{}{}</span><br><span class="line">}()</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> {</span><br><span class="line">  <span class="keyword">case</span> &lt;-time.After(timeout):  <span class="comment">// 处理超时</span></span><br><span class="line">    timeout handling</span><br><span class="line">  <span class="keyword">case</span> &lt;-callChannel:</span><br><span class="line">    function finished</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<h2 id="Knowledges"><a href="#Knowledges" class="headerlink" title="Knowledges"></a>Knowledges</h2><h3 id="如何结束一个goroutine"><a href="#如何结束一个goroutine" class="headerlink" title="如何结束一个goroutine"></a>如何结束一个goroutine</h3><p>利用管道传入一个结束信息（这里是true），然后返回函数即可<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        <span class="keyword">select</span> {</span><br><span class="line">        <span class="keyword">case</span> &lt;- quit:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">// Do other stuff</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do stuff</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Quit goroutine</span></span><br><span class="line">quit &lt;- <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<h3 id="encoding-gob"><a href="#encoding-gob" class="headerlink" title="encoding/gob"></a>encoding/gob</h3><ul>
<li>Package gob 管理 gobs 流 - 在编码器（发送器）和解码器（接收器）之间交换的二进制值</li>
<li><pre><code class="lang-go">enc := gob.NewEncoder(&amp;network) // 将写入网络。
dec := gob.NewDecoder(&amp;network) // 将从网络上读取。
// Encoding（发送）一些值。
err := enc.Encode(P{3, 4, 5, "Pythagoras"})
// 接收
var q Q
err = dec.Decode(&amp;q)
</code></pre>
</li>
</ul>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><h3 id="Context-package"><a href="#Context-package" class="headerlink" title="Context package"></a>Context package</h3><ul>
<li>context 主要用来在 goroutine 之间传递上下文信息，包括：取消信号、超时时间、截止时间、k-v 等。</li>
<li>一句话：context 用来解决 goroutine 之间 <code>退出通知</code>、<code>元数据传递</code>的功能。</li>
<li><img src="https://pic3.zhimg.com/80/v2-6a27526f536505cea08a5813ccce05b2_720w.webp" alt></li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-12-18T07:04:19.000Z" title="12/18/2022, 3:04:19 PM">2022-12-18</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-06-16T08:44:58.017Z" title="6/16/2024, 4:44:58 PM">2024-06-16</time></span><span class="level-item">4 minutes read (About 641 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/12/18/C-Memory-Management/">C++ Memory Management</a></p><div class="content"><h1 id="第一讲-primitives"><a href="#第一讲-primitives" class="headerlink" title="第一讲 primitives"></a>第一讲 primitives</h1><h3 id="1-overview"><a href="#1-overview" class="headerlink" title="1. overview"></a>1. overview</h3><ul>
<li>资料： <a target="_blank" rel="noopener" href="http://gee.cs.oswego.edu/dl/">DL Malloc</a></li>
<li>涉及的库</li>
</ul>
<p><img src="https://Baymine.github.io/images/C-Memory-Management/1671347745514.png" alt="1671347745514"></p>
<h3 id="2、3-内存分配的每一层面及基本用法"><a href="#2、3-内存分配的每一层面及基本用法" class="headerlink" title="2、3. 内存分配的每一层面及基本用法"></a>2、3. 内存分配的每一层面及基本用法</h3><p><img src="https://Baymine.github.io/images/C-Memory-Management/1671348085106.png" alt="1671348085106"></p>
<p>本课程只考虑CRT以上的层次。</p>
<p><strong>基本工具</strong></p>
<p><img src="https://Baymine.github.io/images/C-Memory-Management/1671348161500.png" alt="1671348161500"></p>
<p><strong>基本用法</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* p3 = ::<span class="keyword">operator</span> <span class="built_in">new</span> (<span class="number">512</span>);   <span class="comment">// 512 bytes</span></span><br><span class="line">::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(p3)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __BORLANDC__  <span class="comment">// 不同库不同</span></span></span><br><span class="line">	<span class="comment">// 申请5个int。 一般容器中使用</span></span><br><span class="line">	<span class="type">int</span>* p4 = <span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">allocate</span>(<span class="number">5</span>);</span><br><span class="line">	<span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">deallocate</span>(p4, <span class="number">5</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __GNUC__   <span class="comment">// 较早版本中</span></span></span><br><span class="line">	<span class="type">void</span>* p4 = alloc::<span class="built_in">allocate</span>(<span class="number">512</span>);</span><br><span class="line">	alloc::<span class="built_in">deallocate</span>(p4, <span class="number">512</span>);</span><br><span class="line"> <span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="4、5、6、基本构件——new-delete-expression"><a href="#4、5、6、基本构件——new-delete-expression" class="headerlink" title="4、5、6、基本构件——new delete expression"></a>4、5、6、基本构件——new delete expression</h3><p>new 中实际上就是在调用malloc</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class_name* pc = <span class="keyword">new</span> <span class="built_in">class_name</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器转换为</span></span><br><span class="line"><span class="comment">// 加上try catch</span></span><br><span class="line"><span class="type">void</span>* mem = <span class="keyword">operator</span> <span class="built_in">new</span>(<span class="built_in">sizeof</span>(class_name));</span><br><span class="line">pc = <span class="built_in">static_cast</span>&lt;class_name*&gt;(mem);</span><br><span class="line">pc-&gt;class_name::<span class="built_in">class_name</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 只有编译其才能这样调用构造函数</span></span><br><span class="line"><span class="comment">// 但是可以直接调用析构函数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="7、Array-new"><a href="#7、Array-new" class="headerlink" title="7、Array new"></a>7、Array new</h3><p>当new一个数组的时候，系统会使用4个字节存放数组的一些信息，即为下图中的 <code>cookie</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Complex* pca = <span class="keyword">new</span> Complex[<span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<p><img src="https://Baymine.github.io/images/C-Memory-Management/1671438018665.png" alt="1671438018665"></p>
<ul>
<li>在进行array new的时候，单个元素不会独自进行内存对齐。</li>
<li>构建的时候是从上往下，析构的时候是由下往上</li>
<li><img src="https://Baymine.github.io/images/C-Memory-Management/1671439085184.png" alt="1671439085184"><ul>
<li><code>61h</code>就是cokie，需要进行内存对齐（VC6)中是16位对齐</li>
<li>对于申请的int类型的数组，可以直接使用delete，因为这些数据类型没有析构函数，</li>
</ul>
</li>
<li><img src="https://Baymine.github.io/images/C-Memory-Management/1671440046493.png" alt="1671440046493"><ul>
<li>因为数组个数被写入，所以内存的整体布局会发生变化，所以不能直接用 <code>delete</code>来回收</li>
<li><code>61h</code>的大小计算<ul>
<li>类大小<em>类个数=((3</em>4) <em> 3) = 36\ 上下debugger header = 32 + 4\ 两个61h=4</em>2=8</li>
<li>最后向16的倍数内存对齐最后的 <code>pad</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="8-palcement-new"><a href="#8-palcement-new" class="headerlink" title="8.palcement new"></a>8.palcement new</h3><p>允许将对象构造与已分配的内存中</p>
<p><img src="https://Baymine.github.io/images/C-Memory-Management/1671441329456.png" alt="1671441329456"></p>
<h3 id="9-random"><a href="#9-random" class="headerlink" title="9.random"></a>9.random</h3><ul>
<li>placement new 的重载</li>
<li>嵌入式指针使用案例（内存池）<ul>
<li>通过一次性申请一定量的内存，减少每个内存中的cookie的数量，同时减少malloc的调用</li>
<li>整个内存是通过一个链表管理的，释放内存就是将空闲的内存插入到链表头部</li>
<li>但是申请的内存没有真正释放，所以可能会存在使用峰值的问题</li>
</ul>
</li>
</ul>
<p><img src="https://Baymine.github.io/images/C-Memory-Management/1671541094430.png" alt="1671541094430"></p>
<ul>
<li>可以自定义handler来让更多的空间可用，或者调用abort() 或 exit();</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set_new_handler</span>(handlerFunctionPoint);</span><br></pre></td></tr></table></figure>
<ul>
<li>default, delete 关键字</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-12-16T03:53:01.000Z" title="12/16/2022, 11:53:01 AM">2022-12-16</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-06-16T08:47:39.428Z" title="6/16/2024, 4:47:39 PM">2024-06-16</time></span><span class="level-item">an hour read (About 7460 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/12/16/MIT6-S081/">MIT6.S081</a></p><div class="content"><h1 id="Reading"><a href="#Reading" class="headerlink" title="Reading"></a>Reading</h1><h3 id="Chapter-1-Operating-system-interfaces"><a href="#Chapter-1-Operating-system-interfaces" class="headerlink" title="Chapter 1: Operating system interfaces"></a>Chapter 1: Operating system interfaces</h3><ul>
<li>the shell is a user program, and not part of the kernel</li>
<li>Although the child has the same memory contents as the parent initially, the parent and child are executing with different memory and different registers: changing a variable in one does not affect the other.</li>
<li><p><code>exec</code> replaces the calling process’s memory but preserves its file table</p>
<ul>
<li><code>exec</code> replaces the memory and registers of the current process with a new program</li>
</ul>
</li>
<li><p>I/O and File descriptors</p>
<ul>
<li>The shell ensures that it always has three file descriptors open<ul>
<li>std input, std output, std error</li>
<li>先close(0); 然后open, 让文件描述符与读相连接</li>
</ul>
</li>
<li>read(fd, buf, n)</li>
<li>write(fd, buf, n)</li>
<li><code>dup</code> system call duplicates an existing file descriptor, returning a new one that refers to the same underlying I/O object.</li>
<li>File descriptors are a powerful abstraction, because they hide the details of what they are connected to</li>
</ul>
</li>
<li><p>1.3 Pipes</p>
<ul>
<li>A pipe is a small kernel buffer exposed to processes as a pair of file descriptors, one for reading and one for writing.</li>
<li>命令行pipe实例： grep fork sh.c | wc -l 程序会分别为两个程序创建一个子进程，并递归地运行命令（可能会出现多管道的现象， a | b | c）</li>
<li>与重定向的优势<ul>
<li>会自动清理（重定向需要小心清理临时文件）</li>
<li>能传入任意长的数据流（重定向需要足够的disk空间存储所有的数据）</li>
<li>能够并行执行（重定向只能串行）</li>
</ul>
</li>
</ul>
</li>
<li><p>1.4 File system</p>
<ul>
<li><code>chdir</code>: change current directory</li>
<li><code>mkdir</code> creates a new directory, <code>open</code> with the <code>O_CREATE</code> flag creates a new data file, and <code>mknod</code> creates a new device file</li>
<li>The <code>link</code> system call creates another file system name referring to the same inode as an existing file.</li>
<li>The <code>fstat</code> system call retrieves information from the inode that a file descriptor refers to. It fills in a <code>struct stat</code>, defined in <code>stat.h</code><ul>
<li>Each inode is identified by a unique <code>inode number</code>.</li>
<li>The file’s inode and the disk space holding its content are only freed when the file’s link count is zero and no file descriptors refer to it(using <code>unlink</code>)</li>
</ul>
</li>
<li>sum-up： 文件目录变换，文件的结构和信息，文件的创建和关闭，Unix中运行文件相关命令的方法</li>
</ul>
</li>
</ul>
<h3 id="Chapter-2-Operating-system-organization"><a href="#Chapter-2-Operating-system-organization" class="headerlink" title="Chapter 2: Operating system organization"></a>Chapter 2: Operating system organization</h3><ul>
<li>Thus an operating system must fulfill three requirements: multiplexing, isolation, and interaction.</li>
<li><p>2.1 Abstracting physical resources</p>
<ul>
<li>通过函数结构访问disk的优势（让OS管理内存）</li>
</ul>
</li>
<li><p>2.2 User mode, supervisor mode, and system calls</p>
<ul>
<li>Machine mode<ul>
<li>have full privilege; a CPU starts in machine mode. Machine mode is mostly intended for configuring a computer.</li>
</ul>
</li>
<li>Supervisor mode(Kernel space)<ul>
<li>the CPU is allowed to execute privileged instructions<ul>
<li>If running privileged instructions in user mode, CPU wouldn’t execute it, but switch to the supervisor mode to terminate it</li>
</ul>
</li>
<li>the kernel control the entry point for transitions to supervisor mode</li>
</ul>
</li>
<li>User mode(User space)</li>
<li>实现程序之间隔离的方法</li>
</ul>
</li>
<li><p>2.3 Kernel organization</p>
<ul>
<li><p>monolithic kernel</p>
<ul>
<li>The <strong>entire operating system resides in the kernel</strong>, so that the implementations of all system calls run in supervisor mode</li>
<li><code>Pros</code>: Easy to cooperate, doesn’t have to decide which part of the operating system doesn’t need full hardware privileg</li>
<li><code>Cons</code>: 1. the interfaces between different parts of the operating system are often complex 2. a mistake is fatal, because an error in supervisor mode will often cause the kernel to fail</li>
</ul>
</li>
<li><p>microkernel</p>
<ul>
<li>minimize the amount of operating system code that runs in supervisor mode</li>
<li><img src="https://Baymine.github.io/images/MIT6-S081/microkernel.png" alt="img"></li>
<li>the kernel provides an <code>inter-process communication mechanism</code> to send messages from one user-mode process to another</li>
<li>OS services running as processes are called servers.<ul>
<li>it sends a message to the file server and waits for a response.</li>
</ul>
</li>
</ul>
</li>
<li>sum-up： 两种不同的内核设计方式</li>
</ul>
</li>
<li><p>2.5 Process overview</p>
<ul>
<li>The unit of isolation is a process.</li>
<li>The mechanisms used by the kernel to implement processes include the user/supervisor mode flag, address spaces, and time-slicing of threads</li>
<li><p>Xv6 maintains a separate page table for each process that defines that process’s address space</p>
<ul>
<li><p><img src="https://Baymine.github.io/images/MIT6-S081/virtual%20address%20space.png" alt="img"></p>
<ul>
<li>the trampoline page contains the code to transition in and out of the kernel</li>
<li>mapping the trapframe is necessary to save/restore the state of the user process</li>
</ul>
</li>
<li><p>The xv6 kernel maintains many pieces of state for each process, which it gathers into a <code>struct proc</code></p>
<ul>
<li>most important pieces of kernel state are its page table, its kernel stack, and its run state.</li>
</ul>
</li>
<li><p>Context switch between user space and kernel space</p>
<ul>
<li>To switch transparently between processes, the kernel suspends the currently running thread and resumes another process’s thread.</li>
<li>Each process has two stacks: a user stack and a kernel stack (<code>p-&gt;kstack</code>)<ul>
<li>the kernel can execute even if a process has wrecked its user stack.</li>
</ul>
</li>
<li><code>ecall</code>: change to kernel space; <code>sret</code>: to user space</li>
</ul>
</li>
</ul>
</li>
<li>Sum-up<ul>
<li>an address space to give a process the illusion of its own memory, and, a thread, to give the process the illusion of its own CPU</li>
<li>如何利用进程实现隔离性的以及进程的工作方式</li>
</ul>
</li>
</ul>
</li>
<li><p>2.7 Security Model</p>
<ul>
<li>Safeguards<ul>
<li>Assertions, type checking, stack guard pages, etc.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Chapter-3-Page-tables"><a href="#Chapter-3-Page-tables" class="headerlink" title="Chapter 3: Page tables"></a>Chapter 3: Page tables</h3><ul>
<li>provides each process with its own private address space and memory</li>
<li>Xv6 performs a few tricks: mapping the same memory (a trampoline page) in several address spaces, and guarding kernel and user stacks with an unmapped page.</li>
<li><p>3.1 Paging hardware</p>
<ul>
<li><p>The structure of page table</p>
<ul>
<li><img src="https://Baymine.github.io/images/MIT6-S081/pageTable.png" alt="img"></li>
</ul>
</li>
<li><p>Address translation</p>
<ul>
<li>A page table is stored in physical memory as a three-level tree. (first nine bits is used for indexing PPN of each <code>page directory</code>. and etc.)</li>
<li>If page is not found, raise <code>page-fault exception</code></li>
<li>In the common case in which large ranges of virtual addresses have no mappings, the three-level structure can omit entire page directories.(Allocate pages when they are needed)</li>
<li>flag bits that tell the paging hardware how the associated virtual address is allowed to be used<ul>
<li><strong>每个PTE都包含标志位，说明虚拟地址的使用权限。</strong><ul>
<li><code>PTE_V</code>表示 PTE 是否存在于页表中：如果未设置，那么一个对该页的引用会引发错误(也就是：不允许被使用（ <strong>validity</strong> ）)。</li>
<li><code>PTE_W</code>控制着能否对页执行写操作；</li>
<li><code>PTE_R</code> 控制是否允许使用指令读取页。</li>
<li><code>PTE_X</code>控制CPU是否可以将页面内容解释为指令并执行它们。</li>
<li><code>PTE_U</code>控制着用户程序能否使用该页；如果不能，则只有内核能够使用该页。</li>
</ul>
</li>
</ul>
</li>
<li><code>satp</code>: the physical address of the root pagetable page<ul>
<li>each CPU has its own <code>satp</code>(different CPUs can run different processes)</li>
</ul>
</li>
<li></li>
<li><img src="https://Baymine.github.io/images/MIT6-S081/address%20translation.png" alt="img"></li>
</ul>
</li>
<li><p>Translation Look-aside Buffer (TLB)</p>
<ul>
<li>Motivation: To avoid the cost of loading PTEs from physical memory<ul>
<li>a potential downside of three levels is that the CPU must load three PTEs from memory to perform the translation of the virtual address in the load/store instruction to a physical address.</li>
</ul>
</li>
<li>when xv6 changes a page table, it must tell the CPU to invalidate corresponding cached TLB entries.</li>
</ul>
</li>
</ul>
</li>
<li><p>3.2 Kernel address space</p>
<ul>
<li>Xv6 maintains one page table per process, describing each process’s user address space, plus a single page table that describes the kernel’s address space</li>
<li>The kernel gets at RAM and memory-mapped device registers using “direct mapping;<ul>
<li>Direct mapping simplifies kernel code that reads or writes physical memory.</li>
</ul>
</li>
<li>The guard page’s PTE is invalid (i.e.,PTE_V is not set), so that if the kernel overflows a kernel stack, it will likely cause an exception</li>
<li><img src="https://Baymine.github.io/images/MIT6-S081/kernel%20address%20space.png" alt="img"></li>
</ul>
</li>
<li><p>3.4 Physical memory allocation</p>
<ul>
<li>The kernel must allocate and free physical memory at run-time for page tables, user memory, kernel stacks, and pipe buffers.</li>
<li>Allocation consists of removing a page from the linked list; freeing consists of adding the freed page to the list.</li>
</ul>
</li>
<li><p>3.6 Process address space</p>
<ul>
<li><img src="https://Baymine.github.io/images/MIT6-S081/user%20addr%20space.png" alt="img"></li>
<li>A process’s user memory starts at virtual address zero and can grow up to <code>MAXVA</code>(The max bits the address can take)</li>
<li>Xv6 maps the data, stack, and heap with the permissions <code>PTE_R</code>, <code>PTE_W</code>, and <code>PTE_U</code>.<ul>
<li>Avoid the program modifies the unexpected regions.(the hardware will refuse to execute the store and raises a page fault)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="Lecture-Note"><a href="#Lecture-Note" class="headerlink" title="Lecture Note"></a>Lecture Note</h5><ul>
<li>Address space<ul>
<li>pagetable<ul>
<li>implemented in hardware by the processor or by unit called MMU</li>
<li>CPU—VA—&gt;MMU—-PA—-&gt;Memory<ul>
<li><code>satp</code>: In CPU, this register is used to specify where the map is(VA-&gt;PA). Each one process has unique address for the map(This is writen by the kernel for isolation)</li>
<li>MMU: 读取内存并转换，不保存映射</li>
</ul>
</li>
<li>The max bits of the virtual address is determined by the number of the registers</li>
</ul>
</li>
</ul>
</li>
<li>paging hardware(RISC-V)</li>
<li>xv6 virtual memory code and layout of the kernel address spaces and user address spaces</li>
<li>多级页表中存储PPN是44位的，末尾加上12个0，得到56位物理地址，这就是下一级页表的物理地址<ul>
<li>多次访问耗费时间，所以使用TLB（快表）[VA, PA] mapping</li>
</ul>
</li>
<li>MMU —-hardware</li>
</ul>
<h3 id="Chapter-4-Traps-and-system-calls"><a href="#Chapter-4-Traps-and-system-calls" class="headerlink" title="Chapter 4 Traps and system calls"></a>Chapter 4 Traps and system calls</h3><ul>
<li><p>CPU Interrupt</p>
<ul>
<li><p>Cases</p>
<ul>
<li>system call</li>
<li>exception</li>
<li>device interrupt<ul>
<li>While commonality among the three trap types suggests that a kernel could handle all traps with a single code path, it turns out to be convenient to have separate code for three distinct cases: traps from user space, traps from kernel space, and timer interrupts.</li>
</ul>
</li>
</ul>
</li>
<li><p>The usual sequence</p>
<ul>
<li>a trap forces a transfer of control into the kernel</li>
<li>the kernel saves registers and other state</li>
<li>the kernel restores the saved state and returns from the trap</li>
<li>original code resumes where it left off</li>
</ul>
</li>
<li><p>For what</p>
<ul>
<li>isolation demands that only the kernel be allowed to use devices</li>
<li>the kernel is a convenient mechanism with which to share devices among multiple processes</li>
</ul>
</li>
</ul>
</li>
<li><p>4.1 RISC-V trap machinery</p>
<ul>
<li>Each RISC-V CPU has a set of control registers that the kernel writes to tell the CPU how to handle traps, and that the kernel can read to find out about a trap that has occurred.</li>
<li>sum-up: CPU用专用的寄存器完成上下文转换。但为了trap的效率CPU并不会将所有任务都完成，剩余的工作需要由内核软件完成</li>
</ul>
</li>
<li><p>4.2 Traps from user space</p>
<ul>
<li>Occur if the user program makes a system call (<code>ecall</code> instruction), or does something illegal, or if a device interrupts</li>
<li>RISC-V hardware does not switch page tables when it forces a trap<ul>
<li>Things need to do<ul>
<li>trap handling code needs to switch to the kernel page table</li>
<li>the kernel page table must also have a mapping for the handler pointed to by stvec</li>
</ul>
</li>
<li>Trampoline page<ul>
<li><blockquote>
<p>Trampoline page <strong>stores code to switch between user and kernel space</strong>. The code is mapped at the same virtual address (TRAMPOLINE) in user and kernel space so that it continues to work when it switches page tables.</p>
</blockquote>
</li>
</ul>
</li>
<li><code>TRAPFRAME</code><ul>
<li>address of <code>TRAPFRAME</code> is stored in <code>sscratch</code> register. Saves all the user registers there, including the user’s a0, read back from sscratch.</li>
<li><code>TRAPFRAME</code> also contain the kernel information and the address of <code>usertrap</code> function.<ul>
<li><code>usertrap</code>: The job of <code>usertrap</code> is to determine the cause of the trap, process it, and return</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Pointer as argument on system call<ul>
<li>Problems<ul>
<li>Invalid pointer</li>
<li>kernel page table mappings are not the same as the user page table mappings so the kernel cannot use ordinary instructions to load or store from user-supplied addresses.</li>
</ul>
</li>
<li>Find PA by using user space page table and map it to the VA in the kernel space.</li>
</ul>
</li>
<li>sum-up: 在用户空间中调用trap。</li>
</ul>
</li>
<li>4.5 Traps from kernel space</li>
<li><p>4.6 Page-fault exceptions</p>
<ul>
<li><p>Actions</p>
<ul>
<li>In user space: kill the faulting process</li>
<li>In kernel space: kernel panics<ul>
<li><blockquote>
<p><strong>内核错误 (Kernel panic</strong> )是指操作系统在监测到内部的致命错误，并无法安全处理此错误时采取的动作。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>three kinds of page fault</p>
<ul>
<li>load page faults (when a load instruction cannot translate its virtual address)</li>
<li>store page faults (when a store instruction cannot translate its virtual address)</li>
<li>instruction page faults (when the address in the program counter doesn’t translate)</li>
</ul>
</li>
<li><p>The applications of page-fault exception</p>
<ul>
<li><p>copy-on-write fork</p>
<ul>
<li>Procedure<ul>
<li>the parent and child to initially share all physical pages, but for each to map them read-only</li>
<li>Write to that memory will raise a page-fault exception</li>
<li>The kernel’s trap handler responds by allocating a new page of physical memory and<br>copying into it the physical page that the faulted address maps to.</li>
</ul>
</li>
</ul>
</li>
<li><p>Lazy allocation</p>
<ul>
<li>Procedure<ul>
<li>application asks for more memory by calling <code>sbrk</code></li>
<li>The kernel notes the increase in size, but does not allocate memory or create PTEs</li>
<li>When page-fault occurs in those address, the kernel allocates a page of physical memory and maps it into the page table</li>
</ul>
</li>
<li>Since applications often ask for more memory than they need</li>
<li>Problem<ul>
<li>The extra overhead introduced by kernel/user transition<ul>
<li>reduce this cost by allocating a batch of consecutive pages per page fault instead of one page</li>
<li>specializing the kernel entry/exit code for such page-faults.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>demand paging(需求分页)</p>
<ul>
<li><p>Problem</p>
<ul>
<li>Since applications can be large and reading from disk is expensive, this startup cost may be noticeable to users</li>
</ul>
</li>
<li><p>Solution</p>
<ul>
<li>a modern kernel creates the page table for the user address space, but marks the PTEs for the pages invalid</li>
<li>On a page fault, the kernel reads the content of the page from disk and maps it into the user address space</li>
</ul>
</li>
</ul>
</li>
<li><p>paging to disk</p>
<ul>
<li><p>Problem</p>
<ul>
<li>The programs running on a computer may need more memory than the computer has RAM</li>
</ul>
</li>
<li><p>Solution</p>
<ul>
<li>to store only a fraction of user pages in RAM, and to store the rest on disk in a paging area.</li>
<li>The memory stored in the paging area is set as invalid.</li>
<li>Access paging area will incur a page fault. The kernel trap handler will allocate a page of physical RAM, read the page from disk into the RAM, and modify the relevant PTE to point to the RAM</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Chapter5-Interrupts-and-device-drivers"><a href="#Chapter5-Interrupts-and-device-drivers" class="headerlink" title="Chapter5 Interrupts and device drivers"></a>Chapter5 Interrupts and device drivers</h3><ul>
<li>A driver is the code in an operating system that<ul>
<li>manages a particular device: it configures the device hardware tells the device to perform operations</li>
<li>handles the resulting interrupts</li>
<li>interacts withprocesses that may be waiting for I/O from the device.</li>
</ul>
</li>
<li>device drivers execute code in two contexts<ul>
<li>top half that runs in a process’s kernel thread<ul>
<li>ask the hardware to start an operation</li>
<li>wait for the operation complete</li>
<li>raise an interrupt when the code is completed</li>
</ul>
</li>
<li>a bottom half that executes at interrupt time.<ul>
<li>what operation has completed, wakes up a waiting process if appropriate</li>
<li>tells the hardware to start work on any waiting next operation</li>
</ul>
</li>
</ul>
</li>
<li>A general pattern to note is the decoupling of device activity from process activity via buffering<br>and interrupts. (This idea is sometimes called <code>I/O concurrency</code>.)<ul>
<li>This decoupling can increase performance by allowing processes to execute concurrently with device I/O</li>
</ul>
</li>
<li>驱动程序完全禁用中断，并定期检查设备是否需要注意。这种技术被称为轮询（polling）<ul>
<li>如果设备执行操作非常快，轮询是有意义的，但是如果设备大部分空闲，轮询会浪费CPU时间。一些驱动程序根据当前设备负载在轮询和中断之间动态切换。</li>
</ul>
</li>
<li>程序I/O很简单，但速度太慢，无法在高数据速率下使用。需要高速移动大量数据的设备通常使用直接内存访问（DMA）<ul>
<li>DMA设备硬件直接将传入数据写入内存，并从内存中读取传出数据。</li>
<li>一些操作系统能够直接在用户空间缓冲区和设备硬件之间移动数据，通常带有DMA。</li>
</ul>
</li>
</ul>
<h3 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h3><ul>
<li>锁的缺点是它们会扼杀性能，因为它们会串行化并发操作</li>
<li><p>竞态条件是指多个进程读写某些共享数据（至少有一个访问是写入）的情况</p>
<ul>
<li>在内存池中，两个进程并行地释放内存，那么可能会导致释放的内存被放到同一个地址中，从而变成了覆盖</li>
<li><code>acquire</code>和 <code>release</code>之间的指令序列通常被称为临界区域（critical section）。（加锁的区域）</li>
<li>代码在执行的时候，依托一些 <code>不变量</code>(相当于一些条件)，但是其他进程对这个变量的操作暂时改变了这种不变量，所以导致代码运行错误。（上面就是链表头部指针有一个时间段中不是指向链表头部的，这时候其他进程的操作就可能导致竞态）</li>
<li>以将锁视为串行化（serializing）并发的临界区域，以便同时只有一个进程在运行这部分代码，从而维护不变量（假设临界区域设定了正确的隔离性）</li>
</ul>
</li>
<li><p>冲突</p>
<ul>
<li>如果多个进程同时想要相同的锁或者锁经历了争用，则称之为发生冲突（conflict）</li>
</ul>
</li>
<li><p>要使用多少锁，以及每个锁应该保护哪些数据和不变量</p>
<ul>
<li>任何时候可以被一个CPU写入，同时又可以被另一个CPU读写的变量，都应该使用锁来防止两个操作重叠</li>
<li>锁保护不变量（invariants）：如果一个不变量涉及多个内存位置，通常所有这些位置都需要由一个锁来保护，以确保不变量不被改变。</li>
<li>大内核锁（big kernel lock）<ul>
<li>如果并行性不重要，那么可以安排只拥有一个线程，而不用担心锁。一个简单的内核可以在多处理器上做到这一点，方法是拥有一个锁，这个锁必须在进入内核时获得，并在退出内核时释放</li>
</ul>
</li>
</ul>
</li>
<li><p>死锁和锁排序</p>
<ul>
<li>如果在内核中执行的代码路径必须同时持有数个锁，那么所有代码路径以相同的顺序获取这些锁是很重要的（否则有死锁的风险）</li>
<li>全局锁获取顺序的需求意味着锁实际上是每个函数规范的一部分：调用者必须以一种使锁按照约定顺序被获取的方式调用函数。</li>
</ul>
</li>
<li><p>锁和中断处理函数</p>
<ul>
<li>一个进程中持有一个变量，在执行过程中出现了中断，而中断处理函数可能又会需要访问这个变量，这时候处理函数就会等待这个变量被释放，这时候就产生了死锁<ul>
<li>如果一个自旋锁被中断处理程序所使用，那么CPU必须保证在启用中断的情况下永远不能持有该锁。</li>
</ul>
</li>
</ul>
</li>
<li><p>Re-entrant locks</p>
<ul>
<li>It might appear that some deadlocks and lock-ordering challenges could be avoided by using re-entrant locks, which are also called recursive locks.<ul>
<li>if the lock is held by a process and if that process attempts to acquire the lock again, then the kernel could just allow this</li>
</ul>
</li>
</ul>
</li>
<li><p>指令和内存访问顺序</p>
<ul>
<li>规则确实允许重新排序后改变并发代码的结果，并且很容易导致多处理器上的不正确行为。CPU的排序规则称为内存模型（memory model）。</li>
<li><code>__sync_synchronize()</code>是一个内存障碍：它告诉编译器和CPU不要跨障碍重新排序 <code>load</code>或 <code>store</code>指令。</li>
</ul>
</li>
<li><p>睡眠锁</p>
<ul>
<li>因为等待会浪费CPU时间，所以自旋锁最适合短的临界区域；睡眠锁对于冗长的操作效果很好。</li>
</ul>
</li>
</ul>
<h3 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h3><ul>
<li><p>任何操作系统都可能运行比CPU数量更多的进程，所以需要一个进程间分时共享CPU的方案</p>
<ul>
<li>通过将进程多路复用到硬件CPU上，使每个进程产生一种错觉，即它有自己的虚拟CPU</li>
</ul>
</li>
<li><p>多路复用</p>
<ul>
<li>情景<ul>
<li>进程等待设备或管道I/O完成，或等待子进程退出，或在 <code>sleep</code>系统调用中等待时，xv6使用睡眠（sleep）和唤醒（wakeup）机制切换</li>
<li>xv6周期性地强制切换以处理长时间计算而不睡眠的进程。</li>
</ul>
</li>
</ul>
</li>
<li><p>协程</p>
<ul>
<li>在两个线程之间进行这种样式化切换的过程有时被称为协程（coroutines）<ul>
<li>协程运行在线程之上，当一个协程执行完成后，可以选择主动让出，让另一个协程运行在当前线程之上。 <strong>协程并没有增加线程数量，只是在线程的基础之上通过分时复用的方式运行多个协程</strong> ，而且协程的切换在用户态完成，切换的代价比线程从用户态到内核态的代价小很多。</li>
<li><img src="https://pic3.zhimg.com/80/v2-f4fb2dea86d909ed60498b7021d0fe66_720w.webp" alt="img"></li>
<li>每个线程中运行多个协程</li>
<li><strong>协程只有和异步IO结合起来才能发挥出最大的威力。</strong><ul>
<li>假设协程运行在线程之上，并且协程调用了一个阻塞IO操作，这时候会发生什么？实际上操作系统并不知道协程的存在，它只知道线程，<strong>因此在协程调用阻塞IO操作的时候，操作系统会让线程进入阻塞状态，当前的协程和其它绑定在该线程之上的协程都会陷入阻塞而得不到调度，这往往是不能接受的。</strong></li>
</ul>
</li>
</ul>
</li>
<li>sleep 和 wakeup<ul>
<li>Xv6使用了一种称为 <code>sleep</code>和 <code>wakeup</code>的方法，它允许一个进程在等待事件时休眠，而另一个进程在事件发生后将其唤醒。睡眠和唤醒通常被称为序列协调（sequence coordination）或条件同步机制（conditional synchronization mechanisms）。<ul>
<li><code>Sleep(chan)</code>在任意值 <code>chan</code>上睡眠，称为等待通道（wait channel）。 释放CPU用于其他任务</li>
<li><code>Wakeup(chan)</code>唤醒所有在 <code>chan</code>上睡眠的进程（如果有），使其 <code>sleep</code>调用返回。</li>
<li>为了防止死锁，使用 <code>条件锁</code>，让进程在睡眠之后释放锁<ul>
<li><code>条件锁</code>就是所谓的条件变量，某一个线程因为某个条件为满足时可以使用条件变量使该程序处于阻塞状态。一旦条件满足以“信号量”的方式唤醒一个因为该条件而被阻塞的线程。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><ul>
<li>文件系统的目的是组织和存储数据</li>
<li>解决的问题<ul>
<li>文件系统需要磁盘上的数据结构来表示目录和文件名称树，记录保存每个文件内容的块的标识，以及记录磁盘的哪些区域是空闲的。</li>
<li>文件系统必须支持崩溃恢复（crash recovery）。</li>
<li>文件系统代码必须协调以保持不变量（不同的进程可能在相同的文件系统上运行）</li>
<li>文件系统必须保持常用块的内存缓存（访问磁盘慢）</li>
</ul>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>文件描述符（File descriptor）</th>
</tr>
</thead>
<tbody>
<tr>
<td>路径名（Pathname）</td>
</tr>
<tr>
<td>目录（Directory）</td>
</tr>
<tr>
<td>索引结点（Inode）</td>
</tr>
<tr>
<td>日志（Logging）</td>
</tr>
<tr>
<td>缓冲区高速缓存（Buffer cache）</td>
</tr>
<tr>
<td>磁盘（Disk)</td>
</tr>
</tbody>
</table>
</div>
<p><img src="./https://Baymine.github.io/images/MIT6-S081/Structure%20of%20file%20system.png" alt></p>
<ul>
<li>日志<ul>
<li>日志驻留在超级块中指定的未知。</li>
<li>事务中途奔溃将导致日志头块中的计数为0，提交后奔溃将导致非零计数</li>
</ul>
</li>
</ul>
<h1 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h1><h2 id="Lecture-3-OS-design"><a href="#Lecture-3-OS-design" class="headerlink" title="Lecture 3: OS design"></a>Lecture 3: OS design</h2><ul>
<li><p>Lecture Topic:</p>
<ul>
<li>OS design<ul>
<li>system calls</li>
<li>micro/monolithic kernel</li>
</ul>
</li>
<li>First system call in xv6</li>
</ul>
</li>
<li><p>OS picture</p>
<ul>
<li>apps: sh, echo, …</li>
<li>system call interface (open, close,…)<br>OS</li>
</ul>
</li>
<li><p>Goal of OS</p>
<ul>
<li>run multiple applications</li>
<li>isolate them</li>
<li>multiplex them</li>
<li>share</li>
</ul>
</li>
<li><p>Strawman design: No OS</p>
<ul>
<li>Application directly interacts with hardware<ul>
<li>CPU cores &amp; registers</li>
<li>DRAM chips</li>
<li>Disk blocks</li>
<li>…</li>
</ul>
</li>
<li>OS library perhaps abstracts some of it</li>
</ul>
</li>
<li><p>Strawman design not conducive to multiplexing</p>
<ul>
<li>each app periodically must give up hardware</li>
<li>BUT, weak isolation<ul>
<li>app forgets to give up, no other app runs</li>
<li>apps has end-less loop, no other app runs</li>
<li>you cannot even kill the badly app from another app</li>
</ul>
</li>
<li>but used by real-time OSes<ul>
<li>“cooperative scheduling”</li>
</ul>
</li>
</ul>
</li>
<li><p>Strawman design not conducive to memory isolation</p>
<ul>
<li>all apps share physical memory</li>
<li>one app can overwrites another apps memory</li>
<li>one app can overwrite OS library</li>
</ul>
</li>
<li><p>Unix interface conducive to OS goals</p>
<ul>
<li>abstracts the hardware in way that achieves goals</li>
<li>processes (instead of cores): fork<ul>
<li>OS transparently allocates cores to processes<ul>
<li>Saves and restore registers</li>
</ul>
</li>
<li>Enforces that processes give them up<ul>
<li>Periodically re-allocates cores</li>
</ul>
</li>
</ul>
</li>
<li>memory (instead of physical memory): exec<ul>
<li>Each process has its “own” memory</li>
<li>OS can decide where to place app in memory</li>
<li>OS can enforce isolation between memory of different apps</li>
<li>OS allows storing image in file system</li>
</ul>
</li>
<li>files (instead of disk blocks)<ul>
<li>OS can provide convenient names</li>
<li>OS can allow sharing of files between processes/users</li>
</ul>
</li>
<li>pipes (instead of shared physical mem)<ul>
<li>OS can stop sender/receiver</li>
</ul>
</li>
</ul>
</li>
<li><p>OS must be defensive</p>
<ul>
<li>an application shouldn’t be able to crash OS</li>
<li>an application shouldn’t be able to break out of its isolation</li>
<li>=&gt; need strong isolation between apps and OS</li>
<li>approach: hardware support</li>
</ul>
</li>
<li>user/kernel mode</li>
<li>virtual memory</li>
<li><p>Processors provide user/kernel mode</p>
<ul>
<li>kernel mode: can execute “privileged” instructions<ul>
<li>e.g., setting kernel/user bit</li>
<li>e.g., reprogramming timer chip</li>
</ul>
</li>
<li>user mode: cannot execute privileged instructions</li>
<li>Run OS in kernel mode, applications in user mode</li>
<li>[RISC-V has also an M mode, which we mostly ignore]</li>
</ul>
</li>
<li><p>Processors provide virtual memory</p>
<ul>
<li>Hardware provides page tables that translate virtual address to physical</li>
<li>Define what physical memory an application can access</li>
<li>OS sets up page tables so that each application can access only its memory</li>
</ul>
</li>
<li><p>Apps must be able to communicate with kernel</p>
<ul>
<li>Write to storage device, which is shared =&gt; must be protected =&gt; in kernel</li>
<li>Exit app</li>
<li>…</li>
</ul>
</li>
<li><p>Solution: add instruction to change mode in controlled way</p>
<ul>
<li>ecall <code>&lt;n&gt;</code></li>
<li>enters kernel mode at a pre-agreed entry point</li>
</ul>
</li>
<li><p>Modify OS picture</p>
<ul>
<li>user / kernel (redline)</li>
<li>app -&gt; printf() -&gt; write() -&gt; SYSTEM CALL -&gt; sys_write() -&gt; …<br>user-level libraries are app’s private business</li>
<li>kernel internal functions are not callable by user</li>
<li>other way of drawing picture:</li>
<li>syscall 1  -&gt; system call stub -&gt; kernel entry -&gt; syscall -&gt; fs</li>
<li>syscall 2                                                 -&gt; proc</li>
<li>system call stub executes special instruction to enter kernel<br>hardware switches to kernel mode<br>but only at an entry point specified by the kernel</li>
<li>syscall need some way to get at arguments of syscall</li>
<li>[syscalls the topic of this week’s lab]</li>
</ul>
</li>
<li><p>Kernel is the Trusted Computing Base (TCB)</p>
<ul>
<li>Kernel must be “correct”<ul>
<li>Bugs in kernel could allow user apps to circumvent kernel/user<br>Happens often in practice, because kernels are complex<br>See CVEs</li>
</ul>
</li>
<li>Kernel must treat user apps as suspect<br>User app may trick kernel to do the wrong thing<br>Kernel must check arguments carefully<br>Setup user/kernel correctly<br>Etc.</li>
<li>Kernel in charge of separating applications too<br>One app may try to read/write another app’s memory<br>=&gt; Requires a security mindset<br>Any bug in kernel may be a security exploit</li>
</ul>
</li>
<li><p>Aside: can one have process isolation WITHOUT h/w-supported<br>kernel/user mode and virtual memory?</p>
<ul>
<li>yes! use a strongly-typed programming language</li>
</ul>
</li>
<li>For example, see Singularity O/S<br>the compiler is then the trust computing base (TCB)<br>but h/w user/kernel mode is the most popular plan</li>
<li>Monolothic kernel<br>OS runs in kernel space<br>Xv6 does this.  Linux etc. too.<br>kernel interface == system call interface<br>one big program with file system, drivers, &amp;c</li>
<li>good: easy for subsystems to cooperate<br>one cache shared by file system and virtual memory</li>
<li>bad: interactions are complex<br>leads to bugs<br>no isolation within</li>
<li><p>Microkernel design</p>
<ul>
<li>many OS services run as ordinary user programs<ul>
<li>file system in a file server</li>
</ul>
</li>
<li>kernel implements minimal mechanism to run services in user space<ul>
<li>processes with memory</li>
<li>inter-process communication (IPC)</li>
</ul>
</li>
<li>kernel interface != system call interface</li>
</ul>
</li>
<li>good: more isolation</li>
<li>bad: may be hard to get good performance<br>both monolithic and microkernel designs widely used</li>
<li><p>Xv6 case study</p>
<ul>
<li>Monolithic kernel<ul>
<li>Unix system calls == kernel interface</li>
</ul>
</li>
<li>Source code reflects OS organization (by convention)<ul>
<li>user/    apps in user mode</li>
<li>kernel/  code in kernel mode</li>
</ul>
</li>
<li>Kernel has several parts<ul>
<li>kernel/defs.h<ul>
<li>proc</li>
<li>fs<br>..</li>
</ul>
</li>
</ul>
</li>
<li>Goal: read source code and understand it (without consulting book)</li>
</ul>
</li>
<li><p>The RISC-V computer</p>
<ul>
<li>A very simple board (e.g., no display)</li>
</ul>
</li>
<li>RISC-V processor with 4 cores</li>
<li>RAM (128 MB)</li>
<li>support for interrupts (PLIC, CLINT)</li>
<li>support for UART<br>allows xv6 to talk to console<br>allows xv6 to read from keyboard</li>
<li>support for e1000 network card (through PCIe)<br>Qemu emulates several RISC-V computers</li>
<li>we use the “virt” one<br><a target="_blank" rel="noopener" href="https://github.com/riscv/riscv-qemu/wiki">https://github.com/riscv/riscv-qemu/wiki</a></li>
<li>close to the SiFive board (<a target="_blank" rel="noopener" href="https://www.sifive.com/boards">https://www.sifive.com/boards</a>)<br>but with virtio for disk</li>
<li><p>Boot xv6 (under gdb)</p>
<ul>
<li><span>$</span> make CPUS=1 qemu-gdb<ul>
<li>runs xv6 under gdb (with 1 core)</li>
</ul>
</li>
<li>Qemu starts xv6 in kernel/entry.S (see kernel/kernel.ld)<ul>
<li>set breakpoint at _entry<ul>
<li>look at instruction</li>
<li>info reg</li>
</ul>
</li>
<li>set breakpoint at main<ul>
<li>Walk through main<br>single step into userinit<br>Walk through userinit<br>show kalloc<br>show proc.h<br>show allocproc()<br>show initcode.S/initcode.asm<br>break forkret()<br>walk to userret<br>break syscall<br>print num<br>syscalls[num]<br>exec “/init”<br>points to be made:<br>page table in userinit<br>ecall: U -&gt; K<br>a7: syscall #<br>exec: defensive</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>kernel</p>
<script type="math/tex; mode=display">
\text{proc.c} \stackrel{\text{gcc}}{\rightarrow} \text{proc.s} \stackrel{\text{assembler}}{\rightarrow} \text{proc.o} \rightarrow\text{link different .o file together}</script></li>
</ul>
<h2 id="6-S081-2020-Lecture-4-Virtual-Memory"><a href="#6-S081-2020-Lecture-4-Virtual-Memory" class="headerlink" title="6.S081 2020 Lecture 4: Virtual Memory"></a>6.S081 2020 Lecture 4: Virtual Memory</h2><p>========================================</p>
<ul>
<li>plan:<br>address spaces<br>paging hardware<br>xv6 VM code</li>
</ul>
<h3 id="Virtual-memory-overview"><a href="#Virtual-memory-overview" class="headerlink" title="Virtual memory overview"></a>Virtual memory overview</h3><ul>
<li>today’s problem:<br>[user/kernel diagram]<br>[memory view: diagram with user processes and kernel in memory]<br>suppose the shell has a bug:<br>sometimes it writes to a random memory address<br>how can we keep it from wrecking the kernel?<br>and from wrecking other processes?</li>
<li>we want isolated address spaces<br>each process has its own memory<br>it can read and write its own memory<br>it cannot read or write anything else<br>challenge:<br>how to multiplex several memories over one physical memory?<br>while maintaining isolation between memories</li>
<li>xv6 uses RISC-V’s paging hardware to implement AS’s<br>ask questions! this material is important<br>topic of next lab (and shows up in several other labs)</li>
<li><p>paging provides a level of indirection for addressing<br>CPU -&gt; MMU -&gt; RAM<br>VA     PA</p>
<script type="math/tex; mode=display">
\text{CPU}\stackrel{\text{VA}}{\rightarrow}MMU\stackrel{\text{PA}}{\rightarrow}\text{RAM}</script><p>s/w can only ld/st to virtual addresses, not physical<br>kernel tells MMU how to map each virtual address to a physical address<br>MMU essentially has a table, indexed by va, yielding pa<br>called a “page table”<br>one page table per address space<br>MMU can restrict what virtual addresses user code can use<br>By programming the MMU, the kernel has complete control over va-&gt;pa mapping<br>Allows for many interesting OS features/tricks</p>
</li>
<li>RISC-V maps 4-KB “pages”<br>and aligned — start on 4 KB boundaries<br>4 KB = 12 bits<br>the RISC-V used in xv6 has 64-bit for addresses<br>thus page table index is top 64-12 = 52 bits of VA<br>except that the top 25 of the top 52 are unused<br>no RISC-V has that much memory now<br>can grow in future<br>so, index is 27 bits.</li>
<li>MMU translation<br>see Figure 3.1 of book<br>use index bits of VA to find a page table entry (PTE)<br>construct physical address using PPN from PTE + offset of VA</li>
<li>what is in PTE?<br>each PTE is 64 bits, but only 54 are used<br>top 44 bits of PTE are top bits of physical address<br>“physical page number”<br>low 10 bits of PTE flags<br>Present, Writeable, &amp;c<br>note: size virtual addresses != size physical addresses</li>
<li>where is the page table stored?<br>in RAM — MMU loads (and stores) PTEs<br>o/s can read/write PTEs<br>read/write memory location corresponding to PTEs</li>
<li>would it be reasonable for page table to just be an array of PTEs? how big is it?<br>2^27 is roughly 134 million<br>64 bits per entry<br>134*8 MB for a full page table<br>wasting roughly 1GB per page table<br>one page table per address space<br>one address space per application<br>would waste lots of memory for small programs!<br>you only need mappings for a few hundred pages<br>so the rest of the million entries would be there but not needed</li>
<li>RISC-V 64 uses a “three-level page table” to save space<br>see figure 3.2 from book<br>page directory page (PD)<br>PD has 512 PTEs<br>PTEs point to another PD or is a leaf<br>so 512<em>512</em>512 PTEs in total<br>PD entries can be invalid<br>those PTE pages need not exist<br>so a page table for a small address space can be small</li>
<li>how does the mmu know where the page table is located in RAM?<br>satp holds phys address of top PD<br>pages can be anywhere in RAM — need not be contiguous<br>rewrite satp when switching to another address space/application</li>
<li>how does RISC-V paging hardware translate a va?<br>need to find the right PTE<br>satp register points to PA of top/L2 PD<br>top 9 bits index L2 PD to get PA of L1 PD<br>next 9 bits index L1 PD to get PA of L0 PD<br>next 9 bits index L0 PD to get PA of PTE<br>PPN from PTE + low-12 from VA</li>
<li>flags in PTE<br>V, R, W, X, U<br>xv6 uses all of them</li>
<li>what if V bit not set? or store and W bit not set?<br>“page fault”<br>forces transfer to kernel<br>trap.c in xv6 source<br>kernel can just produce error, kill process<br>in xv6: “usertrap(): unexpected scause … pid=… sepc=… stval=…”<br>or kernel can install a PTE, resume the process<br>e.g. after loading the page of memory from disk</li>
<li>indirection allows paging h/w to solve many problems<br>e.g. phys memory doesn’t have to be contiguous<br>avoids fragmentation<br>e.g. lazy allocation (a lab)<br>e.g. copy-on-write fork (another lab)<br>many more techniques<br>topic of next lecture</li>
<li><p>Q: why use virtual memory in kernel?<br>it is clearly good to have page tables for user processes<br>but why have a page table for the kernel?<br>could the kernel run with using only physical addresses?<br>top-level answer: yes<br>most standard kernels do use virtual addresses<br>why do standard kernels do so?<br>some reasons are lame, some are better, none are fundamental</p>
<ul>
<li>the hardware makes it difficult to turn it off<br>e.g. on entering a system call, one would have to disable VM</li>
<li>the kernel itself can benefit from virtual addresses<br>mark text pages X, but data not (helps tracking down bugs)<br>unmap a page below kernel stack (helps tracking down bugs)<br>map a page both in user and kernel (helps user/kernel transition)</li>
</ul>
</li>
</ul>
<h3 id="Virtual-memory-in-xv6"><a href="#Virtual-memory-in-xv6" class="headerlink" title="Virtual memory in xv6"></a>Virtual memory in xv6</h3><ul>
<li>kernel page table<br>See figure 3.3 of book<br>simple maping mostly<br>map virtual to physical one-on-one<br>note double-mapping of trampoline<br>note permissions<br>why map devices?</li>
<li>each process has its own address space<br>and its own page table<br>see figure 3.4 of book<br>note: trampoline and trapframe aren’t writable by user process<br>kernel switches page tables (i.e. sets satp) when switching processes</li>
<li>Q: why this address space arrangement?<br>user virtual addresses start at zero<br>of course user va 0 maps to different pa for each process<br>16,777,216 GB for user heap to grow contiguously<br>but needn’t have contiguous phys mem — no fragmentation problem<br>both kernel and user map trampoline and trapframe page<br>eases transition user -&gt; kernel and back<br>kernel doesn’t map user applications<br>not easy for kernel to r/w user memory<br>need translate user virtual address to kernel virtual address<br>good for isolation (see spectre attacks)<br>easy for kernel to r/w physical memory<br>pa x mapped at va x</li>
<li>Q: does the kernel have to map all of phys mem into its virtual address space?</li>
</ul>
<h3 id="Code-walk-through"><a href="#Code-walk-through" class="headerlink" title="Code walk through"></a>Code walk through</h3><ul>
<li>setup of kernel address space<br>kvmmap()<br>Q: what is address 0x10000000 (256M)<br>Q: how much address space does 1 L2 entry cover? (1G)<br>Q: how much address space does 1 L1 entry cover? (2MB)<br>Q: how much address space does 1 L0 entry cover? (4096)<br>print kernel page table<br>Q: what is size of address space? (512G)<br>Q: how much memory is used to represent it after 1rst kvmmap()? (3 pages)<br>Q: how many entries is CLINT? (16 pages)<br>Q: how many entries is PLIC? (1024 pages, two level 1 PDs)<br>Q: how many pages is kernel text (8 pages)<br>Q: how many pages is kernel total (128M = 64 * 2MB)<br>Q: Is trampoline mapped twice? (yes, last entry and direct-mapped, entry [2, 3, 7])<br>kvminithart();<br>Q: after executing w_satp() why will the next instruction be sfence_vma()?</li>
<li>mappages() in vm.c<br>arguments are top PD, va, size, pa, perm<br>adds mappings from a range of va’s to corresponding pa’s<br>rounds b/c some uses pass in non-page-aligned addresses<br>for each page-aligned address in the range<br>call walkpgdir to find address of PTE<br>need the PTE’s address (not just content) b/c we want to modify<br>put the desired pa into the PTE<br>mark PTE as valid w/ PTE_P</li>
<li>walk() in vm.c<br>mimics how the paging h/w finds the PTE for an address<br>PX extracts the 9 bits at Level level<br>&amp;pagetable[PX(level, va)] is the address of the relevant PTE<br>if PTE_V<br>the relevant page-table page already exists<br>PTE2PA extracts the PPN from the PDE<br>if not PTE_V<br>alloc a page-table page<br>fill in pte with PPN (using PA2PTE)<br>now the PTE we want is in the page-table page</li>
<li>procinit() in proc.c<br>alloc a page for each kernel stack with a guard page</li>
<li>setup user address space<br>allocproc(): allocates empty top-level page table<br>fork(): uvmcopy()<br>exec(): replace proc’s page table with a new one<br>uvmalloc<br>loadseg<br>print user page table for sh<br>Q: what is entry 2?</li>
<li>a process calls sbrk(n) to ask for n more bytes of heap memory<br>user/umalloc.c calls sbrk() to get memory for the allocator<br>each process has a size<br>kernel adds new memory at process’s end, increases size<br>sbrk() allocates physical memory (RAM)<br>maps it into the process’s page table<br>returns the starting address of the new memory</li>
<li>growproc() in proc.c<br>proc-&gt;sz is the process’s current size<br>uvmalloc() does most of the work<br>when switching to user space satp will be loaded with updated page table</li>
<li>uvmalloc() in vm.c<br>why PGROUNDUP?<br>arguments to mappages()…</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-11-29T12:44:45.000Z" title="11/29/2022, 8:44:45 PM">2022-11-29</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-06-16T08:47:40.552Z" title="6/16/2024, 4:47:40 PM">2024-06-16</time></span><span class="level-item">23 minutes read (About 3493 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/11/29/Basic_must_known/">Basic Knoledge</a></p><div class="content"><h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><ul>
<li><p>Small tricks</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取中间的数：</span></span><br><span class="line"><span class="type">int</span> mid = (left + right) / <span class="number">2</span>; <span class="comment">// 有溢出的风险</span></span><br><span class="line"><span class="type">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>); <span class="comment">// 这样更好</span></span><br></pre></td></tr></table></figure></li>
<li>当异常发⽣时，C++通常会调⽤对象的析构函数来释放资源</li>
<li>指向虚函数表的指针 <code>vptr</code>需要在构造函数中进⾏初始化</li>
<li><p>如何让类不能实例化</p>
<ul>
<li>将类定义位抽象类（包含纯虚函数）</li>
<li>将构造器声明为 <code>private</code></li>
</ul>
</li>
<li><p>虚继承</p>
<ul>
<li>在菱形继承的场景下，会产生两份基类数据，浪费空间，同时访问基类还需要通过域运算符</li>
<li>利用虚继承，在间接继承共同基类时是保留一份基类成员。创建派生类实例的时候，只需要调用一次基类的构造函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>{}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A{}</span><br></pre></td></tr></table></figure></li>
<li>在 C 语言中，数据类型指的是用于声明不同类型的变量或函数的一个广泛的系统。变量的类型决定了变量存储占用的空间，以及如何解释存储的位模式。</li>
<li><h4 id="Linux-和-UNIX-的关系-区别"><a href="#Linux-和-UNIX-的关系-区别" class="headerlink" title="Linux 和 UNIX 的关系/区别"></a>Linux 和 UNIX 的关系/区别</h4></li>
</ul>
<ul>
<li><p>Linux 是一个类似 Unix 的操作系统，Unix 要早于 Linux，Linux 的初衷就是要替代 UNIX，并在功能和用户体验上进行优化，所以 Linux 模仿了 UNIX（但并没有抄袭 UNIX 的源码），使得 Linux 在外观和交互上与 UNIX 非常类似。</p>
<ul>
<li>析构函数</li>
</ul>
</li>
<li><p>类类型：如 <code>struct</code>、<code>class</code>、<code>union</code></p>
<ul>
<li>没有自定义析构函数，那么编译器就会为它们生成内联(inline)、public 的析构函数。</li>
</ul>
</li>
<li>对于析构函数的调用，需要是 public 的访问权限，否则会导致编译错误。</li>
</ul>
<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><script type="math/tex; mode=display">
\text{工作区}\stackrel{add}{\rightarrow}\text{暂存区}\stackrel{commit}{\rightarrow}\text{本地仓库}\stackrel{push}{\rightarrow}\text{远程仓库}\stackrel{pull}{\rightarrow}\text{本地}</script><p><img src="https://Baymine.github.io/images/Basic-Knoledge/1672140678237.png" alt="1672140678237"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># In the work directory</span></span><br><span class="line">git config --global user.name <span class="string">"yourName"</span></span><br><span class="line">git config --global user.email yourEmail</span><br><span class="line"></span><br><span class="line">git init <span class="comment"># initialize the repository</span></span><br><span class="line">git status <span class="comment"># repository information</span></span><br><span class="line">git add fileName</span><br><span class="line">git commit -m <span class="string">"commit msg"</span>EADADWE</span><br><span class="line">git <span class="built_in">log</span>  <span class="comment"># 查看以前的版本</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">touch</span> .gitignore  <span class="comment"># 不追踪的文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建新分支</span></span><br><span class="line">git branch branchName</span><br><span class="line"></span><br><span class="line"><span class="comment"># 两种切换分支的命令</span></span><br><span class="line">git checkout branchName</span><br><span class="line">	- git checkout -d branchName  <span class="comment"># 删除分支</span></span><br><span class="line">	- git checkout -b temp  <span class="comment"># 创建并切换到新建的分支</span></span><br><span class="line">git switch branchName</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并分支</span></span><br><span class="line">git merge temp</span><br><span class="line"></span><br><span class="line"><span class="comment"># add 和 commit合在一起写</span></span><br><span class="line">git commit -a -m <span class="string">"msg"</span>  <span class="comment"># 或者-am</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载远程内容</span></span><br><span class="line"><span class="comment">#### 直接下载zip是不会下载版本信息的，所以需要使用以下命令</span></span><br><span class="line">git <span class="built_in">clone</span></span><br><span class="line"></span><br><span class="line"> ESDAW</span><br></pre></td></tr></table></figure>
<h1 id="C-C"><a href="#C-C" class="headerlink" title="C/C++"></a>C/C++</h1><h3 id="条件变量的虚假唤醒"><a href="#条件变量的虚假唤醒" class="headerlink" title="条件变量的虚假唤醒"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/tqyysm/articles/9765667.html">条件变量的虚假唤醒</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wait 端</span></span><br><span class="line"><span class="built_in">lock</span>(mutex);</span><br><span class="line"><span class="keyword">while</span>(queue.<span class="built_in">empty</span>()){  <span class="comment">// 如果使用if可能会导致虚假唤醒</span></span><br><span class="line">	cond.<span class="built_in">wait</span>();</span><br><span class="line">}</span><br><span class="line">x = queue.<span class="built_in">pop</span>();</span><br><span class="line"><span class="built_in">unlock</span>(mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// signal/broadcast端</span></span><br><span class="line"><span class="built_in">lock</span>(mutex);</span><br><span class="line">queue.<span class="built_in">push_back</span>(x);</span><br><span class="line"><span class="built_in">unlock</span>(mutex);</span><br><span class="line">cond.<span class="built_in">notify</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当条件变量满足的时候，挂起的线程会被唤醒，当他准备获取锁之前，有其他线程将变量改变了，这时候条件变量不满足了，所以这次唤醒是虚假的。</p>
<p>当某个条件满足的时候（即wait端中while中的条件），之后就进入挂起状态，用if语句那么挂起状态结束以后，就会继续往下，但是这个时候条件不一定满足（虚假唤醒时），所以应该利用while，这样可以<strong>进行第二次判断</strong>，这样就不会因为虚假唤醒的情况而被唤醒。</p>
<h3 id="Function-pointer"><a href="#Function-pointer" class="headerlink" title="Function pointer"></a><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/840501/how-do-function-pointers-in-c-work">Function pointer</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">addInt</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> n+m;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> (*functionPtr)(<span class="type">int</span>,<span class="type">int</span>); <span class="comment">// Declare</span></span><br><span class="line">functionPtr = &amp;addInt;  <span class="comment">// Assigment</span></span><br><span class="line"><span class="type">int</span> sum = (*functionPtr)(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">// usage: sum == 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// As a parameter</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add2to3</span><span class="params">(<span class="type">int</span> (*functionPtr)(<span class="type">int</span>, <span class="type">int</span>))</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> (*functionPtr)(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// this is a function called functionFactory which receives parameter n</span></span><br><span class="line"><span class="comment">// and returns a pointer to another function which receives two ints</span></span><br><span class="line"><span class="comment">// and it returns another int</span></span><br><span class="line"><span class="built_in">int</span> (*<span class="built_in">functionFactory</span>(<span class="type">int</span> n))(<span class="type">int</span>, <span class="type">int</span>) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Got parameter %d"</span>, n);</span><br><span class="line">    <span class="built_in">int</span> (*functionPtr)(<span class="type">int</span>,<span class="type">int</span>) = &amp;addInt;</span><br><span class="line">    <span class="keyword">return</span> functionPtr;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// note that the typedef name is indeed myFuncDef</span></span><br><span class="line"><span class="comment">// Confused here ???????</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*myFuncDef)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">myFuncDef <span class="title">functionFactory</span><span class="params">(<span class="type">int</span> n)</span> </span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Got parameter %d"</span>, n);</span><br><span class="line">    myFuncDef functionPtr = &amp;addInt;</span><br><span class="line">    <span class="keyword">return</span> functionPtr;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">addInt</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> n+m;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> (*functionPtr)(<span class="type">int</span>,<span class="type">int</span>); <span class="comment">// Declare</span></span><br><span class="line">functionPtr = &amp;addInt;  <span class="comment">// Assigment</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; addInt &lt;&lt; endl; <span class="comment">// Return 1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>cout 打印函数返回1的<a target="_blank" rel="noopener" href="https://blog.csdn.net/Q_1849805767/article/details/107391572">原因</a>：<br>C++调用非静态的成员函数时，采用的是一种 __thiscall 的函数调用方式。采用这种调用方式，编译器在编译的时候，会在调用的函数形参表中增加一个指向调用该成员函数的指针，也就是我们经常说的this指针。调用的形式类似于Base::f1(Base* this, otherparam…)，在函数体中，涉及到对象的成员变量或者其他成员函数，都会通过这个this指针来调用，从而达到在成员函数中处理调用对象所对应的数据，而不会错误处理其他对象的数据。可见，虽然我们必须通过对象来调用动态函数，但是其实我们访问的都是同一个成员函数。所以我们采用&amp;Base::f1来获取成员函数地址是没错的，动态函数同样是跟类绑定而不是跟对象绑定的。</p>
<p>出错的原因是，<code>输出操作符&lt;&lt;没有对void(__thiscall A:: *)()类型重载，编译器将这种类型转换为bool类型，所以输出了1；</code></p>
<p>对于静态函数，其调用方式并非<strong>thiscall，&lt;&lt;有对它的重载，因此类的静态函数可以直接用cout输出函数地址。我们可以用printf输出，因为他可以接收任意类型的参数，包括</strong>thiscall类型</p>
</blockquote>
<h2 id="Upcasting"><a href="#Upcasting" class="headerlink" title="Upcasting"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/2284.html">Upcasting</a></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> { <span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>; }</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : A{ <span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>; }</span><br><span class="line"></span><br><span class="line">A a; B b;</span><br><span class="line"><span class="comment">// b = a; // Downcasting</span></span><br><span class="line">a = b; <span class="comment">// Upcasting. 派生类成员变量将会被舍去，只保留基类成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象之间的赋值不会影响成员函数，也不会影响 this 指针</span></span><br><span class="line">a.<span class="built_in">func1</span>(); <span class="comment">// 调用的是A中的函数。</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这种转换关系是不可逆的，只能 <code>用派生类对象给基类对象赋值</code>，而 <code>不能</code>用基类对象给派生类对象赋值。理由很简单，基类不包含派生类的成员变量，无法对派生类的成员变量赋值。同理，同一基类的不同派生类对象之间也不能赋值。(如果多出数据，编译器会舍弃，但是少数据了，那么编译器就不知道如何填充剩下的内存了)</p>
</blockquote>
<p><strong>将派生类指针赋值给基类指针</strong></p>
<blockquote>
<p>将派生类指针赋值给基类指针时，通过基类指针只能使用派生类的成员变量，但不能使用派生类的成员函数.</p>
<blockquote>
<p>编译器通过指针访问成员变量，但是不会通过指针访问成员函数，而是通过指针类型来访问。所以，当指针变化的时候，改变的只是指向的内存，也就是对应的类成员变量存储的位置变成了赋值类中的成员变量。</p>
</blockquote>
</blockquote>
<h2 id="MMAP"><a href="#MMAP" class="headerlink" title="MMAP"></a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/357820303">MMAP</a></h2><ul>
<li><p>传统IO</p>
<ul>
<li>整个过程发生了<strong>4次用户态和内核态的上下文切换</strong>和<strong>4次拷贝(1.用户发起read，2.读缓存拷贝到用户缓存，3.用户发起write，4.拷贝到网卡)</strong></li>
<li><img src="/.io//readio.webp" alt="img"></li>
<li><p>DMA拷贝</p>
<ul>
<li>IO操作，都是通过CPU发出对应的指令来完成，但是相比CPU来说，IO的速度太慢了，CPU有大量的时间处于等待IO的状态。因此就产生了<strong>DMA（Direct Memory Access</strong>)直接内存访问技术，本质上来说他就是一块 <code>主板上独立的芯片</code>，通过它来进行内存和IO设备的数据传输，从而减少CPU的等待时间。</li>
</ul>
</li>
</ul>
</li>
<li><p>零拷贝</p>
<ul>
<li>计算机执行操作时，CPU不需要先将数据从某处内存复制到另一个特定区域，这种技术通常用于通过网络传输文件时节省CPU周期和内存带宽。</li>
<li>减少用户态和内核态的切换次数以及CPU拷贝的次数。</li>
<li><p>常见的几种零拷贝技术</p>
<ul>
<li>mmap + write<ul>
<li>使用 <code>mmap</code>替换了read+write中的read操作，减少了一次CPU的拷贝。</li>
<li><code>mmap</code>主要实现方式是将读缓冲区的地址和用户缓冲区的地址进行映射</li>
<li><strong>4次用户态和内核态的上下文切换</strong>和<strong>3次拷贝</strong>（1.mmap调用，2.mmap返回，3.用户调用write，4.拷贝到网卡）</li>
<li><img src="/.io//mmap+write.webp" alt="img"></li>
<li><code>mmap</code>的方式节省了一次CPU拷贝，同时由于用户进程中的内存是虚拟的，只是映射到内核的读缓冲区，所以可以节省一半的内存空间，比较适合大文件的传输。</li>
</ul>
</li>
<li>sendfile<ul>
<li>Linux2.1内核版本后引入的一个系统调用函数，通过使用 <code>sendfile</code>数据可以直接在内核空间进行传输，因此避免了用户空间和内核空间的拷贝</li>
<li><strong>2次用户态和内核态的上下文切换</strong>和<strong>3次拷贝</strong></li>
<li><img src="/.io//sendfile.webp" alt="img"></li>
<li>sendfile方法IO数据对用户空间完全不可见，所以只能适用于完全不需要用户空间处理的情况，比如静态文件服务器。</li>
</ul>
</li>
<li>sendfile + DMA Scatter/Gather<ul>
<li>对 <code>sendfile</code>做了进一步优化，通过引入新的硬件支持，这个方式叫做DMA Scatter/Gather 分散/收集功能。</li>
<li><strong>2次用户态和内核态的上下文切换</strong>和 <strong>2次拷贝</strong> ，其中更重要的是完全没有CPU拷贝</li>
<li><img src="/.io//DMS.webp" alt></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><em>**</em>## <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/385410196">惊群效应</a></p>
<ul>
<li>应用程序是通过 socket 和协议栈交互的，socket 隔离了应用程序和协议栈，socket 是两者之间的接口，对于应用程序，它代表协议栈；而对于协议栈，它又代表应用程序</li>
<li><p>一个典型的accept惊群现象，及解决措施</p>
<ul>
<li>inux 内核通过睡眠队列来组织所有等待某个事件的 task，而wakeup 机制则可以异步唤醒整个睡眠队列上的 task</li>
<li>在唤醒睡眠队列的时候，会遍历队列链表上的每一个节点，并调用对应的callback，这样一个connect到达的时候，会将队列中所有的线程唤醒，但只有一个返回task，其他返回-1(EAGAIN: Resource temporarily unavailable)</li>
<li>添加了一个 WQ_FLAG_EXCLUSIVE 标记告诉内核进行排他性的唤醒，即唤醒一个进程后即退出唤醒的过程</li>
</ul>
</li>
<li><p>select/poll/Epoll “惊群”现象</p>
<ul>
<li>某一时刻多个进程(线程)阻塞在 select/poll/epoll_wait 系统调用上，当一个请求上来的时候，多个进程都会被 select/poll/epoll_wait 唤醒去 accept，但只有一个是有效的。</li>
<li>Niginx的解决方法<ul>
<li>一次仅允许一个进程将 listen fd 放入自己的 epoll 来监听其 READ 事件的方式来达到 listen fd”惊群”避免</li>
<li>同一时刻仅允许一个 worker 进程监听 listen fd 的可读事件的方式<!-- - 不太清楚这部分，实现起来比较复杂，要避免新请求不能及时处理而导致的现象 --></li>
</ul>
</li>
<li>Epoll”惊群”之 LT(水平触发模式)、ET(边沿触发模式)</li>
<li>被Poll的fd, 必须在实现上支持内核的Poll技术，比如fd是某个字符设备,或者是个socket, 它必须实现file_operations中的poll操作, 给自己分配有一个等待队列头wait_queue_head_t，主动poll fd的某个进程task必须分配一个等待队列成员, 添加到fd的等待队列里面去, 并指定资源ready时的回调函数，用socket做例子, 它必须有实现一个poll操作, 这个Poll是发起轮询的代码必须主动调用的, 该函数中必须调用poll_wait(),poll_wait会将发起者作为等待队列成员加入到socket的等待队列中去，这样socket发生事件时可以通过队列头逐个通知所有关心它的进程。</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/37861062">简易版本</a></p>
<ul>
<li>出现场景<ul>
<li>accept<ul>
<li>多线程中的accept函数同时监听一个listenfd，当这个fd可读的时候，等待队列中的所有进程就会被唤醒</li>
<li>解决：当内核接受到一个连接之后，只会唤醒等待队列上的第一个线程</li>
</ul>
</li>
<li>epoll<ul>
<li>使用多线程epoll对同一个fd进行监控的时候，当fd事件到来时，内核会把所有epoll线程唤醒</li>
<li>由于当事件来临的时候，不清楚需要几个线程，所以只能将所有线程唤醒（而在accept中，已知只会需要一个线程）</li>
<li>解决：多个进程将listenfd加入到epoll之前，首先尝试获取一个全局的accept_mutex互斥锁，只有获得该锁的进程才可以把listenfd加入到epoll中</li>
</ul>
</li>
<li>线程池<ul>
<li>当我们往任务队列中放入任务时，需要唤醒等待的线程来处理任务，如果我们使用C++标准库中的函数notify_all()来唤醒线程，则会将所有的线程都唤醒</li>
<li>解决方案：对于只需要唤醒一个线程的情况，我们需要使用notify_one()函数代替notify_all()只唤醒一个线程，从而避免惊群问题。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="CPU调度算法"><a href="#CPU调度算法" class="headerlink" title="CPU调度算法"></a><a href>CPU调度算法</a></h2><h2 id="QUIC"><a href="#QUIC" class="headerlink" title="QUIC"></a><a href>QUIC</a></h2><p><img src="https://Baymine.github.io/images/Basic-Knoledge/QUIC封装过程.png" alt></p>
<ul>
<li>0-RTT</li>
</ul>
<p>不用看：env_monitor、moses  启动：tool_chain_config.py</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-11-23T08:06:49.000Z" title="11/23/2022, 4:06:49 PM">2022-11-23</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-01-14T00:01:01.097Z" title="1/14/2023, 8:01:01 AM">2023-01-14</time></span><span class="level-item">11 minutes read (About 1621 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/11/23/Q-A/">Q&amp;A</a></p><div class="content"><h2 id="右值引用的用法"><a href="#右值引用的用法" class="headerlink" title="右值引用的用法"></a>右值引用的用法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引用右值，避免生成新对象</span></span><br><span class="line">Foo&amp;&amp; foo2 = <span class="built_in">FooFactory</span>();</span><br></pre></td></tr></table></figure>
<p><strong><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/335994370">关于std::move函数</a></strong></p>
<blockquote>
<p>std::move移动不了什么，唯一的功能是把左值强制转化为右值，让右值引用可以指向左值。其实现等同于一个类型转换：static_cast<t&&>(lvalue)。 所以，单纯的std::move(xxx)不会有性能提升. move返回值如果有名称就是左值（被赋值给一个变量），没有名称就是右值。</t&&></p>
<p><strong>使用建议</strong>：可移动对象在&lt;需要拷贝且被拷贝者之后不再被需要&gt;的场景，建议使用std::move触发移动语义，提升性能。（类似于 <code>push_back</code>等的函数）。</p>
<p>对于 <code>unique_ptr</code>只能进行移动构造函数，所以可以使用 <code>move</code>实现赋值构造<br><code>std::unique_ptr&lt;A&gt; ptr = std::move(ptr_a);</code>.</p>
</blockquote>
<p><strong>完美转发 std::forward</strong></p>
<blockquote>
<p>std::forward <code>&lt;T&gt;</code>(u)有两个参数：T与 u。 a. 当T为左值引用类型时，u将被转换为T类型的左值； b. 否则u将被转换为T类型右值。</p>
</blockquote>
<ul>
<li>const右值引用传入的参数可以被修改，而const左值传入的则不可以修改。</li>
</ul>
<h2 id="C-为什么不推荐使用vector"><a href="#C-为什么不推荐使用vector" class="headerlink" title="C++为什么不推荐使用vector\"></a><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/23367698">C++为什么不推荐使用vector\<bool\></bool\></a></h2><p>vector&lt; bool&gt;不是一个标准容器，就是因为它不能支持一些容器该有的基本操作，诸如取地址给指针初始化操作.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">bool</span>&gt; c{<span class="literal">false</span>, <span class="literal">false</span>};</span><br><span class="line"><span class="type">bool</span> b = c[<span class="number">0</span>]; <span class="comment">// 这里有一个隐式的类型转换</span></span><br></pre></td></tr></table></figure>
<h2 id="冷不命中-cold-miss"><a href="#冷不命中-cold-miss" class="headerlink" title="冷不命中(cold miss)"></a>冷不命中(cold miss)</h2><p>缓存会在断电之后清空，那么是不是意味着在刚开机的时候，电脑运行的速度会相对较慢？</p>
<h2 id="ssh命令传输方式"><a href="#ssh命令传输方式" class="headerlink" title="ssh命令传输方式"></a>ssh命令传输方式</h2><p>为什么会因为网络波动而导致无法输入的情况</p>
<h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><ul>
<li>为什么在Xftp中删除文件那么慢，而直接使用rm会快很多？</li>
<li>写入空白和覆盖哪个速度更快？</li>
<li>为什么这么写？while(-1 != (opt = getopt(argc, argv, “x:y:”)))<ul>
<li>防止将==写成=，此时，如果写成a=1编译会通过，如果写成1=a编译不会通过，这样做也可减少这种隐形的bug的出现</li>
</ul>
</li>
<li>函数指针（typedef）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// note that the typedef name is indeed myFuncDef</span></span><br><span class="line"><span class="comment">// Confused here ???????</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*myFuncDef)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">myFuncDef <span class="title">functionFactory</span><span class="params">(<span class="type">int</span> n)</span> </span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Got parameter %d"</span>, n);</span><br><span class="line">    myFuncDef functionPtr = &amp;addInt;</span><br><span class="line">    <span class="keyword">return</span> functionPtr;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<ul>
<li>void (*0)( ) ：是⼀个返回值为void，参数为空的函数指针0 (这里的意思是函数名为0吗？)</li>
<li>为什么在Linux下不能同时安装多个软件，但是在Windows下可以？（并行和串行的优劣？）</li>
<li>在fork之后，父进程和子进程的运行有先后顺序吗？</li>
<li><p>函数名是不是就是函数指针？(是，那么为什么不需要解引用，直接可以调用？)我可以通过函数名调用函数，那可不可以认为这个函数名就是一个句柄？如何理解句柄？异常表中存储就是各种异常处理函数的句柄？能不能理解为一个整数到一个指针的映射？</p>
<blockquote>
<p><strong>为什么要用 handle，而不直接用指针呢？</strong></p>
<ul>
<li>指针作用太强，可做的事情太多。可做的事情越多，就会越危险。接口设计中，功能刚刚好就够了，并非越多权限越好的。</li>
<li>handle 通常只是个整数，实现被隐藏起来，假如直接暴露了指针，也就暴露了指针类型（有时也可以暴露 void* 指针作为某种 handle）。用户看到越多细节，其代码就越有可能依赖这些细节。将来情况有变，但又要兼容用户代码，库内部改起来就更麻烦。</li>
<li>资源在内部管理，通过 handle 作为中间层，可以有效判断 handle 是否合法，也可以通过权限检查防止某种危险操作。</li>
<li>handle 通常只是个整数，所有的语言都有整数这种类型，但并非所有语言都有指针。接口只出现整数，方便同一实现绑定到各种语言。</li>
</ul>
</blockquote>
</li>
<li>在编写信号处理器的时候，最好调用异步信号安全性函数，那为什么不能再执行函数的时候阻塞所有的信号，这样不能保证函数的原子性吗？</li>
<li>printf 和cout混用会有什么后果吗？</li>
<li>free 或者delete掉malloc 或 new 出来的内存会发生什么？</li>
<li>csapp p588: 在32位模式中，  malloc返回的块的地址总是8的倍数，64位模式中，总是16的倍数。 这是为什么？</li>
<li>双字对齐的约束下，块的大小总是为8的倍数，且块大小的最低三位总是为0（这样才能是8的倍数，这里双字表示8字节）</li>
<li>csapp: 练习题9.6中的块大小的计算方法(get)</li>
<li>docker &amp; virtual machine 之间有什么区别？</li>
<li><blockquote>
<p>向上转型：子类除继承父类数据成员，并且还会有自己的数据成员，但是在向上转型后子类的数据成员会被舍弃</p>
</blockquote>
</li>
<li>转型之后的指针为什么可以通过子类的共有方法调用子类成员变量？</li>
<li>多线程：如何理解多线程代码的执行过程，虚假唤醒</li>
</ul>
<h2 id="代码哲学"><a href="#代码哲学" class="headerlink" title="代码哲学"></a>代码哲学</h2><ul>
<li>为什么说各个编程语言之间粒度不同呢？在什么方面体现？<ul>
<li>如果相应的库被实现了，那么这个语言的粒度会不会改变？</li>
</ul>
</li>
<li>短期内形成对方案的评估的能力，能够知晓方案的可行性、难点的能力，这种能力叫什么？如何训练（在刷算法题的时候，往往在完成过程中才能知晓这些，可能的原因有考虑不充分等）</li>
<li>见到一种技术，如何从技术实现得到技术的类型？</li>
<li>将碎片知识进行体系化</li>
<li>解决一个算法问题的过程</li>
<li>为什么说计算机领域最难的两个问题是变量命名和缓存不命中？</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-11-08T08:39:05.000Z" title="11/8/2022, 4:39:05 PM">2022-11-08</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-06-16T09:05:15.647Z" title="6/16/2024, 5:05:15 PM">2024-06-16</time></span><span class="level-item">10 minutes read (About 1441 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/11/08/%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/">命令笔记</a></p><div class="content"><h2 id="linux-命令"><a href="#linux-命令" class="headerlink" title="linux 命令"></a>linux 命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pwd</span> <span class="comment"># Present Working Directory</span></span><br><span class="line">tar &lt;options&gt; &lt;filename&gt; <span class="comment"># Tape ARchive</span></span><br><span class="line"><span class="built_in">rm</span> -rf <span class="comment"># 删除文件夹以及其中的内容</span></span><br><span class="line"><span class="built_in">cat</span> -n <span class="comment"># 查看文件中的内容，-n加上行序号</span></span><br><span class="line">less <span class="comment"># 可以滚动查看， 输入q退出</span></span><br><span class="line">grep &lt;pattern&gt; &lt;file&gt;  <span class="comment"># -v: 不包含模式的字串， -R递归地查找</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">chmod</span> 777 -R &lt;dir_name&gt; <span class="comment"># 将文件夹以及其目录中的所有文件的访问权限全开</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> - <span class="comment"># 上次目录</span></span><br><span class="line"><span class="built_in">head</span> <span class="comment"># 查看文件开头</span></span><br><span class="line">file <span class="comment"># 查看文件属性</span></span><br><span class="line"><span class="variable">${var#week}</span> <span class="comment"># 将var头部的week删掉，$会去除末尾的字符</span></span><br><span class="line">lsof -i:9008  <span class="comment"># 检查9008端口是否开放</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## ----- g++  -------</span></span><br><span class="line"><span class="comment"># - 这样做的好处是当某一个链接文件改动的时候，不需要重新编译所有的文件</span></span><br><span class="line">g++ filename.cpp -c <span class="comment"># 只编译不运行</span></span><br><span class="line">g++ *.o -o main <span class="comment"># 将编译的文件链接</span></span><br></pre></td></tr></table></figure>
<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">make -f fileName <span class="comment"># fileName 你指定的makefile文件</span></span><br><span class="line"><span class="comment"># make通过修改文件的时间戳来判断文件是否被更新</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## ---------------一个编译实例----------</span></span><br><span class="line"><span class="comment"># 增量编译(只重新编译修改过的文件)</span></span><br><span class="line">CXX = g++</span><br><span class="line">TARGET = hello</span><br><span class="line">OBJ = main.o printhello.o factorial.o  <span class="comment"># 声明依赖</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置编译模式</span></span><br><span class="line"><span class="variable">$(TARGET)</span> : <span class="variable">$(OBJ)</span></span><br><span class="line">	<span class="variable">$(CXX)</span> -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJ)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 依赖项的来源，通过g++编译而来</span></span><br><span class="line"><span class="section">main.o: main.cpp</span></span><br><span class="line">	<span class="variable">$(CXX)</span> -c main.cpp</span><br><span class="line"></span><br><span class="line"><span class="comment">## ----------第三个版本-----</span></span><br><span class="line">CXXFLAGS = -c -Wall <span class="comment"># Wall： warning all</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span> : <span class="variable">$(OBJ)</span></span><br><span class="line">	<span class="variable">$(CXX)</span> -o <span class="variable">$@</span> <span class="variable">$^</span>  <span class="comment"># @: TARGET, ^:OBJ</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------统一的规则------------</span></span><br><span class="line"><span class="comment">## $&lt;: 表示依赖中的第一个， $^: 代表所有的依赖</span></span><br><span class="line"><span class="section">%.o: %.cpp</span></span><br><span class="line">	<span class="variable">$(CXX)</span> <span class="variable">$(CXXFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean # 防止出现文件叫clean。这里生成一个依赖于clean的项目，但是什么都不做</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f *.o <span class="variable">$(TARGET)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## -----------版本4----------</span></span><br><span class="line">SRC = <span class="variable">$(<span class="built_in">wildcard</span> *.cpp)</span>  <span class="comment"># 当前目录下的所有.cpp文件都放到变量SRC中</span></span><br><span class="line">OBJ = <span class="variable">$(<span class="built_in">patsubst</span> %.cpp, %.o, <span class="variable">$(SRC)</span>)</span> <span class="comment"># 把SRC中的.cpp文件替换成.o然后存储到OBJ中</span></span><br></pre></td></tr></table></figure>
<h2 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/500002865">CMake</a></h2><p>文件名：CMakeLists.txt<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 由于cmake会生成大量的临时文件，所以最好将cmake的过程放在build</span></span><br><span class="line"><span class="comment"># 文件下，这样清除的时候会比较方便</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>) <span class="comment"># 需要的cmake的最低版本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(hello VERSION <span class="number">1.0</span>)  <span class="comment"># 项目名称以及对应的版本号</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置头文件将版本号传递给源代码</span></span><br><span class="line"><span class="keyword">configure_file</span>(TutorialConfig.h.in TutorialConfig.h)</span><br><span class="line"></span><br><span class="line"><span class="comment"># TutorialConfig.h 文件会被自动写入 build 目录，需要将目录加入到搜索头文件的路径列表中（以下添加到CMakeList.txt文件末尾）</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(<span class="variable">${PROJECT_NAME}</span> PUBLIC</span><br><span class="line">							<span class="variable">${PROJECT_BINARY_DIR}</span></span><br><span class="line">)<span class="comment"># PROJECT_BINARY_DIR 表示当前工程的二进制路径，即编译产物会存放到该路径，此时PROJECT_BINARY_DIR 就是 build 所在路径。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -------------TutorialConfig.h.in ----------------</span></span><br><span class="line">// the configured options <span class="keyword">and</span> settings for Tutorial</span><br><span class="line"><span class="comment">#define Tutorial_VERSION_MAJOR @Tutorial_VERSION_MAJOR@</span></span><br><span class="line"><span class="comment">#define Tutorial_VERSION_MINOR @Tutorial_VERSION_MINOR@</span></span><br><span class="line"><span class="comment"># -------------TutorialConfig.h.in ----------------</span></span><br><span class="line"><span class="comment">#-----------------------------------------</span></span><br><span class="line"><span class="comment"># 以后可以通过这个头文件查看版本信息，MAJOR.MINOR</span></span><br><span class="line"><span class="comment"># cmake 构建之后，会在build中生成一个TutorialConfig.h文件</span></span><br><span class="line">// the configured options <span class="keyword">and</span> settings for Tutorial</span><br><span class="line"><span class="comment">#define Tutorial_VERSION_MAJOR 1</span></span><br><span class="line"><span class="comment">#define Tutorial_VERSION_MINOR 0</span></span><br><span class="line"><span class="comment"># ------------TutorialConfig.h---------------</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成hello程序，后面的是依赖的文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(hello main.cpp factorial.cpp printhello.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment">## -------- 外部构建 --------</span></span><br><span class="line"><span class="comment"># --build 指定编译生成的文件存放目录，其中就包括可执行文件，. 表示存放到当前目录</span></span><br><span class="line">cmake --build .</span><br><span class="line">cmake .. <span class="comment"># .. 是CMakeLists.txt的存放路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## ------- 使用变量 --------</span></span><br><span class="line"><span class="keyword">set</span>(SRC_LIST a.cpp b.cpp c.cpp)  <span class="comment"># 将多个文件用一个变量保存</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>) <span class="comment"># 设置c++11标准</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">True</span>)</span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">${PROJECT_NAME}</span> <span class="variable">${SRC_LIST}</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## -------------添加库---------------</span></span><br><span class="line"><span class="comment"># MathFunctions/CMakeLists.txt</span></span><br><span class="line"><span class="keyword">add_library</span>(MathFunctions mysqrt.cpp) <span class="comment"># 添加一个叫 MathFunctions 的库文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 顶级CMakeLists.txt</span></span><br><span class="line">	<span class="comment"># add the MathFunctions library</span></span><br><span class="line">	<span class="keyword">add_subdirectory</span>(MathFunctions)</span><br><span class="line"></span><br><span class="line">	<span class="comment"># add the executable</span></span><br><span class="line">	<span class="keyword">add_executable</span>(<span class="variable">${PROJECT_NAME}</span> tutorial.cpp)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">target_link_libraries</span>(<span class="variable">${PROJECT_NAME}</span> PUBLIC MathFunctions)</span><br><span class="line"></span><br><span class="line">	<span class="comment"># add the binary tree to the search path for include files</span></span><br><span class="line">	<span class="comment"># so that we will find TutorialConfig.h</span></span><br><span class="line">	<span class="keyword">target_include_directories</span>(<span class="variable">${PROJECT_NAME}</span> PUBLIC</span><br><span class="line">							<span class="variable">${PROJECT_BINARY_DIR}</span></span><br><span class="line">							<span class="variable">${PROJECT_SOURCE_DIR}</span>/MathFunctions</span><br><span class="line">							)</span><br></pre></td></tr></table></figure></p>
<h2 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">info s  <span class="comment"># 查看栈信息</span></span><br><span class="line">info r  <span class="comment"># 查看寄存器信息</span></span><br><span class="line">info <span class="built_in">local</span> <span class="comment"># 查看局部变量</span></span><br><span class="line">bt  <span class="comment"># 查看调用栈</span></span><br><span class="line">disas <span class="comment"># 查看汇编代码， 可以指定函数</span></span><br><span class="line">x/[count][format] [address] <span class="comment"># 打印内存值</span></span><br><span class="line"> - x/s 0x402400 <span class="comment"># 打印在地址0x402400中的值，转换成string</span></span><br><span class="line">run res.txt <span class="comment"># 后面可以加上传入的参数</span></span><br><span class="line">stepi <span class="comment"># 二进制中的一步</span></span><br><span class="line">fs next <span class="comment"># 切换关注的窗口，gdb或者命令行窗口</span></span><br><span class="line"></span><br><span class="line">condition 1 item_to_remove==1  <span class="comment"># 为断点添加一个条件</span></span><br><span class="line">backtrace  <span class="comment"># 查看错误栈</span></span><br></pre></td></tr></table></figure>
<p><strong>快捷键</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl + L: 刷新gdb页面</span><br></pre></td></tr></table></figure></p>
<h2 id="快捷键（Linux）"><a href="#快捷键（Linux）" class="headerlink" title="快捷键（Linux）"></a>快捷键（Linux）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl + D: 结束当前任务</span><br></pre></td></tr></table></figure>
<h2 id="docker-命令"><a href="#docker-命令" class="headerlink" title="docker 命令"></a>docker 命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启docker</span></span><br><span class="line">docker start user_name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入docker</span></span><br><span class="line">docker attach user_name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开ssh服务(进入对应的docker之后)</span></span><br><span class="line">service ssh start</span><br></pre></td></tr></table></figure>
<h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><script type="math/tex; mode=display">
\text{工作区}\stackrel{add}{\rightarrow}\text{暂存区}\stackrel{commit}{\rightarrow}\text{本地仓库}\stackrel{push}{\rightarrow}\text{远程仓库}\stackrel{pull}{\rightarrow}\text{本地}</script><p><img src="https://Baymine.github.io/images/Basic-Knoledge/1672140678237.png" alt="1672140678237"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># In the work directory</span></span><br><span class="line">git config --global user.name <span class="string">"yourName"</span></span><br><span class="line">git config --global user.email yourEmail</span><br><span class="line"></span><br><span class="line">git init <span class="comment"># initialize the repository</span></span><br><span class="line">git status <span class="comment"># repository information</span></span><br><span class="line">git add fileName</span><br><span class="line">git commit -m <span class="string">"commit msg"</span>EADADWE</span><br><span class="line">git <span class="built_in">log</span>  <span class="comment"># 查看以前的版本</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">touch</span> .gitignore  <span class="comment"># 不追踪的文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建新分支</span></span><br><span class="line">git branch branchName</span><br><span class="line"></span><br><span class="line"><span class="comment"># 两种切换分支的命令</span></span><br><span class="line">git checkout branchName</span><br><span class="line">	- git checkout -d branchName  <span class="comment"># 删除分支</span></span><br><span class="line">	- git checkout -b temp  <span class="comment"># 创建并切换到新建的分支</span></span><br><span class="line">git switch branchName</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并分支</span></span><br><span class="line">git merge temp</span><br><span class="line"></span><br><span class="line"><span class="comment"># add 和 commit合在一起写</span></span><br><span class="line">git commit -a -m <span class="string">"msg"</span>  <span class="comment"># 或者-am</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交</span></span><br><span class="line">git push -u &lt;remote_branch&gt; &lt;loacal_branch&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加远程分支（命名为origin）</span></span><br><span class="line">git remote add origin https:****.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载远程内容</span></span><br><span class="line"><span class="comment">#### 直接下载zip是不会下载版本信息的，所以需要使用以下命令</span></span><br><span class="line">git <span class="built_in">clone</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 总结</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"# learningGit"</span> &gt;&gt; README.md</span><br><span class="line">git init</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m <span class="string">"first commit"</span></span><br><span class="line">git branch -M main</span><br><span class="line">git remote add origin https://github.com/Baymine/learningGit.git</span><br><span class="line">git push -u origin main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解决冲突</span></span><br><span class="line"><span class="comment">##　建立分支</span></span><br><span class="line">git checkout -b my_feature</span><br><span class="line"><span class="comment">## 检查差异（与main branch之间的差异）</span></span><br><span class="line">git diff</span><br><span class="line"></span><br><span class="line">git merge &lt;branch&gt;  <span class="comment"># 合并分支，如果有冲突就选择放弃或者保留改动</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不同分支中保存不同的内容，可以从远端pull最新的内容到本地</span></span><br><span class="line"> ESDAW</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-10-21T04:37:04.000Z" title="10/21/2022, 12:37:04 PM">2022-10-21</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-06-16T09:11:42.442Z" title="6/16/2024, 5:11:42 PM">2024-06-16</time></span><span class="level-item">25 minutes read (About 3799 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/10/21/Database/">Database</a></p><div class="content"><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><ul>
<li>SQL therefore treats as unknown the result of any comparison involving a null value</li>
<li>我们通过DBMS访问数据库</li>
<li><p><code>NTILE</code> 函数</p>
<ul>
<li>将排序分区中的行划分为特定数量的组。从每个组分配一个从一开始的桶号。对于每一行，NTILE()函数返回一个桶号，表示行所属的组。</li>
</ul>
</li>
<li><p>条件语句</p>
<ul>
<li><p>if 语句</p>
<ul>
<li>IF(condition, value_if_true, value_if_false)</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> salary <span class="keyword">set</span> sex <span class="operator">=</span> if(sex <span class="operator">=</span> <span class="string">'m'</span>, <span class="string">'f'</span>, <span class="string">'m'</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>IFNULL(<strong>expression_1</strong>,<strong>expression_2</strong>)<ul>
<li>如果 <code>expression_1</code>不为 <code>NULL</code>，则 <code>IFNULL</code>函数返回 <code>expression_1</code>; 否则返回 <code>expression_2</code>的结果。<ul>
<li>```sql<br>select ifNull((<pre><code>select distinct salary
from employee
order by salary desc limit 1, 1
</code></pre>), null) as SecondHighestSalary;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- case</span><br><span class="line"></span><br><span class="line">  ```sql</span><br><span class="line">  update salary set sex=(case sex when 'm' then 'f' else 'm' end);</span><br><span class="line">  &lt;!-- 通式 --&gt;</span><br><span class="line">  CASE</span><br><span class="line">  WHEN condition1 THEN result1</span><br><span class="line">  WHEN condition2 THEN result2</span><br><span class="line">  WHEN conditionN THEN resultN</span><br><span class="line">  ELSE result</span><br><span class="line">  END;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
</li>
<li><p>字符串</p>
<ul>
<li><code>substr</code>:  <code>substr(string,pos,end)</code>这个函数不填入end就是取pos位置及其之后所有的字符</li>
<li><code>LEFT(str, n)</code>: 获得字符串左边n个字符（right同理）</li>
<li><code>length(str)</code>: 获得字符串的大小</li>
<li><code>CONCAT(str1, str2, ...)</code>：合并字符串函数</li>
</ul>
</li>
<li><p>group_concat()</p>
<ul>
<li>concatenate data from multiple rows into one field.</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col1, col2, ..., colN</span><br><span class="line">GROUP_CONCAT ( [<span class="keyword">DISTINCT</span>] col_name1 </span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> clause]  [SEPARATOR str_val] ) </span><br><span class="line"><span class="keyword">FROM</span> table_name <span class="keyword">GROUP</span> <span class="keyword">BY</span> col_name2;</span><br></pre></td></tr></table></figure></li>
<li><p>时间</p>
<ul>
<li><code>datediff(date1, date2)</code>: 如果date1比date2大，结果为正；如果date1比date2小，结果为负。</li>
<li><p><code>timestampdiff(时间类型, 日期1, 日期2)</code>: 这个函数和 <code>diffdate</code>的正、负号规则刚好相反。<br>日期1大于日期2，结果为负，日期1小于日期2，结果为正。</p>
<ul>
<li>通过添加“day”, “hour”, “second”等关键词，来规定计算天数差、小时数差、还是分钟数差</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> timestampdiff(<span class="keyword">day</span>, <span class="string">'2019-01-01'</span>, <span class="string">'2019-01-03'</span>) <span class="keyword">as</span> dayInterval; <span class="comment">--计算天数差</span></span><br></pre></td></tr></table></figure></li>
<li><code>DATE_SUB(date,INTERVAL expr type)</code>: 从日期减去指定的时间间隔。</li>
<li>```sql<br>where activity_date &gt; date_sub(‘2019-07-27’, interval 30 day)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  - `year(time)`: 获取时间中的年份</span><br><span class="line"></span><br><span class="line">**from CMU**</span><br><span class="line"></span><br><span class="line">```sql</span><br><span class="line">-- 窗口函数, 按照指定的分组操作函数（将每一个分组数据作为一个函数的统计对象）</span><br><span class="line">select row_number() over (partition by cid) from titles;</span><br><span class="line">-- Common Table Expressions</span><br><span class="line">with cteName(n1, n2) as (select 1, 2) select n1 + n2 from ctenName;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><blockquote>
<p>limit 20 offset 10;</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> vend_id <span class="keyword">from</span> products; <span class="comment">--只返回不同值</span></span><br><span class="line"><span class="keyword">select</span> prod_name <span class="keyword">from</span> products limit <span class="number">5</span>;  <span class="comment">--返回不多于5行</span></span><br><span class="line"><span class="keyword">select</span> prod_name <span class="keyword">from</span> products limit <span class="number">5</span>, <span class="number">6</span>;  <span class="comment">--从第5行开始的6行（编号从一开始）</span></span><br></pre></td></tr></table></figure>
<h3 id="排序命令"><a href="#排序命令" class="headerlink" title="排序命令"></a>排序命令</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 排序</span></span><br><span class="line"><span class="keyword">select</span> prod_name <span class="keyword">from</span> products <span class="keyword">order</span> <span class="keyword">by</span> prod_name, prod_price; <span class="comment">--排序</span></span><br><span class="line"><span class="keyword">select</span> prod_name <span class="keyword">from</span> products <span class="keyword">order</span> <span class="keyword">by</span> prod_name, prod_price <span class="keyword">DESC</span>; <span class="comment">--降序排序</span></span><br><span class="line"><span class="keyword">select</span> prod_name <span class="keyword">from</span> products <span class="keyword">order</span> <span class="keyword">by</span> prod_price <span class="keyword">DESC</span>, prod_name; <span class="comment">--仅价格降序排序（多个列上进行排序，则需要在列名后面都加上这样的关键字，ASC:升序）</span></span><br></pre></td></tr></table></figure>
<h3 id="过滤数据"><a href="#过滤数据" class="headerlink" title="过滤数据"></a>过滤数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 过滤数据 --</span></span><br><span class="line"><span class="keyword">select</span> prod_name, prod_price <span class="keyword">from</span> products <span class="keyword">where</span> prod_price<span class="operator">=</span><span class="number">2.50</span>; <span class="comment">-- 使用where关键字进行条件筛选。与order by 共用的时候，应该放在where之后</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 几个where的子句符号. &lt;&gt;, !=:不等于； BETWEEN:在指定的两个值之间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 单引号用于限定字符串，当值与字符串进行比较，需要使用单引号</span></span><br><span class="line"><span class="keyword">select</span> prod_name, prod_price <span class="keyword">from</span> products <span class="keyword">where</span> prod_name <span class="operator">=</span> <span class="string">'fuses'</span>;</span><br><span class="line"><span class="operator">~</span> <span class="keyword">where</span> prod_price <span class="keyword">between</span> <span class="number">5</span> <span class="keyword">and</span> <span class="number">10</span>;  <span class="comment">-- ~表示与前面语句一致，下同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 检查NULL值.这在匹配过滤或者不匹配过滤时候不会返回。</span></span><br><span class="line"><span class="operator">~</span> <span class="keyword">where</span> prod_price <span class="keyword">is</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 次序计算，AND的优先级要更高，但是最好还是利用圆括号将操作符分开</span></span><br><span class="line"><span class="keyword">select</span> prod_name, prod_price <span class="keyword">from</span> products <span class="keyword">where</span> (vend_id <span class="operator">=</span> <span class="number">1002</span> <span class="keyword">or</span> vend_id <span class="operator">=</span> <span class="number">1003</span>) <span class="keyword">AND</span> prod_price <span class="operator">&gt;=</span> <span class="number">10</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- IN 操作符指定条件范围</span></span><br><span class="line"><span class="keyword">select</span> prod_name, prod_price <span class="keyword">from</span> products <span class="keyword">where</span> vend_id <span class="keyword">in</span> (<span class="number">1002</span>, <span class="number">1003</span>) <span class="keyword">order</span> <span class="keyword">by</span> prod_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- NOT操作符</span></span><br><span class="line"><span class="operator">~</span> <span class="keyword">where</span> vend_id <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="number">1002</span>, <span class="number">1003</span>) <span class="operator">~</span></span><br></pre></td></tr></table></figure>
<p><strong>利用通配符进行过滤</strong><br>通配符(wildcard)：用来匹配值的一部分特殊字符</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- %: 表示任意长度的字符串，但是不包含NULL</span></span><br><span class="line"><span class="keyword">select</span> prod_id, prod_name <span class="keyword">from</span> products <span class="keyword">where</span> prod_name <span class="keyword">like</span> <span class="string">'jet%'</span>; <span class="comment">-- 搜索以'jet'开头的词</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- _: 只匹配单个字符</span></span><br><span class="line"><span class="operator">~</span> <span class="keyword">like</span> <span class="string">'_ to anvil'</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通配符搜索的处理一般要比前面讨论的其他搜索所花时间更长。如果不是必要不要使用，使用的时候最好不要放在搜索的开始（搜索量太大）。</p>
</blockquote>
<p><strong>利用正则表达式进行搜索</strong><br>只需要将原先的 <code>LIKE</code>关键词转换成 <code>REGEXP</code>。注意前者是匹配文本在是这个，后者是存在这个，也就是后者只需要这个模式在文本中有出现即可，而前者需要全部一致。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- '.'：表示能够匹配任意的字符</span></span><br><span class="line"><span class="keyword">select</span> prod_name <span class="keyword">from</span> products <span class="keyword">where</span> prod_name REGEXP <span class="string">'.000'</span> <span class="keyword">order</span> <span class="keyword">by</span> prod_name; </span><br><span class="line"><span class="comment">-- 正则表达式默认不区分大小写，如果需要则要加上binary关键词</span></span><br><span class="line"><span class="operator">~</span> <span class="keyword">where</span> prod_name REGEXP <span class="type">binary</span> <span class="string">'JetPack .000'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- OR 匹配</span></span><br><span class="line"><span class="operator">~</span> regexp <span class="string">'1000|2000'</span> <span class="operator">~</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 匹配几个字符之一</span></span><br><span class="line"><span class="operator">~</span> REGEXP <span class="string">'[123] Ton'</span> <span class="operator">~</span>; <span class="comment">-- 1 Ton、 2 Ton都行</span></span><br><span class="line"><span class="string">'1|2|3 Ton'</span>  <span class="comment">-- 等价于</span></span><br><span class="line"><span class="operator">~</span> regexp <span class="string">'[1-5] Ton'</span>; <span class="comment">-- 范围匹配</span></span><br><span class="line"><span class="operator">~</span> <span class="keyword">where</span> vend_name regexp <span class="string">'\\.'</span>;  <span class="comment">-- 匹配特殊字符，用\\ 作为前导（转义）</span></span><br><span class="line"><span class="comment">-- 空白元字符： \\f----换页； \\n---换行 。。。。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 匹配字符类</span></span><br></pre></td></tr></table></figure>
<p><img src="https://Baymine.github.io/images/Database/空白元字符.png" alt="空白元字符"><br><img src="https://Baymine.github.io/images/Database/字符类.png" alt="字符类"></p>
<p><strong>匹配多个实例</strong><br>可以利用重复元字符对目标字符中的某一个字符进行指定的性质匹配。<br></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> prod_name <span class="keyword">from</span> products <span class="keyword">where</span> prod_name regexp <span class="string">'\\([0-9] sticks?\\)'</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> prod_name; <span class="comment">-- 最后匹配的是stick 或者 sticks，最后？表示s是可选的匹配字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- [:digit:]: 匹配数字； 第二个[]是为了指明{4} 的作用域</span></span><br><span class="line"><span class="operator">~</span> <span class="keyword">where</span> prod_name regexp <span class="string">'[[:digit:]]{4}'</span>; <span class="comment">-- 匹配连续一起的四个数字</span></span><br></pre></td></tr></table></figure>
<p><strong>定位符</strong></p>
<p><img src="https://Baymine.github.io/images/Database/定位元字符.png" alt="定位元字符"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 找到以数字开头（包括小数点）</span></span><br><span class="line"><span class="operator">~</span> <span class="keyword">where</span> prod_name regexp <span class="string">'[0-9\\.]'</span>; <span class="comment">-- 这样不行，这会在文本的任意位置查找匹配</span></span><br><span class="line"><span class="operator">~</span> <span class="keyword">where</span> prod_name regexp <span class="string">'^[0-9\\.]'</span>; <span class="comment">-- 仅仅从开头开始查找匹配</span></span><br></pre></td></tr></table></figure>
<h3 id="创建计算字符串"><a href="#创建计算字符串" class="headerlink" title="创建计算字符串"></a>创建计算字符串</h3><p><strong>拼接字符串</strong>使用 <code>Concat()</code>将值联结到一起构成单个值。 （使用sum，计算值的和）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- sum 与 case结合的实例</span></span><br><span class="line"><span class="built_in">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> operation<span class="operator">=</span><span class="string">'buy'</span> <span class="keyword">then</span> <span class="operator">-</span>price <span class="keyword">else</span> price <span class="keyword">end</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>多数DBMS使用 <code>+</code>或者 <code>||</code>来实现拼接(sqlite中用 <code>||</code>实现)，但是在MySQL中使用 <code>Concat()</code>函数来实现</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> concat(vend_name, <span class="string">'('</span>, vend_country, <span class="string">')'</span>) <span class="keyword">from</span> vendors ...;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除右侧多余空格来整理数据（RTrim() 函数， LTrim()去掉左侧空格）</span></span><br><span class="line"><span class="keyword">select</span> concat(RTrim(vend_name), <span class="string">'('</span>, RTrim(vend_country), <span class="string">')'</span>)...;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 为拼接的字段取名</span></span><br><span class="line"><span class="keyword">select</span> concat(vend_name, <span class="string">'('</span>, vend_country, <span class="string">')'</span>) <span class="keyword">from</span> vendors <span class="keyword">as</span> vend_title...;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 执行算数运算的结果作为一个项</span></span><br><span class="line"><span class="keyword">select</span> prod_id, quantity<span class="operator">*</span>item_price <span class="keyword">as</span> expanded_price <span class="keyword">from</span> ...;</span><br></pre></td></tr></table></figure>
<h3 id="使用数据处理函数"><a href="#使用数据处理函数" class="headerlink" title="使用数据处理函数"></a>使用数据处理函数</h3><blockquote>
<p><strong>函数没有SQL的可移植性强</strong>， 如果你决定使用函数，应该保证做好代码注释，以便以后你（或其他人）能确切地知道所编写SQL代码的含义。</p>
</blockquote>
<p><img src="https://Baymine.github.io/images/Database/常见的文本处理函数(部分" alt="常见的文本处理函数(部分)">.png)</p>
<blockquote>
<p><code>Soundex()</code>:会匹配与搜索字符串读音相似的字符串</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> vend_name, <span class="built_in">Upper</span>(vend_name) <span class="keyword">as</span> vend_name_upcase ...;</span><br></pre></td></tr></table></figure>
<p><strong>日期和时间处理函数</strong></p>
<blockquote>
<p>使用 <code>WHERE</code>进行筛选，对应的日期格式为：<code>yyyy-mm-dd</code></p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Date()函数得到的仅仅是日期，Time() 函数得到的是时间</span></span><br><span class="line"><span class="comment">-- 下面这段语句不适用Date函数，将会匹配失败，因为where是整个列值进行比较的</span></span><br><span class="line"><span class="keyword">select</span> cust_id, order_num <span class="keyword">from</span> orders <span class="keyword">where</span> <span class="type">Date</span>(order_date) <span class="operator">=</span> <span class="string">'2005-09-01'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 时间段进行筛选</span></span><br><span class="line"><span class="operator">~</span> <span class="keyword">where</span> <span class="type">Date</span>(order_data) <span class="keyword">between</span> <span class="string">'2005-09-01'</span> <span class="keyword">and</span> <span class="string">'2005-9-30'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取时间中的月份或者年份信息</span></span><br><span class="line"><span class="keyword">year</span>(order_date), <span class="keyword">month</span>(order_date);</span><br></pre></td></tr></table></figure>
<p><strong>数值处理函数</strong><br><img src="https://Baymine.github.io/images/Database/常用数值处理函数.png" alt="常用数值处理函数"></p>
<h3 id="汇总数据"><a href="#汇总数据" class="headerlink" title="汇总数据"></a>汇总数据</h3><p>获取表中的汇总信息。<br><img src="https://Baymine.github.io/images/Database/SQL聚集函数.png" alt="SQL聚集函数"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 返回特定供应商提供的产品的平均价格</span></span><br><span class="line"><span class="comment">-- 不允许使用count(distinct)</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(<span class="keyword">distinct</span> prod_price) <span class="keyword">from</span> products <span class="keyword">where</span> vend_id <span class="operator">=</span> <span class="number">1003</span>;</span><br></pre></td></tr></table></figure>
<h3 id="分组数据"><a href="#分组数据" class="headerlink" title="分组数据"></a>分组数据</h3><p>分组数据以便能汇总内容的子集, 将数据按照指定的分组进行统计。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> vend_id, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> num_prods <span class="keyword">from</span> products <span class="keyword">group</span> <span class="keyword">by</span> vend_id;</span><br></pre></td></tr></table></figure>
<p>过滤分组使用 <code>having</code>,这个子句支持所有 <code>where</code>操作符。(对分组数据进行筛选)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 这里直接使用where无法实现相同的目的</span></span><br><span class="line"><span class="operator">~</span> <span class="keyword">group</span> <span class="keyword">by</span> cust_id <span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 过去12个月具有两个或以上的订单，且价格为10以上</span></span><br><span class="line"><span class="keyword">select</span> vend_id, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> num_prods <span class="keyword">from</span> products <span class="keyword">where</span> prod_price <span class="operator">&gt;=</span> <span class="number">10</span> <span class="keyword">group</span> <span class="keyword">by</span> vend_id <span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p><strong>group by &amp; order by</strong></p>
<blockquote>
<p>不要忘记ORDER BY 一般在使用GROUP BY子句时，应该也给出ORDER BY子句。这是保证数据正确排序的唯一方法。千万不要仅依赖GROUP BY排序数据。</p>
</blockquote>
<h3 id="子查询语句"><a href="#子查询语句" class="headerlink" title="子查询语句"></a>子查询语句</h3><p>在select语句中嵌套select语句, <code>in</code> 或者 <code>not in</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> cust_id</span><br><span class="line"><span class="keyword">from</span> orders</span><br><span class="line"><span class="keyword">where</span> order_num <span class="keyword">in</span>(<span class="keyword">select</span> order_num</span><br><span class="line">                   <span class="keyword">from</span> orderitems</span><br><span class="line">                   <span class="keyword">where</span> prod_id <span class="operator">=</span> <span class="string">'TNT2'</span>);</span><br></pre></td></tr></table></figure>
<h3 id="联结表"><a href="#联结表" class="headerlink" title="联结表"></a>联结表</h3><p>在联结两个表时，实际上就是将第一个表中的每一行与第二个表中的每一行进行匹配。Note: left join可以用于数据的剔除（Not in的效果）</p>
<p><img src="/.io//join.jpg" alt="img"></p>
<blockquote>
<p>Ref: Database System Concepts 7ed(Abraham Silberschatz, Henry F. Korth etc.)</p>
</blockquote>
<p><strong><code>&gt; some</code>: greater than at least one</strong><br><strong><code>&gt; all</code>: greater than all. <code>&lt;&gt; all</code>: not in</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> salary <span class="operator">&gt;</span> <span class="keyword">some</span> (<span class="keyword">select</span> salary</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> dept name <span class="operator">=</span> <span class="string">'Biology'</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>cross join</code><ul>
<li>先将两个表进行笛卡尔积，然后利用后面的on对联结表进行筛选<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a.Id</span><br><span class="line"><span class="keyword">from</span> weather <span class="keyword">as</span> a </span><br><span class="line"><span class="keyword">cross</span> <span class="keyword">join</span> weather <span class="keyword">as</span> b</span><br><span class="line"><span class="keyword">on</span> datediff(a.recordDate, b.recordDate) <span class="operator">=</span> <span class="number">1</span>  <span class="comment">-- 这里就是筛选的条件了</span></span><br><span class="line"><span class="keyword">where</span> a.temperature <span class="operator">&gt;</span> b.temperature;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p><strong>内部联结</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.... <span class="keyword">from</span> ...(列名) <span class="keyword">inner</span> <span class="keyword">join</span> ... <span class="keyword">on</span> ....(<span class="keyword">condition</span>);</span><br></pre></td></tr></table></figure>
<h3 id="高级联结"><a href="#高级联结" class="headerlink" title="高级联结"></a>高级联结</h3><p><strong>自联结</strong>：利用别名对同一个表中的条件进行筛选</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> p1.id, p1.name </span><br><span class="line"><span class="keyword">from</span> product <span class="keyword">as</span> p1, product <span class="keyword">as</span> p2  <span class="comment">-- 对同一个表给予两个不同的别名</span></span><br><span class="line"><span class="keyword">where</span> p1.id <span class="operator">=</span> p2.id <span class="keyword">and</span> p2.id <span class="operator">=</span> <span class="string">'DTNTR'</span>;  <span class="comment">-- 这样就得到了id为'DTNTR'的名称了</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用场景： 删除表中重复的元素.仅保留id较小的元素</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> p1 <span class="keyword">from</span> person <span class="keyword">as</span> p1, person <span class="keyword">as</span> p2</span><br><span class="line"><span class="keyword">where</span> p1.email<span class="operator">=</span>p2.email <span class="keyword">and</span> p1.Id <span class="operator">&gt;</span> p2.id;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>外部联结</strong>：联结包含了那些在相关表中没有关联行的行。使用关键字 <code>LEFT OUTER JOIN</code>（左外部联结）</p>
<h3 id="创建组合查询"><a href="#创建组合查询" class="headerlink" title="创建组合查询"></a>创建组合查询</h3><p>使用关键字 <code>Union</code>将两个子句的结果进行组合。</p>
<blockquote>
<p>UNION中的每个查询必须包含相同的列、表达式或聚集函数<br>自动去除重复的行（使用 <code>Union all</code>保留所有的行）<br>末尾的 <code>order by</code>不会是对单一语句的排序，而是对返回的所有的结果进行排序的。</p>
<p>union 和 union all都可以起到关联结果集的作用,<br>union 会自动去除关联的两个结果集中的重复数据<br>union all 不会主动去除两个结果集中的重复数据,会展示所有的数据</p>
</blockquote>
<h3 id="使用全文本搜索"><a href="#使用全文本搜索" class="headerlink" title="使用全文本搜索"></a>使用全文本搜索</h3><p>在建表的时候， 添加 <code>FULLEXT(...)</code>.在检索的时候，会根据这个指示进行检索</p>
<blockquote>
<p>CREATE TABLE语句接受FULLTEXT子句，它给出被索引列的一个逗号分隔的列表。<br>在索引之后，使用两个函数Match()和Against()执行全文本搜索，其中Match()指定被搜索的列，Against()指定要使用的搜索表达式。(Match中的值与FULLEXT中定义的相同)。 这种方法，当匹配词出现在更前面的时候，输出的优先级要高一些。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ... <span class="keyword">where</span> <span class="keyword">Match</span>(note_text) Against(<span class="string">'rabbit'</span>);</span><br></pre></td></tr></table></figure>
<p><strong>查询拓展</strong><br>将包含目标词的语句中的词的语句也同样输出来。(<code>with query expansion</code>)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">... <span class="keyword">where</span> <span class="keyword">match</span>(note_text) Against(<span class="string">'anvils'</span> <span class="keyword">with</span> query expansion);</span><br></pre></td></tr></table></figure>
<p><strong>布尔文本搜索</strong>MySQL支持全文本搜索的另外一种形式，称为布尔方式（boolean mode）。</p>
<blockquote>
<p>全文本搜索布尔操作符-和<em>，-排除一个词，而</em>是截断操作符（可想象为用于词尾的一个通配符）</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">... <span class="keyword">where</span> <span class="keyword">match</span>(..) against(<span class="string">'...'</span> <span class="keyword">in</span> <span class="type">boolean</span> mode);</span><br><span class="line">... <span class="keyword">where</span> <span class="keyword">match</span>(..) against(<span class="string">'... -rope*'</span> <span class="keyword">in</span> <span class="type">boolean</span> mode); <span class="comment">-- 匹配包含...但不包含任意以rope开始的词的行</span></span><br></pre></td></tr></table></figure>
<h3 id="插入完整的行"><a href="#插入完整的行" class="headerlink" title="插入完整的行"></a>插入完整的行</h3><p>需要指定表名，以及表下所有的对应的列的信息。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- insert 插入一行到一个表中</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Customers <span class="keyword">values</span>(list_infomation);  <span class="comment">--虽然这种语法很简单，但并不安全，应该尽量避免使用</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Custormers(cust_name, cust_address,....) <span class="keyword">values</span>(list_infomation);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Custormers(cust_name, cust_address,....) <span class="keyword">values</span>(list_infomation1)， (list_infomation2);  <span class="comment">-- 插入两行到一个表中</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Custormers(cust_name, cust_address,....) <span class="keyword">select</span> cust_name, cust_address,.... <span class="keyword">from</span> custnew; <span class="comment">-- 利用select语句进行填充</span></span><br></pre></td></tr></table></figure>
<h3 id="更新与删除数据"><a href="#更新与删除数据" class="headerlink" title="更新与删除数据"></a>更新与删除数据</h3><p>更新使用关键词 <code>update</code></p>
<blockquote>
<p>MySQL没有撤销（undo）按钮。应该非常小心地使用UPDATE和DELETE.</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> customers <span class="keyword">set</span> cust_name <span class="operator">=</span> <span class="string">'..'</span>, cust_email <span class="operator">=</span> <span class="string">',,'</span> <span class="keyword">where</span> cust_id <span class="operator">=</span> <span class="number">1002</span>; <span class="comment">-- 可以一次性更新多个信息</span></span><br><span class="line"><span class="comment">-- 为了删除某个列的值，可设置它为NULL（假如表定义允许NULL值）。</span></span><br><span class="line"><span class="comment">-- 替换的新的值可以使用if语句</span></span><br></pre></td></tr></table></figure>
<p>删除数据使用关键词 <code>delete</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> customers <span class="keyword">where</span> cust_id <span class="operator">=</span> <span class="number">1006</span>; <span class="comment">-- DELETE不需要列名或通配符。DELETE删除整行而不是删除列。为了删除指定的列，请使用UPDATE语句</span></span><br></pre></td></tr></table></figure>
<h3 id="创建和操纵表"><a href="#创建和操纵表" class="headerlink" title="创建和操纵表"></a>创建和操纵表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tableName(</span><br><span class="line">    <span class="comment">-- AUTO_INCREMENT：本列每当增加一行时自动增量， 每个表只允许一个AUTO_INCREMENT列，而且它必须被索引</span></span><br><span class="line">    <span class="comment">-- 与大多数DBMS不一样，MySQL不允许使用函数作为默认值，它只支持常量</span></span><br><span class="line">    cust_id <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT <span class="keyword">default</span> <span class="number">1</span>,</span><br><span class="line"><span class="comment">--  列名   类型  是否允许NULL             未给出值的时候，默认为1</span></span><br><span class="line">    <span class="comment">-- 主键中只能使用不允许NULL值的列</span></span><br><span class="line">    <span class="keyword">primary</span> key (cust_id)</span><br><span class="line">)ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"><span class="comment">-- 引擎类型，如果省略ENGINE=语句，则使用默认引擎（很可能是MyISAM）。 外键不能跨引擎</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改, 给表添加一个列</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">add</span> vendor <span class="type">char</span>(<span class="number">20</span>);  </span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">drop</span> <span class="keyword">column</span> vendor; <span class="comment">-- 删除</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">add</span> <span class="keyword">constraint</span> .... <span class="comment">-- etc</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除表（删除整个表而不是其内容）</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> table_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">--重命名表</span></span><br><span class="line">rename <span class="keyword">table</span> t <span class="keyword">to</span> t1;</span><br></pre></td></tr></table></figure>
<h3 id="使用视图"><a href="#使用视图" class="headerlink" title="使用视图"></a>使用视图</h3><p>视图本身不包含数据，因此它们返回的数据是从其他表中检索出来的(实际上就是将一个sql语句进行封装)</p>
<blockquote>
<p>视图用 <code>CREATE VIEW</code>语句来创建。</p>
<ul>
<li>使用 <code>SHOW CREATE VIEW viewname；</code>来查看创建视图的语句。</li>
<li>用DROP删除视图，其语法为 <code>DROP VIEW viewname;</code>。</li>
<li>更新视图时，可以先用DROP再用CREATE，也可以直接用 <code>CREATE OR  REPLACE VIEW</code>。如果要更新的视图不存在，则第2条更新语句会创<br>建一个视图；如果要更新的视图存在，则第2条更新语句会替换原<br>有视图</li>
</ul>
<p>并非所有视图都是可更新的。基本上可以说，如果MySQL不能正确地确定被更新的基数据，则不允许更新（包括插入和删除）</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> view_name <span class="keyword">as</span> <span class="keyword">select</span> .....;</span><br></pre></td></tr></table></figure>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-10-21T03:30:25.000Z" title="10/21/2022, 11:30:25 AM">2022-10-21</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-12-22T06:31:12.115Z" title="12/22/2022, 2:31:12 PM">2022-12-22</time></span><span class="level-item">5 minutes read (About 771 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/10/21/6_S081lab1/">6.S081lab1</a></p><div class="content"><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><h3 id="使用Tmux在一个终端中创建多个窗口"><a href="#使用Tmux在一个终端中创建多个窗口" class="headerlink" title="使用Tmux在一个终端中创建多个窗口"></a>使用Tmux在一个终端中创建多个窗口</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tmux # 进入新建的会话中</span><br><span class="line">Ctrl + B , % # 垂直分割（左右）</span><br><span class="line">Ctrl + B , “ # 水平分割（上下）</span><br><span class="line">Ctrl + B , 方向键 # 在不同的终端中切换</span><br><span class="line">exit  # 退出会话</span><br></pre></td></tr></table></figure>
<h3 id="启动qemu的gdb模式"><a href="#启动qemu的gdb模式" class="headerlink" title="启动qemu的gdb模式"></a>启动qemu的gdb模式</h3><p>在第一个窗口运行 <code>make CPUS=1 qemu-gdb</code>, 第二个窗口运行 <code>gdb-multiarch</code>，开启gdb模式。</p>
<p>如果lient端没有连接到server，那么需要在 <code>/root</code> 创建 <code>.gdbinit</code> 文件, 加上：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add-auto-load-safe-path /root/xv6-labs-2022/.gdbinit  # xv6 directory</span><br></pre></td></tr></table></figure>
<h4 id="gdb的使用方法"><a href="#gdb的使用方法" class="headerlink" title="gdb的使用方法"></a>gdb的使用方法</h4><p>首先是链接文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file fileName</span><br></pre></td></tr></table></figure>
<p>常见的命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">r = run</span><br><span class="line">c = continue # 让暂停的程序继续运行</span><br><span class="line">n = next  # 运行到下一行</span><br><span class="line">s = step # 单步执行，遇到函数会进入</span><br><span class="line">p = print  # 打印变量或寄存器</span><br></pre></td></tr></table></figure>
<h2 id="实验一"><a href="#实验一" class="headerlink" title="实验一"></a>实验一</h2><p>预备知识：</p>
<ul>
<li><code>pid_t wait(int *wstatus)</code>：等待（阻塞状态）子进程状态发生变化（子进程终结、子进程被信号停止或恢复）。如果子进程是被终结，那么wait能够允许系统释放子进程的资源。如果wait没有得到执行，那么终结的子进程就会变成“僵尸”状态。<code>exit(0)</code>表示等待所有的子进程退出。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"kernel/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"user/user.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RD 0 <span class="comment">//pipe的read端</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WR 1 <span class="comment">//pipe的write端</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span>{</span><br><span class="line">    <span class="type">char</span> buf = <span class="string">'P'</span>; <span class="comment">//用于传送的字节</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd_c2p[<span class="number">2</span>]; <span class="comment">//子进程-&gt;父进程</span></span><br><span class="line">    <span class="type">int</span> fd_p2c[<span class="number">2</span>]; <span class="comment">//父进程-&gt;子进程</span></span><br><span class="line">    <span class="built_in">pipe</span>(fd_c2p);</span><br><span class="line">    <span class="built_in">pipe</span>(fd_p2c);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="type">int</span> exit_status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">"fork() error!\n"</span>);</span><br><span class="line">        <span class="built_in">close</span>(fd_c2p[RD]);</span><br><span class="line">        <span class="built_in">close</span>(fd_c2p[WR]);</span><br><span class="line">        <span class="built_in">close</span>(fd_p2c[RD]);</span><br><span class="line">        <span class="built_in">close</span>(fd_p2c[WR]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) { <span class="comment">//子进程</span></span><br><span class="line">        <span class="built_in">close</span>(fd_p2c[WR]);</span><br><span class="line">        <span class="built_in">close</span>(fd_c2p[RD]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">read</span>(fd_p2c[RD], &amp;buf, <span class="built_in">sizeof</span>(<span class="type">char</span>)) != <span class="built_in">sizeof</span>(<span class="type">char</span>)) {</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">"child read() error!\n"</span>);</span><br><span class="line">            exit_status = <span class="number">1</span>; <span class="comment">//标记出错</span></span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">1</span>, <span class="string">"%d: received ping\n"</span>, <span class="built_in">getpid</span>());</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">write</span>(fd_c2p[WR], &amp;buf, <span class="built_in">sizeof</span>(<span class="type">char</span>)) != <span class="built_in">sizeof</span>(<span class="type">char</span>)) {</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">"child write() error!\n"</span>);</span><br><span class="line">            exit_status = <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="built_in">close</span>(fd_p2c[RD]);</span><br><span class="line">        <span class="built_in">close</span>(fd_c2p[WR]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(exit_status);</span><br><span class="line">    } <span class="keyword">else</span> { <span class="comment">//父进程</span></span><br><span class="line">        <span class="built_in">close</span>(fd_p2c[RD]);</span><br><span class="line">        <span class="built_in">close</span>(fd_c2p[WR]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">write</span>(fd_p2c[WR], &amp;buf, <span class="built_in">sizeof</span>(<span class="type">char</span>)) != <span class="built_in">sizeof</span>(<span class="type">char</span>)) {</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">"parent write() error!\n"</span>);</span><br><span class="line">            exit_status = <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">read</span>(fd_c2p[RD], &amp;buf, <span class="built_in">sizeof</span>(<span class="type">char</span>)) != <span class="built_in">sizeof</span>(<span class="type">char</span>)) {</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">"parent read() error!\n"</span>);</span><br><span class="line">            exit_status = <span class="number">1</span>; <span class="comment">//标记出错</span></span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">1</span>, <span class="string">"%d: received pong\n"</span>, <span class="built_in">getpid</span>());</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="built_in">close</span>(fd_p2c[WR]);</span><br><span class="line">        <span class="built_in">close</span>(fd_c2p[RD]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(exit_status);</span><br><span class="line">    }</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><ul>
<li>0、1、2是文件描述符（分别对应stdin、stdout、stderr）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fprintf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span><span class="comment">// C 库函数发送格式化输出到流 stream 中。</span></span></span><br><span class="line"><span class="function"><span class="comment">// -----------------------------------------------------------</span></span></span><br><span class="line"><span class="function"><span class="keyword">struct</span> dirent</span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">　　<span class="type">long</span> d_ino; <span class="comment">/* inode number 索引节点号 */</span></span><br><span class="line">    <span class="type">off_t</span> d_off; <span class="comment">/* offset to this dirent 在目录文件中的偏移 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> d_reclen; <span class="comment">/* length of this d_name 文件名长 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> d_type; <span class="comment">/* the type of d_name 文件类型 */</span></span><br><span class="line">    <span class="type">char</span> d_name [NAME_MAX+<span class="number">1</span>]; <span class="comment">/* file name (null-terminated) 文件名，最长255字符 */</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------------------------------------------</span></span><br><span class="line"><span class="comment">// 从 str2 复制 n 个字符到 str1，但是在重叠内存块这方面，memmove() 是比 memcpy() 更安全的方法</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">memmove</span><span class="params">(<span class="type">void</span> *str1, <span class="type">const</span> <span class="type">void</span> *str2, <span class="type">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="实验二"><a href="#实验二" class="headerlink" title="实验二"></a>实验二</h2><h3 id="trace"><a href="#trace" class="headerlink" title="trace"></a>trace</h3><p>TODO: 理清楚整个调用的过程</p>
<p>xv6系统调用的过程，这里以fork为例:<br></p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/page/0/">Previous</a></div><div class="pagination-next"><a href="/page/2/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/5/">5</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="York Cao"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">York Cao</p><p class="is-size-6 is-block">Data Engineer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Beijing</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">41</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">8</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/Baymine" target="_blank" rel="me noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Github" href="https://github.com/Baymine"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-06-03T02:56:51.000Z">2024-06-03</time></p><p class="title"><a href="/2024/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%95%99%E8%82%B2%E7%BC%BA%E5%A4%B1%E7%9A%84%E4%B8%80%E8%AF%BE/">计算机教育缺失的一课</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-05-29T13:26:01.000Z">2024-05-29</time></p><p class="title"><a href="/2024/05/29/Clickhouse%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E6%97%A5%E8%AE%B0/">Clickhouse源码阅读日记</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-01-05T08:48:47.000Z">2023-01-05</time></p><p class="title"><a href="/2023/01/05/GeePRC-notes/">GeePRC notes</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-12-18T07:04:19.000Z">2022-12-18</time></p><p class="title"><a href="/2022/12/18/C-Memory-Management/">C++ Memory Management</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-12-16T03:53:01.000Z">2022-12-16</time></p><p class="title"><a href="/2022/12/16/MIT6-S081/">MIT6.S081</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/06/"><span class="level-start"><span class="level-item">June 2024</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/05/"><span class="level-start"><span class="level-item">May 2024</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/01/"><span class="level-start"><span class="level-item">January 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/12/"><span class="level-start"><span class="level-item">December 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/11/"><span class="level-start"><span class="level-item">November 2022</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/10/"><span class="level-start"><span class="level-item">October 2022</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/07/"><span class="level-start"><span class="level-item">July 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/06/"><span class="level-start"><span class="level-item">June 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">May 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">April 2021</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">March 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/02/"><span class="level-start"><span class="level-item">February 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">January 2021</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/12/"><span class="level-start"><span class="level-item">December 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C++</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C-primer/"><span class="tag">C++ primer</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/DB/"><span class="tag">DB</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OS/"><span class="tag">OS</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Projects/"><span class="tag">Projects</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/bugs/"><span class="tag">bugs</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/computer-network/"><span class="tag">computer network</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BE%AF%E6%8D%B7C/"><span class="tag">侯捷C++</span><span class="tag">5</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">Subscribe for updates</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div><div class="card widget"><div class="card-content"><div class="notification is-danger">You need to set <code>client_id</code> and <code>slot_id</code> to show this AD unit. Please set it in <code>_config.yml</code>.</div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Baymine&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2024 John Doe</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>