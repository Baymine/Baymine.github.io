<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/01/05/GeePRC-notes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/01/05/GeePRC-notes/" class="post-title-link" itemprop="url">GeePRC notes</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-01-05 16:48:47" itemprop="dateCreated datePublished" datetime="2023-01-05T16:48:47+08:00">2023-01-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-01-16 19:35:05" itemprop="dateModified" datetime="2023-01-16T19:35:05+08:00">2023-01-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="项目大纲"><a href="#项目大纲" class="headerlink" title="项目大纲"></a>项目大纲</h2><ul>
<li><p>codec.go</p>
<ul>
<li>报文Header</li>
<li>消息体编码解码的接口 Codec<ul>
<li>读取报头</li>
<li>读取主体</li>
<li>写入报头的方法</li>
</ul>
</li>
<li>Codec的构造函数</li>
<li>可选用的编码方式<ul>
<li>存储在一个map中<ul>
<li>不同的编码方式调用不同的codec构造函数</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>gob.go</p>
<ul>
<li>gob结构体</li>
<li>GobCodec实现接口codec</li>
</ul>
</li>
<li><p>server.go</p>
<ul>
<li>Option<ul>
<li>标识<ul>
<li>Magic number</li>
</ul>
</li>
<li>编码方式</li>
<li>默认的Option</li>
</ul>
</li>
</ul>
</li>
<li><p>main.go</p>
<ul>
<li>创建一个监听者<ul>
<li>通过一个协程在执行</li>
<li>协程中的得到的地址通过管道通知主线程</li>
</ul>
</li>
<li>确定编码方式</li>
<li>发送接收<ul>
<li>创建报头</li>
<li>写入<ul>
<li>cc.Write()</li>
</ul>
</li>
<li>接收回应<ul>
<li>cc.ReadHeader()</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="bug"><a href="#bug" class="headerlink" title="bug"></a>bug</h2><p>day5, go run main.go:<br>rpc server: register Foo.Sum<br>rpc server debug path: &#x2F;debug&#x2F;geerpc<br>call Foo.Sum error:rpc server: request handle timeout: expect within 10ns<br>exit status 1</p>
<h2 id="Chanllenge"><a href="#Chanllenge" class="headerlink" title="Chanllenge"></a>Chanllenge</h2><h3 id="网络粘包"><a href="#网络粘包" class="headerlink" title="网络粘包"></a>网络粘包</h3><p>执行 <code>go test -v</code> 会有一定概率出现测试卡死无响应的bug<br><a target="_blank" rel="noopener" href="https://github.com/geektutu/7days-golang/issues/26">issue</a></p>
<h2 id="Great-designs"><a href="#Great-designs" class="headerlink" title="Great designs"></a>Great designs</h2><h3 id="使用通道实现超时判断"><a href="#使用通道实现超时判断" class="headerlink" title="使用通道实现超时判断"></a>使用通道实现超时判断</h3><p>在goroutine中，完成一步之后往管道内传入<code>struct &#123;&#125;&#123;&#125;</code>这样，在goroutine外部就可以接收到这些信息，这样外部就知道goroutine内部某个函数完成了，</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">callChannel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">  err := call(args)</span><br><span class="line">  callChannel &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> &lt;-time.After(timeout):  <span class="comment">// 处理超时</span></span><br><span class="line">    timeout handling</span><br><span class="line">  <span class="keyword">case</span> &lt;-callChannel:</span><br><span class="line">    function finished</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Knowledges"><a href="#Knowledges" class="headerlink" title="Knowledges"></a>Knowledges</h2><h3 id="如何结束一个goroutine"><a href="#如何结束一个goroutine" class="headerlink" title="如何结束一个goroutine"></a>如何结束一个goroutine</h3><p>利用管道传入一个结束信息（这里是true），然后返回函数即可</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;- quit:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">// Do other stuff</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do stuff</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Quit goroutine</span></span><br><span class="line">quit &lt;- <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="encoding-x2F-gob"><a href="#encoding-x2F-gob" class="headerlink" title="encoding&#x2F;gob"></a>encoding&#x2F;gob</h3><ul>
<li>Package gob 管理 gobs 流 - 在编码器（发送器）和解码器（接收器）之间交换的二进制值</li>
<li><pre><code class="go">enc := gob.NewEncoder(&amp;network) // 将写入网络。
dec := gob.NewDecoder(&amp;network) // 将从网络上读取。
// Encoding（发送）一些值。
err := enc.Encode(P&#123;3, 4, 5, &quot;Pythagoras&quot;&#125;)
// 接收
var q Q
err = dec.Decode(&amp;q)
</code></pre>
</li>
</ul>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><h3 id="Context-package"><a href="#Context-package" class="headerlink" title="Context package"></a>Context package</h3><ul>
<li>context 主要用来在 goroutine 之间传递上下文信息，包括：取消信号、超时时间、截止时间、k-v 等。</li>
<li>一句话：context 用来解决 goroutine 之间 <code>退出通知</code>、<code>元数据传递</code>的功能。</li>
<li><img src="https://pic3.zhimg.com/80/v2-6a27526f536505cea08a5813ccce05b2_720w.webp"></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/18/C-Memory-Management/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/18/C-Memory-Management/" class="post-title-link" itemprop="url">C++ Memory Management</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-12-18 15:04:19" itemprop="dateCreated datePublished" datetime="2022-12-18T15:04:19+08:00">2022-12-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-12-21 17:08:01" itemprop="dateModified" datetime="2022-12-21T17:08:01+08:00">2022-12-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第一讲-primitives"><a href="#第一讲-primitives" class="headerlink" title="第一讲 primitives"></a>第一讲 primitives</h1><h3 id="1-overview"><a href="#1-overview" class="headerlink" title="1. overview"></a>1. overview</h3><ul>
<li>资料： <a target="_blank" rel="noopener" href="http://gee.cs.oswego.edu/dl/">DL Malloc</a></li>
<li>涉及的库</li>
</ul>
<p><img src="/.com//C-Memory-Management/1671347745514.png" alt="1671347745514"></p>
<h3 id="2、3-内存分配的每一层面及基本用法"><a href="#2、3-内存分配的每一层面及基本用法" class="headerlink" title="2、3. 内存分配的每一层面及基本用法"></a>2、3. 内存分配的每一层面及基本用法</h3><p><img src="/.com//C-Memory-Management/1671348085106.png" alt="1671348085106"></p>
<p>本课程只考虑CRT以上的层次。</p>
<p><strong>基本工具</strong></p>
<p><img src="/.com//C-Memory-Management/1671348161500.png" alt="1671348161500"></p>
<p><strong>基本用法</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* p3 = ::<span class="keyword">operator</span> <span class="built_in">new</span> (<span class="number">512</span>);   <span class="comment">// 512 bytes</span></span><br><span class="line">::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(p3)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __BORLANDC__  <span class="comment">// 不同库不同</span></span></span><br><span class="line">	<span class="comment">// 申请5个int。 一般容器中使用</span></span><br><span class="line">	<span class="type">int</span>* p4 = <span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">allocate</span>(<span class="number">5</span>);</span><br><span class="line">	<span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">deallocate</span>(p4, <span class="number">5</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __GNUC__   <span class="comment">// 较早版本中</span></span></span><br><span class="line">	<span class="type">void</span>* p4 = alloc::<span class="built_in">allocate</span>(<span class="number">512</span>);</span><br><span class="line">	alloc::<span class="built_in">deallocate</span>(p4, <span class="number">512</span>);</span><br><span class="line"> <span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="4、5、6、基本构件——new-delete-expression"><a href="#4、5、6、基本构件——new-delete-expression" class="headerlink" title="4、5、6、基本构件——new delete expression"></a>4、5、6、基本构件——new delete expression</h3><p>new 中实际上就是在调用malloc</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class_name* pc = <span class="keyword">new</span> <span class="built_in">class_name</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器转换为</span></span><br><span class="line"><span class="comment">// 加上try catch</span></span><br><span class="line"><span class="type">void</span>* mem = <span class="keyword">operator</span> <span class="built_in">new</span>(<span class="built_in">sizeof</span>(class_name));</span><br><span class="line">pc = <span class="built_in">static_cast</span>&lt;class_name*&gt;(mem);</span><br><span class="line">pc-&gt;class_name::<span class="built_in">class_name</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 只有编译其才能这样调用构造函数</span></span><br><span class="line"><span class="comment">// 但是可以直接调用析构函数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="7、Array-new"><a href="#7、Array-new" class="headerlink" title="7、Array new"></a>7、Array new</h3><p>当new一个数组的时候，系统会使用4个字节存放数组的一些信息，即为下图中的 <code>cookie</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Complex* pca = <span class="keyword">new</span> Complex[<span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<p><img src="/.com//C-Memory-Management/1671438018665.png" alt="1671438018665"></p>
<ul>
<li>在进行array new的时候，单个元素不会独自进行内存对齐。</li>
<li>构建的时候是从上往下，析构的时候是由下往上</li>
<li><img src="/.com//C-Memory-Management/1671439085184.png" alt="1671439085184"><ul>
<li><code> 61h</code>就是cokie，需要进行内存对齐（VC6)中是16位对齐</li>
<li>对于申请的int类型的数组，可以直接使用delete，因为这些数据类型没有析构函数，</li>
</ul>
</li>
<li><img src="/.com//C-Memory-Management/1671440046493.png" alt="1671440046493"><ul>
<li>因为数组个数被写入，所以内存的整体布局会发生变化，所以不能直接用 <code>delete</code>来回收</li>
<li><code>61h</code>的大小计算<ul>
<li>类大小<em>类个数&#x3D;((3</em>4) * 3) &#x3D; 36\ 上下debugger header &#x3D; 32 + 4\ 两个61h&#x3D;4*2&#x3D;8</li>
<li>最后向16的倍数内存对齐最后的 <code>pad</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="8-palcement-new"><a href="#8-palcement-new" class="headerlink" title="8.palcement new"></a>8.palcement new</h3><p>允许将对象构造与已分配的内存中</p>
<p><img src="/.com//C-Memory-Management/1671441329456.png" alt="1671441329456"></p>
<h3 id="9-random"><a href="#9-random" class="headerlink" title="9.random"></a>9.random</h3><ul>
<li>placement new 的重载</li>
<li>嵌入式指针使用案例（内存池）<ul>
<li>通过一次性申请一定量的内存，减少每个内存中的cookie的数量，同时减少malloc的调用</li>
<li>整个内存是通过一个链表管理的，释放内存就是将空闲的内存插入到链表头部</li>
<li>但是申请的内存没有真正释放，所以可能会存在使用峰值的问题</li>
</ul>
</li>
</ul>
<p><img src="/.com//C-Memory-Management/1671541094430.png" alt="1671541094430"></p>
<ul>
<li>可以自定义handler来让更多的空间可用，或者调用abort() 或 exit();</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set_new_handler</span>(handlerFunctionPoint);</span><br></pre></td></tr></table></figure>

<ul>
<li>default, delete 关键字</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/16/MIT6-S081/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/16/MIT6-S081/" class="post-title-link" itemprop="url">MIT6.S081</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-12-16 11:53:01" itemprop="dateCreated datePublished" datetime="2022-12-16T11:53:01+08:00">2022-12-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-12-30 09:54:18" itemprop="dateModified" datetime="2022-12-30T09:54:18+08:00">2022-12-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Reading"><a href="#Reading" class="headerlink" title="Reading"></a>Reading</h1><h3 id="Chapter-1-Operating-system-interfaces"><a href="#Chapter-1-Operating-system-interfaces" class="headerlink" title="Chapter 1: Operating system interfaces"></a>Chapter 1: Operating system interfaces</h3><ul>
<li><p>the shell is a user program, and not part of the kernel</p>
</li>
<li><p>Although the child has the same memory contents as the parent initially, the parent and child are executing with different memory and different registers: changing a variable in one does not affect the other.</p>
</li>
<li><p><code>exec</code> replaces the calling process’s memory but preserves its file table</p>
<ul>
<li><code>exec</code> replaces the memory and registers of the current process with a new program</li>
</ul>
</li>
<li><p>I&#x2F;O and File descriptors</p>
<ul>
<li>The shell ensures that it always has three file descriptors open<ul>
<li>std input, std output, std error</li>
<li>先close(0); 然后open, 让文件描述符与读相连接</li>
</ul>
</li>
<li>read(fd, buf, n)</li>
<li>write(fd, buf, n)</li>
<li><code>dup</code> system call duplicates an existing file descriptor, returning a new one that refers to the same underlying I&#x2F;O object.</li>
<li>File descriptors are a powerful abstraction, because they hide the details of what they are connected to</li>
</ul>
</li>
<li><p>1.3 Pipes</p>
<ul>
<li>A pipe is a small kernel buffer exposed to processes as a pair of file descriptors, one for reading and one for writing.</li>
<li>命令行pipe实例： grep fork sh.c | wc -l 程序会分别为两个程序创建一个子进程，并递归地运行命令（可能会出现多管道的现象， a | b | c）</li>
<li>与重定向的优势<ul>
<li>会自动清理（重定向需要小心清理临时文件）</li>
<li>能传入任意长的数据流（重定向需要足够的disk空间存储所有的数据）</li>
<li>能够并行执行（重定向只能串行）</li>
</ul>
</li>
</ul>
</li>
<li><p>1.4 File system</p>
<ul>
<li><code>chdir</code>: change current directory</li>
<li><code>mkdir</code> creates a new directory, <code>open</code> with the <code>O_CREATE</code> flag creates a new data file, and <code>mknod</code> creates a new device file</li>
<li>The <code>link</code> system call creates another file system name referring to the same inode as an existing file.</li>
<li>The <code>fstat</code> system call retrieves information from the inode that a file descriptor refers to. It fills in a <code>struct stat</code>, defined in <code>stat.h</code><ul>
<li>Each inode is identified by a unique <code>inode number</code>.</li>
<li>The file’s inode and the disk space holding its content are only freed when the file’s link count is zero and no file descriptors refer to it(using <code>unlink</code>)</li>
</ul>
</li>
<li>sum-up： 文件目录变换，文件的结构和信息，文件的创建和关闭，Unix中运行文件相关命令的方法</li>
</ul>
</li>
</ul>
<h3 id="Chapter-2-Operating-system-organization"><a href="#Chapter-2-Operating-system-organization" class="headerlink" title="Chapter 2: Operating system organization"></a>Chapter 2: Operating system organization</h3><ul>
<li><p>Thus an operating system must fulfill three requirements: multiplexing, isolation, and interaction.</p>
</li>
<li><p>2.1 Abstracting physical resources</p>
<ul>
<li>通过函数结构访问disk的优势（让OS管理内存）</li>
</ul>
</li>
<li><p>2.2 User mode, supervisor mode, and system calls</p>
<ul>
<li>Machine mode<ul>
<li>have full privilege; a CPU starts in machine mode. Machine mode is mostly intended for configuring a computer.</li>
</ul>
</li>
<li>Supervisor mode(Kernel space)<ul>
<li>the CPU is allowed to execute privileged instructions<ul>
<li>If running privileged instructions in user mode, CPU wouldn’t execute it, but switch to the supervisor mode to terminate it</li>
</ul>
</li>
<li>the kernel control the entry point for transitions to supervisor mode</li>
</ul>
</li>
<li>User mode(User space)</li>
<li>实现程序之间隔离的方法</li>
</ul>
</li>
<li><p>2.3 Kernel organization</p>
<ul>
<li><p>monolithic kernel</p>
<ul>
<li>The <strong>entire operating system resides in the kernel</strong>, so that the implementations of all system calls run in supervisor mode</li>
<li><code>Pros</code>: Easy to cooperate, doesn’t have to decide which part of the operating system doesn’t need full hardware privileg</li>
<li><code>Cons</code>: 1. the interfaces between different parts of the operating system are often complex 2. a mistake is fatal, because an error in supervisor mode will often cause the kernel to fail</li>
</ul>
</li>
<li><p>microkernel</p>
<ul>
<li>minimize the amount of operating system code that runs in supervisor mode</li>
<li><img src="/.com//microkernel.png" alt="img"></li>
<li>the kernel provides an <code>inter-process communication mechanism</code> to send messages from one user-mode process to another</li>
<li>OS services running as processes are called servers.<ul>
<li>it sends a message to the file server and waits for a response.</li>
</ul>
</li>
</ul>
</li>
<li><p>sum-up： 两种不同的内核设计方式</p>
</li>
</ul>
</li>
<li><p>2.5 Process overview</p>
<ul>
<li>The unit of isolation is a process.</li>
<li>The mechanisms used by the kernel to implement processes include the user&#x2F;supervisor mode flag, address spaces, and time-slicing of threads</li>
<li>Xv6 maintains a separate page table for each process that defines that process’s address space<ul>
<li><p><img src="/.com//virtual%20address%20space.png" alt="img"></p>
<ul>
<li>the trampoline page contains the code to transition in and out of the kernel</li>
<li>mapping the trapframe is necessary to save&#x2F;restore the state of the user process</li>
</ul>
</li>
<li><p>The xv6 kernel maintains many pieces of state for each process, which it gathers into a <code>struct proc</code></p>
<ul>
<li>most important pieces of kernel state are its page table, its kernel stack, and its run state.</li>
</ul>
</li>
<li><p>Context switch between user space and kernel space</p>
<ul>
<li>To switch transparently between processes, the kernel suspends the currently running thread and resumes another process’s thread.</li>
<li>Each process has two stacks: a user stack and a kernel stack (<code>p-&gt;kstack</code>)<ul>
<li>the kernel can execute even if a process has wrecked its user stack.</li>
</ul>
</li>
<li><code>ecall</code>: change to kernel space; <code>sret</code>: to user space</li>
</ul>
</li>
</ul>
</li>
<li>Sum-up<ul>
<li>an address space to give a process the illusion of its own memory, and, a thread, to give the process the illusion of its own CPU</li>
<li>如何利用进程实现隔离性的以及进程的工作方式</li>
</ul>
</li>
</ul>
</li>
<li><p>2.7 Security Model</p>
<ul>
<li>Safeguards<ul>
<li>Assertions, type checking, stack guard pages, etc.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Chapter-3-Page-tables"><a href="#Chapter-3-Page-tables" class="headerlink" title="Chapter 3: Page tables"></a>Chapter 3: Page tables</h3><ul>
<li><p>provides each process with its own private address space and memory</p>
</li>
<li><p>Xv6 performs a few tricks: mapping the same memory (a trampoline page) in several address spaces, and guarding kernel and user stacks with an unmapped page.</p>
</li>
<li><p>3.1 Paging hardware</p>
<ul>
<li><p>The structure of page table</p>
<ul>
<li><img src="/.com//pageTable.png" alt="img"></li>
</ul>
</li>
<li><p>Address translation</p>
<ul>
<li>A page table is stored in physical memory as a three-level tree. (first nine bits is used for indexing PPN of each <code>page directory</code>. and etc.)</li>
<li>If page is not found, raise <code>page-fault exception</code></li>
<li>In the common case in which large ranges of virtual addresses have no mappings, the three-level structure can omit entire page directories.(Allocate pages when they are needed)</li>
<li>flag bits that tell the paging hardware how the associated virtual address is allowed to be used<ul>
<li><strong>每个PTE都包含标志位，说明虚拟地址的使用权限。</strong><ul>
<li><code>PTE_V</code>表示 PTE 是否存在于页表中：如果未设置，那么一个对该页的引用会引发错误(也就是：不允许被使用（ <strong>validity</strong> ）)。</li>
<li><code>PTE_W</code>控制着能否对页执行写操作；</li>
<li><code>PTE_R</code> 控制是否允许使用指令读取页。</li>
<li><code>PTE_X</code>控制CPU是否可以将页面内容解释为指令并执行它们。</li>
<li><code>PTE_U</code>控制着用户程序能否使用该页；如果不能，则只有内核能够使用该页。</li>
</ul>
</li>
</ul>
</li>
<li><code>satp</code>: the physical address of the root pagetable page<ul>
<li>each CPU has its own <code>satp</code>(different CPUs can run different processes)</li>
</ul>
</li>
<li></li>
<li><img src="/.com//address%20translation.png" alt="img"></li>
</ul>
</li>
<li><p>Translation Look-aside Buffer (TLB)</p>
<ul>
<li>Motivation: To avoid the cost of loading PTEs from physical memory<ul>
<li>a potential downside of three levels is that the CPU must load three PTEs from memory to perform the translation of the virtual address in the load&#x2F;store instruction to a physical address.</li>
</ul>
</li>
<li>when xv6 changes a page table, it must tell the CPU to invalidate corresponding cached TLB entries.</li>
</ul>
</li>
</ul>
</li>
<li><p>3.2 Kernel address space</p>
<ul>
<li>Xv6 maintains one page table per process, describing each process’s user address space, plus a single page table that describes the kernel’s address space</li>
<li>The kernel gets at RAM and memory-mapped device registers using “direct mapping;<ul>
<li>Direct mapping simplifies kernel code that reads or writes physical memory.</li>
</ul>
</li>
<li>The guard page’s PTE is invalid (i.e.,PTE_V is not set), so that if the kernel overflows a kernel stack, it will likely cause an exception</li>
<li><img src="/.com//kernel%20address%20space.png" alt="img"></li>
</ul>
</li>
<li><p>3.4 Physical memory allocation</p>
<ul>
<li>The kernel must allocate and free physical memory at run-time for page tables, user memory, kernel stacks, and pipe buffers.</li>
<li>Allocation consists of removing a page from the linked list; freeing consists of adding the freed page to the list.</li>
</ul>
</li>
<li><p>3.6 Process address space</p>
<ul>
<li><img src="/.com//user%20addr%20space.png" alt="img"></li>
<li>A process’s user memory starts at virtual address zero and can grow up to <code>MAXVA</code>(The max bits the address can take)</li>
<li>Xv6 maps the data, stack, and heap with the permissions <code>PTE_R</code>, <code>PTE_W</code>, and <code>PTE_U</code>.<ul>
<li>Avoid the program modifies the unexpected regions.(the hardware will refuse to execute the store and raises a page fault)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="Lecture-Note"><a href="#Lecture-Note" class="headerlink" title="Lecture Note"></a>Lecture Note</h5><ul>
<li>Address space<ul>
<li>pagetable<ul>
<li>implemented in hardware by the processor or by unit called MMU</li>
<li>CPU–VA–&gt;MMU—PA—&gt;Memory<ul>
<li><code>satp</code>: In CPU, this register is used to specify where the map is(VA-&gt;PA). Each one process has unique address for the map(This is writen by the kernel for isolation)</li>
<li>MMU: 读取内存并转换，不保存映射</li>
</ul>
</li>
<li>The max bits of the virtual address is determined by the number of the registers</li>
</ul>
</li>
</ul>
</li>
<li>paging hardware(RISC-V)</li>
<li>xv6 virtual memory code and layout of the kernel address spaces and user address spaces</li>
<li>多级页表中存储PPN是44位的，末尾加上12个0，得到56位物理地址，这就是下一级页表的物理地址<ul>
<li>多次访问耗费时间，所以使用TLB（快表）[VA, PA] mapping</li>
</ul>
</li>
<li>MMU —hardware</li>
</ul>
<h3 id="Chapter-4-Traps-and-system-calls"><a href="#Chapter-4-Traps-and-system-calls" class="headerlink" title="Chapter 4 Traps and system calls"></a>Chapter 4 Traps and system calls</h3><ul>
<li><p>CPU Interrupt</p>
<ul>
<li><p>Cases</p>
<ul>
<li>system call</li>
<li>exception</li>
<li>device interrupt<ul>
<li>While commonality among the three trap types suggests that a kernel could handle all traps with a single code path, it turns out to be convenient to have separate code for three distinct cases: traps from user space, traps from kernel space, and timer interrupts.</li>
</ul>
</li>
</ul>
</li>
<li><p>The usual sequence</p>
<ul>
<li>a trap forces a transfer of control into the kernel</li>
<li>the kernel saves registers and other state</li>
<li>the kernel restores the saved state and returns from the trap</li>
<li>original code resumes where it left off</li>
</ul>
</li>
<li><p>For what</p>
<ul>
<li>isolation demands that only the kernel be allowed to use devices</li>
<li>the kernel is a convenient mechanism with which to share devices among multiple processes</li>
</ul>
</li>
</ul>
</li>
<li><p>4.1 RISC-V trap machinery</p>
<ul>
<li>Each RISC-V CPU has a set of control registers that the kernel writes to tell the CPU how to handle traps, and that the kernel can read to find out about a trap that has occurred.</li>
<li>sum-up: CPU用专用的寄存器完成上下文转换。但为了trap的效率CPU并不会将所有任务都完成，剩余的工作需要由内核软件完成</li>
</ul>
</li>
<li><p>4.2 Traps from user space</p>
<ul>
<li>Occur if the user program makes a system call (<code>ecall</code> instruction), or does something illegal, or if a device interrupts</li>
<li>RISC-V hardware does not switch page tables when it forces a trap<ul>
<li>Things need to do<ul>
<li>trap handling code needs to switch to the kernel page table</li>
<li>the kernel page table must also have a mapping for the handler pointed to by stvec</li>
</ul>
</li>
<li>Trampoline page<ul>
<li><blockquote>
<p>Trampoline page <strong>stores code to switch between user and kernel space</strong>. The code is mapped at the same virtual address (TRAMPOLINE) in user and kernel space so that it continues to work when it switches page tables.</p>
</blockquote>
</li>
</ul>
</li>
<li><code>TRAPFRAME</code><ul>
<li>address of <code>TRAPFRAME</code> is stored in <code>sscratch</code> register. Saves all the user registers there, including the user’s a0, read back from sscratch.</li>
<li><code>TRAPFRAME</code> also contain the kernel information and the address of <code>usertrap</code> function.<ul>
<li><code>usertrap</code>: The job of <code>usertrap</code> is to determine the cause of the trap, process it, and return</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Pointer as argument on system call<ul>
<li>Problems<ul>
<li>Invalid pointer</li>
<li>kernel page table mappings are not the same as the user page table mappings so the kernel cannot use ordinary instructions to load or store from user-supplied addresses.</li>
</ul>
</li>
<li>Find PA by using user space page table and map it to the VA in the kernel space.</li>
</ul>
</li>
<li>sum-up: 在用户空间中调用trap。</li>
</ul>
</li>
<li><p>4.5 Traps from kernel space</p>
</li>
<li><p>4.6 Page-fault exceptions</p>
<ul>
<li><p>Actions</p>
<ul>
<li>In user space: kill the faulting process</li>
<li>In kernel space: kernel panics<ul>
<li><blockquote>
<p><strong>内核错误 (Kernel panic</strong> )是指操作系统在监测到内部的致命错误，并无法安全处理此错误时采取的动作。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>three kinds of page fault</p>
<ul>
<li>load page faults (when a load instruction cannot translate its virtual address)</li>
<li>store page faults (when a store instruction cannot translate its virtual address)</li>
<li>instruction page faults (when the address in the program counter doesn’t translate)</li>
</ul>
</li>
<li><p>The applications of page-fault exception</p>
<ul>
<li><p>copy-on-write fork</p>
<ul>
<li>Procedure<ul>
<li>the parent and child to initially share all physical pages, but for each to map them read-only</li>
<li>Write to that memory will raise a page-fault exception</li>
<li>The kernel’s trap handler responds by allocating a new page of physical memory and<br>copying into it the physical page that the faulted address maps to.</li>
</ul>
</li>
</ul>
</li>
<li><p>Lazy allocation</p>
<ul>
<li>Procedure<ul>
<li>application asks for more memory by calling <code>sbrk</code></li>
<li>The kernel notes the increase in size, but does not allocate memory or create PTEs</li>
<li>When page-fault occurs in those address, the kernel allocates a page of physical memory and maps it into the page table</li>
</ul>
</li>
<li>Since applications often ask for more memory than they need</li>
<li>Problem<ul>
<li>The extra overhead introduced by kernel&#x2F;user transition<ul>
<li>reduce this cost by allocating a batch of consecutive pages per page fault instead of one page</li>
<li>specializing the kernel entry&#x2F;exit code for such page-faults.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>demand paging(需求分页)</p>
<ul>
<li><p>Problem</p>
<ul>
<li>Since applications can be large and reading from disk is expensive, this startup cost may be noticeable to users</li>
</ul>
</li>
<li><p>Solution</p>
<ul>
<li>a modern kernel creates the page table for the user address space, but marks the PTEs for the pages invalid</li>
<li>On a page fault, the kernel reads the content of the page from disk and maps it into the user address space</li>
</ul>
</li>
</ul>
</li>
<li><p>paging to disk</p>
<ul>
<li><p>Problem</p>
<ul>
<li>The programs running on a computer may need more memory than the computer has RAM</li>
</ul>
</li>
<li><p>Solution</p>
<ul>
<li>to store only a fraction of user pages in RAM, and to store the rest on disk in a paging area.</li>
<li>The memory stored in the paging area is set as invalid.</li>
<li>Access paging area will incur a page fault. The kernel trap handler will allocate a page of physical RAM, read the page from disk into the RAM, and modify the relevant PTE to point to the RAM</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Chapter5-Interrupts-and-device-drivers"><a href="#Chapter5-Interrupts-and-device-drivers" class="headerlink" title="Chapter5 Interrupts and device drivers"></a>Chapter5 Interrupts and device drivers</h3><ul>
<li>A driver is the code in an operating system that<ul>
<li>manages a particular device: it configures the device hardware tells the device to perform operations</li>
<li>handles the resulting interrupts</li>
<li>interacts withprocesses that may be waiting for I&#x2F;O from the device.</li>
</ul>
</li>
<li>device drivers execute code in two contexts<ul>
<li>top half that runs in a process’s kernel thread<ul>
<li>ask the hardware to start an operation</li>
<li>wait for the operation complete</li>
<li>raise an interrupt when the code is completed</li>
</ul>
</li>
<li>a bottom half that executes at interrupt time.<ul>
<li>what operation has completed, wakes up a waiting process if appropriate</li>
<li>tells the hardware to start work on any waiting next operation</li>
</ul>
</li>
</ul>
</li>
<li>A general pattern to note is the decoupling of device activity from process activity via buffering<br>and interrupts. (This idea is sometimes called <code>I/O concurrency</code>.)<ul>
<li>This decoupling can increase performance by allowing processes to execute concurrently with device I&#x2F;O</li>
</ul>
</li>
<li>驱动程序完全禁用中断，并定期检查设备是否需要注意。这种技术被称为轮询（polling）<ul>
<li>如果设备执行操作非常快，轮询是有意义的，但是如果设备大部分空闲，轮询会浪费CPU时间。一些驱动程序根据当前设备负载在轮询和中断之间动态切换。</li>
</ul>
</li>
<li>程序I&#x2F;O很简单，但速度太慢，无法在高数据速率下使用。需要高速移动大量数据的设备通常使用直接内存访问（DMA）<ul>
<li>DMA设备硬件直接将传入数据写入内存，并从内存中读取传出数据。</li>
<li>一些操作系统能够直接在用户空间缓冲区和设备硬件之间移动数据，通常带有DMA。</li>
</ul>
</li>
</ul>
<h3 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h3><ul>
<li><p>锁的缺点是它们会扼杀性能，因为它们会串行化并发操作</p>
</li>
<li><p>竞态条件是指多个进程读写某些共享数据（至少有一个访问是写入）的情况</p>
<ul>
<li>在内存池中，两个进程并行地释放内存，那么可能会导致释放的内存被放到同一个地址中，从而变成了覆盖</li>
<li><code>acquire</code>和 <code>release</code>之间的指令序列通常被称为临界区域（critical section）。（加锁的区域）</li>
<li>代码在执行的时候，依托一些 <code>不变量</code>(相当于一些条件)，但是其他进程对这个变量的操作暂时改变了这种不变量，所以导致代码运行错误。（上面就是链表头部指针有一个时间段中不是指向链表头部的，这时候其他进程的操作就可能导致竞态）</li>
<li>以将锁视为串行化（serializing）并发的临界区域，以便同时只有一个进程在运行这部分代码，从而维护不变量（假设临界区域设定了正确的隔离性）</li>
</ul>
</li>
<li><p>冲突</p>
<ul>
<li>如果多个进程同时想要相同的锁或者锁经历了争用，则称之为发生冲突（conflict）</li>
</ul>
</li>
<li><p>要使用多少锁，以及每个锁应该保护哪些数据和不变量</p>
<ul>
<li>任何时候可以被一个CPU写入，同时又可以被另一个CPU读写的变量，都应该使用锁来防止两个操作重叠</li>
<li>锁保护不变量（invariants）：如果一个不变量涉及多个内存位置，通常所有这些位置都需要由一个锁来保护，以确保不变量不被改变。</li>
<li>大内核锁（big kernel lock）<ul>
<li>如果并行性不重要，那么可以安排只拥有一个线程，而不用担心锁。一个简单的内核可以在多处理器上做到这一点，方法是拥有一个锁，这个锁必须在进入内核时获得，并在退出内核时释放</li>
</ul>
</li>
</ul>
</li>
<li><p>死锁和锁排序</p>
<ul>
<li>如果在内核中执行的代码路径必须同时持有数个锁，那么所有代码路径以相同的顺序获取这些锁是很重要的（否则有死锁的风险）</li>
<li>全局锁获取顺序的需求意味着锁实际上是每个函数规范的一部分：调用者必须以一种使锁按照约定顺序被获取的方式调用函数。</li>
</ul>
</li>
<li><p>锁和中断处理函数</p>
<ul>
<li>一个进程中持有一个变量，在执行过程中出现了中断，而中断处理函数可能又会需要访问这个变量，这时候处理函数就会等待这个变量被释放，这时候就产生了死锁<ul>
<li>如果一个自旋锁被中断处理程序所使用，那么CPU必须保证在启用中断的情况下永远不能持有该锁。</li>
</ul>
</li>
</ul>
</li>
<li><p>Re-entrant locks</p>
<ul>
<li>It might appear that some deadlocks and lock-ordering challenges could be avoided by using re-entrant locks, which are also called recursive locks.<ul>
<li>if the lock is held by a process and if that process attempts to acquire the lock again, then the kernel could just allow this</li>
</ul>
</li>
</ul>
</li>
<li><p>指令和内存访问顺序</p>
<ul>
<li>规则确实允许重新排序后改变并发代码的结果，并且很容易导致多处理器上的不正确行为。CPU的排序规则称为内存模型（memory model）。</li>
<li><code>__sync_synchronize()</code>是一个内存障碍：它告诉编译器和CPU不要跨障碍重新排序 <code>load</code>或 <code>store</code>指令。</li>
</ul>
</li>
<li><p>睡眠锁</p>
<ul>
<li>因为等待会浪费CPU时间，所以自旋锁最适合短的临界区域；睡眠锁对于冗长的操作效果很好。</li>
</ul>
</li>
</ul>
<h3 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h3><ul>
<li><p>任何操作系统都可能运行比CPU数量更多的进程，所以需要一个进程间分时共享CPU的方案</p>
<ul>
<li>通过将进程多路复用到硬件CPU上，使每个进程产生一种错觉，即它有自己的虚拟CPU</li>
</ul>
</li>
<li><p>多路复用</p>
<ul>
<li>情景<ul>
<li>进程等待设备或管道I&#x2F;O完成，或等待子进程退出，或在 <code>sleep</code>系统调用中等待时，xv6使用睡眠（sleep）和唤醒（wakeup）机制切换</li>
<li>xv6周期性地强制切换以处理长时间计算而不睡眠的进程。</li>
</ul>
</li>
</ul>
</li>
<li><p>协程</p>
<ul>
<li>在两个线程之间进行这种样式化切换的过程有时被称为协程（coroutines）<ul>
<li>协程运行在线程之上，当一个协程执行完成后，可以选择主动让出，让另一个协程运行在当前线程之上。 <strong>协程并没有增加线程数量，只是在线程的基础之上通过分时复用的方式运行多个协程</strong> ，而且协程的切换在用户态完成，切换的代价比线程从用户态到内核态的代价小很多。</li>
<li><img src="https://pic3.zhimg.com/80/v2-f4fb2dea86d909ed60498b7021d0fe66_720w.webp" alt="img"></li>
<li>每个线程中运行多个协程</li>
<li><strong>协程只有和异步IO结合起来才能发挥出最大的威力。</strong><ul>
<li>假设协程运行在线程之上，并且协程调用了一个阻塞IO操作，这时候会发生什么？实际上操作系统并不知道协程的存在，它只知道线程，<strong>因此在协程调用阻塞IO操作的时候，操作系统会让线程进入阻塞状态，当前的协程和其它绑定在该线程之上的协程都会陷入阻塞而得不到调度，这往往是不能接受的。</strong></li>
</ul>
</li>
</ul>
</li>
<li>sleep 和 wakeup<ul>
<li>Xv6使用了一种称为 <code>sleep</code>和 <code>wakeup</code>的方法，它允许一个进程在等待事件时休眠，而另一个进程在事件发生后将其唤醒。睡眠和唤醒通常被称为序列协调（sequence coordination）或条件同步机制（conditional synchronization mechanisms）。<ul>
<li><code>Sleep(chan)</code>在任意值 <code>chan</code>上睡眠，称为等待通道（wait channel）。 释放CPU用于其他任务</li>
<li><code>Wakeup(chan)</code>唤醒所有在 <code>chan</code>上睡眠的进程（如果有），使其 <code>sleep</code>调用返回。</li>
<li>为了防止死锁，使用 <code>条件锁</code>，让进程在睡眠之后释放锁<ul>
<li><code>条件锁</code>就是所谓的条件变量，某一个线程因为某个条件为满足时可以使用条件变量使该程序处于阻塞状态。一旦条件满足以“信号量”的方式唤醒一个因为该条件而被阻塞的线程。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><ul>
<li>文件系统的目的是组织和存储数据</li>
<li>解决的问题<ul>
<li>文件系统需要磁盘上的数据结构来表示目录和文件名称树，记录保存每个文件内容的块的标识，以及记录磁盘的哪些区域是空闲的。</li>
<li>文件系统必须支持崩溃恢复（crash recovery）。</li>
<li>文件系统代码必须协调以保持不变量（不同的进程可能在相同的文件系统上运行）</li>
<li>文件系统必须保持常用块的内存缓存（访问磁盘慢）</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>文件描述符（File descriptor）</th>
</tr>
</thead>
<tbody><tr>
<td>路径名（Pathname）</td>
</tr>
<tr>
<td>目录（Directory）</td>
</tr>
<tr>
<td>索引结点（Inode）</td>
</tr>
<tr>
<td>日志（Logging）</td>
</tr>
<tr>
<td>缓冲区高速缓存（Buffer cache）</td>
</tr>
<tr>
<td>磁盘（Disk)</td>
</tr>
</tbody></table>
<p><img src="/.com//Structure%20of%20file%20system.png"></p>
<ul>
<li>日志<ul>
<li>日志驻留在超级块中指定的未知。</li>
<li>事务中途奔溃将导致日志头块中的计数为0，提交后奔溃将导致非零计数</li>
</ul>
</li>
</ul>
<h1 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h1><h2 id="Lecture-3-OS-design"><a href="#Lecture-3-OS-design" class="headerlink" title="Lecture 3: OS design"></a>Lecture 3: OS design</h2><ul>
<li><p>Lecture Topic:</p>
<ul>
<li>OS design<ul>
<li>system calls</li>
<li>micro&#x2F;monolithic kernel</li>
</ul>
</li>
<li>First system call in xv6</li>
</ul>
</li>
<li><p>OS picture</p>
<ul>
<li>apps: sh, echo, …</li>
<li>system call interface (open, close,…)<br>OS</li>
</ul>
</li>
<li><p>Goal of OS</p>
<ul>
<li>run multiple applications</li>
<li>isolate them</li>
<li>multiplex them</li>
<li>share</li>
</ul>
</li>
<li><p>Strawman design: No OS</p>
<ul>
<li>Application directly interacts with hardware<ul>
<li>CPU cores &amp; registers</li>
<li>DRAM chips</li>
<li>Disk blocks</li>
<li>…</li>
</ul>
</li>
<li>OS library perhaps abstracts some of it</li>
</ul>
</li>
<li><p>Strawman design not conducive to multiplexing</p>
<ul>
<li>each app periodically must give up hardware</li>
<li>BUT, weak isolation<ul>
<li>app forgets to give up, no other app runs</li>
<li>apps has end-less loop, no other app runs</li>
<li>you cannot even kill the badly app from another app</li>
</ul>
</li>
<li>but used by real-time OSes<ul>
<li>“cooperative scheduling”</li>
</ul>
</li>
</ul>
</li>
<li><p>Strawman design not conducive to memory isolation</p>
<ul>
<li>all apps share physical memory</li>
<li>one app can overwrites another apps memory</li>
<li>one app can overwrite OS library</li>
</ul>
</li>
<li><p>Unix interface conducive to OS goals</p>
<ul>
<li>abstracts the hardware in way that achieves goals</li>
<li>processes (instead of cores): fork<ul>
<li>OS transparently allocates cores to processes<ul>
<li>Saves and restore registers</li>
</ul>
</li>
<li>Enforces that processes give them up<ul>
<li>Periodically re-allocates cores</li>
</ul>
</li>
</ul>
</li>
<li>memory (instead of physical memory): exec<ul>
<li>Each process has its “own” memory</li>
<li>OS can decide where to place app in memory</li>
<li>OS can enforce isolation between memory of different apps</li>
<li>OS allows storing image in file system</li>
</ul>
</li>
<li>files (instead of disk blocks)<ul>
<li>OS can provide convenient names</li>
<li>OS can allow sharing of files between processes&#x2F;users</li>
</ul>
</li>
<li>pipes (instead of shared physical mem)<ul>
<li>OS can stop sender&#x2F;receiver</li>
</ul>
</li>
</ul>
</li>
<li><p>OS must be defensive</p>
<ul>
<li>an application shouldn’t be able to crash OS</li>
<li>an application shouldn’t be able to break out of its isolation</li>
<li>&#x3D;&gt; need strong isolation between apps and OS</li>
<li>approach: hardware support</li>
</ul>
</li>
<li><p>user&#x2F;kernel mode</p>
</li>
<li><p>virtual memory</p>
</li>
<li><p>Processors provide user&#x2F;kernel mode</p>
<ul>
<li>kernel mode: can execute “privileged” instructions<ul>
<li>e.g., setting kernel&#x2F;user bit</li>
<li>e.g., reprogramming timer chip</li>
</ul>
</li>
<li>user mode: cannot execute privileged instructions</li>
<li>Run OS in kernel mode, applications in user mode</li>
<li>[RISC-V has also an M mode, which we mostly ignore]</li>
</ul>
</li>
<li><p>Processors provide virtual memory</p>
<ul>
<li>Hardware provides page tables that translate virtual address to physical</li>
<li>Define what physical memory an application can access</li>
<li>OS sets up page tables so that each application can access only its memory</li>
</ul>
</li>
<li><p>Apps must be able to communicate with kernel</p>
<ul>
<li>Write to storage device, which is shared &#x3D;&gt; must be protected &#x3D;&gt; in kernel</li>
<li>Exit app</li>
<li>…</li>
</ul>
</li>
<li><p>Solution: add instruction to change mode in controlled way</p>
<ul>
<li>ecall <code>&lt;n&gt;</code></li>
<li>enters kernel mode at a pre-agreed entry point</li>
</ul>
</li>
<li><p>Modify OS picture</p>
<ul>
<li>user &#x2F; kernel (redline)</li>
<li>app -&gt; printf() -&gt; write() -&gt; SYSTEM CALL -&gt; sys_write() -&gt; …<br>user-level libraries are app’s private business</li>
<li>kernel internal functions are not callable by user</li>
<li>other way of drawing picture:</li>
<li>syscall 1  -&gt; system call stub -&gt; kernel entry -&gt; syscall -&gt; fs</li>
<li>syscall 2                                                 -&gt; proc</li>
<li>system call stub executes special instruction to enter kernel<br>hardware switches to kernel mode<br>but only at an entry point specified by the kernel</li>
<li>syscall need some way to get at arguments of syscall</li>
<li>[syscalls the topic of this week’s lab]</li>
</ul>
</li>
<li><p>Kernel is the Trusted Computing Base (TCB)</p>
<ul>
<li>Kernel must be “correct”<ul>
<li>Bugs in kernel could allow user apps to circumvent kernel&#x2F;user<br>Happens often in practice, because kernels are complex<br>See CVEs</li>
</ul>
</li>
<li>Kernel must treat user apps as suspect<br>User app may trick kernel to do the wrong thing<br>Kernel must check arguments carefully<br>Setup user&#x2F;kernel correctly<br>Etc.</li>
<li>Kernel in charge of separating applications too<br>One app may try to read&#x2F;write another app’s memory<br>&#x3D;&gt; Requires a security mindset<br>Any bug in kernel may be a security exploit</li>
</ul>
</li>
<li><p>Aside: can one have process isolation WITHOUT h&#x2F;w-supported<br>kernel&#x2F;user mode and virtual memory?</p>
<ul>
<li>yes! use a strongly-typed programming language</li>
</ul>
</li>
<li><p>For example, see Singularity O&#x2F;S<br>the compiler is then the trust computing base (TCB)<br>but h&#x2F;w user&#x2F;kernel mode is the most popular plan</p>
</li>
<li><p>Monolothic kernel<br>OS runs in kernel space<br>Xv6 does this.  Linux etc. too.<br>kernel interface &#x3D;&#x3D; system call interface<br>one big program with file system, drivers, &amp;c</p>
</li>
<li><p>good: easy for subsystems to cooperate<br>one cache shared by file system and virtual memory</p>
</li>
<li><p>bad: interactions are complex<br>leads to bugs<br>no isolation within</p>
</li>
<li><p>Microkernel design</p>
<ul>
<li>many OS services run as ordinary user programs<ul>
<li>file system in a file server</li>
</ul>
</li>
<li>kernel implements minimal mechanism to run services in user space<ul>
<li>processes with memory</li>
<li>inter-process communication (IPC)</li>
</ul>
</li>
<li>kernel interface !&#x3D; system call interface</li>
</ul>
</li>
<li><p>good: more isolation</p>
</li>
<li><p>bad: may be hard to get good performance<br>both monolithic and microkernel designs widely used</p>
</li>
<li><p>Xv6 case study</p>
<ul>
<li>Monolithic kernel<ul>
<li>Unix system calls &#x3D;&#x3D; kernel interface</li>
</ul>
</li>
<li>Source code reflects OS organization (by convention)<ul>
<li>user&#x2F;    apps in user mode</li>
<li>kernel&#x2F;  code in kernel mode</li>
</ul>
</li>
<li>Kernel has several parts<ul>
<li>kernel&#x2F;defs.h<ul>
<li>proc</li>
<li>fs<br>..</li>
</ul>
</li>
</ul>
</li>
<li>Goal: read source code and understand it (without consulting book)</li>
</ul>
</li>
<li><p>The RISC-V computer</p>
<ul>
<li>A very simple board (e.g., no display)</li>
</ul>
</li>
<li><p>RISC-V processor with 4 cores</p>
</li>
<li><p>RAM (128 MB)</p>
</li>
<li><p>support for interrupts (PLIC, CLINT)</p>
</li>
<li><p>support for UART<br>allows xv6 to talk to console<br>allows xv6 to read from keyboard</p>
</li>
<li><p>support for e1000 network card (through PCIe)<br>Qemu emulates several RISC-V computers</p>
</li>
<li><p>we use the “virt” one<br><a target="_blank" rel="noopener" href="https://github.com/riscv/riscv-qemu/wiki">https://github.com/riscv/riscv-qemu/wiki</a></p>
</li>
<li><p>close to the SiFive board (<a target="_blank" rel="noopener" href="https://www.sifive.com/boards">https://www.sifive.com/boards</a>)<br>but with virtio for disk</p>
</li>
<li><p>Boot xv6 (under gdb)</p>
<ul>
<li>$ make CPUS&#x3D;1 qemu-gdb<ul>
<li>runs xv6 under gdb (with 1 core)</li>
</ul>
</li>
<li>Qemu starts xv6 in kernel&#x2F;entry.S (see kernel&#x2F;kernel.ld)<ul>
<li>set breakpoint at _entry<ul>
<li>look at instruction</li>
<li>info reg</li>
</ul>
</li>
<li>set breakpoint at main<ul>
<li>Walk through main<br>single step into userinit<br>Walk through userinit<br>show kalloc<br>show proc.h<br>show allocproc()<br>show initcode.S&#x2F;initcode.asm<br>break forkret()<br>walk to userret<br>break syscall<br>print num<br>syscalls[num]<br>exec “&#x2F;init”<br>points to be made:<br>page table in userinit<br>ecall: U -&gt; K<br>a7: syscall #<br>exec: defensive</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>kernel</p>
<p>$$<br>\text{proc.c} \stackrel{\text{gcc}}{\rightarrow} \text{proc.s} \stackrel{\text{assembler}}{\rightarrow} \text{proc.o} \rightarrow\text{link different .o file together}<br>$$</p>
</li>
</ul>
<h2 id="6-S081-2020-Lecture-4-Virtual-Memory"><a href="#6-S081-2020-Lecture-4-Virtual-Memory" class="headerlink" title="6.S081 2020 Lecture 4: Virtual Memory"></a>6.S081 2020 Lecture 4: Virtual Memory</h2><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>
<ul>
<li>plan:<br>address spaces<br>paging hardware<br>xv6 VM code</li>
</ul>
<h3 id="Virtual-memory-overview"><a href="#Virtual-memory-overview" class="headerlink" title="Virtual memory overview"></a>Virtual memory overview</h3><ul>
<li><p>today’s problem:<br>[user&#x2F;kernel diagram]<br>[memory view: diagram with user processes and kernel in memory]<br>suppose the shell has a bug:<br>sometimes it writes to a random memory address<br>how can we keep it from wrecking the kernel?<br>and from wrecking other processes?</p>
</li>
<li><p>we want isolated address spaces<br>each process has its own memory<br>it can read and write its own memory<br>it cannot read or write anything else<br>challenge:<br>how to multiplex several memories over one physical memory?<br>while maintaining isolation between memories</p>
</li>
<li><p>xv6 uses RISC-V’s paging hardware to implement AS’s<br>ask questions! this material is important<br>topic of next lab (and shows up in several other labs)</p>
</li>
<li><p>paging provides a level of indirection for addressing<br>CPU -&gt; MMU -&gt; RAM<br>VA     PA</p>
<p>$$<br>\text{CPU}\stackrel{\text{VA}}{\rightarrow}MMU\stackrel{\text{PA}}{\rightarrow}\text{RAM}<br>$$</p>
<p>s&#x2F;w can only ld&#x2F;st to virtual addresses, not physical<br>kernel tells MMU how to map each virtual address to a physical address<br>MMU essentially has a table, indexed by va, yielding pa<br>called a “page table”<br>one page table per address space<br>MMU can restrict what virtual addresses user code can use<br>By programming the MMU, the kernel has complete control over va-&gt;pa mapping<br>Allows for many interesting OS features&#x2F;tricks</p>
</li>
<li><p>RISC-V maps 4-KB “pages”<br>and aligned – start on 4 KB boundaries<br>4 KB &#x3D; 12 bits<br>the RISC-V used in xv6 has 64-bit for addresses<br>thus page table index is top 64-12 &#x3D; 52 bits of VA<br>except that the top 25 of the top 52 are unused<br>no RISC-V has that much memory now<br>can grow in future<br>so, index is 27 bits.</p>
</li>
<li><p>MMU translation<br>see Figure 3.1 of book<br>use index bits of VA to find a page table entry (PTE)<br>construct physical address using PPN from PTE + offset of VA</p>
</li>
<li><p>what is in PTE?<br>each PTE is 64 bits, but only 54 are used<br>top 44 bits of PTE are top bits of physical address<br>“physical page number”<br>low 10 bits of PTE flags<br>Present, Writeable, &amp;c<br>note: size virtual addresses !&#x3D; size physical addresses</p>
</li>
<li><p>where is the page table stored?<br>in RAM – MMU loads (and stores) PTEs<br>o&#x2F;s can read&#x2F;write PTEs<br>read&#x2F;write memory location corresponding to PTEs</p>
</li>
<li><p>would it be reasonable for page table to just be an array of PTEs? how big is it?<br>2^27 is roughly 134 million<br>64 bits per entry<br>134*8 MB for a full page table<br>wasting roughly 1GB per page table<br>one page table per address space<br>one address space per application<br>would waste lots of memory for small programs!<br>you only need mappings for a few hundred pages<br>so the rest of the million entries would be there but not needed</p>
</li>
<li><p>RISC-V 64 uses a “three-level page table” to save space<br>see figure 3.2 from book<br>page directory page (PD)<br>PD has 512 PTEs<br>PTEs point to another PD or is a leaf<br>so 512<em>512</em>512 PTEs in total<br>PD entries can be invalid<br>those PTE pages need not exist<br>so a page table for a small address space can be small</p>
</li>
<li><p>how does the mmu know where the page table is located in RAM?<br>satp holds phys address of top PD<br>pages can be anywhere in RAM – need not be contiguous<br>rewrite satp when switching to another address space&#x2F;application</p>
</li>
<li><p>how does RISC-V paging hardware translate a va?<br>need to find the right PTE<br>satp register points to PA of top&#x2F;L2 PD<br>top 9 bits index L2 PD to get PA of L1 PD<br>next 9 bits index L1 PD to get PA of L0 PD<br>next 9 bits index L0 PD to get PA of PTE<br>PPN from PTE + low-12 from VA</p>
</li>
<li><p>flags in PTE<br>V, R, W, X, U<br>xv6 uses all of them</p>
</li>
<li><p>what if V bit not set? or store and W bit not set?<br>“page fault”<br>forces transfer to kernel<br>trap.c in xv6 source<br>kernel can just produce error, kill process<br>in xv6: “usertrap(): unexpected scause … pid&#x3D;… sepc&#x3D;… stval&#x3D;…”<br>or kernel can install a PTE, resume the process<br>e.g. after loading the page of memory from disk</p>
</li>
<li><p>indirection allows paging h&#x2F;w to solve many problems<br>e.g. phys memory doesn’t have to be contiguous<br>avoids fragmentation<br>e.g. lazy allocation (a lab)<br>e.g. copy-on-write fork (another lab)<br>many more techniques<br>topic of next lecture</p>
</li>
<li><p>Q: why use virtual memory in kernel?<br>it is clearly good to have page tables for user processes<br>but why have a page table for the kernel?<br>could the kernel run with using only physical addresses?<br>top-level answer: yes<br>most standard kernels do use virtual addresses<br>why do standard kernels do so?<br>some reasons are lame, some are better, none are fundamental</p>
<ul>
<li>the hardware makes it difficult to turn it off<br>e.g. on entering a system call, one would have to disable VM</li>
<li>the kernel itself can benefit from virtual addresses<br>mark text pages X, but data not (helps tracking down bugs)<br>unmap a page below kernel stack (helps tracking down bugs)<br>map a page both in user and kernel (helps user&#x2F;kernel transition)</li>
</ul>
</li>
</ul>
<h3 id="Virtual-memory-in-xv6"><a href="#Virtual-memory-in-xv6" class="headerlink" title="Virtual memory in xv6"></a>Virtual memory in xv6</h3><ul>
<li>kernel page table<br>See figure 3.3 of book<br>simple maping mostly<br>map virtual to physical one-on-one<br>note double-mapping of trampoline<br>note permissions<br>why map devices?</li>
<li>each process has its own address space<br>and its own page table<br>see figure 3.4 of book<br>note: trampoline and trapframe aren’t writable by user process<br>kernel switches page tables (i.e. sets satp) when switching processes</li>
<li>Q: why this address space arrangement?<br>user virtual addresses start at zero<br>of course user va 0 maps to different pa for each process<br>16,777,216 GB for user heap to grow contiguously<br>but needn’t have contiguous phys mem – no fragmentation problem<br>both kernel and user map trampoline and trapframe page<br>eases transition user -&gt; kernel and back<br>kernel doesn’t map user applications<br>not easy for kernel to r&#x2F;w user memory<br>need translate user virtual address to kernel virtual address<br>good for isolation (see spectre attacks)<br>easy for kernel to r&#x2F;w physical memory<br>pa x mapped at va x</li>
<li>Q: does the kernel have to map all of phys mem into its virtual address space?</li>
</ul>
<h3 id="Code-walk-through"><a href="#Code-walk-through" class="headerlink" title="Code walk through"></a>Code walk through</h3><ul>
<li>setup of kernel address space<br>kvmmap()<br>Q: what is address 0x10000000 (256M)<br>Q: how much address space does 1 L2 entry cover? (1G)<br>Q: how much address space does 1 L1 entry cover? (2MB)<br>Q: how much address space does 1 L0 entry cover? (4096)<br>print kernel page table<br>Q: what is size of address space? (512G)<br>Q: how much memory is used to represent it after 1rst kvmmap()? (3 pages)<br>Q: how many entries is CLINT? (16 pages)<br>Q: how many entries is PLIC? (1024 pages, two level 1 PDs)<br>Q: how many pages is kernel text (8 pages)<br>Q: how many pages is kernel total (128M &#x3D; 64 * 2MB)<br>Q: Is trampoline mapped twice? (yes, last entry and direct-mapped, entry [2, 3, 7])<br>kvminithart();<br>Q: after executing w_satp() why will the next instruction be sfence_vma()?</li>
<li>mappages() in vm.c<br>arguments are top PD, va, size, pa, perm<br>adds mappings from a range of va’s to corresponding pa’s<br>rounds b&#x2F;c some uses pass in non-page-aligned addresses<br>for each page-aligned address in the range<br>call walkpgdir to find address of PTE<br>need the PTE’s address (not just content) b&#x2F;c we want to modify<br>put the desired pa into the PTE<br>mark PTE as valid w&#x2F; PTE_P</li>
<li>walk() in vm.c<br>mimics how the paging h&#x2F;w finds the PTE for an address<br>PX extracts the 9 bits at Level level<br>&amp;pagetable[PX(level, va)] is the address of the relevant PTE<br>if PTE_V<br>the relevant page-table page already exists<br>PTE2PA extracts the PPN from the PDE<br>if not PTE_V<br>alloc a page-table page<br>fill in pte with PPN (using PA2PTE)<br>now the PTE we want is in the page-table page</li>
<li>procinit() in proc.c<br>alloc a page for each kernel stack with a guard page</li>
<li>setup user address space<br>allocproc(): allocates empty top-level page table<br>fork(): uvmcopy()<br>exec(): replace proc’s page table with a new one<br>uvmalloc<br>loadseg<br>print user page table for sh<br>Q: what is entry 2?</li>
<li>a process calls sbrk(n) to ask for n more bytes of heap memory<br>user&#x2F;umalloc.c calls sbrk() to get memory for the allocator<br>each process has a size<br>kernel adds new memory at process’s end, increases size<br>sbrk() allocates physical memory (RAM)<br>maps it into the process’s page table<br>returns the starting address of the new memory</li>
<li>growproc() in proc.c<br>proc-&gt;sz is the process’s current size<br>uvmalloc() does most of the work<br>when switching to user space satp will be loaded with updated page table</li>
<li>uvmalloc() in vm.c<br>why PGROUNDUP?<br>arguments to mappages()…</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/29/Basic-Knoledge/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/29/Basic-Knoledge/" class="post-title-link" itemprop="url">Basic Knoledge</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-29 20:44:45" itemprop="dateCreated datePublished" datetime="2022-11-29T20:44:45+08:00">2022-11-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-01-13 20:25:06" itemprop="dateModified" datetime="2023-01-13T20:25:06+08:00">2023-01-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><ul>
<li><p>Small tricks</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取中间的数：</span></span><br><span class="line"><span class="type">int</span> mid = (left + right) / <span class="number">2</span>; <span class="comment">// 有溢出的风险</span></span><br><span class="line"><span class="type">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>); <span class="comment">// 这样更好</span></span><br></pre></td></tr></table></figure></li>
<li><p>当异常发⽣时，C++通常会调⽤对象的析构函数来释放资源</p>
</li>
<li><p>指向虚函数表的指针 <code>vptr</code>需要在构造函数中进⾏初始化</p>
</li>
<li><p>如何让类不能实例化</p>
<ul>
<li>将类定义位抽象类（包含纯虚函数）</li>
<li>将构造器声明为 <code>private</code></li>
</ul>
</li>
<li><p>虚继承</p>
<ul>
<li>在菱形继承的场景下，会产生两份基类数据，浪费空间，同时访问基类还需要通过域运算符</li>
<li>利用虚继承，在间接继承共同基类时是保留一份基类成员。创建派生类实例的时候，只需要调用一次基类的构造函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在 C 语言中，数据类型指的是用于声明不同类型的变量或函数的一个广泛的系统。变量的类型决定了变量存储占用的空间，以及如何解释存储的位模式。</p>
</li>
<li><h4 id="Linux-和-UNIX-的关系-x2F-区别"><a href="#Linux-和-UNIX-的关系-x2F-区别" class="headerlink" title="Linux 和 UNIX 的关系&#x2F;区别"></a>Linux 和 UNIX 的关系&#x2F;区别</h4><ul>
<li>Linux 是一个类似 Unix 的操作系统，Unix 要早于 Linux，Linux 的初衷就是要替代 UNIX，并在功能和用户体验上进行优化，所以 Linux 模仿了 UNIX（但并没有抄袭 UNIX 的源码），使得 Linux 在外观和交互上与 UNIX 非常类似。</li>
</ul>
</li>
<li><p>析构函数</p>
<ul>
<li>类类型：如 <code>struct</code>、<code>class</code>、<code>union</code><ul>
<li>没有自定义析构函数，那么编译器就会为它们生成内联(inline)、public 的析构函数。</li>
</ul>
</li>
<li>对于析构函数的调用，需要是 public 的访问权限，否则会导致编译错误。</li>
</ul>
</li>
</ul>
<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><p>$$<br>\text{工作区}\stackrel{add}{\rightarrow}\text{暂存区}\stackrel{commit}{\rightarrow}\text{本地仓库}\stackrel{push}{\rightarrow}\text{远程仓库}\stackrel{pull}{\rightarrow}\text{本地}<br>$$</p>
<p><img src="/.com//Basic-Knoledge/1672140678237.png" alt="1672140678237"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># In the work directory</span></span><br><span class="line">git config --global user.name <span class="string">&quot;yourName&quot;</span></span><br><span class="line">git config --global user.email yourEmail</span><br><span class="line"></span><br><span class="line">git init <span class="comment"># initialize the repository</span></span><br><span class="line">git status <span class="comment"># repository information</span></span><br><span class="line">git add fileName</span><br><span class="line">git commit -m <span class="string">&quot;commit msg&quot;</span>EADADWE</span><br><span class="line">git <span class="built_in">log</span>  <span class="comment"># 查看以前的版本</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">touch</span> .gitignore  <span class="comment"># 不追踪的文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建新分支</span></span><br><span class="line">git branch branchName</span><br><span class="line"></span><br><span class="line"><span class="comment"># 两种切换分支的命令</span></span><br><span class="line">git checkout branchName</span><br><span class="line">	- git checkout -d branchName  <span class="comment"># 删除分支</span></span><br><span class="line">	- git checkout -b temp  <span class="comment"># 创建并切换到新建的分支</span></span><br><span class="line">git switch branchName</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并分支</span></span><br><span class="line">git merge temp</span><br><span class="line"></span><br><span class="line"><span class="comment"># add 和 commit合在一起写</span></span><br><span class="line">git commit -a -m <span class="string">&quot;msg&quot;</span>  <span class="comment"># 或者-am</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载远程内容</span></span><br><span class="line"><span class="comment">#### 直接下载zip是不会下载版本信息的，所以需要使用以下命令</span></span><br><span class="line">git <span class="built_in">clone</span></span><br><span class="line"></span><br><span class="line"> ESDAW</span><br></pre></td></tr></table></figure>

<h1 id="C-x2F-C"><a href="#C-x2F-C" class="headerlink" title="C&#x2F;C++"></a>C&#x2F;C++</h1><h3 id="条件变量的虚假唤醒"><a href="#条件变量的虚假唤醒" class="headerlink" title="条件变量的虚假唤醒"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/tqyysm/articles/9765667.html">条件变量的虚假唤醒</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wait 端</span></span><br><span class="line"><span class="built_in">lock</span>(mutex);</span><br><span class="line"><span class="keyword">while</span>(queue.<span class="built_in">empty</span>())&#123;  <span class="comment">// 如果使用if可能会导致虚假唤醒</span></span><br><span class="line">	cond.<span class="built_in">wait</span>();</span><br><span class="line">&#125;</span><br><span class="line">x = queue.<span class="built_in">pop</span>();</span><br><span class="line"><span class="built_in">unlock</span>(mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// signal/broadcast端</span></span><br><span class="line"><span class="built_in">lock</span>(mutex);</span><br><span class="line">queue.<span class="built_in">push_back</span>(x);</span><br><span class="line"><span class="built_in">unlock</span>(mutex);</span><br><span class="line">cond.<span class="built_in">notify</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当条件变量满足的时候，挂起的线程会被唤醒，当他准备获取锁之前，有其他线程将变量改变了，这时候条件变量不满足了，所以这次唤醒是虚假的。</p>
<p>当某个条件满足的时候（即wait端中while中的条件），之后就进入挂起状态，用if语句那么挂起状态结束以后，就会继续往下，但是这个时候条件不一定满足（虚假唤醒时），所以应该利用while，这样可以<strong>进行第二次判断</strong>，这样就不会因为虚假唤醒的情况而被唤醒。</p>
<h3 id="Function-pointer"><a href="#Function-pointer" class="headerlink" title="Function pointer"></a><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/840501/how-do-function-pointers-in-c-work">Function pointer</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">addInt</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n+m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> (*functionPtr)(<span class="type">int</span>,<span class="type">int</span>); <span class="comment">// Declare</span></span><br><span class="line">functionPtr = &amp;addInt;  <span class="comment">// Assigment</span></span><br><span class="line"><span class="type">int</span> sum = (*functionPtr)(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">// usage: sum == 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// As a parameter</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add2to3</span><span class="params">(<span class="type">int</span> (*functionPtr)(<span class="type">int</span>, <span class="type">int</span>))</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (*functionPtr)(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this is a function called functionFactory which receives parameter n</span></span><br><span class="line"><span class="comment">// and returns a pointer to another function which receives two ints</span></span><br><span class="line"><span class="comment">// and it returns another int</span></span><br><span class="line"><span class="built_in">int</span> (*<span class="built_in">functionFactory</span>(<span class="type">int</span> n))(<span class="type">int</span>, <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Got parameter %d&quot;</span>, n);</span><br><span class="line">    <span class="built_in">int</span> (*functionPtr)(<span class="type">int</span>,<span class="type">int</span>) = &amp;addInt;</span><br><span class="line">    <span class="keyword">return</span> functionPtr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// note that the typedef name is indeed myFuncDef</span></span><br><span class="line"><span class="comment">// Confused here ???????</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*myFuncDef)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">myFuncDef <span class="title">functionFactory</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Got parameter %d&quot;</span>, n);</span><br><span class="line">    myFuncDef functionPtr = &amp;addInt;</span><br><span class="line">    <span class="keyword">return</span> functionPtr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">addInt</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n+m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> (*functionPtr)(<span class="type">int</span>,<span class="type">int</span>); <span class="comment">// Declare</span></span><br><span class="line">functionPtr = &amp;addInt;  <span class="comment">// Assigment</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; addInt &lt;&lt; endl; <span class="comment">// Return 1</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>cout 打印函数返回1的<a target="_blank" rel="noopener" href="https://blog.csdn.net/Q_1849805767/article/details/107391572">原因</a>：<br>C++调用非静态的成员函数时，采用的是一种 __thiscall 的函数调用方式。采用这种调用方式，编译器在编译的时候，会在调用的函数形参表中增加一个指向调用该成员函数的指针，也就是我们经常说的this指针。调用的形式类似于Base::f1(Base* this, otherparam…)，在函数体中，涉及到对象的成员变量或者其他成员函数，都会通过这个this指针来调用，从而达到在成员函数中处理调用对象所对应的数据，而不会错误处理其他对象的数据。可见，虽然我们必须通过对象来调用动态函数，但是其实我们访问的都是同一个成员函数。所以我们采用&amp;Base::f1来获取成员函数地址是没错的，动态函数同样是跟类绑定而不是跟对象绑定的。</p>
</blockquote>
<blockquote>
<p>出错的原因是，<code>输出操作符&lt;&lt;没有对void(__thiscall A:: *)()类型重载，编译器将这种类型转换为bool类型，所以输出了1；</code></p>
</blockquote>
<blockquote>
<p>对于静态函数，其调用方式并非__thiscall，&lt;&lt;有对它的重载，因此类的静态函数可以直接用cout输出函数地址。我们可以用printf输出，因为他可以接收任意类型的参数，包括__thiscall类型</p>
</blockquote>
<h2 id="Upcasting"><a href="#Upcasting" class="headerlink" title="Upcasting"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/2284.html">Upcasting</a></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; <span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : A&#123; <span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>; &#125;</span><br><span class="line"></span><br><span class="line">A a; B b;</span><br><span class="line"><span class="comment">// b = a; // Downcasting</span></span><br><span class="line">a = b; <span class="comment">// Upcasting. 派生类成员变量将会被舍去，只保留基类成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象之间的赋值不会影响成员函数，也不会影响 this 指针</span></span><br><span class="line">a.<span class="built_in">func1</span>(); <span class="comment">// 调用的是A中的函数。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这种转换关系是不可逆的，只能 <code>用派生类对象给基类对象赋值</code>，而 <code>不能</code>用基类对象给派生类对象赋值。理由很简单，基类不包含派生类的成员变量，无法对派生类的成员变量赋值。同理，同一基类的不同派生类对象之间也不能赋值。(如果多出数据，编译器会舍弃，但是少数据了，那么编译器就不知道如何填充剩下的内存了)</p>
</blockquote>
<p><strong>将派生类指针赋值给基类指针</strong></p>
<blockquote>
<p>将派生类指针赋值给基类指针时，通过基类指针只能使用派生类的成员变量，但不能使用派生类的成员函数.</p>
<blockquote>
<p>编译器通过指针访问成员变量，但是不会通过指针访问成员函数，而是通过指针类型来访问。所以，当指针变化的时候，改变的只是指向的内存，也就是对应的类成员变量存储的位置变成了赋值类中的成员变量。</p>
</blockquote>
</blockquote>
<h2 id="MMAP"><a href="#MMAP" class="headerlink" title="MMAP"></a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/357820303">MMAP</a></h2><ul>
<li><p>传统IO</p>
<ul>
<li><p>整个过程发生了<strong>4次用户态和内核态的上下文切换</strong>和<strong>4次拷贝(1.用户发起read，2.读缓存拷贝到用户缓存，3.用户发起write，4.拷贝到网卡)</strong></p>
</li>
<li><p><img src="/.com//readio.webp" alt="img"></p>
</li>
<li><p>DMA拷贝</p>
<ul>
<li>IO操作，都是通过CPU发出对应的指令来完成，但是相比CPU来说，IO的速度太慢了，CPU有大量的时间处于等待IO的状态。因此就产生了<strong>DMA（Direct Memory Access</strong>)直接内存访问技术，本质上来说他就是一块 <code>主板上独立的芯片</code>，通过它来进行内存和IO设备的数据传输，从而减少CPU的等待时间。</li>
</ul>
</li>
</ul>
</li>
<li><p>零拷贝</p>
<ul>
<li><p>计算机执行操作时，CPU不需要先将数据从某处内存复制到另一个特定区域，这种技术通常用于通过网络传输文件时节省CPU周期和内存带宽。</p>
</li>
<li><p>减少用户态和内核态的切换次数以及CPU拷贝的次数。</p>
</li>
<li><p>常见的几种零拷贝技术</p>
<ul>
<li>mmap + write<ul>
<li>使用 <code>mmap</code>替换了read+write中的read操作，减少了一次CPU的拷贝。</li>
<li><code>mmap</code>主要实现方式是将读缓冲区的地址和用户缓冲区的地址进行映射</li>
<li><strong>4次用户态和内核态的上下文切换</strong>和<strong>3次拷贝</strong>（1.mmap调用，2.mmap返回，3.用户调用write，4.拷贝到网卡）</li>
<li><img src="/.com//mmap+write.webp" alt="img"></li>
<li><code>mmap</code>的方式节省了一次CPU拷贝，同时由于用户进程中的内存是虚拟的，只是映射到内核的读缓冲区，所以可以节省一半的内存空间，比较适合大文件的传输。</li>
</ul>
</li>
<li>sendfile<ul>
<li>Linux2.1内核版本后引入的一个系统调用函数，通过使用 <code>sendfile</code>数据可以直接在内核空间进行传输，因此避免了用户空间和内核空间的拷贝</li>
<li><strong>2次用户态和内核态的上下文切换</strong>和<strong>3次拷贝</strong></li>
<li><img src="/.com//sendfile.webp" alt="img"></li>
<li>sendfile方法IO数据对用户空间完全不可见，所以只能适用于完全不需要用户空间处理的情况，比如静态文件服务器。</li>
</ul>
</li>
<li>sendfile + DMA Scatter&#x2F;Gather<ul>
<li>对 <code>sendfile</code>做了进一步优化，通过引入新的硬件支持，这个方式叫做DMA Scatter&#x2F;Gather 分散&#x2F;收集功能。</li>
<li><strong>2次用户态和内核态的上下文切换</strong>和 <strong>2次拷贝</strong> ，其中更重要的是完全没有CPU拷贝</li>
<li><img src="/.com//DMS.webp"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/23/Q-A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/23/Q-A/" class="post-title-link" itemprop="url">Q&A</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-23 16:06:49" itemprop="dateCreated datePublished" datetime="2022-11-23T16:06:49+08:00">2022-11-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-01-14 08:01:01" itemprop="dateModified" datetime="2023-01-14T08:01:01+08:00">2023-01-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="右值引用的用法"><a href="#右值引用的用法" class="headerlink" title="右值引用的用法"></a>右值引用的用法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引用右值，避免生成新对象</span></span><br><span class="line">Foo&amp;&amp; foo2 = <span class="built_in">FooFactory</span>();</span><br></pre></td></tr></table></figure>

<p><strong><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/335994370">关于std::move函数</a></strong></p>
<blockquote>
<p>std::move移动不了什么，唯一的功能是把左值强制转化为右值，让右值引用可以指向左值。其实现等同于一个类型转换：static_cast&lt;T&amp;&amp;&gt;(lvalue)。 所以，单纯的std::move(xxx)不会有性能提升. move返回值如果有名称就是左值（被赋值给一个变量），没有名称就是右值。</p>
<p><strong>使用建议</strong>：可移动对象在&lt;需要拷贝且被拷贝者之后不再被需要&gt;的场景，建议使用std::move触发移动语义，提升性能。（类似于 <code>push_back</code>等的函数）。</p>
<p>对于 <code>unique_ptr</code>只能进行移动构造函数，所以可以使用 <code>move</code>实现赋值构造<br><code>std::unique_ptr&lt;A&gt; ptr = std::move(ptr_a);</code>.</p>
</blockquote>
<p><strong>完美转发 std::forward</strong></p>
<blockquote>
<p>std::forward <code>&lt;T&gt;</code>(u)有两个参数：T与 u。 a. 当T为左值引用类型时，u将被转换为T类型的左值； b. 否则u将被转换为T类型右值。</p>
</blockquote>
<ul>
<li>const右值引用传入的参数可以被修改，而const左值传入的则不可以修改。</li>
</ul>
<h2 id="C-为什么不推荐使用vector-lt-bool-gt"><a href="#C-为什么不推荐使用vector-lt-bool-gt" class="headerlink" title="C++为什么不推荐使用vector&lt;bool&gt;"></a><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/23367698">C++为什么不推荐使用vector&lt;bool&gt;</a></h2><p>vector&lt; bool&gt;不是一个标准容器，就是因为它不能支持一些容器该有的基本操作，诸如取地址给指针初始化操作.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">bool</span>&gt; c&#123;<span class="literal">false</span>, <span class="literal">false</span>&#125;;</span><br><span class="line"><span class="type">bool</span> b = c[<span class="number">0</span>]; <span class="comment">// 这里有一个隐式的类型转换</span></span><br></pre></td></tr></table></figure>

<h2 id="冷不命中-cold-miss"><a href="#冷不命中-cold-miss" class="headerlink" title="冷不命中(cold miss)"></a>冷不命中(cold miss)</h2><p>缓存会在断电之后清空，那么是不是意味着在刚开机的时候，电脑运行的速度会相对较慢？</p>
<h2 id="ssh命令传输方式"><a href="#ssh命令传输方式" class="headerlink" title="ssh命令传输方式"></a>ssh命令传输方式</h2><p>为什么会因为网络波动而导致无法输入的情况</p>
<h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><ul>
<li>为什么在Xftp中删除文件那么慢，而直接使用rm会快很多？</li>
<li>写入空白和覆盖哪个速度更快？</li>
<li>为什么这么写？while(-1 !&#x3D; (opt &#x3D; getopt(argc, argv, “x:y:”)))<ul>
<li>防止将&#x3D;&#x3D;写成&#x3D;，此时，如果写成a&#x3D;1编译会通过，如果写成1&#x3D;a编译不会通过，这样做也可减少这种隐形的bug的出现</li>
</ul>
</li>
<li>函数指针（typedef）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// note that the typedef name is indeed myFuncDef</span></span><br><span class="line"><span class="comment">// Confused here ???????</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*myFuncDef)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">myFuncDef <span class="title">functionFactory</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Got parameter %d&quot;</span>, n);</span><br><span class="line">    myFuncDef functionPtr = &amp;addInt;</span><br><span class="line">    <span class="keyword">return</span> functionPtr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>void (*0)( ) ：是⼀个返回值为void，参数为空的函数指针0 (这里的意思是函数名为0吗？)</p>
</li>
<li><p>为什么在Linux下不能同时安装多个软件，但是在Windows下可以？（并行和串行的优劣？）</p>
</li>
<li><p>在fork之后，父进程和子进程的运行有先后顺序吗？</p>
</li>
<li><p>函数名是不是就是函数指针？(是，那么为什么不需要解引用，直接可以调用？)我可以通过函数名调用函数，那可不可以认为这个函数名就是一个句柄？如何理解句柄？异常表中存储就是各种异常处理函数的句柄？能不能理解为一个整数到一个指针的映射？</p>
<blockquote>
<p><strong>为什么要用 handle，而不直接用指针呢？</strong></p>
<ul>
<li>指针作用太强，可做的事情太多。可做的事情越多，就会越危险。接口设计中，功能刚刚好就够了，并非越多权限越好的。</li>
<li>handle 通常只是个整数，实现被隐藏起来，假如直接暴露了指针，也就暴露了指针类型（有时也可以暴露 void* 指针作为某种 handle）。用户看到越多细节，其代码就越有可能依赖这些细节。将来情况有变，但又要兼容用户代码，库内部改起来就更麻烦。</li>
<li>资源在内部管理，通过 handle 作为中间层，可以有效判断 handle 是否合法，也可以通过权限检查防止某种危险操作。</li>
<li>handle 通常只是个整数，所有的语言都有整数这种类型，但并非所有语言都有指针。接口只出现整数，方便同一实现绑定到各种语言。</li>
</ul>
</blockquote>
</li>
<li><p>在编写信号处理器的时候，最好调用异步信号安全性函数，那为什么不能再执行函数的时候阻塞所有的信号，这样不能保证函数的原子性吗？</p>
</li>
<li><p>printf 和cout混用会有什么后果吗？</p>
</li>
<li><p>free 或者delete掉malloc 或 new 出来的内存会发生什么？</p>
</li>
<li><p>csapp p588: 在32位模式中，  malloc返回的块的地址总是8的倍数，64位模式中，总是16的倍数。 这是为什么？</p>
</li>
<li><p>双字对齐的约束下，块的大小总是为8的倍数，且块大小的最低三位总是为0（这样才能是8的倍数，这里双字表示8字节）</p>
</li>
<li><p>csapp: 练习题9.6中的块大小的计算方法(get)</p>
</li>
<li><p>docker &amp; virtual machine 之间有什么区别？</p>
</li>
<li><blockquote>
<p>向上转型：子类除继承父类数据成员，并且还会有自己的数据成员，但是在向上转型后子类的数据成员会被舍弃</p>
</blockquote>
</li>
<li><p>转型之后的指针为什么可以通过子类的共有方法调用子类成员变量？</p>
</li>
<li><p>多线程：如何理解多线程代码的执行过程，虚假唤醒</p>
</li>
</ul>
<h2 id="代码哲学"><a href="#代码哲学" class="headerlink" title="代码哲学"></a>代码哲学</h2><ul>
<li>为什么说各个编程语言之间粒度不同呢？在什么方面体现？<ul>
<li>如果相应的库被实现了，那么这个语言的粒度会不会改变？</li>
</ul>
</li>
<li>短期内形成对方案的评估的能力，能够知晓方案的可行性、难点的能力，这种能力叫什么？如何训练（在刷算法题的时候，往往在完成过程中才能知晓这些，可能的原因有考虑不充分等）</li>
<li>见到一种技术，如何从技术实现得到技术的类型？</li>
<li>将碎片知识进行体系化</li>
<li>解决一个算法问题的过程</li>
<li>为什么说计算机领域最难的两个问题是变量命名和缓存不命中？</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/08/%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/08/%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">命令笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-08 16:39:05" itemprop="dateCreated datePublished" datetime="2022-11-08T16:39:05+08:00">2022-11-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-01-13 13:37:03" itemprop="dateModified" datetime="2023-01-13T13:37:03+08:00">2023-01-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="linux-命令"><a href="#linux-命令" class="headerlink" title="linux 命令"></a>linux 命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pwd</span> <span class="comment"># Present Working Directory</span></span><br><span class="line">tar &lt;options&gt; &lt;filename&gt; <span class="comment"># Tape ARchive</span></span><br><span class="line"><span class="built_in">rm</span> -rf <span class="comment"># 删除文件夹以及其中的内容</span></span><br><span class="line"><span class="built_in">cat</span> -n <span class="comment"># 查看文件中的内容，-n加上行序号</span></span><br><span class="line">less <span class="comment"># 可以滚动查看， 输入q退出</span></span><br><span class="line">grep &lt;pattern&gt; &lt;file&gt;  <span class="comment"># -v: 不包含模式的字串， -R递归地查找</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">chmod</span> 777 -R &lt;dir_name&gt; <span class="comment"># 将文件夹以及其目录中的所有文件的访问权限全开</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># vim</span></span><br><span class="line">:wq  <span class="comment"># 退出，w：写入； q:退出</span></span><br><span class="line">:q!  <span class="comment"># 强制退出，不保存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 正常模式</span></span><br><span class="line">5yy <span class="comment"># 拷贝5行</span></span><br><span class="line">5dd <span class="comment"># 删除5行</span></span><br><span class="line">p <span class="comment"># 粘贴</span></span><br><span class="line">/main  <span class="comment"># 查找字符串main</span></span><br></pre></td></tr></table></figure>

<h2 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">info s  # 查看栈信息</span><br><span class="line">info r  # 查看寄存器信息</span><br><span class="line">disas # 查看汇编代码， 可以指定函数</span><br><span class="line">x/[count][format] [address] # 打印内存值</span><br><span class="line"> - x/s 0x402400 # 打印在地址0x402400中的值，转换成string</span><br><span class="line">run res.txt # 后面可以加上传入的参数</span><br><span class="line">stepi # 二进制中的一步</span><br><span class="line">fs next # 切换关注的窗口，gdb或者命令行窗口</span><br><span class="line"></span><br><span class="line">condition 1 item_to_remove==1  # 为断点添加一个条件</span><br><span class="line">backtrace  # 查看错误栈</span><br></pre></td></tr></table></figure>

<p><strong>快捷键</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl + L: 刷新gdb页面</span><br></pre></td></tr></table></figure>

<h2 id="快捷键（Linux）"><a href="#快捷键（Linux）" class="headerlink" title="快捷键（Linux）"></a>快捷键（Linux）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl + D: 结束当前任务</span><br></pre></td></tr></table></figure>

<h2 id="docker-命令"><a href="#docker-命令" class="headerlink" title="docker 命令"></a>docker 命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启docker</span></span><br><span class="line">docker start user_name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入docker</span></span><br><span class="line">docker attach user_name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开ssh服务(进入对应的docker之后)</span></span><br><span class="line">service ssh start</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/21/Database/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/21/Database/" class="post-title-link" itemprop="url">Database</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-10-21 12:37:04" itemprop="dateCreated datePublished" datetime="2022-10-21T12:37:04+08:00">2022-10-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-12-21 08:42:56" itemprop="dateModified" datetime="2022-12-21T08:42:56+08:00">2022-12-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><ul>
<li><p>SQL therefore treats as unknown the result of any comparison involving a null value</p>
</li>
<li><p>我们通过DBMS访问数据库</p>
</li>
<li><p><code>NTILE</code> 函数</p>
<ul>
<li>将排序分区中的行划分为特定数量的组。从每个组分配一个从一开始的桶号。对于每一行，NTILE()函数返回一个桶号，表示行所属的组。</li>
</ul>
</li>
<li><p>条件语句</p>
<ul>
<li><p>if 语句</p>
<ul>
<li>IF(condition, value_if_true, value_if_false)</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> salary <span class="keyword">set</span> sex <span class="operator">=</span> if(sex <span class="operator">=</span> <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;m&#x27;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>IFNULL(<strong>expression_1</strong>,<strong>expression_2</strong>)<ul>
<li>如果 <code>expression_1</code>不为 <code>NULL</code>，则 <code>IFNULL</code>函数返回 <code>expression_1</code>; 否则返回 <code>expression_2</code>的结果。<ul>
<li>&#96;&#96;&#96;sql<br>select ifNull((<br>select distinct salary<br>from employee<br>order by salary desc limit 1, 1<br>), null) as SecondHighestSalary;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- case</span><br><span class="line"></span><br><span class="line">  ```sql</span><br><span class="line">  update salary set sex=(case sex when &#x27;m&#x27; then &#x27;f&#x27; else &#x27;m&#x27; end);</span><br><span class="line">  &lt;!-- 通式 --&gt;</span><br><span class="line">  CASE</span><br><span class="line">  WHEN condition1 THEN result1</span><br><span class="line">  WHEN condition2 THEN result2</span><br><span class="line">  WHEN conditionN THEN resultN</span><br><span class="line">  ELSE result</span><br><span class="line">  END;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
</li>
<li><p>字符串</p>
<ul>
<li><code>substr</code>:  <code>substr(string,pos,end)</code>这个函数不填入end就是取pos位置及其之后所有的字符</li>
<li><code>LEFT(str, n)</code>: 获得字符串左边n个字符（right同理）</li>
<li><code>length(str)</code>: 获得字符串的大小</li>
<li><code>CONCAT(str1, str2, ...)</code>：合并字符串函数</li>
</ul>
</li>
<li><p>group_concat()</p>
<ul>
<li>concatenate data from multiple rows into one field.</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col1, col2, ..., colN</span><br><span class="line">GROUP_CONCAT ( [<span class="keyword">DISTINCT</span>] col_name1 </span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> clause]  [SEPARATOR str_val] ) </span><br><span class="line"><span class="keyword">FROM</span> table_name <span class="keyword">GROUP</span> <span class="keyword">BY</span> col_name2;</span><br></pre></td></tr></table></figure></li>
<li><p>时间</p>
<ul>
<li><p><code>datediff(date1, date2)</code>: 如果date1比date2大，结果为正；如果date1比date2小，结果为负。</p>
</li>
<li><p><code>timestampdiff(时间类型, 日期1, 日期2)</code>: 这个函数和 <code>diffdate</code>的正、负号规则刚好相反。<br>日期1大于日期2，结果为负，日期1小于日期2，结果为正。</p>
<ul>
<li>通过添加“day”, “hour”, “second”等关键词，来规定计算天数差、小时数差、还是分钟数差</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> timestampdiff(<span class="keyword">day</span>, <span class="string">&#x27;2019-01-01&#x27;</span>, <span class="string">&#x27;2019-01-03&#x27;</span>) <span class="keyword">as</span> dayInterval; <span class="comment">--计算天数差</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>DATE_SUB(date,INTERVAL expr type)</code>: 从日期减去指定的时间间隔。</p>
</li>
<li><p>&#96;&#96;&#96;sql<br>where activity_date &gt; date_sub(‘2019-07-27’, interval 30 day)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  - `year(time)`: 获取时间中的年份</span><br><span class="line"></span><br><span class="line">**from CMU**</span><br><span class="line"></span><br><span class="line">```sql</span><br><span class="line">-- 窗口函数, 按照指定的分组操作函数（将每一个分组数据作为一个函数的统计对象）</span><br><span class="line">select row_number() over (partition by cid) from titles;</span><br><span class="line">-- Common Table Expressions</span><br><span class="line">with cteName(n1, n2) as (select 1, 2) select n1 + n2 from ctenName;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><blockquote>
<p>limit 20 offset 10;</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> vend_id <span class="keyword">from</span> products; <span class="comment">--只返回不同值</span></span><br><span class="line"><span class="keyword">select</span> prod_name <span class="keyword">from</span> products limit <span class="number">5</span>;  <span class="comment">--返回不多于5行</span></span><br><span class="line"><span class="keyword">select</span> prod_name <span class="keyword">from</span> products limit <span class="number">5</span>, <span class="number">6</span>;  <span class="comment">--从第5行开始的6行（编号从一开始）</span></span><br></pre></td></tr></table></figure>

<h3 id="排序命令"><a href="#排序命令" class="headerlink" title="排序命令"></a>排序命令</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 排序</span></span><br><span class="line"><span class="keyword">select</span> prod_name <span class="keyword">from</span> products <span class="keyword">order</span> <span class="keyword">by</span> prod_name, prod_price; <span class="comment">--排序</span></span><br><span class="line"><span class="keyword">select</span> prod_name <span class="keyword">from</span> products <span class="keyword">order</span> <span class="keyword">by</span> prod_name, prod_price <span class="keyword">DESC</span>; <span class="comment">--降序排序</span></span><br><span class="line"><span class="keyword">select</span> prod_name <span class="keyword">from</span> products <span class="keyword">order</span> <span class="keyword">by</span> prod_price <span class="keyword">DESC</span>, prod_name; <span class="comment">--仅价格降序排序（多个列上进行排序，则需要在列名后面都加上这样的关键字，ASC:升序）</span></span><br></pre></td></tr></table></figure>

<h3 id="过滤数据"><a href="#过滤数据" class="headerlink" title="过滤数据"></a>过滤数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 过滤数据 --</span></span><br><span class="line"><span class="keyword">select</span> prod_name, prod_price <span class="keyword">from</span> products <span class="keyword">where</span> prod_price<span class="operator">=</span><span class="number">2.50</span>; <span class="comment">-- 使用where关键字进行条件筛选。与order by 共用的时候，应该放在where之后</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 几个where的子句符号. &lt;&gt;, !=:不等于； BETWEEN:在指定的两个值之间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 单引号用于限定字符串，当值与字符串进行比较，需要使用单引号</span></span><br><span class="line"><span class="keyword">select</span> prod_name, prod_price <span class="keyword">from</span> products <span class="keyword">where</span> prod_name <span class="operator">=</span> <span class="string">&#x27;fuses&#x27;</span>;</span><br><span class="line"><span class="operator">~</span> <span class="keyword">where</span> prod_price <span class="keyword">between</span> <span class="number">5</span> <span class="keyword">and</span> <span class="number">10</span>;  <span class="comment">-- ~表示与前面语句一致，下同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 检查NULL值.这在匹配过滤或者不匹配过滤时候不会返回。</span></span><br><span class="line"><span class="operator">~</span> <span class="keyword">where</span> prod_price <span class="keyword">is</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 次序计算，AND的优先级要更高，但是最好还是利用圆括号将操作符分开</span></span><br><span class="line"><span class="keyword">select</span> prod_name, prod_price <span class="keyword">from</span> products <span class="keyword">where</span> (vend_id <span class="operator">=</span> <span class="number">1002</span> <span class="keyword">or</span> vend_id <span class="operator">=</span> <span class="number">1003</span>) <span class="keyword">AND</span> prod_price <span class="operator">&gt;=</span> <span class="number">10</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- IN 操作符指定条件范围</span></span><br><span class="line"><span class="keyword">select</span> prod_name, prod_price <span class="keyword">from</span> products <span class="keyword">where</span> vend_id <span class="keyword">in</span> (<span class="number">1002</span>, <span class="number">1003</span>) <span class="keyword">order</span> <span class="keyword">by</span> prod_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- NOT操作符</span></span><br><span class="line"><span class="operator">~</span> <span class="keyword">where</span> vend_id <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="number">1002</span>, <span class="number">1003</span>) <span class="operator">~</span></span><br></pre></td></tr></table></figure>

<p><strong>利用通配符进行过滤</strong><br>通配符(wildcard)：用来匹配值的一部分特殊字符</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- %: 表示任意长度的字符串，但是不包含NULL</span></span><br><span class="line"><span class="keyword">select</span> prod_id, prod_name <span class="keyword">from</span> products <span class="keyword">where</span> prod_name <span class="keyword">like</span> <span class="string">&#x27;jet%&#x27;</span>; <span class="comment">-- 搜索以&#x27;jet&#x27;开头的词</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- _: 只匹配单个字符</span></span><br><span class="line"><span class="operator">~</span> <span class="keyword">like</span> <span class="string">&#x27;_ to anvil&#x27;</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通配符搜索的处理一般要比前面讨论的其他搜索所花时间更长。如果不是必要不要使用，使用的时候最好不要放在搜索的开始（搜索量太大）。</p>
</blockquote>
<p><strong>利用正则表达式进行搜索</strong><br>只需要将原先的 <code>LIKE</code>关键词转换成 <code>REGEXP</code>。注意前者是匹配文本在是这个，后者是存在这个，也就是后者只需要这个模式在文本中有出现即可，而前者需要全部一致。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- &#x27;.&#x27;：表示能够匹配任意的字符</span></span><br><span class="line"><span class="keyword">select</span> prod_name <span class="keyword">from</span> products <span class="keyword">where</span> prod_name REGEXP <span class="string">&#x27;.000&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> prod_name; </span><br><span class="line"><span class="comment">-- 正则表达式默认不区分大小写，如果需要则要加上binary关键词</span></span><br><span class="line"><span class="operator">~</span> <span class="keyword">where</span> prod_name REGEXP <span class="type">binary</span> <span class="string">&#x27;JetPack .000&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- OR 匹配</span></span><br><span class="line"><span class="operator">~</span> regexp <span class="string">&#x27;1000|2000&#x27;</span> <span class="operator">~</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 匹配几个字符之一</span></span><br><span class="line"><span class="operator">~</span> REGEXP <span class="string">&#x27;[123] Ton&#x27;</span> <span class="operator">~</span>; <span class="comment">-- 1 Ton、 2 Ton都行</span></span><br><span class="line"><span class="string">&#x27;1|2|3 Ton&#x27;</span>  <span class="comment">-- 等价于</span></span><br><span class="line"><span class="operator">~</span> regexp <span class="string">&#x27;[1-5] Ton&#x27;</span>; <span class="comment">-- 范围匹配</span></span><br><span class="line"><span class="operator">~</span> <span class="keyword">where</span> vend_name regexp <span class="string">&#x27;\\.&#x27;</span>;  <span class="comment">-- 匹配特殊字符，用\\ 作为前导（转义）</span></span><br><span class="line"><span class="comment">-- 空白元字符： \\f----换页； \\n---换行 。。。。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 匹配字符类</span></span><br></pre></td></tr></table></figure>

<img src="/.com//10/21/Database/%E7%A9%BA%E7%99%BD%E5%85%83%E5%AD%97%E7%AC%A6.png" class title="空白元字符">
<img src="/.com//10/21/Database/%E5%AD%97%E7%AC%A6%E7%B1%BB.png" class title="字符类">

<p><strong>匹配多个实例</strong><br>可以利用重复元字符对目标字符中的某一个字符进行指定的性质匹配。</p>
<img src="/.com//10/21/Database/%E9%87%8D%E5%A4%8D%E5%85%83%E5%AD%97%E7%AC%A6.png" class title="重复云字符">

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> prod_name <span class="keyword">from</span> products <span class="keyword">where</span> prod_name regexp <span class="string">&#x27;\\([0-9] sticks?\\)&#x27;</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> prod_name; <span class="comment">-- 最后匹配的是stick 或者 sticks，最后？表示s是可选的匹配字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- [:digit:]: 匹配数字； 第二个[]是为了指明&#123;4&#125; 的作用域</span></span><br><span class="line"><span class="operator">~</span> <span class="keyword">where</span> prod_name regexp <span class="string">&#x27;[[:digit:]]&#123;4&#125;&#x27;</span>; <span class="comment">-- 匹配连续一起的四个数字</span></span><br></pre></td></tr></table></figure>

<p><strong>定位符</strong></p>
<img src="/.com//10/21/Database/%E5%AE%9A%E4%BD%8D%E5%85%83%E5%AD%97%E7%AC%A6.png" class title="定位元字符">

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 找到以数字开头（包括小数点）</span></span><br><span class="line"><span class="operator">~</span> <span class="keyword">where</span> prod_name regexp <span class="string">&#x27;[0-9\\.]&#x27;</span>; <span class="comment">-- 这样不行，这会在文本的任意位置查找匹配</span></span><br><span class="line"><span class="operator">~</span> <span class="keyword">where</span> prod_name regexp <span class="string">&#x27;^[0-9\\.]&#x27;</span>; <span class="comment">-- 仅仅从开头开始查找匹配</span></span><br></pre></td></tr></table></figure>

<h3 id="创建计算字符串"><a href="#创建计算字符串" class="headerlink" title="创建计算字符串"></a>创建计算字符串</h3><p><strong>拼接字符串</strong>使用 <code>Concat()</code>将值联结到一起构成单个值。 （使用sum，计算值的和）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- sum 与 case结合的实例</span></span><br><span class="line"><span class="built_in">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> operation<span class="operator">=</span><span class="string">&#x27;buy&#x27;</span> <span class="keyword">then</span> <span class="operator">-</span>price <span class="keyword">else</span> price <span class="keyword">end</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>多数DBMS使用 <code>+</code>或者 <code>||</code>来实现拼接(sqlite中用 <code>||</code>实现)，但是在MySQL中使用 <code>Concat()</code>函数来实现</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> concat(vend_name, <span class="string">&#x27;(&#x27;</span>, vend_country, <span class="string">&#x27;)&#x27;</span>) <span class="keyword">from</span> vendors ...;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除右侧多余空格来整理数据（RTrim() 函数， LTrim()去掉左侧空格）</span></span><br><span class="line"><span class="keyword">select</span> concat(RTrim(vend_name), <span class="string">&#x27;(&#x27;</span>, RTrim(vend_country), <span class="string">&#x27;)&#x27;</span>)...;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 为拼接的字段取名</span></span><br><span class="line"><span class="keyword">select</span> concat(vend_name, <span class="string">&#x27;(&#x27;</span>, vend_country, <span class="string">&#x27;)&#x27;</span>) <span class="keyword">from</span> vendors <span class="keyword">as</span> vend_title...;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 执行算数运算的结果作为一个项</span></span><br><span class="line"><span class="keyword">select</span> prod_id, quantity<span class="operator">*</span>item_price <span class="keyword">as</span> expanded_price <span class="keyword">from</span> ...;</span><br></pre></td></tr></table></figure>

<h3 id="使用数据处理函数"><a href="#使用数据处理函数" class="headerlink" title="使用数据处理函数"></a>使用数据处理函数</h3><blockquote>
<p><strong>函数没有SQL的可移植性强</strong>， 如果你决定使用函数，应该保证做好代码注释，以便以后你（或其他人）能确切地知道所编写SQL代码的含义。</p>
</blockquote>
<img src="/.com//10/21/Database/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0(%E9%83%A8%E5%88%86).png" class title="常见的文本处理函数(部分)">

<blockquote>
<p><code>Soundex()</code>:会匹配与搜索字符串读音相似的字符串</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> vend_name, <span class="built_in">Upper</span>(vend_name) <span class="keyword">as</span> vend_name_upcase ...;</span><br></pre></td></tr></table></figure>

<p><strong>日期和时间处理函数</strong><img src="/.com//10/21/Database/%E5%B8%B8%E7%94%A8%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0.png" class title="常用日期和时间处理函数"></p>
<blockquote>
<p>使用 <code>WHERE</code>进行筛选，对应的日期格式为：<code>yyyy-mm-dd</code></p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Date()函数得到的仅仅是日期，Time() 函数得到的是时间</span></span><br><span class="line"><span class="comment">-- 下面这段语句不适用Date函数，将会匹配失败，因为where是整个列值进行比较的</span></span><br><span class="line"><span class="keyword">select</span> cust_id, order_num <span class="keyword">from</span> orders <span class="keyword">where</span> <span class="type">Date</span>(order_date) <span class="operator">=</span> <span class="string">&#x27;2005-09-01&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 时间段进行筛选</span></span><br><span class="line"><span class="operator">~</span> <span class="keyword">where</span> <span class="type">Date</span>(order_data) <span class="keyword">between</span> <span class="string">&#x27;2005-09-01&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;2005-9-30&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取时间中的月份或者年份信息</span></span><br><span class="line"><span class="keyword">year</span>(order_date), <span class="keyword">month</span>(order_date);</span><br></pre></td></tr></table></figure>

<p><strong>数值处理函数</strong></p>
<img src="/.com//10/21/Database/%E5%B8%B8%E7%94%A8%E6%95%B0%E5%80%BC%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0.png" class title="常用数值处理函数">

<h3 id="汇总数据"><a href="#汇总数据" class="headerlink" title="汇总数据"></a>汇总数据</h3><p>获取表中的汇总信息。</p>
<img src="/.com//10/21/Database/SQL%E8%81%9A%E9%9B%86%E5%87%BD%E6%95%B0.png" class title="SQL聚集函数">

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 返回特定供应商提供的产品的平均价格</span></span><br><span class="line"><span class="comment">-- 不允许使用count(distinct)</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(<span class="keyword">distinct</span> prod_price) <span class="keyword">from</span> products <span class="keyword">where</span> vend_id <span class="operator">=</span> <span class="number">1003</span>;</span><br></pre></td></tr></table></figure>

<h3 id="分组数据"><a href="#分组数据" class="headerlink" title="分组数据"></a>分组数据</h3><p>分组数据以便能汇总内容的子集, 将数据按照指定的分组进行统计。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> vend_id, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> num_prods <span class="keyword">from</span> products <span class="keyword">group</span> <span class="keyword">by</span> vend_id;</span><br></pre></td></tr></table></figure>

<p>过滤分组使用 <code>having</code>,这个子句支持所有 <code>where</code>操作符。(对分组数据进行筛选)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 这里直接使用where无法实现相同的目的</span></span><br><span class="line"><span class="operator">~</span> <span class="keyword">group</span> <span class="keyword">by</span> cust_id <span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 过去12个月具有两个或以上的订单，且价格为10以上</span></span><br><span class="line"><span class="keyword">select</span> vend_id, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> num_prods <span class="keyword">from</span> products <span class="keyword">where</span> prod_price <span class="operator">&gt;=</span> <span class="number">10</span> <span class="keyword">group</span> <span class="keyword">by</span> vend_id <span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p><strong>group by &amp; order by</strong></p>
<blockquote>
<p>不要忘记ORDER BY 一般在使用GROUP BY子句时，应该也给出ORDER BY子句。这是保证数据正确排序的唯一方法。千万不要仅依赖GROUP BY排序数据。</p>
</blockquote>
<h3 id="子查询语句"><a href="#子查询语句" class="headerlink" title="子查询语句"></a>子查询语句</h3><p>在select语句中嵌套select语句, <code>in</code> 或者 <code>not in</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> cust_id</span><br><span class="line"><span class="keyword">from</span> orders</span><br><span class="line"><span class="keyword">where</span> order_num <span class="keyword">in</span>(<span class="keyword">select</span> order_num</span><br><span class="line">                   <span class="keyword">from</span> orderitems</span><br><span class="line">                   <span class="keyword">where</span> prod_id <span class="operator">=</span> <span class="string">&#x27;TNT2&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="联结表"><a href="#联结表" class="headerlink" title="联结表"></a>联结表</h3><p>在联结两个表时，实际上就是将第一个表中的每一行与第二个表中的每一行进行匹配。Note: left join可以用于数据的剔除（Not in的效果）</p>
<p><img src="/.com//join.jpg" alt="img"></p>
<blockquote>
<p>Ref: Database System Concepts 7ed(Abraham Silberschatz, Henry F. Korth etc.)</p>
</blockquote>
<p><strong><code>&gt; some</code>: greater than at least one</strong><br><strong><code>&gt; all</code>: greater than all. <code>&lt;&gt; all</code>: not in</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> salary <span class="operator">&gt;</span> <span class="keyword">some</span> (<span class="keyword">select</span> salary</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> dept name <span class="operator">=</span> <span class="string">&#x27;Biology&#x27;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>cross join</code><ul>
<li>先将两个表进行笛卡尔积，然后利用后面的on对联结表进行筛选<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a.Id</span><br><span class="line"><span class="keyword">from</span> weather <span class="keyword">as</span> a </span><br><span class="line"><span class="keyword">cross</span> <span class="keyword">join</span> weather <span class="keyword">as</span> b</span><br><span class="line"><span class="keyword">on</span> datediff(a.recordDate, b.recordDate) <span class="operator">=</span> <span class="number">1</span>  <span class="comment">-- 这里就是筛选的条件了</span></span><br><span class="line"><span class="keyword">where</span> a.temperature <span class="operator">&gt;</span> b.temperature;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><strong>内部联结</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.... <span class="keyword">from</span> ...(列名) <span class="keyword">inner</span> <span class="keyword">join</span> ... <span class="keyword">on</span> ....(<span class="keyword">condition</span>);</span><br></pre></td></tr></table></figure>

<h3 id="高级联结"><a href="#高级联结" class="headerlink" title="高级联结"></a>高级联结</h3><p><strong>自联结</strong>：利用别名对同一个表中的条件进行筛选</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> p1.id, p1.name </span><br><span class="line"><span class="keyword">from</span> product <span class="keyword">as</span> p1, product <span class="keyword">as</span> p2  <span class="comment">-- 对同一个表给予两个不同的别名</span></span><br><span class="line"><span class="keyword">where</span> p1.id <span class="operator">=</span> p2.id <span class="keyword">and</span> p2.id <span class="operator">=</span> <span class="string">&#x27;DTNTR&#x27;</span>;  <span class="comment">-- 这样就得到了id为&#x27;DTNTR&#x27;的名称了</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用场景： 删除表中重复的元素.仅保留id较小的元素</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> p1 <span class="keyword">from</span> person <span class="keyword">as</span> p1, person <span class="keyword">as</span> p2</span><br><span class="line"><span class="keyword">where</span> p1.email<span class="operator">=</span>p2.email <span class="keyword">and</span> p1.Id <span class="operator">&gt;</span> p2.id;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>外部联结</strong>：联结包含了那些在相关表中没有关联行的行。使用关键字 <code>LEFT OUTER JOIN</code>（左外部联结）</p>
<h3 id="创建组合查询"><a href="#创建组合查询" class="headerlink" title="创建组合查询"></a>创建组合查询</h3><p>使用关键字 <code>Union</code>将两个子句的结果进行组合。</p>
<blockquote>
<p>UNION中的每个查询必须包含相同的列、表达式或聚集函数<br>自动去除重复的行（使用 <code>Union all</code>保留所有的行）<br>末尾的 <code>order by</code>不会是对单一语句的排序，而是对返回的所有的结果进行排序的。</p>
</blockquote>
<blockquote>
<p>union 和 union all都可以起到关联结果集的作用,<br>union 会自动去除关联的两个结果集中的重复数据<br>union all 不会主动去除两个结果集中的重复数据,会展示所有的数据</p>
</blockquote>
<h3 id="使用全文本搜索"><a href="#使用全文本搜索" class="headerlink" title="使用全文本搜索"></a>使用全文本搜索</h3><p>在建表的时候， 添加 <code>FULLEXT(...)</code>.在检索的时候，会根据这个指示进行检索</p>
<blockquote>
<p>CREATE TABLE语句接受FULLTEXT子句，它给出被索引列的一个逗号分隔的列表。<br>在索引之后，使用两个函数Match()和Against()执行全文本搜索，其中Match()指定被搜索的列，Against()指定要使用的搜索表达式。(Match中的值与FULLEXT中定义的相同)。 这种方法，当匹配词出现在更前面的时候，输出的优先级要高一些。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ... <span class="keyword">where</span> <span class="keyword">Match</span>(note_text) Against(<span class="string">&#x27;rabbit&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>查询拓展</strong><br>将包含目标词的语句中的词的语句也同样输出来。(<code>with query expansion</code>)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">... <span class="keyword">where</span> <span class="keyword">match</span>(note_text) Against(<span class="string">&#x27;anvils&#x27;</span> <span class="keyword">with</span> query expansion);</span><br></pre></td></tr></table></figure>

<p><strong>布尔文本搜索</strong>MySQL支持全文本搜索的另外一种形式，称为布尔方式（boolean mode）。</p>
<blockquote>
<p>全文本搜索布尔操作符-和<em>，-排除一个词，而</em>是截断操作符（可想象为用于词尾的一个通配符）</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">... <span class="keyword">where</span> <span class="keyword">match</span>(..) against(<span class="string">&#x27;...&#x27;</span> <span class="keyword">in</span> <span class="type">boolean</span> mode);</span><br><span class="line">... <span class="keyword">where</span> <span class="keyword">match</span>(..) against(<span class="string">&#x27;... -rope*&#x27;</span> <span class="keyword">in</span> <span class="type">boolean</span> mode); <span class="comment">-- 匹配包含...但不包含任意以rope开始的词的行</span></span><br></pre></td></tr></table></figure>

<h3 id="插入完整的行"><a href="#插入完整的行" class="headerlink" title="插入完整的行"></a>插入完整的行</h3><p>需要指定表名，以及表下所有的对应的列的信息。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- insert 插入一行到一个表中</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Customers <span class="keyword">values</span>(list_infomation);  <span class="comment">--虽然这种语法很简单，但并不安全，应该尽量避免使用</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Custormers(cust_name, cust_address,....) <span class="keyword">values</span>(list_infomation);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Custormers(cust_name, cust_address,....) <span class="keyword">values</span>(list_infomation1)， (list_infomation2);  <span class="comment">-- 插入两行到一个表中</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Custormers(cust_name, cust_address,....) <span class="keyword">select</span> cust_name, cust_address,.... <span class="keyword">from</span> custnew; <span class="comment">-- 利用select语句进行填充</span></span><br></pre></td></tr></table></figure>

<h3 id="更新与删除数据"><a href="#更新与删除数据" class="headerlink" title="更新与删除数据"></a>更新与删除数据</h3><p>更新使用关键词 <code>update</code></p>
<blockquote>
<p>MySQL没有撤销（undo）按钮。应该非常小心地使用UPDATE和DELETE.</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> customers <span class="keyword">set</span> cust_name <span class="operator">=</span> <span class="string">&#x27;..&#x27;</span>, cust_email <span class="operator">=</span> <span class="string">&#x27;,,&#x27;</span> <span class="keyword">where</span> cust_id <span class="operator">=</span> <span class="number">1002</span>; <span class="comment">-- 可以一次性更新多个信息</span></span><br><span class="line"><span class="comment">-- 为了删除某个列的值，可设置它为NULL（假如表定义允许NULL值）。</span></span><br><span class="line"><span class="comment">-- 替换的新的值可以使用if语句</span></span><br></pre></td></tr></table></figure>

<p>删除数据使用关键词 <code>delete</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> customers <span class="keyword">where</span> cust_id <span class="operator">=</span> <span class="number">1006</span>; <span class="comment">-- DELETE不需要列名或通配符。DELETE删除整行而不是删除列。为了删除指定的列，请使用UPDATE语句</span></span><br></pre></td></tr></table></figure>

<h3 id="创建和操纵表"><a href="#创建和操纵表" class="headerlink" title="创建和操纵表"></a>创建和操纵表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tableName(</span><br><span class="line">    <span class="comment">-- AUTO_INCREMENT：本列每当增加一行时自动增量， 每个表只允许一个AUTO_INCREMENT列，而且它必须被索引</span></span><br><span class="line">    <span class="comment">-- 与大多数DBMS不一样，MySQL不允许使用函数作为默认值，它只支持常量</span></span><br><span class="line">    cust_id <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT <span class="keyword">default</span> <span class="number">1</span>,</span><br><span class="line"><span class="comment">--  列名   类型  是否允许NULL             未给出值的时候，默认为1</span></span><br><span class="line">    <span class="comment">-- 主键中只能使用不允许NULL值的列</span></span><br><span class="line">    <span class="keyword">primary</span> key (cust_id)</span><br><span class="line">)ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"><span class="comment">-- 引擎类型，如果省略ENGINE=语句，则使用默认引擎（很可能是MyISAM）。 外键不能跨引擎</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改, 给表添加一个列</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">add</span> vendor <span class="type">char</span>(<span class="number">20</span>);  </span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">drop</span> <span class="keyword">column</span> vendor; <span class="comment">-- 删除</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">add</span> <span class="keyword">constraint</span> .... <span class="comment">-- etc</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除表（删除整个表而不是其内容）</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> table_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">--重命名表</span></span><br><span class="line">rename <span class="keyword">table</span> t <span class="keyword">to</span> t1;</span><br></pre></td></tr></table></figure>

<h3 id="使用视图"><a href="#使用视图" class="headerlink" title="使用视图"></a>使用视图</h3><p>视图本身不包含数据，因此它们返回的数据是从其他表中检索出来的(实际上就是将一个sql语句进行封装)</p>
<blockquote>
<p>视图用 <code>CREATE VIEW</code>语句来创建。</p>
<ul>
<li>使用 <code>SHOW CREATE VIEW viewname；</code>来查看创建视图的语句。</li>
<li>用DROP删除视图，其语法为 <code>DROP VIEW viewname;</code>。</li>
<li>更新视图时，可以先用DROP再用CREATE，也可以直接用 <code>CREATE OR  REPLACE VIEW</code>。如果要更新的视图不存在，则第2条更新语句会创<br>建一个视图；如果要更新的视图存在，则第2条更新语句会替换原<br>有视图</li>
</ul>
</blockquote>
<blockquote>
<p>并非所有视图都是可更新的。基本上可以说，如果MySQL不能正确地确定被更新的基数据，则不允许更新（包括插入和删除）</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> view_name <span class="keyword">as</span> <span class="keyword">select</span> .....;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/21/6_S081lab1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/21/6_S081lab1/" class="post-title-link" itemprop="url">6.S081lab1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-10-21 11:30:25" itemprop="dateCreated datePublished" datetime="2022-10-21T11:30:25+08:00">2022-10-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-12-22 14:31:12" itemprop="dateModified" datetime="2022-12-22T14:31:12+08:00">2022-12-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><h3 id="使用Tmux在一个终端中创建多个窗口"><a href="#使用Tmux在一个终端中创建多个窗口" class="headerlink" title="使用Tmux在一个终端中创建多个窗口"></a>使用Tmux在一个终端中创建多个窗口</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tmux # 进入新建的会话中</span><br><span class="line">Ctrl + B , % # 垂直分割（左右）</span><br><span class="line">Ctrl + B , “ # 水平分割（上下）</span><br><span class="line">Ctrl + B , 方向键 # 在不同的终端中切换</span><br><span class="line">exit  # 退出会话</span><br></pre></td></tr></table></figure>

<h3 id="启动qemu的gdb模式"><a href="#启动qemu的gdb模式" class="headerlink" title="启动qemu的gdb模式"></a>启动qemu的gdb模式</h3><p>在第一个窗口运行 <code>make CPUS=1 qemu-gdb</code>, 第二个窗口运行 <code>gdb-multiarch</code>，开启gdb模式。</p>
<p>如果lient端没有连接到server，那么需要在 <code>/root</code> 创建 <code>.gdbinit</code> 文件, 加上：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add-auto-load-safe-path /root/xv6-labs-2022/.gdbinit  # xv6 directory</span><br></pre></td></tr></table></figure>

<h4 id="gdb的使用方法"><a href="#gdb的使用方法" class="headerlink" title="gdb的使用方法"></a>gdb的使用方法</h4><p>首先是链接文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file fileName</span><br></pre></td></tr></table></figure>

<p>常见的命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">r = run</span><br><span class="line">c = continue # 让暂停的程序继续运行</span><br><span class="line">n = next  # 运行到下一行</span><br><span class="line">s = step # 单步执行，遇到函数会进入</span><br><span class="line">p = print  # 打印变量或寄存器</span><br></pre></td></tr></table></figure>


<h2 id="实验一"><a href="#实验一" class="headerlink" title="实验一"></a>实验一</h2><p>预备知识：</p>
<ul>
<li><code>pid_t wait(int *wstatus)</code>：等待（阻塞状态）子进程状态发生变化（子进程终结、子进程被信号停止或恢复）。如果子进程是被终结，那么wait能够允许系统释放子进程的资源。如果wait没有得到执行，那么终结的子进程就会变成“僵尸”状态。<code>exit(0)</code>表示等待所有的子进程退出。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RD 0 <span class="comment">//pipe的read端</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WR 1 <span class="comment">//pipe的write端</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> buf = <span class="string">&#x27;P&#x27;</span>; <span class="comment">//用于传送的字节</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd_c2p[<span class="number">2</span>]; <span class="comment">//子进程-&gt;父进程</span></span><br><span class="line">    <span class="type">int</span> fd_p2c[<span class="number">2</span>]; <span class="comment">//父进程-&gt;子进程</span></span><br><span class="line">    <span class="built_in">pipe</span>(fd_c2p);</span><br><span class="line">    <span class="built_in">pipe</span>(fd_p2c);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="type">int</span> exit_status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;fork() error!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(fd_c2p[RD]);</span><br><span class="line">        <span class="built_in">close</span>(fd_c2p[WR]);</span><br><span class="line">        <span class="built_in">close</span>(fd_p2c[RD]);</span><br><span class="line">        <span class="built_in">close</span>(fd_p2c[WR]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">//子进程</span></span><br><span class="line">        <span class="built_in">close</span>(fd_p2c[WR]);</span><br><span class="line">        <span class="built_in">close</span>(fd_c2p[RD]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">read</span>(fd_p2c[RD], &amp;buf, <span class="built_in">sizeof</span>(<span class="type">char</span>)) != <span class="built_in">sizeof</span>(<span class="type">char</span>)) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;child read() error!\n&quot;</span>);</span><br><span class="line">            exit_status = <span class="number">1</span>; <span class="comment">//标记出错</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">1</span>, <span class="string">&quot;%d: received ping\n&quot;</span>, <span class="built_in">getpid</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">write</span>(fd_c2p[WR], &amp;buf, <span class="built_in">sizeof</span>(<span class="type">char</span>)) != <span class="built_in">sizeof</span>(<span class="type">char</span>)) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;child write() error!\n&quot;</span>);</span><br><span class="line">            exit_status = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">close</span>(fd_p2c[RD]);</span><br><span class="line">        <span class="built_in">close</span>(fd_c2p[WR]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(exit_status);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//父进程</span></span><br><span class="line">        <span class="built_in">close</span>(fd_p2c[RD]);</span><br><span class="line">        <span class="built_in">close</span>(fd_c2p[WR]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">write</span>(fd_p2c[WR], &amp;buf, <span class="built_in">sizeof</span>(<span class="type">char</span>)) != <span class="built_in">sizeof</span>(<span class="type">char</span>)) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;parent write() error!\n&quot;</span>);</span><br><span class="line">            exit_status = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">read</span>(fd_c2p[RD], &amp;buf, <span class="built_in">sizeof</span>(<span class="type">char</span>)) != <span class="built_in">sizeof</span>(<span class="type">char</span>)) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;parent read() error!\n&quot;</span>);</span><br><span class="line">            exit_status = <span class="number">1</span>; <span class="comment">//标记出错</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">1</span>, <span class="string">&quot;%d: received pong\n&quot;</span>, <span class="built_in">getpid</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">close</span>(fd_p2c[WR]);</span><br><span class="line">        <span class="built_in">close</span>(fd_c2p[RD]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(exit_status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><ul>
<li>0、1、2是文件描述符（分别对应stdin、stdout、stderr）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fprintf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span><span class="comment">// C 库函数发送格式化输出到流 stream 中。</span></span></span><br><span class="line"><span class="function"><span class="comment">// -----------------------------------------------------------</span></span></span><br><span class="line"><span class="function"><span class="keyword">struct</span> dirent</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">　　<span class="type">long</span> d_ino; <span class="comment">/* inode number 索引节点号 */</span></span><br><span class="line">    <span class="type">off_t</span> d_off; <span class="comment">/* offset to this dirent 在目录文件中的偏移 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> d_reclen; <span class="comment">/* length of this d_name 文件名长 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> d_type; <span class="comment">/* the type of d_name 文件类型 */</span></span><br><span class="line">    <span class="type">char</span> d_name [NAME_MAX+<span class="number">1</span>]; <span class="comment">/* file name (null-terminated) 文件名，最长255字符 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------------------------------------------</span></span><br><span class="line"><span class="comment">// 从 str2 复制 n 个字符到 str1，但是在重叠内存块这方面，memmove() 是比 memcpy() 更安全的方法</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">memmove</span><span class="params">(<span class="type">void</span> *str1, <span class="type">const</span> <span class="type">void</span> *str2, <span class="type">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="实验二"><a href="#实验二" class="headerlink" title="实验二"></a>实验二</h2><h3 id="trace"><a href="#trace" class="headerlink" title="trace"></a>trace</h3><p>TODO: 理清楚整个调用的过程</p>
<p>xv6系统调用的过程，这里以fork为例:</p>
<img src="/.com//10/21/6_S081lab1/fork.png" class>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/12/C-primer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/12/C-primer/" class="post-title-link" itemprop="url">C++ primer</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-10-12 20:07:04" itemprop="dateCreated datePublished" datetime="2022-10-12T20:07:04+08:00">2022-10-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-10-22 08:41:39" itemprop="dateModified" datetime="2022-10-22T08:41:39+08:00">2022-10-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="TODO："><a href="#TODO：" class="headerlink" title="TODO："></a>TODO：</h2><p>总结各种初始化方法</p>
<h1 id="temp"><a href="#temp" class="headerlink" title="temp"></a>temp</h1><ul>
<li>p407：内置类型或组合类型的对象的值将是未定义的，而类对象将用默认构造函数进行初始化<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">string *ps = <span class="keyword">new</span> string;  <span class="comment">// empty string</span></span><br><span class="line"><span class="type">int</span> *pi = <span class="keyword">new</span> <span class="type">int</span>;  <span class="comment">// uninitialized int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 值初始化</span></span><br><span class="line"><span class="type">int</span> *pi2 = <span class="keyword">new</span> <span class="built_in">int</span>(); <span class="comment">// initialized as 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝构造也可以这样</span></span><br><span class="line"><span class="keyword">auto</span> p1 = <span class="keyword">new</span> <span class="built_in">auto</span>(p2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态分配const 对象</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *pci = <span class="keyword">new</span> <span class="type">const</span> <span class="built_in">int</span>(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>有一个很容易出错的点，当函数返回一个指向动态内存的指针的时候，调用者需要自行删除内存。还有在内存被释放之后，应该将指针空，这样可以防止使用被释放了的内存。当同一块内存释放两次，可能会对自由空间造成破坏。</p>
<ul>
<li><p>接受指针参数的只能智能指针的构造函数是explicit的，所以不能将一个内置的指针隐式地转换成智能指针</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; p1 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1024</span>); <span class="comment">// Error!</span></span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt;<span class="built_in">p2</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">42</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同样函数作为返回值的时候也是不能进行隐式转换的</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">clone</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">	<span class="comment">// return new int(p); // Error!</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;<span class="type">int</span>&gt;(<span class="keyword">new</span> <span class="built_in">int</span> (p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在利用智能指针进行传参的时候，不能直接传入一个内置的指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(shared_ptr&lt;<span class="type">int</span>&gt; ptr)</span></span>&#123; <span class="comment">// 智能指针的引用+1，在函数中的引用不会小于2</span></span><br><span class="line">	....</span><br><span class="line">&#125;<span class="comment">// 离开作用域之后，ptr所指向的内存不会被销毁</span></span><br><span class="line"><span class="comment">// 你需要使用一个临时变量进行传参</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;</span><br><span class="line"><span class="built_in">process</span>(p); <span class="comment">// 离开作用域之后p这个临时变量就会被销毁</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>利用get函数能够获得智慧指针的内置指针。</p>
</li>
</ul>
<p><code>永远不要get初始化另一个智能指针或者为另一个智能指针赋值</code>。他们会指向相同的内存</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;</span><br><span class="line"><span class="type">int</span> *q = p.<span class="built_in">get</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li>其他操作<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查p是不是指向该内存的唯一指针，是则重置并分配指针</span></span><br><span class="line"><span class="keyword">if</span>(!p.<span class="built_in">unique</span>())p.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">string</span>(*p));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">smart</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="built_in">int</span>();</span><br><span class="line">    <span class="keyword">auto</span> sp = <span class="built_in">shared_ptr</span>&lt;<span class="type">int</span>&gt;(p);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;address of p: &quot;</span> &lt;&lt; p </span><br><span class="line">        &lt;&lt; <span class="string">&quot;\n addresss of sp:&quot;</span> &lt;&lt; sp  <span class="comment">// p与sp的地址相同 </span></span><br><span class="line">        &lt;&lt; <span class="string">&quot;\n Count:&quot;</span> &lt;&lt; sp.<span class="built_in">use_count</span>() &lt;&lt; endl;  <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<strong>unique_ptr</strong></li>
</ul>
<p>这种指针只能指向一个给定的对象，不支持普通的拷贝或者赋值操作，没有类似<code>make_shared</code>的标准库函数返回一个这样的指针，只能通过绑定到一个new返回的指针上</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转移</span></span><br><span class="line">unique_ptr&lt;<span class="type">int</span>&gt;<span class="built_in">p1</span>(p2.<span class="built_in">release</span>());</span><br><span class="line"><span class="comment">// 或者.reset释放了p1指向的内存</span></span><br><span class="line">p1.<span class="built_in">reset</span>(p2.<span class="built_in">release</span>());</span><br><span class="line">p2.<span class="built_in">release</span>(); <span class="comment">// Error!要释放p2指向的内存</span></span><br></pre></td></tr></table></figure>



<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ul>
<li><p>当结构体很大且需要将结构体作为指针传入到函数中的时候，这时候最好是转入一个结构体指针</p>
</li>
<li><p>C++的函数名表示函数指针，你可以使用这个函数名作为函数的输入参数</p>
</li>
<li><p>C++中不允许<code>main()</code>调用自己，而在C语言中可以</p>
</li>
<li><p>存在递归的函数不能设置为内联函数</p>
</li>
<li><p>应该将默认参数全部放在参数的最后。</p>
</li>
<li><p>使用别名传参（引用传参）的时候，传入的变量会可能会被修改，其效果和传址的方式类似。</p>
</li>
</ul>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>  <span class="title">swap</span> <span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="built_in">swap</span> (a, b);</span><br><span class="line"><span class="comment">//这个时候函数体内的变量和传入的变量是同一个变量</span></span><br></pre></td></tr></table></figure>

<img src="/.com//10/12/C-primer/20211209210853.png" class>
<ul>
<li>**重载解析(Overload Resolution)**： 编译器选择哪一个版本的函数的过程（函数可能经过重载等会有多个同名函数）</li>
</ul>
<h2 id="Object-Oriented-Programming"><a href="#Object-Oriented-Programming" class="headerlink" title="Object-Oriented Programming"></a>Object-Oriented Programming</h2><ul>
<li>在类中定义的任何函数在默认情况下都会被认为是内联函数（内联函数只能在定义它的文件当中使用，但是一些编译器有智能链接器，可以让内联函数在其他文件当中被使用）<u>p517最后一段不是很理解</u><blockquote>
<p><strong>重写逻辑（Rewriting Rule）</strong>：</p>
</blockquote>
</li>
<li>其实类的使用与client-sever模型很相似</li>
<li>如果有一种更好的实现方法，那么你应该仅修改函数的具体实现细节，而不是对应的接口</li>
</ul>
<p><strong>构造函数</strong>：</p>
<ul>
<li>如果没有构造函数，你不能直接对类进行初始化，因为这些数据是仅能进行私有访问的，所以你需要一个能够访问这些私有变量的函数，也就是构造函数。</li>
<li>构造函数不需要返回值类型，名称应该与类名一致，并且构造函数还会在类被定义的时候自动被调用，同时为了避免混淆，构造函数中的参数名称不能与成员变量的名称一致，对于成员变量可以在变量名称前面加上<code>m_</code>或者在名称后面加上<code>_</code></li>
</ul>
<p>构造函数不能直接通过对象直接访问，当构造函数完成它的任务之后，这个对象的构造函数就消失了。</p>
<p><strong>关于构造函数的使用</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Stock food = <span class="built_in">Stock</span>(<span class="string">&quot;World Cabbage&quot;</span>, <span class="number">250</span>, <span class="number">1.25</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">Stock <span class="title">garment</span><span class="params">(<span class="string">&quot;Furry Mason&quot;</span>, <span class="number">50</span>, <span class="number">2.5</span>)</span></span>;</span><br><span class="line">Stock pstock* = <span class="keyword">new</span> <span class="built_in">Stock</span>(<span class="string">&quot;Electroshock Games&quot;</span>, <span class="number">19</span>, <span class="number">19.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// List Initialization</span></span><br><span class="line">Stock hot_tip = &#123;<span class="string">&quot;Derivative Plus Plus&quot;</span>, <span class="number">100</span>, <span class="number">45.0</span>&#125;;</span><br><span class="line">Stock hot_tip&#123;<span class="string">&quot;Derivative Plus Plus&quot;</span>, <span class="number">100</span>, <span class="number">45.0</span>&#125;</span><br><span class="line">Stock temp&#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>在对一个以赋值的类变量进行赋值的时候，编译器会先构造一个临时的变量，然后将内容转移到另一个类变量中，这时候再删除这个变量。一些编译器会让这个临时变量存在一段时间，之后再调用析构函数。下面是一个关于这方面的例子，首先利用一个构造函数创建一个变量，然后对这个变量进行一个重新赋值，这时候，就需要上面的临时变量了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stock stock2 = <span class="built_in">Stock</span>(<span class="string">&quot;Boffo Objects&quot;</span>, <span class="number">2</span>, <span class="number">2.0</span>);  <span class="comment">// Constructor called</span></span><br><span class="line">stock2 = <span class="built_in">Stock</span>(<span class="string">&quot;Nifty Foods&quot;</span>, <span class="number">10</span>, <span class="number">50.0</span>); <span class="comment">// The constructor and destructor for temporary variable will be called</span></span><br></pre></td></tr></table></figure>
<p>所以可以看出，<strong>利用第一种方法直接对变量初始化是一种更加高效的方法</strong>（防止临时变量的出现）。</p>
<p>当程序退出的时候，先声明的变量的构造器会最后被调用，因为这些变量都是存放在一个栈中的。</p>
<p>**<code>const</code> 成员函数 (静态成员变量)**：<br>有时候用一个const关键字修饰了一个类变量，这个变量应该是不能被修改的，但是对于一些函数不能保证不修改这个变量，所以可以在函数后面加上一个<code>const</code>关键字，声明这个函数是不修改静态变量的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// Promises not to change invoking object</span></span><br></pre></td></tr></table></figure>
<p>TIPS：当你声明的成员函数不修改变量的时候，你最好在后面加上一个<code>const</code>关键字。</p>
<h3 id="对象列表"><a href="#对象列表" class="headerlink" title="对象列表"></a>对象列表</h3><p>你可以对列表中的每一个元素分别使用构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> STKS = <span class="number">4</span>;</span><br><span class="line">Stock stocks[STKS] = &#123;</span><br><span class="line">	<span class="built_in">Stock</span>(<span class="string">&quot;NanoSmart&quot;</span>, <span class="number">12.5</span>, <span class="number">20</span>),</span><br><span class="line">	<span class="built_in">Stock</span>(<span class="string">&quot;Boffo Objects&quot;</span>, <span class="number">200</span>, <span class="number">2.0</span>),</span><br><span class="line">	<span class="built_in">Stock</span>(<span class="string">&quot;Monolithic Obelisks&quot;</span>, <span class="number">130</span>, <span class="number">3.25</span>),</span><br><span class="line">	<span class="built_in">Stock</span>(<span class="string">&quot;Fleep Enterprises&quot;</span>, <span class="number">60</span>, <span class="number">6.5</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="this-指针"><a href="#this-指针" class="headerlink" title="this 指针"></a>this 指针</h3><p>一个指向类自己的指针，当一个函数访问私有变量的时候，实际上就是在使用this这个类来访问。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A member function</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; val&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// C-type</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">const</span> Stock*<span class="keyword">this</span>)</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="keyword">this</span>-&gt;val&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Class-Scope-Constants"><a href="#Class-Scope-Constants" class="headerlink" title="Class Scope Constants"></a>Class Scope Constants</h3><p>属于这个类的常量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">enum</span> &#123;Months=<span class="number">12</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种声明不会创建类数据成员。</p>
<p>第二种定义类内常量的方式——使用关键词<code>static</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bakery</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">const</span> <span class="type">int</span> Months = <span class="number">12</span>;</span><br><span class="line">	....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="拥有类作用域的枚举类型（C-11）"><a href="#拥有类作用域的枚举类型（C-11）" class="headerlink" title="拥有类作用域的枚举类型（C++11）"></a>拥有类作用域的枚举类型（C++11）</h3><p>在通常的枚举类型中，其中的枚举变量的名称不能一致，因为两个不同的枚举变量之间的作用域是一致的，但是在C++11中，提供了一种拥有类作用域的枚举类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">egg</span>&#123;Small, Medium, Large, Jumbo&#125;;</span><br><span class="line">egg choice = egg::Larger;</span><br></pre></td></tr></table></figure>
<p>但是不像传统的枚举类型，类枚举类型不能进行隐式类型转换。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">egg_old</span> &#123;Small, Medium, Large, Jumbo&#125;; <span class="comment">// unscoped</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">t_shirt</span> &#123;Small, Medium, Large, Xlarge&#125;; <span class="comment">// scoped</span></span><br><span class="line">egg_old one = Medium; <span class="comment">// unscoped</span></span><br><span class="line">t_shirt rolf = t_shirt::Large; <span class="comment">// scoped</span></span><br><span class="line"><span class="type">int</span> king = one; <span class="comment">// implicit type conversion for unscoped</span></span><br><span class="line"><span class="type">int</span> ring = rolf; <span class="comment">// not allowed, no implicit type conversion</span></span><br><span class="line"><span class="keyword">if</span> (king &lt; Jumbo) <span class="comment">// allowed</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Jumbo converted to int before comparison.\n&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (king &lt; t_shirt::Medium) <span class="comment">// not allowed</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Not allowed: &lt; not defined for scoped enum.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是可以进行显示类型转换</span></span><br><span class="line"><span class="type">int</span> Frodo = <span class="built_in">int</span>(t_shirt::Small);</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以指定其中变量的类型</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">class</span> : <span class="type">short</span> pizza &#123;Small, Medium, Large, XLarge&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="输入输出方面的命令"><a href="#输入输出方面的命令" class="headerlink" title="输入输出方面的命令"></a>输入输出方面的命令</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">getline</span>(cin, string_var); <span class="comment">// 读取整行，包括前导和嵌入的空格（应该是遇到&quot;\n&quot;时结束）</span></span><br><span class="line">cin &gt;&gt; char_variable; <span class="comment">// 从第一个非空格开始阅读，当读取到下一个空白字符时，停止读取</span></span><br><span class="line">cin.<span class="built_in">get</span>(); <span class="comment">// cin对象的内置函数，获取一个字符，并返回（赋值的方式）</span></span><br><span class="line"><span class="comment">/*对于这个函数，可以用于暂停程序的一个方法（按下回车以继续）*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// What are the differences they make ?</span></span><br></pre></td></tr></table></figure>

<h2 id="Separate-Compilation"><a href="#Separate-Compilation" class="headerlink" title="Separate Compilation"></a>Separate Compilation</h2><p>在编写大型程序的时候，最好将程序放在三个文件当中。</p>
<ul>
<li>一个是头文件，这个用于存储函数头和一些结构体的声明，但是不能定义一些具体的变量，因为这个头文件可能会被不同的程序文件所包含，这使得头文件可能会被反复编译，这可能会导致重定义的问题。</li>
<li>一个是用于定义函数的文件。</li>
<li>一个是主程序文件，这个文件中包含main文件。</li>
</ul>
<p><strong>守卫</strong>：为了防止一些变量被反复编译，C++中定义了守卫</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># ifndefine FUNCTION_NAME</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> FUNCTION_NAME</span></span><br><span class="line">....<span class="comment">// Your code</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>当存在多个程序文件的时候，程序就会进行联合编译。在window中直接运行即可，但是在UNIX系统中需要指定联合编译的文件。(在Linux系统中只需要执行其中一个文件即可，这是用include语句包含了对应的文件)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CC file1.cpp file2.cpp</span><br><span class="line"></span><br><span class="line">g++ file1.cpp file2.cpp</span><br></pre></td></tr></table></figure>

<p>在包含文件的时候，不同的标点符号会使得程序查找文件的范围顺序有所差异</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;file&gt;</span>  <span class="comment">//在系统文件中寻找</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&quot;file&quot;</span>  <span class="comment">// 优先在当前路径下查找文件</span></span></span><br></pre></td></tr></table></figure>
<h2 id="Storage-Duration-Scope-and-Linkage"><a href="#Storage-Duration-Scope-and-Linkage" class="headerlink" title="Storage Duration, Scope, and Linkage"></a>Storage Duration, Scope, and Linkage</h2><p>C++中的常见变量的生命周期：</p>
<ol>
<li><strong>Automatic storage duration</strong> ： 在函数中定义的变量，当函数结束的时候，变量会被释放</li>
<li><strong>Static storage duration</strong>： 在函数外或者其他地方定义的变量，当程序结束的时候被释放</li>
<li><strong>Thread storage duration (C++11)</strong> ： 生命周期局限于某一个线程</li>
<li><strong>Dynamic storage duration</strong> ： 由关键字<code>new</code>申请的空间，生命周期由操作者确定，或者在程序结束的时候被释放</li>
</ol>
<h3 id="变量的作用域（Scope）"><a href="#变量的作用域（Scope）" class="headerlink" title="变量的作用域（Scope）"></a>变量的作用域（Scope）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> outter = <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">		<span class="type">int</span> outter = <span class="number">10</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;The inner = &quot;</span> &lt;&lt; outter &lt;&lt; endl; <span class="comment">// 这里的outter与外部的无关</span></span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;The outer = &quot;</span> &lt;&lt; outter &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* The inner = 10</span></span><br><span class="line"><span class="comment">The outer = 100*/</span></span><br></pre></td></tr></table></figure>
<p>在函数内部出现与全局变量一致的变量，这个时候函数内的这个变量会是局部变量，想要访问全局变量需要使用作用域解析运算符<code>::</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> warming = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">local</span> <span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">double</span> warming = <span class="number">5</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Local = &quot;</span>&lt;&lt; warming&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Global = &quot;</span>&lt;&lt; :: warming &lt;&lt; endl;  <span class="comment">// 访问全局变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器是通过利用栈将这些变量的优先级进行调整的，当进入一个函数的时候，声明的变量会出现在栈顶端，这时候条用这个变量的时候就会优先调用这个函数内的局部变量。<br>全局变量应该仅仅被使用于一些通用的变量</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> months[<span class="number">12</span>] =</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;January&quot;</span>, <span class="string">&quot;February&quot;</span>, <span class="string">&quot;March&quot;</span>, <span class="string">&quot;April&quot;</span>, <span class="string">&quot;May&quot;</span>,</span><br><span class="line"><span class="string">&quot;June&quot;</span>, <span class="string">&quot;July&quot;</span>, <span class="string">&quot;August&quot;</span>, <span class="string">&quot;September&quot;</span>, <span class="string">&quot;October&quot;</span>,</span><br><span class="line"><span class="string">&quot;November&quot;</span>, <span class="string">&quot;December&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里第二个const是为了保证数组不被改变，第一个是为了使得数组内的指针所指向的元素</span></span><br><span class="line"><span class="comment">不会发生改变</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这样理解：第一个const实际上是得到一个类型const char* 这代表数组元素，第二个修饰数组</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><code>const</code>关键词实际上就是在表明变量的<strong>内存</strong>一旦确定之后在之后就不应该被改变了<br>在联合编译的时候，一个文件中定义的全局变量会在另外一个文件中被访问到，这时候可以使用<code>static</code>关键词，这使得这个变量仅仅存在于当前文件中。</p>
<blockquote>
<p>在Ubuntu上面没有办法成功编译！</p>
</blockquote>
<p>在函数内定义变量时加上这个关键词，则可以使得这个变量在整个文件中都能够被访问到。<br>当这个关键词被加上之后，这个变量当且仅当被定义的时候初始化为0，其余的时候这其中的值不会被初始化。</p>
<h4 id="volatile关键词"><a href="#volatile关键词" class="headerlink" title="volatile关键词"></a>volatile关键词</h4><p>当一个变量多次被使用的时候，编译器会将这个变量放到寄存器中，也就是说编译器会为了系统的优化改动定义的变量存储的地址。如果加上<code>volatile</code>关键词，那么这种改动就不会发生</p>
<h4 id="mutable"><a href="#mutable" class="headerlink" title="mutable"></a>mutable</h4><p>在一个<code>const</code>修饰的变量中，被<code>mutable</code>修饰的成员变量还是能够被修改.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">data</span>&#123;</span><br><span class="line">	<span class="keyword">mutable</span> <span class="type">int</span> data;</span><br><span class="line">	<span class="type">float</span> value;</span><br><span class="line">&#125;</span><br><span class="line">data d = &#123;<span class="number">10</span>, <span class="number">10.23</span>&#125;</span><br><span class="line">d.data = <span class="number">20</span>; <span class="comment">// Allow</span></span><br><span class="line">d.value = <span class="number">10.20</span>; <span class="comment">// Disallow</span></span><br></pre></td></tr></table></figure>
<h4 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h4><p><code>extern</code> 修饰的变量不能直接初始化。<br>但是如果想用常量作为具有外部链接的变量，那么可以使用<code>const</code>重载这个修辞</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="keyword">extern</span> <span class="type">int</span> con = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<h3 id="Functions-and-Linkage"><a href="#Functions-and-Linkage" class="headerlink" title="Functions and Linkage"></a>Functions and Linkage</h3><p>由于C++中不允许一个函数在另外一个函数中定义，所以，所有的函数的作用域都是静态存储的周期（当程序结束时被释放）。但是你可以在函数原型前面加上一些关键词来指定函数的作用域（像<code>extern</code>、<code>static</code>等）<br>在默认的情况下，函数都是有外部链接的，也就是说联合编译中，其他文件是可以调用不同文件中的函数的。但是要调用其他文件中的函数还是需要包含所使用函数的函数原型。<br>编译器查找的方式是根据函数原型的作用域确定查找范围的。如果你在文件中定义了一个与外部函数有相同名称的函数，那么最终的这个内部链接的函数还覆盖外部链接的函数。</p>
<h3 id="Language-Linking"><a href="#Language-Linking" class="headerlink" title="Language Linking"></a>Language Linking</h3><p>编译器在链接的过程中需要为每一个不同的函数找一个不同的符号名称（symbolic name）。在C语言中，因为函数不允许重载，所以可以在函数名称前面简单地加上一个下划线即可，但是由于在C++中存在函数的重载，所以需要正在这个符号语言中加上函数的参数信息。例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spiff(double, double) to _spiff_d_d</span><br></pre></td></tr></table></figure>
<p>如果我们需要在C++中使用C语言中的函数，我们可以显式地指定这种符号名称的类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">void</span> <span class="title">spiff</span><span class="params">(<span class="type">int</span>)</span></span>; <span class="comment">// use C protocol for name look-up</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">spoff</span><span class="params">(<span class="type">int</span>)</span></span>; <span class="comment">// use C++ protocol for name look-up</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C++&quot;</span> <span class="function"><span class="type">void</span> <span class="title">spaff</span><span class="params">(<span class="type">int</span>)</span></span>; <span class="comment">// use C++ protocol for name look-up</span></span><br></pre></td></tr></table></figure>

<h3 id="Storage-Schemes-and-Dynamic-Allocation"><a href="#Storage-Schemes-and-Dynamic-Allocation" class="headerlink" title="Storage Schemes and Dynamic Allocation"></a>Storage Schemes and Dynamic Allocation</h3><p>编译器会为不同的变量划分出三个不同的内存，分别是：<code>静态变量区</code>、<code>局部变量区（automatic variable）</code>、<code>动态变量区</code>。但是，编译器会适应静态变量存储区或者局部变量区的内存跟踪动态变量区的变量（也就是指针）。</p>
<blockquote>
<p>虽然说动态生成的数据的存储空间在程序结束的时候会自动被释放掉，但是对于一些健壮性不是很好的操作系统，这个自动过程可能不会自动执行，所以还是最好使用<code>delete</code>将<code>new</code>出来的变量删掉。</p>
</blockquote>
<p>动态变量的初始化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *a = <span class="keyword">new</span> <span class="built_in">int</span> (<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">name</span>&#123;<span class="type">int</span> x; <span class="type">int</span> y; <span class="type">int</span> z&#125;;</span><br><span class="line"></span><br><span class="line">name* n = <span class="keyword">new</span> name&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;  <span class="comment">// 初始化结构体</span></span><br></pre></td></tr></table></figure>
<p><code>new</code>、<code>delete</code>是可以被替换的，所以你可以根据自己的需求对这两个函数进行调整。<br>你可以指定申请变量的存储的地址</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;new&gt;</span></span></span><br><span class="line"><span class="type">char</span> buffer[<span class="number">100</span>]; <span class="comment">// 在静态变量区申请的内存</span></span><br><span class="line"><span class="type">int</span>* a = <span class="built_in">new</span> (buffer) <span class="type">double</span> [<span class="number">10</span>]; <span class="comment">// 申请的变量会被存储在指定的内存区域</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是最终不能使用delete删除，这会导致错误。这是因为变量申请的空间是在静态变量空间中，而delete只能删除动态变量空间</span></span><br></pre></td></tr></table></figure>
<p>传统的<code>new</code>会存储之前可用的内存的位置，或者搜索可用的内存，但是可替换的<code>new</code>不会检查当前的内存是否被占用，也不存储之前可用的内存的位置信息。<br>实际上可替换的<code>new</code>只是简单地将传入的地址的类型转换成<code>void*</code>使得输出的地址能够分配给任意类型的指针。</p>
<h3 id="名字域"><a href="#名字域" class="headerlink" title="名字域"></a>名字域</h3>
<p>在每一个定义区域中各个变量之间的定义不会发生冲突。</p>
<img src="/.com//10/12/C-primer/Scope.png" class>
<p>作用域，指的是在变量定义之后的区域，也就是程序中可以使用这个变量的区域。不同的定义区域中的变量的作用域不会发生冲突。</p>
<p>使用关键字<code>namespace</code>定义自己的名字域,这些名字域中可以包含函数或者其他名字域，也可以自己在里面定义一个名字域。由于为了防止直接导入一些不需要的变量可能导致的问题，你可以使用名字域解析运算符或者指定导入变量的方式。也可以自定义一个名字域，在其中放入自己常用的函数或变量。</p>
<p>将名字域导入到当前的定义域中的方法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Name&#123;</span><br><span class="line">	<span class="type">int</span> age = <span class="number">20</span>;</span><br><span class="line">	string first;</span><br><span class="line">	string second;</span><br><span class="line">	<span class="function">string <span class="title">Concatenate</span><span class="params">(string a, string b)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a + b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">using</span> std::out;</span><br><span class="line">	<span class="keyword">using</span> std::endl;</span><br><span class="line">	<span class="keyword">namespace</span> life&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给名字域起一个别名</span></span><br><span class="line"><span class="keyword">namespace</span> n = Name::life</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="built_in">func</span>()&#123;</span><br><span class="line">	<span class="comment">// using declaration</span></span><br><span class="line">	<span class="keyword">using</span> Name::first;</span><br><span class="line">	<span class="comment">//这种方式就是将这个变量导入到当前的定义域中，这时候first不能再次被定义</span></span><br><span class="line">	<span class="comment">// 有时候利用这种方式导入，可能会导致冲突，编译器会避免这种导入</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> age = <span class="number">25</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">// using directive</span></span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> Name; <span class="comment">// 导入到当前定义域，其他的定义域中不能使用这个名字域 </span></span><br><span class="line">	<span class="type">int</span> age = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; age &lt;&lt; Name::age &lt;&lt; ::age; <span class="comment">// 10 20 25</span></span><br><span class="line">	<span class="comment">//这种方式导入，当前的定义域可以直接使用名字域中所有的变量，但是其中的变量没有局部作用域，所以可以被覆写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于名字域的定义不一定需要指定名字。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接下来的代码都能够使用这里的变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> count;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意一点，静态变量不是不能修改，而是只会初始化一次。之后在遇到初始化的语句就会直接被忽略。</p>
</blockquote>
<h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><ul>
<li>在使用模板的时候，如果出现比较，那么比较的东西可能会与预期的不太一致。还有在赋值的时候可能会出现数值和地址之间的冲突。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T c = a*b <span class="comment">// 这时候c可能会被赋予一个新的地址</span></span><br></pre></td></tr></table></figure>
当你想要对模板类型进行具体化的时候，可以采用以下策略：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">maxn</span><span class="params">(T arr[], <span class="type">int</span> n)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="type">char</span>* <span class="built_in">maxn</span>&lt;<span class="type">char</span>*&gt;(<span class="type">char</span>* arr[], <span class="type">int</span> n)&#123;&#125;  <span class="comment">// &lt;char*&gt;是可以忽略的</span></span><br></pre></td></tr></table></figure>
 在对模板类型进行具体化的时候，这个过程称为Implicit Instantiation,但是C++提供了显示初始化Explicit Instantiation. <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> <span class="type">void</span> <span class="built_in">Swap</span>&lt;<span class="type">int</span>&gt;(<span class="type">int</span> &amp;, <span class="type">int</span> &amp;);</span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="type">void</span> <span class="title">Swap</span><span class="params">(<span class="type">int</span> &amp;, <span class="type">int</span> &amp;)</span></span>;</span><br></pre></td></tr></table></figure>
 当输入的变量类型不一致的时候，使用模板的函数可能会报错，这时候需要显示实例化 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function">T <span class="title">Add</span><span class="params">(T a, T b)</span> <span class="keyword">return</span> a + b</span>;</span><br><span class="line"><span class="type">int</span> m = <span class="number">6</span>;</span><br><span class="line"><span class="type">double</span> x = <span class="number">10.2</span>;</span><br><span class="line">cout &lt;&lt; <span class="built_in">Add</span>&lt;<span class="type">double</span>&gt;(x,m) &lt;&lt; endl;  <span class="comment">// 不实例化会导致报错 p429</span></span><br></pre></td></tr></table></figure>
 上述概念的使用场景：</li>
<li>隐式具体化—模板类型的自动推断</li>
<li>显示具体化—自定义类型的参数必须使用（？）</li>
<li>显示实例化—实例化参数 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span> <span class="params">(T &amp;, T &amp;)</span></span>; <span class="comment">// template prototype</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="type">void</span> <span class="built_in">Swap</span>&lt;job&gt;(job &amp;, job &amp;); <span class="comment">// explicit specialization for job</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">template</span> <span class="type">void</span> <span class="built_in">Swap</span>&lt;<span class="type">char</span>&gt;(<span class="type">char</span> &amp;, <span class="type">char</span> &amp;); <span class="comment">// explicit instantiation for char</span></span><br><span class="line"><span class="type">short</span> a, b;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">Swap</span>(a,b); <span class="comment">// implicit template instantiation for short</span></span><br><span class="line">job n, m;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">Swap</span>(n, m); <span class="comment">// use explicit specialization for job</span></span><br><span class="line"><span class="type">char</span> g, h;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">Swap</span>(g, h); <span class="comment">// use explicit template instantiation for char</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>我们想让一个函数能够调用其他函数。这需要完成以下三个步骤：</p>
<ol>
<li>获取函数的地址 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">process</span>(<span class="built_in">think</span>())  <span class="comment">// 将函数的返回值作为传入参数</span></span><br><span class="line"><span class="built_in">process</span>(think)   <span class="comment">// 将函数的地址作为参数</span></span><br></pre></td></tr></table></figure></li>
<li>定义指向函数的指针<blockquote>
<p>函数签名（function’s signature）: 函数的参数列表<br>C++中的<strong>函数签名</strong>(function signature)：包含了一个<strong>函数</strong>的信息，包括<strong>函数</strong>名、参数类型、参数个数、顺序以及它所在的类和命名空间。（这是为了帮助编译器准确地找到想要访问的函数）</p>
</blockquote>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">pam</span><span class="params">(<span class="type">int</span>)</span></span>;  <span class="comment">// Function Prototype</span></span><br><span class="line"><span class="built_in">double</span> (*pf) (<span class="type">int</span>); <span class="comment">// 指针pf指向一个输入参数为int，输出为double的函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*本质上就是将函数名用(*pf)进行代替了，这里还利用了括号的具有更高优先级的特性，指明这里是一个指</span></span><br><span class="line"><span class="comment">针，如果pf没有括号，那么就变成一个函数了*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">estimate</span><span class="params">(<span class="type">int</span> lines, <span class="type">double</span>(*pf)(<span class="type">int</span>))</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>在函数中使用函数指针<br>可以通过函数名或者函数指针访问函数。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> x = <span class="built_in">pam</span>(<span class="number">4</span>);  <span class="comment">// Prefer</span></span><br><span class="line"><span class="type">double</span> x = (*pf)(<span class="number">5</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="函数指针可能遇到的问题"><a href="#函数指针可能遇到的问题" class="headerlink" title="函数指针可能遇到的问题"></a>函数指针可能遇到的问题</h3><p>定义以下函数的函数指针会不会重名？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">double</span> * <span class="title">f1</span><span class="params">(<span class="type">const</span> <span class="type">double</span> ar[], <span class="type">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">double</span> * <span class="title">f2</span><span class="params">(<span class="type">const</span> <span class="type">double</span> [], <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">double</span> * <span class="title">f3</span><span class="params">(<span class="type">const</span> <span class="type">double</span> *, <span class="type">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>向函数中传入一个数组和传入一个指针是等价的.</li>
<li>在函数原型中，参数的名称是可以忽略的，“const double []”就是忽略了数组的名称<br>所以上述的三个函数是一致的</li>
</ol>
</blockquote>
<p>在对函数指针进行初始化的时候，可以利用C++11的新特性，auto自动推断对应的类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> * (*p1)(<span class="type">const</span> <span class="type">double</span> *, <span class="type">int</span>) = f1;</span><br><span class="line"><span class="comment">// Equivelent to</span></span><br><span class="line"><span class="keyword">auto</span> p2 = f2;</span><br></pre></td></tr></table></figure>

<p><strong>定义一个函数指针数组</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> * (*pa[<span class="number">3</span>])(<span class="type">const</span> <span class="type">double</span> *, <span class="type">int</span>) = &#123;f1, f2, f3&#125;;</span><br></pre></td></tr></table></figure>
<p>分析中括号的作用： 因为中括号的优先级比较高，所以中括号优先指明这个名称是个数组</p>
<blockquote>
<p>Automatic type deduction works with a single initializer value, not an initialization list.也就是说这里前面的指针定义不能用auto代替（因为初始化的是一个数组）。但是我们能够用auto推断数组指针类型</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pb = pa;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>数组名<code>a</code>表示的是数组的第一个元素的地址，<code>&amp;a</code>表示的所有数组所有元素的地址，<code>&amp;a+1</code>就表示下一个数组（是不是一个保存数组每一个元素的地址的数组？）</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">	<span class="type">int</span> a[<span class="number">3</span>]&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;\t&amp;a:&quot;</span> &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;size of a:&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; <span class="string">&quot;\tsize of &amp;a:&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(&amp;a) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a + 1:&quot;</span> &lt;&lt; a + <span class="number">1</span> &lt;&lt; <span class="string">&quot;\t&amp;a+1&quot;</span> &lt;&lt; &amp;a + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">a:00AFFCA4      &amp;a:00AFFCA4</span></span><br><span class="line"><span class="comment">size of a:12    size of &amp;a:4</span></span><br><span class="line"><span class="comment">a + 1:00AFFCA8  &amp;a+1:00AFFCB0  这里增加了C，也就是12</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 可见</span></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/12/STL%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/12/STL%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">STL和泛型编程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-12 19:46:55 / Modified: 20:00:22" itemprop="dateCreated datePublished" datetime="2022-10-12T19:46:55+08:00">2022-10-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1-认识header、版本、重要资源"><a href="#1-认识header、版本、重要资源" class="headerlink" title="1. 认识header、版本、重要资源"></a>1. 认识header、版本、重要资源</h3><p>头文件命名形式：</p>
<ul>
<li>C++标准库header files 不带（.h）</li>
<li>新型的C头文件不带.h</li>
<li>原先的C头文件(带有.h)的，仍旧可以使用（但是最好还是使用最新的形式）</li>
<li>所有的新式headers都在名字域“std”中</li>
<li>旧式的头文件不被包含在“std”中</li>
</ul>
<h3 id="2-STL体系结构基础介绍"><a href="#2-STL体系结构基础介绍" class="headerlink" title="2.STL体系结构基础介绍"></a>2.STL体系结构基础介绍</h3><p>STL的六大部件：</p>
<ul>
<li>容器</li>
<li>分配器</li>
<li>算法</li>
<li>迭代器</li>
<li>适配器</li>
<li>仿函数(Functors)</li>
</ul>
<img src="/.com//10/12/STL%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/20220915211226.png" class>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;vector&gt;</span>  <span class="comment">// 与容器同名</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> ia[<span class="number">6</span>] = &#123;<span class="number">27</span>, <span class="number">210</span>, <span class="number">12</span>, <span class="number">47</span>, <span class="number">109</span>, <span class="number">83</span>&#125;;</span><br><span class="line">	vector&lt;<span class="type">int</span>, allocator&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">vi</span>(ia, ia+<span class="number">6</span>);<span class="comment">// 分配器用于分配内存（一般默认）</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	count_if: algorithm;</span></span><br><span class="line"><span class="comment">	not1: function adapter(negator);</span></span><br><span class="line"><span class="comment">	bind2nd: 绑定第二参数，function adapter(binder)</span></span><br><span class="line"><span class="comment">	less: function object</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; <span class="built_in">count_if</span>(vi.<span class="built_in">begin</span>(), vi.<span class="built_in">end</span>(),</span><br><span class="line">				<span class="built_in">not1</span>(<span class="built_in">bind2nd</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(), <span class="number">40</span>)));  <span class="comment">// 大于等于40</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>标准库中的容器都是前开后闭的。但是容器的end()方法指向的是容器最后的元素的下一个元素，所以直接将这个指针解引用出来，得到的是一个未知的东西。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Container&lt;T&gt; c;</span><br><span class="line">....</span><br><span class="line">Container&lt;T&gt;::iterator ite = c.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span>(; ite != c.<span class="built_in">end</span>(); ++ite)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++11</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; elem : c)&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-6-容器分类与各种测试"><a href="#3-6-容器分类与各种测试" class="headerlink" title="3~6. 容器分类与各种测试"></a>3~6. 容器分类与各种测试</h3><p>标准库中的集合和map一般用红黑树实现。</p>
<blockquote>
<p>代码习惯：测试程序放在名字域中，对应的库放在对应的名字域中，对应的定义变量需要的时候再写，为了注明，定义变量不会进行缩进。</p>
</blockquote>
<p><strong>vector</strong>： 对于空间扩充是呈现两倍增长的。这个增长是通过找到一个新的内存，然后将原先的元素全部复制到这个新的空间中，所以这个增长的过程实际上是比较缓慢的。</p>
<p><code>deque</code> : 分段，但是逻辑上是连续的。没有自己的sort</p>
<p>关联式容器查找都非常快</p>
<p><code>multiset</code>:内部是红黑树实现的,可以包含重复元素</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">multiset&lt;string&gt;c;</span><br></pre></td></tr></table></figure>
<p><code>multimap</code>:不可以使用<code>[]</code>作为插入</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">multimap&lt;<span class="type">long</span>, string&gt;c;</span><br><span class="line">c.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">long</span>, string&gt;(i, buf));</span><br><span class="line"><span class="comment">// 访问需要使用first &amp; second</span></span><br></pre></td></tr></table></figure>
<p><code>unordered_multiset</code>:散列表实现的（哈希表）</p>
<p><code>set</code>: 不会出现重复的元素</p>
<p><code>map</code>: 底层实现是红黑树， 可以使用<code>[]</code>添加元素，key不重复，value是有重复的</p>
<h3 id="7-分配器测试"><a href="#7-分配器测试" class="headerlink" title="7. 分配器测试"></a>7. 分配器测试</h3><p>分配器用于内存分配</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p;</span><br><span class="line">__gnu_cxx::malloc_allocator&lt;<span class="type">int</span>&gt; alloc;</span><br><span class="line">p = alloc.<span class="built_in">allocate</span>(<span class="number">1</span>);</span><br><span class="line">alloc.<span class="built_in">deallocate</span>(p, <span class="number">1</span>);  <span class="comment">// 不建议使用，需要记住申请的内存的大小（用于空间释放）</span></span><br></pre></td></tr></table></figure>

<h3 id="8-源代码分布"><a href="#8-源代码分布" class="headerlink" title="8.源代码分布"></a>8.源代码分布</h3><h3 id="9-OOP-amp-泛化编程"><a href="#9-OOP-amp-泛化编程" class="headerlink" title="9. OOP &amp; 泛化编程"></a>9. OOP &amp; 泛化编程</h3><p>泛化编程是将数据和方法分开来了。容器与算法（方法）之间通过迭代器相互关联。 </p>
<blockquote>
<p>为什么list不能使用<code>::sort()</code>?<br>因为<code>::sort()</code>中使用的迭代器指针需要是能够随机访问的（能前能后），但是在list中，这种性质不满足。</p>
</blockquote>
<p><strong>特化</strong><br>模板在特定类型的时候使用特定的方法（更优的）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">type</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__type_traits</span>&#123;</span><br><span class="line">	....</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">__type_traits</span>&lt;<span class="type">int</span>&gt;&#123;</span><br><span class="line">	....</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">__type_traits</span>&lt;<span class="type">double</span>&gt;&#123;</span><br><span class="line">	....</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 偏特化，如果传入的是一个指针（范围上的偏特化）</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">type</span>&gt; <span class="keyword">struct</span> <span class="title class_">__type_traits</span>&lt;type*&gt;&#123;</span><br><span class="line">	....</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt;</span><br><span class="line"><span class="keyword">class</span> vector&#123;</span><br><span class="line">	....</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 偏特化：仅将其中一个模板参数进行特化（数量上的局部）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">vector</span>&lt;<span class="type">bool</span>, Alloc&gt;</span><br><span class="line">&#123;</span><br><span class="line">	....</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="11-分配器"><a href="#11-分配器" class="headerlink" title="11.分配器"></a>11.分配器</h3><p><code>malloc</code>申请内存的时候是有额外的开销的（其中包括了申请的空间的大小）。当申请的空间比较小的时候，这种开销占比比较大<br>在VC6的allocator中知识以<code>::operator new</code> 和 <code>::operator delete</code> 完成allocate() 和 deallocate() 没有特殊设计。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _FARQ</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> _FARQ</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> _PDFT ptrdiff_t</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> _SIZT  size_t</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _POINTER_X(T, A) T_FARQ*</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _REFFERENCE_X(T, A) T_FARQ&amp;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>&gt; <span class="keyword">inline</span></span><br><span class="line">_Ty _FARQ* _Allocate(_PDFT _N, _Ty _FARQ*)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(_N &lt; <span class="number">0</span>) _N = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ((_Ty _FARQ*) <span class="keyword">operator</span> <span class="built_in">new</span>((_SIZT)_N*<span class="built_in">sizeof</span>(_Ty)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">allocator</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> _SIZT size_type;</span><br><span class="line">    <span class="keyword">typedef</span> _PDFT difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Ty _FARQ * pointer;</span><br><span class="line">    <span class="keyword">typedef</span> _Ty value_type;</span><br><span class="line">    <span class="function">pointer <span class="title">allocate</span><span class="params">(size_type _N, <span class="type">const</span> <span class="type">void</span>*)</span> <span class="comment">// 第二个是任意参数</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> (_Allocate((difference_type) _N, (pointer)<span class="number">0</span>)); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deallocate</span><span class="params">(<span class="type">void</span> _FARQ *_P, size_type)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(_P)</span></span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配512 ints</span></span><br><span class="line"><span class="type">int</span>* p = <span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">allocate</span>(<span class="number">512</span>, (<span class="type">int</span>*<span class="number">0</span>));</span><br><span class="line"><span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">deallocate</span>(p, <span class="number">512</span>);  <span class="comment">// 用临时变量调用类方法</span></span><br></pre></td></tr></table></figure>
<p>这种方式可能会导致太大的额外开销，所以，一些改进的方法是一次申请固定倍数大小的空间，这样可以减少malloc的使用（与vector中的空间拓展思想类似）</p>
<h3 id="13、14-list源代码"><a href="#13、14-list源代码" class="headerlink" title="13、14. list源代码"></a>13、14. list源代码</h3><blockquote>
<p>i++ 和 ++i<br>因为符号一样，所以给后置版本加一个int形参作为区分，这个形参是0，但是在函数体中是用不到的，只是为了区分前置后置。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self <span class="keyword">operator</span>++(<span class="type">int</span>) &#123; ... &#125; <span class="comment">// i++</span></span><br><span class="line">self <span class="keyword">operator</span>++() &#123; ... &#125; <span class="comment">// ++i （可以认为i作为参数已经传入了）</span></span><br></pre></td></tr></table></figure>
<p>另外整数不能连续进行两次后连加，可以前加（++++i √，i++++ × ）</p>
</blockquote>
<p>为了满足容器前闭后开的性质，在list链表中会有一个空白的头节点，这个就是end指针指向的节点，其内部实际上是一个环形双向链表。</p>
<h3 id="15-Iterator-必须提供的5种相关类别"><a href="#15-Iterator-必须提供的5种相关类别" class="headerlink" title="15. Iterator 必须提供的5种相关类别"></a>15. Iterator 必须提供的5种相关类别</h3><ul>
<li>iterator_category</li>
<li>value_type</li>
<li>pointer</li>
<li>reference</li>
<li>difference_type</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">I</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::reference;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>萃取机（iterator_traits）</strong>: 用于分离class iterator 和 non-class iterator。这是用过偏特化实现的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;calss I&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type value_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两种偏特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;T*&gt;&#123;</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;<span class="type">const</span> T*&gt;&#123;</span><br><span class="line">	<span class="keyword">typedef</span> T value_type; <span class="comment">// 不能用const T，因为这样声明的变量无法赋值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取I的value_type</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> I, ...&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">algorithmn</span><span class="params">(...)</span></span>&#123;</span><br><span class="line">	<span class="keyword">typename</span> iterator_traits&lt;I&gt;::value_type v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个实例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;T*&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> T* pointer;</span><br><span class="line">    <span class="keyword">typedef</span> T&amp; reference;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="16-vector深度探索"><a href="#16-vector深度探索" class="headerlink" title="16.vector深度探索"></a>16.vector深度探索</h3><img src="/.com//10/12/STL%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/20220921095514.png" class>
<p>在进行扩充的时候，需要重新申请空间，并且原先的空间将会被销毁，这使得这个过程中需要调用大量的构造函数和析构函数。</p>
<p>如果是连续空间，那么这个容器的迭代器就可以单纯地使用指针来表现。</p>
<h3 id="17-array、forward-list-深度探索"><a href="#17-array、forward-list-深度探索" class="headerlink" title="17. array、forward_list 深度探索"></a>17. array、forward_list 深度探索</h3><p>在特化array的时候，需要指明大小，这是因为array的大小是固定的，它没有构造器和析构器。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>, 10&gt; myArray;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义数组</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">100</span>]; <span class="comment">// √</span></span><br><span class="line"><span class="comment">//int[100] a;  // ×</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> T[<span class="number">100</span>];</span><br><span class="line">T c;  <span class="comment">// √</span></span><br></pre></td></tr></table></figure>

<h3 id="18，19-deque、queue和stack深度探索"><a href="#18，19-deque、queue和stack深度探索" class="headerlink" title="18，19. deque、queue和stack深度探索"></a>18，19. deque、queue和stack深度探索</h3><p><strong>deque</strong>：这个容器的地址是由几个内存段产生的，用一个向量存储每一个内存段的首地址。对于迭代器，是由一个类组成，其中包含当前内存块的边界，当前指针指向的元素，以及当前内存块在地址向量中的位置</p>
<img src="/.com//10/12/STL%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/20220921134657.png" class>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里会找到离边界最近的方向移动元素</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="type">const</span> value_type&amp; x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(position.cur == start.cur)&#123;  <span class="comment">// 是否是在开头</span></span><br><span class="line">        <span class="built_in">push_front</span>(x);</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(position.cur == finish.cur)&#123;<span class="comment">// 是否是在尾部 </span></span><br><span class="line">        <span class="built_in">push_back</span>(x);</span><br><span class="line">        iterator tmp = finish;</span><br><span class="line">        --tmp;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">insert_aux</span>(position, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> BufSize&gt;</span><br><span class="line"><span class="keyword">typename</span> deque&lt;T, Alloc, BufSize&gt;::iterator</span><br><span class="line">deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">insert_aux</span>(iterator pos, <span class="type">const</span> value_type)&#123;</span><br><span class="line">	difference_type index = pos - start;</span><br><span class="line">	value_type x_copy = x;</span><br><span class="line">	<span class="keyword">if</span>(index &lt; <span class="built_in">size</span>()/<span class="number">2</span>)&#123;  <span class="comment">// 检查是否小于中点</span></span><br><span class="line">		<span class="built_in">push_front</span>(<span class="built_in">front</span>()); <span class="comment">//复制第一个元素</span></span><br><span class="line">		...</span><br><span class="line">		<span class="built_in">copy</span>(front2, pos1, front1);  <span class="comment">// 全部往前移动</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">push_back</span>(<span class="built_in">back</span>());</span><br><span class="line">		....</span><br><span class="line">		<span class="built_in">copy_backward</span>(pos, back2, back1);</span><br><span class="line">	&#125;</span><br><span class="line">	*pos = x_copy;</span><br><span class="line">	<span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模拟连续空间，累加，<code>[]</code>，向前移动$n$元素</p>
<p>在stack和queue中，默认一个deque。 这两者可选择list或deque作为底层结构。二者不可用set或map作为底层结构。转调用的时候，一些函数不满容器特性。<br><code>这二者不允许遍历，也不提供iterator</code>，这种操作会干扰容器的特性（FIFO 或 FILO）</p>
<p>二者不同的是，queue 不可选择vector作为底层结构，stack可以。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Sequence</span>=deque&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> queue&#123;</span><br><span class="line">	....</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	Sequence c;<span class="comment">// 底层容器</span></span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">stack&lt;string, llist&lt;string&gt;&gt;c;</span><br></pre></td></tr></table></figure>

<h3 id="RB-tree"><a href="#RB-tree" class="headerlink" title="RB-tree"></a>RB-tree</h3><p>关联式容器。<br>RB-tree：平衡二叉搜索树。有利于search和insert。rb_tree 的迭代器不应该用于修改元素，但是未被禁止这种操作，因为它为set和map服务，而map允许data被修改，只有key不可以被修改，此时，红黑树是根据map的key进行排序的。<br>红黑树提供两种insertion操作：<code>insert_unique()</code>, <code>insert_equal</code>前者key是要求独一无二的，后者可以有重复</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">KeyOfValue</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>=alloc&gt;</span><br><span class="line"><span class="keyword">class</span> rb_tree&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">typedef</span> __rb_tree_node&lt;Value&gt; rb_tree_node;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> rb_tree_node* link_type;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">// 大小为9，但是为了内存对齐，这里实际上占用的内存为12 </span></span><br><span class="line">	size_type node_count;  <span class="comment">// 节点个数</span></span><br><span class="line">	link_type header;</span><br><span class="line">	Compare key_compare;  <span class="comment">// key的大小比较准则，是一个函数对象.理论上是0，但是实现为1</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="21-set-amp-multiset"><a href="#21-set-amp-multiset" class="headerlink" title="21.set &amp; multiset"></a>21.set &amp; multiset</h3><ul>
<li>一个元素不可重复，一个可以重复。</li>
<li>无法使用二者的iterator改变元素值，这些容器中的key有其固定的排列规则，这种iterator底层是RB tree的const iterator</li>
<li>元素特性是key就是value， value就是key</li>
<li>在实现中，set都是在调用rb tree中的操作，所以可以说set是一个容器的适配器</li>
</ul>
<h3 id="22-map-amp-multimap"><a href="#22-map-amp-multimap" class="headerlink" title="22.map &amp; multimap"></a>22.map &amp; multimap</h3><ul>
<li>与之前不同的是，这里的value被分为key和data</li>
<li>其他的性质与22中提到的类似</li>
<li>multimap 不可使用<code>[]</code>, map可以，如果找到，则返回值，如果没有就将键值插入到map中。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用逻辑</span></span><br><span class="line">map&lt;<span class="type">int</span>, string&gt;my_map;</span><br><span class="line">map&lt;<span class="type">int</span>, string, less&lt;<span class="type">int</span>&gt;, alloc&gt;my_map;</span><br><span class="line"></span><br><span class="line"><span class="comment">// selectlst: 获取键值，第一个元素</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span>, pair&lt;<span class="type">const</span> <span class="type">int</span>, string&gt;, selectlst&lt;pair&lt;<span class="type">const</span> <span class="type">int</span>, string&gt;&gt;, less&lt;<span class="type">int</span>&gt;, alloc&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">rb_tree</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="23，24、hash-table"><a href="#23，24、hash-table" class="headerlink" title="23，24、hash table"></a>23，24、hash table</h3><ul>
<li>直接使用原始数字作为键值需要大量的空间，所以通常采用原始数据与一个素数的余数作为键值，这个素数可以被成为“篮子”(扩充大小实际上时固定的，根据不同的版本存在不同)</li>
<li>当元素个数大于篮子的数时，需要rehashing，重新规划篮子的大小（选下一个素数作为篮子大小，这样所有的元素都要重新计算）。</li>
</ul>
<h3 id="26-unodered容器概念"><a href="#26-unodered容器概念" class="headerlink" title="26.unodered容器概念"></a>26.unodered容器概念</h3><p>C++之后，将原先的hash_set、hash_miltiset、hash_map、hash_miltimap中的hash编程unordered</p>
<h3 id="27-算法形式"><a href="#27-算法形式" class="headerlink" title="27.算法形式"></a>27.算法形式</h3><p>算法的所需的一切信息都由迭代器取得</p>
<h3 id="28-迭代器的分类"><a href="#28-迭代器的分类" class="headerlink" title="28. 迭代器的分类"></a>28. 迭代器的分类</h3><p>随机访问迭代器、双向迭代器、单向迭代器<br>random_access_iterator, bidirectional_iterator, forward_iterator. </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 特殊的迭代器</span></span><br><span class="line"><span class="built_in">display_category</span>(<span class="built_in">istream_iterator</span>&lt;<span class="type">int</span>&gt;()); <span class="comment">// input_iterator</span></span><br><span class="line"><span class="built_in">display_category</span>(<span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(cout, <span class="string">&quot;&quot;</span>)); <span class="comment">// output_iterator</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="built_in">typeid</span>(itr).<span class="built_in">name</span>(); <span class="comment">// 查看变量类型</span></span><br></pre></td></tr></table></figure>

<h3 id="29-迭代器分类对算法的影响"><a href="#29-迭代器分类对算法的影响" class="headerlink" title="29. 迭代器分类对算法的影响"></a>29. 迭代器分类对算法的影响</h3><p>如果是随机访问迭代器，那么迭代器可以直接到达指定的位置，如果是input_iterator，迭代器只能一个个加到指定的位置，这种功能可以通过偏特化实现（特化迭代器的类型）</p>
<p>对于output iterator是write-only，无法像forward iterator那样可以read， 所以不可以使用<code>*</code>运算符进行读取</p>
<h3 id="30-算法源码剖析"><a href="#30-算法源码剖析" class="headerlink" title="30.算法源码剖析"></a>30.算法源码剖析</h3><p><strong>accumulate</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> jj34</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">myfunc</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123; <span class="keyword">return</span> x + <span class="number">2</span> * y &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> myclass&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="built_in">operator</span>()(<span class="type">int</span> x, <span class="type">int</span> y)&#123; <span class="keyword">return</span> x + <span class="number">3</span> * y; &#125;</span><br><span class="line"></span><br><span class="line">    &#125;myobj;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test_accumlate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> init = <span class="number">100</span>;</span><br><span class="line">        <span class="type">int</span> nums[] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// default</span></span><br><span class="line">        cout &lt;&lt; <span class="built_in">accumulate</span>(nums, nums + <span class="number">3</span>, init); <span class="comment">// 160</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// using functional&#x27;s minus</span></span><br><span class="line">        cout &lt;&lt; <span class="built_in">accumulate</span>(nums, nums + <span class="number">3</span>, init, <span class="built_in">minus</span>&lt;<span class="type">int</span>&gt;());  <span class="comment">//40</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Using self-defined function</span></span><br><span class="line">        cout &lt;&lt; <span class="built_in">accumulate</span>(nums, nums + <span class="number">3</span>, init, myobj);  <span class="comment">// </span></span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">       init = binary_op(init, *first) // binary_op 就是传入的函数，可以传入函数或者仿函数（重载括号运算符）</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>for_each</strong></p>
<p><strong>replace, replace_if, replace_copy</strong><br>1.替换元素，2。在给定条件下替换  3.不删除被替换元素，将其复制到其他位置</p>
<p><strong>count， count_if</strong></p>
<p><strong>find, find_if</strong><br>find:循序查找</p>
<p><strong>sort</strong>：<br>传入迭代器范围</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">begin</span>() + <span class="number">3</span>); <span class="comment">// 默认从小到大， i &lt; j</span></span><br><span class="line">vec.<span class="built_in">rbegin</span>() = vec.<span class="built_in">end</span>(); <span class="comment">// 一个反向的迭代器</span></span><br></pre></td></tr></table></figure>

<p><strong>binary_search</strong></p>
<h3 id="仿函数和函数对象"><a href="#仿函数和函数对象" class="headerlink" title="仿函数和函数对象"></a>仿函数和函数对象</h3><h3 id="binder2nd"><a href="#binder2nd" class="headerlink" title="binder2nd"></a>binder2nd</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里的less&lt;int&gt;() 不是在调用，这是一个对象</span></span><br><span class="line"><span class="built_in">count_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">not</span>(<span class="built_in">bind2nd</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(), <span class="number">40</span>)));</span><br></pre></td></tr></table></figure>
<p>仿函数可被适配的条件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Arg</span>, <span class="keyword">class</span> <span class="title class_">Result</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">unary_function</span>&#123;</span><br><span class="line">	<span class="keyword">typedef</span> Arg argument_type;</span><br><span class="line">	<span class="keyword">typedef</span> Result result_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Arg1</span>, <span class="keyword">class</span> <span class="title class_">Arg2</span>, <span class="keyword">class</span> <span class="title class_">Result</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">binary_function</span>&#123;</span><br><span class="line">	<span class="keyword">typedef</span> Arg1 first_argument_type;</span><br><span class="line">	<span class="keyword">typedef</span> Arg2 second_argument_type;</span><br><span class="line">	<span class="keyword">typedef</span> Result result_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 每一个可适配的函数都会继承上面的结构体，因为需要向Function adapter提供上面结构体定义的信息</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">less</span> : <span class="keyword">public</span> binary_function&lt;T, T, <span class="type">bool</span>&gt;&#123;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; x, <span class="type">const</span> T&amp; y)</span><span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;<span class="keyword">return</span> x &lt; y;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>新型适配器<code>bind</code>上述适配器已被弃用。</p>
<h3 id="34-not1"><a href="#34-not1" class="headerlink" title="34. not1"></a>34. not1</h3><h3 id="35-bind-（C-11）"><a href="#35-bind-（C-11）" class="headerlink" title="35.bind （C++11）"></a>35.bind （C++11）</h3><p>可以绑定：</p>
<ul>
<li>functions</li>
<li>function object</li>
<li>member function (_1需要是地址)</li>
<li>data member(_1需要是地址)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">my_divide</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span></span></span><br><span class="line"><span class="function">	</span>&#123; <span class="keyword">return</span> x/y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyPair</span>&#123;</span><br><span class="line">	<span class="type">double</span> a, b;</span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">multiply</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> a*b;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholder; <span class="comment">// adds visibility of _1, _2 ....</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> fn_five = <span class="built_in">bind</span>(my_divide, <span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; <span class="built_in">fn_five</span>() ; <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> fn_five = <span class="built_in">bind</span>(my_divide, _1, <span class="number">2</span>);  <span class="comment">// _1 占位符</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">fn_five</span>(<span class="number">10</span>) ; <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> fn_five = <span class="built_in">bind</span>(my_divide, _2, _1); <span class="comment">// _2 第二个占位符</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">fn_five</span>(<span class="number">10</span>, <span class="number">2</span>) ; <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定return type 为int</span></span><br><span class="line"><span class="keyword">auto</span> fn_five = <span class="built_in">bind</span>&lt;<span class="type">int</span>&gt;(my_divide, _2, _1); <span class="comment">// _2 第二个占位符</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">fn_five</span>(<span class="number">10</span>, <span class="number">2</span>) ; <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">MyPair ten_two&#123;<span class="number">10</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> bound_memfn = <span class="built_in">bind</span>(&amp;MyPair::multiply, _1);</span><br><span class="line">cout &lt;&lt; <span class="built_in">vound_memfn</span>(ten_two); <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 本质上就是将函数中的一个参数绑定一个固定的值</span></span><br><span class="line"><span class="comment">// ps： cbegin：表示constant</span></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">39</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
