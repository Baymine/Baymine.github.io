<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"baymine.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="1. 认识header、版本、重要资源头文件命名形式：  C++标准库header files 不带（.h） 新型的C头文件不带.h 原先的C头文件(带有.h)的，仍旧可以使用（但是最好还是使用最新的形式） 所有的新式headers都在名字域“std”中 旧式的头文件不被包含在“std”中  2.STL体系结构基础介绍STL的六大部件：  容器 分配器 算法 迭代器 适配器 仿函数(Functor">
<meta property="og:type" content="article">
<meta property="og:title" content="STL和泛型编程">
<meta property="og:url" content="https://baymine.github.io/2022/10/12/STL%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1. 认识header、版本、重要资源头文件命名形式：  C++标准库header files 不带（.h） 新型的C头文件不带.h 原先的C头文件(带有.h)的，仍旧可以使用（但是最好还是使用最新的形式） 所有的新式headers都在名字域“std”中 旧式的头文件不被包含在“std”中  2.STL体系结构基础介绍STL的六大部件：  容器 分配器 算法 迭代器 适配器 仿函数(Functor">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://baymine.github.io/.io//10/12/STL%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/20220915211226.png">
<meta property="og:image" content="https://baymine.github.io/.io//10/12/STL%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/20220921095514.png">
<meta property="og:image" content="https://baymine.github.io/.io//10/12/STL%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/20220921134657.png">
<meta property="article:published_time" content="2022-10-12T11:46:55.000Z">
<meta property="article:modified_time" content="2022-10-12T12:00:22.565Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="侯捷C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://baymine.github.io/.io//10/12/STL%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/20220915211226.png">

<link rel="canonical" href="https://baymine.github.io/2022/10/12/STL%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>STL和泛型编程 | Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://baymine.github.io/2022/10/12/STL%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          STL和泛型编程
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-12 19:46:55 / Modified: 20:00:22" itemprop="dateCreated datePublished" datetime="2022-10-12T19:46:55+08:00">2022-10-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="1-认识header、版本、重要资源"><a href="#1-认识header、版本、重要资源" class="headerlink" title="1. 认识header、版本、重要资源"></a>1. 认识header、版本、重要资源</h3><p>头文件命名形式：</p>
<ul>
<li>C++标准库header files 不带（.h）</li>
<li>新型的C头文件不带.h</li>
<li>原先的C头文件(带有.h)的，仍旧可以使用（但是最好还是使用最新的形式）</li>
<li>所有的新式headers都在名字域“std”中</li>
<li>旧式的头文件不被包含在“std”中</li>
</ul>
<h3 id="2-STL体系结构基础介绍"><a href="#2-STL体系结构基础介绍" class="headerlink" title="2.STL体系结构基础介绍"></a>2.STL体系结构基础介绍</h3><p>STL的六大部件：</p>
<ul>
<li>容器</li>
<li>分配器</li>
<li>算法</li>
<li>迭代器</li>
<li>适配器</li>
<li>仿函数(Functors)</li>
</ul>
<img src="/.io//10/12/STL%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/20220915211226.png" class>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;vector&gt;</span>  <span class="comment">// 与容器同名</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">int</span> ia[<span class="number">6</span>] = {<span class="number">27</span>, <span class="number">210</span>, <span class="number">12</span>, <span class="number">47</span>, <span class="number">109</span>, <span class="number">83</span>};</span><br><span class="line">	vector&lt;<span class="type">int</span>, allocator&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">vi</span>(ia, ia+<span class="number">6</span>);<span class="comment">// 分配器用于分配内存（一般默认）</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	count_if: algorithm;</span></span><br><span class="line"><span class="comment">	not1: function adapter(negator);</span></span><br><span class="line"><span class="comment">	bind2nd: 绑定第二参数，function adapter(binder)</span></span><br><span class="line"><span class="comment">	less: function object</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; <span class="built_in">count_if</span>(vi.<span class="built_in">begin</span>(), vi.<span class="built_in">end</span>(),</span><br><span class="line">				<span class="built_in">not1</span>(<span class="built_in">bind2nd</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(), <span class="number">40</span>)));  <span class="comment">// 大于等于40</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>标准库中的容器都是前开后闭的。但是容器的end()方法指向的是容器最后的元素的下一个元素，所以直接将这个指针解引用出来，得到的是一个未知的东西。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Container&lt;T&gt; c;</span><br><span class="line">....</span><br><span class="line">Container&lt;T&gt;::iterator ite = c.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span>(; ite != c.<span class="built_in">end</span>(); ++ite)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++11</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; elem : c){</span><br><span class="line">	...</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<h3 id="3-6-容器分类与各种测试"><a href="#3-6-容器分类与各种测试" class="headerlink" title="3~6. 容器分类与各种测试"></a>3~6. 容器分类与各种测试</h3><p>标准库中的集合和map一般用红黑树实现。</p>
<blockquote>
<p>代码习惯：测试程序放在名字域中，对应的库放在对应的名字域中，对应的定义变量需要的时候再写，为了注明，定义变量不会进行缩进。</p>
</blockquote>
<p><strong>vector</strong>： 对于空间扩充是呈现两倍增长的。这个增长是通过找到一个新的内存，然后将原先的元素全部复制到这个新的空间中，所以这个增长的过程实际上是比较缓慢的。</p>
<p><code>deque</code> : 分段，但是逻辑上是连续的。没有自己的sort</p>
<p>关联式容器查找都非常快</p>
<p><code>multiset</code>:内部是红黑树实现的,可以包含重复元素<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">multiset&lt;string&gt;c;</span><br></pre></td></tr></table></figure><br><code>multimap</code>:不可以使用<code>[]</code>作为插入<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">multimap&lt;<span class="type">long</span>, string&gt;c;</span><br><span class="line">c.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">long</span>, string&gt;(i, buf));</span><br><span class="line"><span class="comment">// 访问需要使用first &amp; second</span></span><br></pre></td></tr></table></figure><br><code>unordered_multiset</code>:散列表实现的（哈希表）</p>
<p><code>set</code>: 不会出现重复的元素</p>
<p><code>map</code>: 底层实现是红黑树， 可以使用<code>[]</code>添加元素，key不重复，value是有重复的</p>
<h3 id="7-分配器测试"><a href="#7-分配器测试" class="headerlink" title="7. 分配器测试"></a>7. 分配器测试</h3><p>分配器用于内存分配<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p;</span><br><span class="line">__gnu_cxx::malloc_allocator&lt;<span class="type">int</span>&gt; alloc;</span><br><span class="line">p = alloc.<span class="built_in">allocate</span>(<span class="number">1</span>);</span><br><span class="line">alloc.<span class="built_in">deallocate</span>(p, <span class="number">1</span>);  <span class="comment">// 不建议使用，需要记住申请的内存的大小（用于空间释放）</span></span><br></pre></td></tr></table></figure></p>
<h3 id="8-源代码分布"><a href="#8-源代码分布" class="headerlink" title="8.源代码分布"></a>8.源代码分布</h3><h3 id="9-OOP-amp-泛化编程"><a href="#9-OOP-amp-泛化编程" class="headerlink" title="9. OOP & 泛化编程"></a>9. OOP &amp; 泛化编程</h3><p>泛化编程是将数据和方法分开来了。容器与算法（方法）之间通过迭代器相互关联。 </p>
<blockquote>
<p>为什么list不能使用<code>::sort()</code>?\<br>因为<code>::sort()</code>中使用的迭代器指针需要是能够随机访问的（能前能后），但是在list中，这种性质不满足。</p>
</blockquote>
<p><strong>特化</strong>\<br>模板在特定类型的时候使用特定的方法（更优的）<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">type</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__type_traits</span>{</span><br><span class="line">	....</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">__type_traits</span>&lt;<span class="type">int</span>&gt;{</span><br><span class="line">	....</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">__type_traits</span>&lt;<span class="type">double</span>&gt;{</span><br><span class="line">	....</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 偏特化，如果传入的是一个指针（范围上的偏特化）</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">type</span>&gt; <span class="keyword">struct</span> <span class="title class_">__type_traits</span>&lt;type*&gt;{</span><br><span class="line">	....</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt;</span><br><span class="line"><span class="keyword">class</span> vector{</span><br><span class="line">	....</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 偏特化：仅将其中一个模板参数进行特化（数量上的局部）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">vector</span>&lt;<span class="type">bool</span>, Alloc&gt;</span><br><span class="line">{</span><br><span class="line">	....</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="11-分配器"><a href="#11-分配器" class="headerlink" title="11.分配器"></a>11.分配器</h3><p><code>malloc</code>申请内存的时候是有额外的开销的（其中包括了申请的空间的大小）。当申请的空间比较小的时候，这种开销占比比较大\<br>在VC6的allocator中知识以<code>::operator new</code> 和 <code>::operator delete</code> 完成allocate() 和 deallocate() 没有特殊设计。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _FARQ</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> _FARQ</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> _PDFT ptrdiff_t</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> _SIZT  size_t</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _POINTER_X(T, A) T_FARQ*</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _REFFERENCE_X(T, A) T_FARQ&amp;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>&gt; <span class="keyword">inline</span></span><br><span class="line">_Ty _FARQ* _Allocate(_PDFT _N, _Ty _FARQ*)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(_N &lt; <span class="number">0</span>) _N = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ((_Ty _FARQ*) <span class="keyword">operator</span> <span class="built_in">new</span>((_SIZT)_N*<span class="built_in">sizeof</span>(_Ty)));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">allocator</span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> _SIZT size_type;</span><br><span class="line">    <span class="keyword">typedef</span> _PDFT difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Ty _FARQ * pointer;</span><br><span class="line">    <span class="keyword">typedef</span> _Ty value_type;</span><br><span class="line">    <span class="function">pointer <span class="title">allocate</span><span class="params">(size_type _N, <span class="type">const</span> <span class="type">void</span>*)</span> <span class="comment">// 第二个是任意参数</span></span></span><br><span class="line"><span class="function">    </span>{ <span class="keyword">return</span> (_Allocate((difference_type) _N, (pointer)<span class="number">0</span>)); }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deallocate</span><span class="params">(<span class="type">void</span> _FARQ *_P, size_type)</span></span></span><br><span class="line"><span class="function">    </span>{ <span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(_P)</span></span>; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配512 ints</span></span><br><span class="line"><span class="type">int</span>* p = <span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">allocate</span>(<span class="number">512</span>, (<span class="type">int</span>*<span class="number">0</span>));</span><br><span class="line"><span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">deallocate</span>(p, <span class="number">512</span>);  <span class="comment">// 用临时变量调用类方法</span></span><br></pre></td></tr></table></figure><br>这种方式可能会导致太大的额外开销，所以，一些改进的方法是一次申请固定倍数大小的空间，这样可以减少malloc的使用（与vector中的空间拓展思想类似）</p>
<h3 id="13、14-list源代码"><a href="#13、14-list源代码" class="headerlink" title="13、14. list源代码"></a>13、14. list源代码</h3><blockquote>
<p>i++ 和 ++i\<br>因为符号一样，所以给后置版本加一个int形参作为区分，这个形参是0，但是在函数体中是用不到的，只是为了区分前置后置。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self <span class="keyword">operator</span>++(<span class="type">int</span>) { ... } <span class="comment">// i++</span></span><br><span class="line">self <span class="keyword">operator</span>++() { ... } <span class="comment">// ++i （可以认为i作为参数已经传入了）</span></span><br></pre></td></tr></table></figure><br>另外整数不能连续进行两次后连加，可以前加（++++i √，i++++ × ）</p>
</blockquote>
<p>为了满足容器前闭后开的性质，在list链表中会有一个空白的头节点，这个就是end指针指向的节点，其内部实际上是一个环形双向链表。</p>
<h3 id="15-Iterator-必须提供的5种相关类别"><a href="#15-Iterator-必须提供的5种相关类别" class="headerlink" title="15. Iterator 必须提供的5种相关类别"></a>15. Iterator 必须提供的5种相关类别</h3><ul>
<li>iterator_category</li>
<li>value_type</li>
<li>pointer</li>
<li>reference</li>
<li>difference_type</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">I</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::reference;</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<p><strong>萃取机（iterator_traits）</strong>: 用于分离class iterator 和 non-class iterator。这是用过偏特化实现的<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;calss I&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>{</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type value_type;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两种偏特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;T*&gt;{</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;<span class="type">const</span> T*&gt;{</span><br><span class="line">	<span class="keyword">typedef</span> T value_type; <span class="comment">// 不能用const T，因为这样声明的变量无法赋值</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取I的value_type</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> I, ...&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">algorithmn</span><span class="params">(...)</span></span>{</span><br><span class="line">	<span class="keyword">typename</span> iterator_traits&lt;I&gt;::value_type v1;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个实例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;T*&gt;</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> T* pointer;</span><br><span class="line">    <span class="keyword">typedef</span> T&amp; reference;</span><br><span class="line">};</span><br></pre></td></tr></table></figure></p>
<h3 id="16-vector深度探索"><a href="#16-vector深度探索" class="headerlink" title="16.vector深度探索"></a>16.vector深度探索</h3><img src="/.io//10/12/STL%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/20220921095514.png" class>
<p>在进行扩充的时候，需要重新申请空间，并且原先的空间将会被销毁，这使得这个过程中需要调用大量的构造函数和析构函数。</p>
<p>如果是连续空间，那么这个容器的迭代器就可以单纯地使用指针来表现。</p>
<h3 id="17-array、forward-list-深度探索"><a href="#17-array、forward-list-深度探索" class="headerlink" title="17. array、forward_list 深度探索"></a>17. array、forward_list 深度探索</h3><p>在特化array的时候，需要指明大小，这是因为array的大小是固定的，它没有构造器和析构器。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>, 10&gt; myArray;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义数组</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">100</span>]; <span class="comment">// √</span></span><br><span class="line"><span class="comment">//int[100] a;  // ×</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> T[<span class="number">100</span>];</span><br><span class="line">T c;  <span class="comment">// √</span></span><br></pre></td></tr></table></figure></p>
<h3 id="18，19-deque、queue和stack深度探索"><a href="#18，19-deque、queue和stack深度探索" class="headerlink" title="18，19. deque、queue和stack深度探索"></a>18，19. deque、queue和stack深度探索</h3><p><strong>deque</strong>：这个容器的地址是由几个内存段产生的，用一个向量存储每一个内存段的首地址。对于迭代器，是由一个类组成，其中包含当前内存块的边界，当前指针指向的元素，以及当前内存块在地址向量中的位置<br><img src="/.io//10/12/STL%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/20220921134657.png" class></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里会找到离边界最近的方向移动元素</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="type">const</span> value_type&amp; x)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(position.cur == start.cur){  <span class="comment">// 是否是在开头</span></span><br><span class="line">        <span class="built_in">push_front</span>(x);</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(position.cur == finish.cur){<span class="comment">// 是否是在尾部 </span></span><br><span class="line">        <span class="built_in">push_back</span>(x);</span><br><span class="line">        iterator tmp = finish;</span><br><span class="line">        --tmp;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">insert_aux</span>(position, x);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> BufSize&gt;</span><br><span class="line"><span class="keyword">typename</span> deque&lt;T, Alloc, BufSize&gt;::iterator</span><br><span class="line">deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">insert_aux</span>(iterator pos, <span class="type">const</span> value_type){</span><br><span class="line">	difference_type index = pos - start;</span><br><span class="line">	value_type x_copy = x;</span><br><span class="line">	<span class="keyword">if</span>(index &lt; <span class="built_in">size</span>()/<span class="number">2</span>){  <span class="comment">// 检查是否小于中点</span></span><br><span class="line">		<span class="built_in">push_front</span>(<span class="built_in">front</span>()); <span class="comment">//复制第一个元素</span></span><br><span class="line">		...</span><br><span class="line">		<span class="built_in">copy</span>(front2, pos1, front1);  <span class="comment">// 全部往前移动</span></span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span>{</span><br><span class="line">		<span class="built_in">push_back</span>(<span class="built_in">back</span>());</span><br><span class="line">		....</span><br><span class="line">		<span class="built_in">copy_backward</span>(pos, back2, back1);</span><br><span class="line">	}</span><br><span class="line">	*pos = x_copy;</span><br><span class="line">	<span class="keyword">return</span> pos;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>模拟连续空间，累加，<code>[]</code>，向前移动<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewbox="0 -442 600 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>元素</p>
<p>在stack和queue中，默认一个deque。 这两者可选择list或deque作为底层结构。二者不可用set或map作为底层结构。转调用的时候，一些函数不满容器特性。<br><code>这二者不允许遍历，也不提供iterator</code>，这种操作会干扰容器的特性（FIFO 或 FILO）</p>
<p>二者不同的是，queue 不可选择vector作为底层结构，stack可以。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Sequence</span>=deque&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> queue{</span><br><span class="line">	....</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	Sequence c;<span class="comment">// 底层容器</span></span><br><span class="line">	...</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">stack&lt;string, llist&lt;string&gt;&gt;c;</span><br></pre></td></tr></table></figure>
<h3 id="RB-tree"><a href="#RB-tree" class="headerlink" title="RB-tree"></a>RB-tree</h3><p>关联式容器。<br>RB-tree：平衡二叉搜索树。有利于search和insert。rb_tree 的迭代器不应该用于修改元素，但是未被禁止这种操作，因为它为set和map服务，而map允许data被修改，只有key不可以被修改，此时，红黑树是根据map的key进行排序的。<br>红黑树提供两种insertion操作：<code>insert_unique()</code>, <code>insert_equal</code>前者key是要求独一无二的，后者可以有重复<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">KeyOfValue</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>=alloc&gt;</span><br><span class="line"><span class="keyword">class</span> rb_tree{</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">typedef</span> __rb_tree_node&lt;Value&gt; rb_tree_node;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> rb_tree_node* link_type;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">// 大小为9，但是为了内存对齐，这里实际上占用的内存为12 </span></span><br><span class="line">	size_type node_count;  <span class="comment">// 节点个数</span></span><br><span class="line">	link_type header;</span><br><span class="line">	Compare key_compare;  <span class="comment">// key的大小比较准则，是一个函数对象.理论上是0，但是实现为1</span></span><br><span class="line">	...</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<h3 id="21-set-amp-multiset"><a href="#21-set-amp-multiset" class="headerlink" title="21.set & multiset"></a>21.set &amp; multiset</h3><ul>
<li>一个元素不可重复，一个可以重复。</li>
<li>无法使用二者的iterator改变元素值，这些容器中的key有其固定的排列规则，这种iterator底层是RB tree的const iterator</li>
<li>元素特性是key就是value， value就是key</li>
<li>在实现中，set都是在调用rb tree中的操作，所以可以说set是一个容器的适配器</li>
</ul>
<h3 id="22-map-amp-multimap"><a href="#22-map-amp-multimap" class="headerlink" title="22.map & multimap"></a>22.map &amp; multimap</h3><ul>
<li>与之前不同的是，这里的value被分为key和data</li>
<li>其他的性质与22中提到的类似</li>
<li>multimap 不可使用<code>[]</code>, map可以，如果找到，则返回值，如果没有就将键值插入到map中。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用逻辑</span></span><br><span class="line">map&lt;<span class="type">int</span>, string&gt;my_map;</span><br><span class="line">map&lt;<span class="type">int</span>, string, less&lt;<span class="type">int</span>&gt;, alloc&gt;my_map;</span><br><span class="line"></span><br><span class="line"><span class="comment">// selectlst: 获取键值，第一个元素</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span>, pair&lt;<span class="type">const</span> <span class="type">int</span>, string&gt;, selectlst&lt;pair&lt;<span class="type">const</span> <span class="type">int</span>, string&gt;&gt;, less&lt;<span class="type">int</span>&gt;, alloc&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">rb_tree</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="23，24、hash-table"><a href="#23，24、hash-table" class="headerlink" title="23，24、hash table"></a>23，24、hash table</h3><ul>
<li>直接使用原始数字作为键值需要大量的空间，所以通常采用原始数据与一个素数的余数作为键值，这个素数可以被成为“篮子”(扩充大小实际上时固定的，根据不同的版本存在不同)</li>
<li>当元素个数大于篮子的数时，需要rehashing，重新规划篮子的大小（选下一个素数作为篮子大小，这样所有的元素都要重新计算）。</li>
</ul>
<h3 id="26-unodered容器概念"><a href="#26-unodered容器概念" class="headerlink" title="26.unodered容器概念"></a>26.unodered容器概念</h3><p>C++之后，将原先的hash_set、hash_miltiset、hash_map、hash_miltimap中的hash编程unordered</p>
<h3 id="27-算法形式"><a href="#27-算法形式" class="headerlink" title="27.算法形式"></a>27.算法形式</h3><p>算法的所需的一切信息都由迭代器取得</p>
<h3 id="28-迭代器的分类"><a href="#28-迭代器的分类" class="headerlink" title="28. 迭代器的分类"></a>28. 迭代器的分类</h3><p>随机访问迭代器、双向迭代器、单向迭代器<br>random_access_iterator, bidirectional_iterator, forward_iterator.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 特殊的迭代器</span></span><br><span class="line"><span class="built_in">display_category</span>(<span class="built_in">istream_iterator</span>&lt;<span class="type">int</span>&gt;()); <span class="comment">// input_iterator</span></span><br><span class="line"><span class="built_in">display_category</span>(<span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(cout, <span class="string">""</span>)); <span class="comment">// output_iterator</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="built_in">typeid</span>(itr).<span class="built_in">name</span>(); <span class="comment">// 查看变量类型</span></span><br></pre></td></tr></table></figure></p>
<h3 id="29-迭代器分类对算法的影响"><a href="#29-迭代器分类对算法的影响" class="headerlink" title="29. 迭代器分类对算法的影响"></a>29. 迭代器分类对算法的影响</h3><p>如果是随机访问迭代器，那么迭代器可以直接到达指定的位置，如果是input_iterator，迭代器只能一个个加到指定的位置，这种功能可以通过偏特化实现（特化迭代器的类型）</p>
<p>对于output iterator是write-only，无法像forward iterator那样可以read， 所以不可以使用<code>*</code>运算符进行读取</p>
<h3 id="30-算法源码剖析"><a href="#30-算法源码剖析" class="headerlink" title="30.算法源码剖析"></a>30.算法源码剖析</h3><p><strong>accumulate</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> jj34</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">myfunc</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>{ <span class="keyword">return</span> x + <span class="number">2</span> * y }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> myclass{</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="built_in">operator</span>()(<span class="type">int</span> x, <span class="type">int</span> y){ <span class="keyword">return</span> x + <span class="number">3</span> * y; }</span><br><span class="line"></span><br><span class="line">    }myobj;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test_accumlate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="type">int</span> init = <span class="number">100</span>;</span><br><span class="line">        <span class="type">int</span> nums[] = {<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>};</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// default</span></span><br><span class="line">        cout &lt;&lt; <span class="built_in">accumulate</span>(nums, nums + <span class="number">3</span>, init); <span class="comment">// 160</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// using functional's minus</span></span><br><span class="line">        cout &lt;&lt; <span class="built_in">accumulate</span>(nums, nums + <span class="number">3</span>, init, <span class="built_in">minus</span>&lt;<span class="type">int</span>&gt;());  <span class="comment">//40</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Using self-defined function</span></span><br><span class="line">        cout &lt;&lt; <span class="built_in">accumulate</span>(nums, nums + <span class="number">3</span>, init, myobj);  <span class="comment">// </span></span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">       init = binary_op(init, *first) // binary_op 就是传入的函数，可以传入函数或者仿函数（重载括号运算符）</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<p><strong>for_each</strong></p>
<p><strong>replace, replace_if, replace_copy</strong><br>1.替换元素，2。在给定条件下替换  3.不删除被替换元素，将其复制到其他位置</p>
<p><strong>count， count_if</strong></p>
<p><strong>find, find_if</strong><br>find:循序查找</p>
<p><strong>sort</strong>：<br>传入迭代器范围<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">begin</span>() + <span class="number">3</span>); <span class="comment">// 默认从小到大， i &lt; j</span></span><br><span class="line">vec.<span class="built_in">rbegin</span>() = vec.<span class="built_in">end</span>(); <span class="comment">// 一个反向的迭代器</span></span><br></pre></td></tr></table></figure></p>
<p><strong>binary_search</strong></p>
<h3 id="仿函数和函数对象"><a href="#仿函数和函数对象" class="headerlink" title="仿函数和函数对象"></a>仿函数和函数对象</h3><h3 id="binder2nd"><a href="#binder2nd" class="headerlink" title="binder2nd"></a>binder2nd</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里的less&lt;int&gt;() 不是在调用，这是一个对象</span></span><br><span class="line"><span class="built_in">count_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">not</span>(<span class="built_in">bind2nd</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(), <span class="number">40</span>)));</span><br></pre></td></tr></table></figure>
<p>仿函数可被适配的条件<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Arg</span>, <span class="keyword">class</span> <span class="title class_">Result</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">unary_function</span>{</span><br><span class="line">	<span class="keyword">typedef</span> Arg argument_type;</span><br><span class="line">	<span class="keyword">typedef</span> Result result_type;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Arg1</span>, <span class="keyword">class</span> <span class="title class_">Arg2</span>, <span class="keyword">class</span> <span class="title class_">Result</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">binary_function</span>{</span><br><span class="line">	<span class="keyword">typedef</span> Arg1 first_argument_type;</span><br><span class="line">	<span class="keyword">typedef</span> Arg2 second_argument_type;</span><br><span class="line">	<span class="keyword">typedef</span> Result result_type;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 每一个可适配的函数都会继承上面的结构体，因为需要向Function adapter提供上面结构体定义的信息</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">less</span> : <span class="keyword">public</span> binary_function&lt;T, T, <span class="type">bool</span>&gt;{</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; x, <span class="type">const</span> T&amp; y)</span><span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>{<span class="keyword">return</span> x &lt; y;}</span><br><span class="line">};</span><br></pre></td></tr></table></figure><br>新型适配器<code>bind</code>上述适配器已被弃用。</p>
<h3 id="34-not1"><a href="#34-not1" class="headerlink" title="34. not1"></a>34. not1</h3><h3 id="35-bind-（C-11）"><a href="#35-bind-（C-11）" class="headerlink" title="35.bind （C++11）"></a>35.bind （C++11）</h3><p>可以绑定：</p>
<ul>
<li>functions</li>
<li>function object</li>
<li>member function (_1需要是地址)</li>
<li>data member(_1需要是地址)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">my_divide</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span></span></span><br><span class="line"><span class="function">	</span>{ <span class="keyword">return</span> x/y; }</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyPair</span>{</span><br><span class="line">	<span class="type">double</span> a, b;</span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">multiply</span><span class="params">()</span></span>{<span class="keyword">return</span> a*b;}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholder; <span class="comment">// adds visibility of _1, _2 ....</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> fn_five = <span class="built_in">bind</span>(my_divide, <span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; <span class="built_in">fn_five</span>() ; <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> fn_five = <span class="built_in">bind</span>(my_divide, _1, <span class="number">2</span>);  <span class="comment">// _1 占位符</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">fn_five</span>(<span class="number">10</span>) ; <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> fn_five = <span class="built_in">bind</span>(my_divide, _2, _1); <span class="comment">// _2 第二个占位符</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">fn_five</span>(<span class="number">10</span>, <span class="number">2</span>) ; <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定return type 为int</span></span><br><span class="line"><span class="keyword">auto</span> fn_five = <span class="built_in">bind</span>&lt;<span class="type">int</span>&gt;(my_divide, _2, _1); <span class="comment">// _2 第二个占位符</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">fn_five</span>(<span class="number">10</span>, <span class="number">2</span>) ; <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">MyPair ten_two{<span class="number">10</span>, <span class="number">2</span>};</span><br><span class="line"><span class="keyword">auto</span> bound_memfn = <span class="built_in">bind</span>(&amp;MyPair::multiply, _1);</span><br><span class="line">cout &lt;&lt; <span class="built_in">vound_memfn</span>(ten_two); <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 本质上就是将函数中的一个参数绑定一个固定的值</span></span><br><span class="line"><span class="comment">// ps： cbegin：表示constant</span></span><br></pre></td></tr></table></figure>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E4%BE%AF%E6%8D%B7C/" rel="tag"># 侯捷C++</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/10/12/C-%E6%A0%87%E5%87%8611-14/" rel="prev" title="C++标准11-14">
      <i class="fa fa-chevron-left"></i> C++标准11-14
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/10/12/C-primer/" rel="next" title="C++ primer">
      C++ primer <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E8%AE%A4%E8%AF%86header%E3%80%81%E7%89%88%E6%9C%AC%E3%80%81%E9%87%8D%E8%A6%81%E8%B5%84%E6%BA%90"><span class="nav-number">1.</span> <span class="nav-text">1. 认识header、版本、重要资源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-STL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D"><span class="nav-number">2.</span> <span class="nav-text">2.STL体系结构基础介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-%E5%AE%B9%E5%99%A8%E5%88%86%E7%B1%BB%E4%B8%8E%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95"><span class="nav-number">3.</span> <span class="nav-text">3~6. 容器分类与各种测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E5%88%86%E9%85%8D%E5%99%A8%E6%B5%8B%E8%AF%95"><span class="nav-number">4.</span> <span class="nav-text">7. 分配器测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E5%B8%83"><span class="nav-number">5.</span> <span class="nav-text">8.源代码分布</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-OOP-amp-%E6%B3%9B%E5%8C%96%E7%BC%96%E7%A8%8B"><span class="nav-number">6.</span> <span class="nav-text">9. OOP &amp; 泛化编程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-%E5%88%86%E9%85%8D%E5%99%A8"><span class="nav-number">7.</span> <span class="nav-text">11.分配器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13%E3%80%8114-list%E6%BA%90%E4%BB%A3%E7%A0%81"><span class="nav-number">8.</span> <span class="nav-text">13、14. list源代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-Iterator-%E5%BF%85%E9%A1%BB%E6%8F%90%E4%BE%9B%E7%9A%845%E7%A7%8D%E7%9B%B8%E5%85%B3%E7%B1%BB%E5%88%AB"><span class="nav-number">9.</span> <span class="nav-text">15. Iterator 必须提供的5种相关类别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-vector%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2"><span class="nav-number">10.</span> <span class="nav-text">16.vector深度探索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-array%E3%80%81forward-list-%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2"><span class="nav-number">11.</span> <span class="nav-text">17. array、forward_list 深度探索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18%EF%BC%8C19-deque%E3%80%81queue%E5%92%8Cstack%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2"><span class="nav-number">12.</span> <span class="nav-text">18，19. deque、queue和stack深度探索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RB-tree"><span class="nav-number">13.</span> <span class="nav-text">RB-tree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-set-amp-multiset"><span class="nav-number">14.</span> <span class="nav-text">21.set &amp; multiset</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-map-amp-multimap"><span class="nav-number">15.</span> <span class="nav-text">22.map &amp; multimap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23%EF%BC%8C24%E3%80%81hash-table"><span class="nav-number">16.</span> <span class="nav-text">23，24、hash table</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#26-unodered%E5%AE%B9%E5%99%A8%E6%A6%82%E5%BF%B5"><span class="nav-number">17.</span> <span class="nav-text">26.unodered容器概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#27-%E7%AE%97%E6%B3%95%E5%BD%A2%E5%BC%8F"><span class="nav-number">18.</span> <span class="nav-text">27.算法形式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#28-%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">19.</span> <span class="nav-text">28. 迭代器的分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#29-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%88%86%E7%B1%BB%E5%AF%B9%E7%AE%97%E6%B3%95%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="nav-number">20.</span> <span class="nav-text">29. 迭代器分类对算法的影响</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#30-%E7%AE%97%E6%B3%95%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90"><span class="nav-number">21.</span> <span class="nav-text">30.算法源码剖析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BF%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="nav-number">22.</span> <span class="nav-text">仿函数和函数对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#binder2nd"><span class="nav-number">23.</span> <span class="nav-text">binder2nd</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#34-not1"><span class="nav-number">24.</span> <span class="nav-text">34. not1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#35-bind-%EF%BC%88C-11%EF%BC%89"><span class="nav-number">25.</span> <span class="nav-text">35.bind （C++11）</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">39</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
