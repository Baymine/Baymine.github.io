
 <!DOCTYPE HTML>
<html lang="en">
<head>
  <meta charset="UTF-8">
  
    <title>STL和泛型编程 | Hexo</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="John Doe">
    
    <meta name="description" content="1. 认识header、版本、重要资源头文件命名形式：

C++标准库header files 不带（.h）
新型的C头文件不带.h
原先的C头文件(带有.h)的，仍旧可以使用（但是最好还是使用最新的形式）
所有的新式headers都在名字域“std”中
旧式的头文件不被包含在“std”中

2.S">
    
    
    
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/pacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/pacman.jpg">
    
    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head>

  <body>
    <header>
      <div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.svg" alt="Hexo" title="Hexo"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Hexo">Hexo</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
					<li>
					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="text" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:example.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2022/10/12/STL和泛型编程/" title="STL和泛型编程" itemprop="url">STL和泛型编程</a>
  </h1>
  <p class="article-author">By
    
      <a href="http://example.com" title="John Doe">John Doe</a>
    </p>
  <p class="article-time">
    <time datetime="2022-10-12T11:46:55.000Z" itemprop="datePublished">2022-10-12</time>
    Updated:<time datetime="2022-10-12T12:00:22.565Z" itemprop="dateModified">2022-10-12</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">Contents</strong>
		<ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%AE%A4%E8%AF%86header%E3%80%81%E7%89%88%E6%9C%AC%E3%80%81%E9%87%8D%E8%A6%81%E8%B5%84%E6%BA%90"><span class="toc-number">1.</span> <span class="toc-text">1. 认识header、版本、重要资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-STL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.</span> <span class="toc-text">2.STL体系结构基础介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-%E5%AE%B9%E5%99%A8%E5%88%86%E7%B1%BB%E4%B8%8E%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95"><span class="toc-number">3.</span> <span class="toc-text">3~6. 容器分类与各种测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%88%86%E9%85%8D%E5%99%A8%E6%B5%8B%E8%AF%95"><span class="toc-number">4.</span> <span class="toc-text">7. 分配器测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E5%B8%83"><span class="toc-number">5.</span> <span class="toc-text">8.源代码分布</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-OOP-amp-%E6%B3%9B%E5%8C%96%E7%BC%96%E7%A8%8B"><span class="toc-number">6.</span> <span class="toc-text">9. OOP &amp; 泛化编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E5%88%86%E9%85%8D%E5%99%A8"><span class="toc-number">7.</span> <span class="toc-text">11.分配器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13%E3%80%8114-list%E6%BA%90%E4%BB%A3%E7%A0%81"><span class="toc-number">8.</span> <span class="toc-text">13、14. list源代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-Iterator-%E5%BF%85%E9%A1%BB%E6%8F%90%E4%BE%9B%E7%9A%845%E7%A7%8D%E7%9B%B8%E5%85%B3%E7%B1%BB%E5%88%AB"><span class="toc-number">9.</span> <span class="toc-text">15. Iterator 必须提供的5种相关类别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-vector%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2"><span class="toc-number">10.</span> <span class="toc-text">16.vector深度探索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-array%E3%80%81forward-list-%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2"><span class="toc-number">11.</span> <span class="toc-text">17. array、forward_list 深度探索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18%EF%BC%8C19-deque%E3%80%81queue%E5%92%8Cstack%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2"><span class="toc-number">12.</span> <span class="toc-text">18，19. deque、queue和stack深度探索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RB-tree"><span class="toc-number">13.</span> <span class="toc-text">RB-tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-set-amp-multiset"><span class="toc-number">14.</span> <span class="toc-text">21.set &amp; multiset</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-map-amp-multimap"><span class="toc-number">15.</span> <span class="toc-text">22.map &amp; multimap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23%EF%BC%8C24%E3%80%81hash-table"><span class="toc-number">16.</span> <span class="toc-text">23，24、hash table</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-unodered%E5%AE%B9%E5%99%A8%E6%A6%82%E5%BF%B5"><span class="toc-number">17.</span> <span class="toc-text">26.unodered容器概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-%E7%AE%97%E6%B3%95%E5%BD%A2%E5%BC%8F"><span class="toc-number">18.</span> <span class="toc-text">27.算法形式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">19.</span> <span class="toc-text">28. 迭代器的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%88%86%E7%B1%BB%E5%AF%B9%E7%AE%97%E6%B3%95%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">20.</span> <span class="toc-text">29. 迭代器分类对算法的影响</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30-%E7%AE%97%E6%B3%95%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90"><span class="toc-number">21.</span> <span class="toc-text">30.算法源码剖析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BF%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="toc-number">22.</span> <span class="toc-text">仿函数和函数对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#binder2nd"><span class="toc-number">23.</span> <span class="toc-text">binder2nd</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34-not1"><span class="toc-number">24.</span> <span class="toc-text">34. not1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35-bind-%EF%BC%88C-11%EF%BC%89"><span class="toc-number">25.</span> <span class="toc-text">35.bind （C++11）</span></a></li></ol>
		</div>
		
		<h3 id="1-认识header、版本、重要资源"><a href="#1-认识header、版本、重要资源" class="headerlink" title="1. 认识header、版本、重要资源"></a>1. 认识header、版本、重要资源</h3><p>头文件命名形式：</p>
<ul>
<li>C++标准库header files 不带（.h）</li>
<li>新型的C头文件不带.h</li>
<li>原先的C头文件(带有.h)的，仍旧可以使用（但是最好还是使用最新的形式）</li>
<li>所有的新式headers都在名字域“std”中</li>
<li>旧式的头文件不被包含在“std”中</li>
</ul>
<h3 id="2-STL体系结构基础介绍"><a href="#2-STL体系结构基础介绍" class="headerlink" title="2.STL体系结构基础介绍"></a>2.STL体系结构基础介绍</h3><p>STL的六大部件：</p>
<ul>
<li>容器</li>
<li>分配器</li>
<li>算法</li>
<li>迭代器</li>
<li>适配器</li>
<li>仿函数(Functors)</li>
</ul>
<img src="/.com//10/12/STL%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/20220915211226.png" class>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;vector&gt;</span>  <span class="comment">// 与容器同名</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> ia[<span class="number">6</span>] = &#123;<span class="number">27</span>, <span class="number">210</span>, <span class="number">12</span>, <span class="number">47</span>, <span class="number">109</span>, <span class="number">83</span>&#125;;</span><br><span class="line">	vector&lt;<span class="type">int</span>, allocator&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">vi</span>(ia, ia+<span class="number">6</span>);<span class="comment">// 分配器用于分配内存（一般默认）</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	count_if: algorithm;</span></span><br><span class="line"><span class="comment">	not1: function adapter(negator);</span></span><br><span class="line"><span class="comment">	bind2nd: 绑定第二参数，function adapter(binder)</span></span><br><span class="line"><span class="comment">	less: function object</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; <span class="built_in">count_if</span>(vi.<span class="built_in">begin</span>(), vi.<span class="built_in">end</span>(),</span><br><span class="line">				<span class="built_in">not1</span>(<span class="built_in">bind2nd</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(), <span class="number">40</span>)));  <span class="comment">// 大于等于40</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>标准库中的容器都是前开后闭的。但是容器的end()方法指向的是容器最后的元素的下一个元素，所以直接将这个指针解引用出来，得到的是一个未知的东西。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Container&lt;T&gt; c;</span><br><span class="line">....</span><br><span class="line">Container&lt;T&gt;::iterator ite = c.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span>(; ite != c.<span class="built_in">end</span>(); ++ite)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++11</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; elem : c)&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-6-容器分类与各种测试"><a href="#3-6-容器分类与各种测试" class="headerlink" title="3~6. 容器分类与各种测试"></a>3~6. 容器分类与各种测试</h3><p>标准库中的集合和map一般用红黑树实现。</p>
<blockquote>
<p>代码习惯：测试程序放在名字域中，对应的库放在对应的名字域中，对应的定义变量需要的时候再写，为了注明，定义变量不会进行缩进。</p>
</blockquote>
<p><strong>vector</strong>： 对于空间扩充是呈现两倍增长的。这个增长是通过找到一个新的内存，然后将原先的元素全部复制到这个新的空间中，所以这个增长的过程实际上是比较缓慢的。</p>
<p><code>deque</code> : 分段，但是逻辑上是连续的。没有自己的sort</p>
<p>关联式容器查找都非常快</p>
<p><code>multiset</code>:内部是红黑树实现的,可以包含重复元素</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">multiset&lt;string&gt;c;</span><br></pre></td></tr></table></figure>
<p><code>multimap</code>:不可以使用<code>[]</code>作为插入</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">multimap&lt;<span class="type">long</span>, string&gt;c;</span><br><span class="line">c.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">long</span>, string&gt;(i, buf));</span><br><span class="line"><span class="comment">// 访问需要使用first &amp; second</span></span><br></pre></td></tr></table></figure>
<p><code>unordered_multiset</code>:散列表实现的（哈希表）</p>
<p><code>set</code>: 不会出现重复的元素</p>
<p><code>map</code>: 底层实现是红黑树， 可以使用<code>[]</code>添加元素，key不重复，value是有重复的</p>
<h3 id="7-分配器测试"><a href="#7-分配器测试" class="headerlink" title="7. 分配器测试"></a>7. 分配器测试</h3><p>分配器用于内存分配</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p;</span><br><span class="line">__gnu_cxx::malloc_allocator&lt;<span class="type">int</span>&gt; alloc;</span><br><span class="line">p = alloc.<span class="built_in">allocate</span>(<span class="number">1</span>);</span><br><span class="line">alloc.<span class="built_in">deallocate</span>(p, <span class="number">1</span>);  <span class="comment">// 不建议使用，需要记住申请的内存的大小（用于空间释放）</span></span><br></pre></td></tr></table></figure>

<h3 id="8-源代码分布"><a href="#8-源代码分布" class="headerlink" title="8.源代码分布"></a>8.源代码分布</h3><h3 id="9-OOP-amp-泛化编程"><a href="#9-OOP-amp-泛化编程" class="headerlink" title="9. OOP &amp; 泛化编程"></a>9. OOP &amp; 泛化编程</h3><p>泛化编程是将数据和方法分开来了。容器与算法（方法）之间通过迭代器相互关联。 </p>
<blockquote>
<p>为什么list不能使用<code>::sort()</code>?<br>因为<code>::sort()</code>中使用的迭代器指针需要是能够随机访问的（能前能后），但是在list中，这种性质不满足。</p>
</blockquote>
<p><strong>特化</strong><br>模板在特定类型的时候使用特定的方法（更优的）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">type</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__type_traits</span>&#123;</span><br><span class="line">	....</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">__type_traits</span>&lt;<span class="type">int</span>&gt;&#123;</span><br><span class="line">	....</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">__type_traits</span>&lt;<span class="type">double</span>&gt;&#123;</span><br><span class="line">	....</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 偏特化，如果传入的是一个指针（范围上的偏特化）</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">type</span>&gt; <span class="keyword">struct</span> <span class="title class_">__type_traits</span>&lt;type*&gt;&#123;</span><br><span class="line">	....</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt;</span><br><span class="line"><span class="keyword">class</span> vector&#123;</span><br><span class="line">	....</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 偏特化：仅将其中一个模板参数进行特化（数量上的局部）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">vector</span>&lt;<span class="type">bool</span>, Alloc&gt;</span><br><span class="line">&#123;</span><br><span class="line">	....</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="11-分配器"><a href="#11-分配器" class="headerlink" title="11.分配器"></a>11.分配器</h3><p><code>malloc</code>申请内存的时候是有额外的开销的（其中包括了申请的空间的大小）。当申请的空间比较小的时候，这种开销占比比较大<br>在VC6的allocator中知识以<code>::operator new</code> 和 <code>::operator delete</code> 完成allocate() 和 deallocate() 没有特殊设计。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _FARQ</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> _FARQ</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> _PDFT ptrdiff_t</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> _SIZT  size_t</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _POINTER_X(T, A) T_FARQ*</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _REFFERENCE_X(T, A) T_FARQ&amp;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>&gt; <span class="keyword">inline</span></span><br><span class="line">_Ty _FARQ* _Allocate(_PDFT _N, _Ty _FARQ*)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(_N &lt; <span class="number">0</span>) _N = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ((_Ty _FARQ*) <span class="keyword">operator</span> <span class="built_in">new</span>((_SIZT)_N*<span class="built_in">sizeof</span>(_Ty)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">allocator</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> _SIZT size_type;</span><br><span class="line">    <span class="keyword">typedef</span> _PDFT difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Ty _FARQ * pointer;</span><br><span class="line">    <span class="keyword">typedef</span> _Ty value_type;</span><br><span class="line">    <span class="function">pointer <span class="title">allocate</span><span class="params">(size_type _N, <span class="type">const</span> <span class="type">void</span>*)</span> <span class="comment">// 第二个是任意参数</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> (_Allocate((difference_type) _N, (pointer)<span class="number">0</span>)); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deallocate</span><span class="params">(<span class="type">void</span> _FARQ *_P, size_type)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(_P)</span></span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配512 ints</span></span><br><span class="line"><span class="type">int</span>* p = <span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">allocate</span>(<span class="number">512</span>, (<span class="type">int</span>*<span class="number">0</span>));</span><br><span class="line"><span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">deallocate</span>(p, <span class="number">512</span>);  <span class="comment">// 用临时变量调用类方法</span></span><br></pre></td></tr></table></figure>
<p>这种方式可能会导致太大的额外开销，所以，一些改进的方法是一次申请固定倍数大小的空间，这样可以减少malloc的使用（与vector中的空间拓展思想类似）</p>
<h3 id="13、14-list源代码"><a href="#13、14-list源代码" class="headerlink" title="13、14. list源代码"></a>13、14. list源代码</h3><blockquote>
<p>i++ 和 ++i<br>因为符号一样，所以给后置版本加一个int形参作为区分，这个形参是0，但是在函数体中是用不到的，只是为了区分前置后置。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self <span class="keyword">operator</span>++(<span class="type">int</span>) &#123; ... &#125; <span class="comment">// i++</span></span><br><span class="line">self <span class="keyword">operator</span>++() &#123; ... &#125; <span class="comment">// ++i （可以认为i作为参数已经传入了）</span></span><br></pre></td></tr></table></figure>
<p>另外整数不能连续进行两次后连加，可以前加（++++i √，i++++ × ）</p>
</blockquote>
<p>为了满足容器前闭后开的性质，在list链表中会有一个空白的头节点，这个就是end指针指向的节点，其内部实际上是一个环形双向链表。</p>
<h3 id="15-Iterator-必须提供的5种相关类别"><a href="#15-Iterator-必须提供的5种相关类别" class="headerlink" title="15. Iterator 必须提供的5种相关类别"></a>15. Iterator 必须提供的5种相关类别</h3><ul>
<li>iterator_category</li>
<li>value_type</li>
<li>pointer</li>
<li>reference</li>
<li>difference_type</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">I</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::reference;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>萃取机（iterator_traits）</strong>: 用于分离class iterator 和 non-class iterator。这是用过偏特化实现的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;calss I&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type value_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两种偏特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;T*&gt;&#123;</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;<span class="type">const</span> T*&gt;&#123;</span><br><span class="line">	<span class="keyword">typedef</span> T value_type; <span class="comment">// 不能用const T，因为这样声明的变量无法赋值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取I的value_type</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> I, ...&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">algorithmn</span><span class="params">(...)</span></span>&#123;</span><br><span class="line">	<span class="keyword">typename</span> iterator_traits&lt;I&gt;::value_type v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个实例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;T*&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> T* pointer;</span><br><span class="line">    <span class="keyword">typedef</span> T&amp; reference;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="16-vector深度探索"><a href="#16-vector深度探索" class="headerlink" title="16.vector深度探索"></a>16.vector深度探索</h3><img src="/.com//10/12/STL%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/20220921095514.png" class>
<p>在进行扩充的时候，需要重新申请空间，并且原先的空间将会被销毁，这使得这个过程中需要调用大量的构造函数和析构函数。</p>
<p>如果是连续空间，那么这个容器的迭代器就可以单纯地使用指针来表现。</p>
<h3 id="17-array、forward-list-深度探索"><a href="#17-array、forward-list-深度探索" class="headerlink" title="17. array、forward_list 深度探索"></a>17. array、forward_list 深度探索</h3><p>在特化array的时候，需要指明大小，这是因为array的大小是固定的，它没有构造器和析构器。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>, 10&gt; myArray;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义数组</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">100</span>]; <span class="comment">// √</span></span><br><span class="line"><span class="comment">//int[100] a;  // ×</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> T[<span class="number">100</span>];</span><br><span class="line">T c;  <span class="comment">// √</span></span><br></pre></td></tr></table></figure>

<h3 id="18，19-deque、queue和stack深度探索"><a href="#18，19-deque、queue和stack深度探索" class="headerlink" title="18，19. deque、queue和stack深度探索"></a>18，19. deque、queue和stack深度探索</h3><p><strong>deque</strong>：这个容器的地址是由几个内存段产生的，用一个向量存储每一个内存段的首地址。对于迭代器，是由一个类组成，其中包含当前内存块的边界，当前指针指向的元素，以及当前内存块在地址向量中的位置</p>
<img src="/.com//10/12/STL%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/20220921134657.png" class>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里会找到离边界最近的方向移动元素</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="type">const</span> value_type&amp; x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(position.cur == start.cur)&#123;  <span class="comment">// 是否是在开头</span></span><br><span class="line">        <span class="built_in">push_front</span>(x);</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(position.cur == finish.cur)&#123;<span class="comment">// 是否是在尾部 </span></span><br><span class="line">        <span class="built_in">push_back</span>(x);</span><br><span class="line">        iterator tmp = finish;</span><br><span class="line">        --tmp;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">insert_aux</span>(position, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> BufSize&gt;</span><br><span class="line"><span class="keyword">typename</span> deque&lt;T, Alloc, BufSize&gt;::iterator</span><br><span class="line">deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">insert_aux</span>(iterator pos, <span class="type">const</span> value_type)&#123;</span><br><span class="line">	difference_type index = pos - start;</span><br><span class="line">	value_type x_copy = x;</span><br><span class="line">	<span class="keyword">if</span>(index &lt; <span class="built_in">size</span>()/<span class="number">2</span>)&#123;  <span class="comment">// 检查是否小于中点</span></span><br><span class="line">		<span class="built_in">push_front</span>(<span class="built_in">front</span>()); <span class="comment">//复制第一个元素</span></span><br><span class="line">		...</span><br><span class="line">		<span class="built_in">copy</span>(front2, pos1, front1);  <span class="comment">// 全部往前移动</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">push_back</span>(<span class="built_in">back</span>());</span><br><span class="line">		....</span><br><span class="line">		<span class="built_in">copy_backward</span>(pos, back2, back1);</span><br><span class="line">	&#125;</span><br><span class="line">	*pos = x_copy;</span><br><span class="line">	<span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模拟连续空间，累加，<code>[]</code>，向前移动$n$元素</p>
<p>在stack和queue中，默认一个deque。 这两者可选择list或deque作为底层结构。二者不可用set或map作为底层结构。转调用的时候，一些函数不满容器特性。<br><code>这二者不允许遍历，也不提供iterator</code>，这种操作会干扰容器的特性（FIFO 或 FILO）</p>
<p>二者不同的是，queue 不可选择vector作为底层结构，stack可以。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Sequence</span>=deque&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> queue&#123;</span><br><span class="line">	....</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	Sequence c;<span class="comment">// 底层容器</span></span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">stack&lt;string, llist&lt;string&gt;&gt;c;</span><br></pre></td></tr></table></figure>

<h3 id="RB-tree"><a href="#RB-tree" class="headerlink" title="RB-tree"></a>RB-tree</h3><p>关联式容器。<br>RB-tree：平衡二叉搜索树。有利于search和insert。rb_tree 的迭代器不应该用于修改元素，但是未被禁止这种操作，因为它为set和map服务，而map允许data被修改，只有key不可以被修改，此时，红黑树是根据map的key进行排序的。<br>红黑树提供两种insertion操作：<code>insert_unique()</code>, <code>insert_equal</code>前者key是要求独一无二的，后者可以有重复</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">KeyOfValue</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>=alloc&gt;</span><br><span class="line"><span class="keyword">class</span> rb_tree&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">typedef</span> __rb_tree_node&lt;Value&gt; rb_tree_node;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> rb_tree_node* link_type;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">// 大小为9，但是为了内存对齐，这里实际上占用的内存为12 </span></span><br><span class="line">	size_type node_count;  <span class="comment">// 节点个数</span></span><br><span class="line">	link_type header;</span><br><span class="line">	Compare key_compare;  <span class="comment">// key的大小比较准则，是一个函数对象.理论上是0，但是实现为1</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="21-set-amp-multiset"><a href="#21-set-amp-multiset" class="headerlink" title="21.set &amp; multiset"></a>21.set &amp; multiset</h3><ul>
<li>一个元素不可重复，一个可以重复。</li>
<li>无法使用二者的iterator改变元素值，这些容器中的key有其固定的排列规则，这种iterator底层是RB tree的const iterator</li>
<li>元素特性是key就是value， value就是key</li>
<li>在实现中，set都是在调用rb tree中的操作，所以可以说set是一个容器的适配器</li>
</ul>
<h3 id="22-map-amp-multimap"><a href="#22-map-amp-multimap" class="headerlink" title="22.map &amp; multimap"></a>22.map &amp; multimap</h3><ul>
<li>与之前不同的是，这里的value被分为key和data</li>
<li>其他的性质与22中提到的类似</li>
<li>multimap 不可使用<code>[]</code>, map可以，如果找到，则返回值，如果没有就将键值插入到map中。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用逻辑</span></span><br><span class="line">map&lt;<span class="type">int</span>, string&gt;my_map;</span><br><span class="line">map&lt;<span class="type">int</span>, string, less&lt;<span class="type">int</span>&gt;, alloc&gt;my_map;</span><br><span class="line"></span><br><span class="line"><span class="comment">// selectlst: 获取键值，第一个元素</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span>, pair&lt;<span class="type">const</span> <span class="type">int</span>, string&gt;, selectlst&lt;pair&lt;<span class="type">const</span> <span class="type">int</span>, string&gt;&gt;, less&lt;<span class="type">int</span>&gt;, alloc&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">rb_tree</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="23，24、hash-table"><a href="#23，24、hash-table" class="headerlink" title="23，24、hash table"></a>23，24、hash table</h3><ul>
<li>直接使用原始数字作为键值需要大量的空间，所以通常采用原始数据与一个素数的余数作为键值，这个素数可以被成为“篮子”(扩充大小实际上时固定的，根据不同的版本存在不同)</li>
<li>当元素个数大于篮子的数时，需要rehashing，重新规划篮子的大小（选下一个素数作为篮子大小，这样所有的元素都要重新计算）。</li>
</ul>
<h3 id="26-unodered容器概念"><a href="#26-unodered容器概念" class="headerlink" title="26.unodered容器概念"></a>26.unodered容器概念</h3><p>C++之后，将原先的hash_set、hash_miltiset、hash_map、hash_miltimap中的hash编程unordered</p>
<h3 id="27-算法形式"><a href="#27-算法形式" class="headerlink" title="27.算法形式"></a>27.算法形式</h3><p>算法的所需的一切信息都由迭代器取得</p>
<h3 id="28-迭代器的分类"><a href="#28-迭代器的分类" class="headerlink" title="28. 迭代器的分类"></a>28. 迭代器的分类</h3><p>随机访问迭代器、双向迭代器、单向迭代器<br>random_access_iterator, bidirectional_iterator, forward_iterator. </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 特殊的迭代器</span></span><br><span class="line"><span class="built_in">display_category</span>(<span class="built_in">istream_iterator</span>&lt;<span class="type">int</span>&gt;()); <span class="comment">// input_iterator</span></span><br><span class="line"><span class="built_in">display_category</span>(<span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(cout, <span class="string">&quot;&quot;</span>)); <span class="comment">// output_iterator</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="built_in">typeid</span>(itr).<span class="built_in">name</span>(); <span class="comment">// 查看变量类型</span></span><br></pre></td></tr></table></figure>

<h3 id="29-迭代器分类对算法的影响"><a href="#29-迭代器分类对算法的影响" class="headerlink" title="29. 迭代器分类对算法的影响"></a>29. 迭代器分类对算法的影响</h3><p>如果是随机访问迭代器，那么迭代器可以直接到达指定的位置，如果是input_iterator，迭代器只能一个个加到指定的位置，这种功能可以通过偏特化实现（特化迭代器的类型）</p>
<p>对于output iterator是write-only，无法像forward iterator那样可以read， 所以不可以使用<code>*</code>运算符进行读取</p>
<h3 id="30-算法源码剖析"><a href="#30-算法源码剖析" class="headerlink" title="30.算法源码剖析"></a>30.算法源码剖析</h3><p><strong>accumulate</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> jj34</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">myfunc</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123; <span class="keyword">return</span> x + <span class="number">2</span> * y &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> myclass&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="built_in">operator</span>()(<span class="type">int</span> x, <span class="type">int</span> y)&#123; <span class="keyword">return</span> x + <span class="number">3</span> * y; &#125;</span><br><span class="line"></span><br><span class="line">    &#125;myobj;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test_accumlate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> init = <span class="number">100</span>;</span><br><span class="line">        <span class="type">int</span> nums[] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// default</span></span><br><span class="line">        cout &lt;&lt; <span class="built_in">accumulate</span>(nums, nums + <span class="number">3</span>, init); <span class="comment">// 160</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// using functional&#x27;s minus</span></span><br><span class="line">        cout &lt;&lt; <span class="built_in">accumulate</span>(nums, nums + <span class="number">3</span>, init, <span class="built_in">minus</span>&lt;<span class="type">int</span>&gt;());  <span class="comment">//40</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Using self-defined function</span></span><br><span class="line">        cout &lt;&lt; <span class="built_in">accumulate</span>(nums, nums + <span class="number">3</span>, init, myobj);  <span class="comment">// </span></span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">       init = binary_op(init, *first) // binary_op 就是传入的函数，可以传入函数或者仿函数（重载括号运算符）</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>for_each</strong></p>
<p><strong>replace, replace_if, replace_copy</strong><br>1.替换元素，2。在给定条件下替换  3.不删除被替换元素，将其复制到其他位置</p>
<p><strong>count， count_if</strong></p>
<p><strong>find, find_if</strong><br>find:循序查找</p>
<p><strong>sort</strong>：<br>传入迭代器范围</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">begin</span>() + <span class="number">3</span>); <span class="comment">// 默认从小到大， i &lt; j</span></span><br><span class="line">vec.<span class="built_in">rbegin</span>() = vec.<span class="built_in">end</span>(); <span class="comment">// 一个反向的迭代器</span></span><br></pre></td></tr></table></figure>

<p><strong>binary_search</strong></p>
<h3 id="仿函数和函数对象"><a href="#仿函数和函数对象" class="headerlink" title="仿函数和函数对象"></a>仿函数和函数对象</h3><h3 id="binder2nd"><a href="#binder2nd" class="headerlink" title="binder2nd"></a>binder2nd</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里的less&lt;int&gt;() 不是在调用，这是一个对象</span></span><br><span class="line"><span class="built_in">count_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">not</span>(<span class="built_in">bind2nd</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(), <span class="number">40</span>)));</span><br></pre></td></tr></table></figure>
<p>仿函数可被适配的条件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Arg</span>, <span class="keyword">class</span> <span class="title class_">Result</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">unary_function</span>&#123;</span><br><span class="line">	<span class="keyword">typedef</span> Arg argument_type;</span><br><span class="line">	<span class="keyword">typedef</span> Result result_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Arg1</span>, <span class="keyword">class</span> <span class="title class_">Arg2</span>, <span class="keyword">class</span> <span class="title class_">Result</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">binary_function</span>&#123;</span><br><span class="line">	<span class="keyword">typedef</span> Arg1 first_argument_type;</span><br><span class="line">	<span class="keyword">typedef</span> Arg2 second_argument_type;</span><br><span class="line">	<span class="keyword">typedef</span> Result result_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 每一个可适配的函数都会继承上面的结构体，因为需要向Function adapter提供上面结构体定义的信息</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">less</span> : <span class="keyword">public</span> binary_function&lt;T, T, <span class="type">bool</span>&gt;&#123;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; x, <span class="type">const</span> T&amp; y)</span><span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;<span class="keyword">return</span> x &lt; y;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>新型适配器<code>bind</code>上述适配器已被弃用。</p>
<h3 id="34-not1"><a href="#34-not1" class="headerlink" title="34. not1"></a>34. not1</h3><h3 id="35-bind-（C-11）"><a href="#35-bind-（C-11）" class="headerlink" title="35.bind （C++11）"></a>35.bind （C++11）</h3><p>可以绑定：</p>
<ul>
<li>functions</li>
<li>function object</li>
<li>member function (_1需要是地址)</li>
<li>data member(_1需要是地址)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">my_divide</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span></span></span><br><span class="line"><span class="function">	</span>&#123; <span class="keyword">return</span> x/y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyPair</span>&#123;</span><br><span class="line">	<span class="type">double</span> a, b;</span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">multiply</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> a*b;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholder; <span class="comment">// adds visibility of _1, _2 ....</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> fn_five = <span class="built_in">bind</span>(my_divide, <span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; <span class="built_in">fn_five</span>() ; <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> fn_five = <span class="built_in">bind</span>(my_divide, _1, <span class="number">2</span>);  <span class="comment">// _1 占位符</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">fn_five</span>(<span class="number">10</span>) ; <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> fn_five = <span class="built_in">bind</span>(my_divide, _2, _1); <span class="comment">// _2 第二个占位符</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">fn_five</span>(<span class="number">10</span>, <span class="number">2</span>) ; <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定return type 为int</span></span><br><span class="line"><span class="keyword">auto</span> fn_five = <span class="built_in">bind</span>&lt;<span class="type">int</span>&gt;(my_divide, _2, _1); <span class="comment">// _2 第二个占位符</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">fn_five</span>(<span class="number">10</span>, <span class="number">2</span>) ; <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">MyPair ten_two&#123;<span class="number">10</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> bound_memfn = <span class="built_in">bind</span>(&amp;MyPair::multiply, _1);</span><br><span class="line">cout &lt;&lt; <span class="built_in">vound_memfn</span>(ten_two); <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 本质上就是将函数中的一个参数绑定一个固定的值</span></span><br><span class="line"><span class="comment">// ps： cbegin：表示constant</span></span><br></pre></td></tr></table></figure>  
	</div>
		<footer class="article-footer clearfix">

  <div class="article-tags">
  
  <span></span> <a href="/tags/侯捷C/">侯捷C++</a>
  </div>




<div class="article-share" id="share">

  <div data-url="http://example.com/2022/10/12/STL%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/" data-title="STL和泛型编程 | Hexo" data-tsina="" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2022/10/12/C-primer/" title="C++ primer">
  <strong>PREVIOUS:</strong><br/>
  <span>
  C++ primer</span>
</a>
</div>


<div class="next">
<a href="/2022/10/12/C-标准11-14/"  title="C++标准11-14">
 <strong>NEXT:</strong><br/> 
 <span>C++标准11-14
</span>
</a>
</div>

</nav>

	
</div>  
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">Contents</strong>
  <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%AE%A4%E8%AF%86header%E3%80%81%E7%89%88%E6%9C%AC%E3%80%81%E9%87%8D%E8%A6%81%E8%B5%84%E6%BA%90"><span class="toc-number">1.</span> <span class="toc-text">1. 认识header、版本、重要资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-STL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.</span> <span class="toc-text">2.STL体系结构基础介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-%E5%AE%B9%E5%99%A8%E5%88%86%E7%B1%BB%E4%B8%8E%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95"><span class="toc-number">3.</span> <span class="toc-text">3~6. 容器分类与各种测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%88%86%E9%85%8D%E5%99%A8%E6%B5%8B%E8%AF%95"><span class="toc-number">4.</span> <span class="toc-text">7. 分配器测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E5%B8%83"><span class="toc-number">5.</span> <span class="toc-text">8.源代码分布</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-OOP-amp-%E6%B3%9B%E5%8C%96%E7%BC%96%E7%A8%8B"><span class="toc-number">6.</span> <span class="toc-text">9. OOP &amp; 泛化编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E5%88%86%E9%85%8D%E5%99%A8"><span class="toc-number">7.</span> <span class="toc-text">11.分配器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13%E3%80%8114-list%E6%BA%90%E4%BB%A3%E7%A0%81"><span class="toc-number">8.</span> <span class="toc-text">13、14. list源代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-Iterator-%E5%BF%85%E9%A1%BB%E6%8F%90%E4%BE%9B%E7%9A%845%E7%A7%8D%E7%9B%B8%E5%85%B3%E7%B1%BB%E5%88%AB"><span class="toc-number">9.</span> <span class="toc-text">15. Iterator 必须提供的5种相关类别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-vector%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2"><span class="toc-number">10.</span> <span class="toc-text">16.vector深度探索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-array%E3%80%81forward-list-%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2"><span class="toc-number">11.</span> <span class="toc-text">17. array、forward_list 深度探索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18%EF%BC%8C19-deque%E3%80%81queue%E5%92%8Cstack%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2"><span class="toc-number">12.</span> <span class="toc-text">18，19. deque、queue和stack深度探索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RB-tree"><span class="toc-number">13.</span> <span class="toc-text">RB-tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-set-amp-multiset"><span class="toc-number">14.</span> <span class="toc-text">21.set &amp; multiset</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-map-amp-multimap"><span class="toc-number">15.</span> <span class="toc-text">22.map &amp; multimap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23%EF%BC%8C24%E3%80%81hash-table"><span class="toc-number">16.</span> <span class="toc-text">23，24、hash table</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-unodered%E5%AE%B9%E5%99%A8%E6%A6%82%E5%BF%B5"><span class="toc-number">17.</span> <span class="toc-text">26.unodered容器概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-%E7%AE%97%E6%B3%95%E5%BD%A2%E5%BC%8F"><span class="toc-number">18.</span> <span class="toc-text">27.算法形式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">19.</span> <span class="toc-text">28. 迭代器的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%88%86%E7%B1%BB%E5%AF%B9%E7%AE%97%E6%B3%95%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">20.</span> <span class="toc-text">29. 迭代器分类对算法的影响</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30-%E7%AE%97%E6%B3%95%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90"><span class="toc-number">21.</span> <span class="toc-text">30.算法源码剖析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BF%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="toc-number">22.</span> <span class="toc-text">仿函数和函数对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#binder2nd"><span class="toc-number">23.</span> <span class="toc-text">binder2nd</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34-not1"><span class="toc-number">24.</span> <span class="toc-text">34. not1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35-bind-%EF%BC%88C-11%EF%BC%89"><span class="toc-number">25.</span> <span class="toc-text">35.bind （C++11）</span></a></li></ol>
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  

  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			<li><a href="/tags/C-primer/" title="C++ primer">C++ primer<sup>1</sup></a></li>
		
			<li><a href="/tags/DB/" title="DB">DB<sup>1</sup></a></li>
		
			<li><a href="/tags/OS/" title="OS">OS<sup>2</sup></a></li>
		
			<li><a href="/tags/Projects/" title="Projects">Projects<sup>1</sup></a></li>
		
			<li><a href="/tags/侯捷C/" title="侯捷C++">侯捷C++<sup>5</sup></a></li>
		
		</ul>
</div>


  <div class="rsspart">
	<a href="" target="_blank" title="rss">RSS</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<div class="social-font clearfix">
		
		
		
		
		
	</div>
		<p class="copyright">Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/A-limon/pacman" target="_blank" title="Pacman">Pacman</a> © 2023 
		
		<a href="http://example.com" target="_blank" title="John Doe">John Doe</a>
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>






  </body>
</html>
