<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>Q&amp;A - Hexo</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Hexo"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Hexo"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="右值引用的用法12&amp;#x2F;&amp;#x2F; 引用右值，避免生成新对象Foo&amp;amp;&amp;amp; foo2 &amp;#x3D; FooFactory(); 关于std::move函数  std::move移动不了什么，唯一的功能是把左值强制转化为右值，让右值引用可以指向左值。其实现等同于一个类型转换：static_cast(lvalue)。 所以，单纯的std::move(xxx)不会有性能提升. move返回值如果有名称就是左值（被"><meta property="og:type" content="article"><meta property="og:title" content="Q&amp;A"><meta property="og:url" content="https://baymine.github.io/2022/11/23/Q-A/"><meta property="og:site_name" content="Hexo"><meta property="og:description" content="右值引用的用法12&amp;#x2F;&amp;#x2F; 引用右值，避免生成新对象Foo&amp;amp;&amp;amp; foo2 &amp;#x3D; FooFactory(); 关于std::move函数  std::move移动不了什么，唯一的功能是把左值强制转化为右值，让右值引用可以指向左值。其实现等同于一个类型转换：static_cast(lvalue)。 所以，单纯的std::move(xxx)不会有性能提升. move返回值如果有名称就是左值（被"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://baymine.github.io/img/og_image.png"><meta property="article:published_time" content="2022-11-23T08:06:49.000Z"><meta property="article:modified_time" content="2023-01-14T00:01:01.097Z"><meta property="article:author" content="John Doe"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://baymine.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://baymine.github.io/2022/11/23/Q-A/"},"headline":"Q&A","image":["https://baymine.github.io/img/og_image.png"],"datePublished":"2022-11-23T08:06:49.000Z","dateModified":"2023-01-14T00:01:01.097Z","author":{"@type":"Person","name":"John Doe"},"publisher":{"@type":"Organization","name":"Hexo","logo":{"@type":"ImageObject"}},"description":"右值引用的用法12&#x2F;&#x2F; 引用右值，避免生成新对象Foo&amp;&amp; foo2 &#x3D; FooFactory(); 关于std::move函数  std::move移动不了什么，唯一的功能是把左值强制转化为右值，让右值引用可以指向左值。其实现等同于一个类型转换：static_cast(lvalue)。 所以，单纯的std::move(xxx)不会有性能提升. move返回值如果有名称就是左值（被"}</script><link rel="canonical" href="https://baymine.github.io/2022/11/23/Q-A/"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head><body class="is-1-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">Hexo</a></div><div class="navbar-menu"><div class="navbar-end"></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-12"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-11-23T08:06:49.000Z" title="11/23/2022, 4:06:49 PM">2022-11-23</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-01-14T00:01:01.097Z" title="1/14/2023, 8:01:01 AM">2023-01-14</time></span></div></div><h1 class="title is-3 is-size-4-mobile">Q&amp;A</h1><div class="content"><h2 id="右值引用的用法"><a href="#右值引用的用法" class="headerlink" title="右值引用的用法"></a>右值引用的用法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引用右值，避免生成新对象</span></span><br><span class="line">Foo&amp;&amp; foo2 = <span class="built_in">FooFactory</span>();</span><br></pre></td></tr></table></figure>
<p><strong><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/335994370">关于std::move函数</a></strong></p>
<blockquote>
<p>std::move移动不了什么，唯一的功能是把左值强制转化为右值，让右值引用可以指向左值。其实现等同于一个类型转换：static_cast<t&&>(lvalue)。 所以，单纯的std::move(xxx)不会有性能提升. move返回值如果有名称就是左值（被赋值给一个变量），没有名称就是右值。</t&&></p>
<p><strong>使用建议</strong>：可移动对象在&lt;需要拷贝且被拷贝者之后不再被需要&gt;的场景，建议使用std::move触发移动语义，提升性能。（类似于 <code>push_back</code>等的函数）。</p>
<p>对于 <code>unique_ptr</code>只能进行移动构造函数，所以可以使用 <code>move</code>实现赋值构造<br><code>std::unique_ptr&lt;A&gt; ptr = std::move(ptr_a);</code>.</p>
</blockquote>
<p><strong>完美转发 std::forward</strong></p>
<blockquote>
<p>std::forward <code>&lt;T&gt;</code>(u)有两个参数：T与 u。 a. 当T为左值引用类型时，u将被转换为T类型的左值； b. 否则u将被转换为T类型右值。</p>
</blockquote>
<ul>
<li>const右值引用传入的参数可以被修改，而const左值传入的则不可以修改。</li>
</ul>
<h2 id="C-为什么不推荐使用vector"><a href="#C-为什么不推荐使用vector" class="headerlink" title="C++为什么不推荐使用vector\"></a><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/23367698">C++为什么不推荐使用vector\<bool\></bool\></a></h2><p>vector&lt; bool&gt;不是一个标准容器，就是因为它不能支持一些容器该有的基本操作，诸如取地址给指针初始化操作.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">bool</span>&gt; c{<span class="literal">false</span>, <span class="literal">false</span>};</span><br><span class="line"><span class="type">bool</span> b = c[<span class="number">0</span>]; <span class="comment">// 这里有一个隐式的类型转换</span></span><br></pre></td></tr></table></figure>
<h2 id="冷不命中-cold-miss"><a href="#冷不命中-cold-miss" class="headerlink" title="冷不命中(cold miss)"></a>冷不命中(cold miss)</h2><p>缓存会在断电之后清空，那么是不是意味着在刚开机的时候，电脑运行的速度会相对较慢？</p>
<h2 id="ssh命令传输方式"><a href="#ssh命令传输方式" class="headerlink" title="ssh命令传输方式"></a>ssh命令传输方式</h2><p>为什么会因为网络波动而导致无法输入的情况</p>
<h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><ul>
<li>为什么在Xftp中删除文件那么慢，而直接使用rm会快很多？</li>
<li>写入空白和覆盖哪个速度更快？</li>
<li>为什么这么写？while(-1 != (opt = getopt(argc, argv, “x:y:”)))<ul>
<li>防止将==写成=，此时，如果写成a=1编译会通过，如果写成1=a编译不会通过，这样做也可减少这种隐形的bug的出现</li>
</ul>
</li>
<li>函数指针（typedef）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// note that the typedef name is indeed myFuncDef</span></span><br><span class="line"><span class="comment">// Confused here ???????</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*myFuncDef)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">myFuncDef <span class="title">functionFactory</span><span class="params">(<span class="type">int</span> n)</span> </span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Got parameter %d"</span>, n);</span><br><span class="line">    myFuncDef functionPtr = &amp;addInt;</span><br><span class="line">    <span class="keyword">return</span> functionPtr;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<ul>
<li>void (*0)( ) ：是⼀个返回值为void，参数为空的函数指针0 (这里的意思是函数名为0吗？)</li>
<li>为什么在Linux下不能同时安装多个软件，但是在Windows下可以？（并行和串行的优劣？）</li>
<li>在fork之后，父进程和子进程的运行有先后顺序吗？</li>
<li><p>函数名是不是就是函数指针？(是，那么为什么不需要解引用，直接可以调用？)我可以通过函数名调用函数，那可不可以认为这个函数名就是一个句柄？如何理解句柄？异常表中存储就是各种异常处理函数的句柄？能不能理解为一个整数到一个指针的映射？</p>
<blockquote>
<p><strong>为什么要用 handle，而不直接用指针呢？</strong></p>
<ul>
<li>指针作用太强，可做的事情太多。可做的事情越多，就会越危险。接口设计中，功能刚刚好就够了，并非越多权限越好的。</li>
<li>handle 通常只是个整数，实现被隐藏起来，假如直接暴露了指针，也就暴露了指针类型（有时也可以暴露 void* 指针作为某种 handle）。用户看到越多细节，其代码就越有可能依赖这些细节。将来情况有变，但又要兼容用户代码，库内部改起来就更麻烦。</li>
<li>资源在内部管理，通过 handle 作为中间层，可以有效判断 handle 是否合法，也可以通过权限检查防止某种危险操作。</li>
<li>handle 通常只是个整数，所有的语言都有整数这种类型，但并非所有语言都有指针。接口只出现整数，方便同一实现绑定到各种语言。</li>
</ul>
</blockquote>
</li>
<li>在编写信号处理器的时候，最好调用异步信号安全性函数，那为什么不能再执行函数的时候阻塞所有的信号，这样不能保证函数的原子性吗？</li>
<li>printf 和cout混用会有什么后果吗？</li>
<li>free 或者delete掉malloc 或 new 出来的内存会发生什么？</li>
<li>csapp p588: 在32位模式中，  malloc返回的块的地址总是8的倍数，64位模式中，总是16的倍数。 这是为什么？</li>
<li>双字对齐的约束下，块的大小总是为8的倍数，且块大小的最低三位总是为0（这样才能是8的倍数，这里双字表示8字节）</li>
<li>csapp: 练习题9.6中的块大小的计算方法(get)</li>
<li>docker &amp; virtual machine 之间有什么区别？</li>
<li><blockquote>
<p>向上转型：子类除继承父类数据成员，并且还会有自己的数据成员，但是在向上转型后子类的数据成员会被舍弃</p>
</blockquote>
</li>
<li>转型之后的指针为什么可以通过子类的共有方法调用子类成员变量？</li>
<li>多线程：如何理解多线程代码的执行过程，虚假唤醒</li>
</ul>
<h2 id="代码哲学"><a href="#代码哲学" class="headerlink" title="代码哲学"></a>代码哲学</h2><ul>
<li>为什么说各个编程语言之间粒度不同呢？在什么方面体现？<ul>
<li>如果相应的库被实现了，那么这个语言的粒度会不会改变？</li>
</ul>
</li>
<li>短期内形成对方案的评估的能力，能够知晓方案的可行性、难点的能力，这种能力叫什么？如何训练（在刷算法题的时候，往往在完成过程中才能知晓这些，可能的原因有考虑不充分等）</li>
<li>见到一种技术，如何从技术实现得到技术的类型？</li>
<li>将碎片知识进行体系化</li>
<li>解决一个算法问题的过程</li>
<li>为什么说计算机领域最难的两个问题是变量命名和缓存不命中？</li>
</ul>
</div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2022/11/29/Basic_must_known/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Basic Knoledge</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2022/11/08/%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/"><span class="level-item">命令笔记</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><!--!--><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">Hexo</a><p class="is-size-7"><span>&copy; 2024 John Doe</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><!--!--><script data-pjax src="/js/main.js" defer></script><!--!--></body></html>