<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>Tag: 侯捷C++ - Baymine&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Baymine&#039;s Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Baymine&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Baymine&#039;s Blog"><meta property="og:url" content="https://baymine.github.io/"><meta property="og:site_name" content="Baymine&#039;s Blog"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://baymine.github.io/img/og_image.png"><meta property="article:author" content="John Doe"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://baymine.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://Baymine.github.io"},"headline":"Baymine's Blog","image":["https://baymine.github.io/img/og_image.png"],"author":{"@type":"Person","name":"John Doe"},"publisher":{"@type":"Organization","name":"Baymine's Blog","logo":{"@type":"ImageObject","url":"https://baymine.github.io/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style><link rel="alternate" href="/atom.xml" title="Baymine's Blog" type="application/atom+xml">
</head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Baymine&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags">Tags</a></li><li class="is-active"><a href="#" aria-current="page">侯捷C++</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-12-18T07:04:19.000Z" title="12/18/2022, 3:04:19 PM">2022-12-18</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-06-16T08:44:58.017Z" title="6/16/2024, 4:44:58 PM">2024-06-16</time></span><span class="level-item">4 minutes read (About 641 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/12/18/C-Memory-Management/">C++ Memory Management</a></p><div class="content"><h1 id="第一讲-primitives"><a href="#第一讲-primitives" class="headerlink" title="第一讲 primitives"></a>第一讲 primitives</h1><h3 id="1-overview"><a href="#1-overview" class="headerlink" title="1. overview"></a>1. overview</h3><ul>
<li>资料： <a target="_blank" rel="noopener" href="http://gee.cs.oswego.edu/dl/">DL Malloc</a></li>
<li>涉及的库</li>
</ul>
<p><img src="https://Baymine.github.io/images/C-Memory-Management/1671347745514.png" alt="1671347745514"></p>
<h3 id="2、3-内存分配的每一层面及基本用法"><a href="#2、3-内存分配的每一层面及基本用法" class="headerlink" title="2、3. 内存分配的每一层面及基本用法"></a>2、3. 内存分配的每一层面及基本用法</h3><p><img src="https://Baymine.github.io/images/C-Memory-Management/1671348085106.png" alt="1671348085106"></p>
<p>本课程只考虑CRT以上的层次。</p>
<p><strong>基本工具</strong></p>
<p><img src="https://Baymine.github.io/images/C-Memory-Management/1671348161500.png" alt="1671348161500"></p>
<p><strong>基本用法</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* p3 = ::<span class="keyword">operator</span> <span class="built_in">new</span> (<span class="number">512</span>);   <span class="comment">// 512 bytes</span></span><br><span class="line">::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(p3)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __BORLANDC__  <span class="comment">// 不同库不同</span></span></span><br><span class="line">	<span class="comment">// 申请5个int。 一般容器中使用</span></span><br><span class="line">	<span class="type">int</span>* p4 = <span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">allocate</span>(<span class="number">5</span>);</span><br><span class="line">	<span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">deallocate</span>(p4, <span class="number">5</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __GNUC__   <span class="comment">// 较早版本中</span></span></span><br><span class="line">	<span class="type">void</span>* p4 = alloc::<span class="built_in">allocate</span>(<span class="number">512</span>);</span><br><span class="line">	alloc::<span class="built_in">deallocate</span>(p4, <span class="number">512</span>);</span><br><span class="line"> <span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="4、5、6、基本构件——new-delete-expression"><a href="#4、5、6、基本构件——new-delete-expression" class="headerlink" title="4、5、6、基本构件——new delete expression"></a>4、5、6、基本构件——new delete expression</h3><p>new 中实际上就是在调用malloc</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class_name* pc = <span class="keyword">new</span> <span class="built_in">class_name</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器转换为</span></span><br><span class="line"><span class="comment">// 加上try catch</span></span><br><span class="line"><span class="type">void</span>* mem = <span class="keyword">operator</span> <span class="built_in">new</span>(<span class="built_in">sizeof</span>(class_name));</span><br><span class="line">pc = <span class="built_in">static_cast</span>&lt;class_name*&gt;(mem);</span><br><span class="line">pc-&gt;class_name::<span class="built_in">class_name</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 只有编译其才能这样调用构造函数</span></span><br><span class="line"><span class="comment">// 但是可以直接调用析构函数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="7、Array-new"><a href="#7、Array-new" class="headerlink" title="7、Array new"></a>7、Array new</h3><p>当new一个数组的时候，系统会使用4个字节存放数组的一些信息，即为下图中的 <code>cookie</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Complex* pca = <span class="keyword">new</span> Complex[<span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<p><img src="https://Baymine.github.io/images/C-Memory-Management/1671438018665.png" alt="1671438018665"></p>
<ul>
<li>在进行array new的时候，单个元素不会独自进行内存对齐。</li>
<li>构建的时候是从上往下，析构的时候是由下往上</li>
<li><img src="https://Baymine.github.io/images/C-Memory-Management/1671439085184.png" alt="1671439085184"><ul>
<li><code>61h</code>就是cokie，需要进行内存对齐（VC6)中是16位对齐</li>
<li>对于申请的int类型的数组，可以直接使用delete，因为这些数据类型没有析构函数，</li>
</ul>
</li>
<li><img src="https://Baymine.github.io/images/C-Memory-Management/1671440046493.png" alt="1671440046493"><ul>
<li>因为数组个数被写入，所以内存的整体布局会发生变化，所以不能直接用 <code>delete</code>来回收</li>
<li><code>61h</code>的大小计算<ul>
<li>类大小<em>类个数=((3</em>4) <em> 3) = 36\ 上下debugger header = 32 + 4\ 两个61h=4</em>2=8</li>
<li>最后向16的倍数内存对齐最后的 <code>pad</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="8-palcement-new"><a href="#8-palcement-new" class="headerlink" title="8.palcement new"></a>8.palcement new</h3><p>允许将对象构造与已分配的内存中</p>
<p><img src="https://Baymine.github.io/images/C-Memory-Management/1671441329456.png" alt="1671441329456"></p>
<h3 id="9-random"><a href="#9-random" class="headerlink" title="9.random"></a>9.random</h3><ul>
<li>placement new 的重载</li>
<li>嵌入式指针使用案例（内存池）<ul>
<li>通过一次性申请一定量的内存，减少每个内存中的cookie的数量，同时减少malloc的调用</li>
<li>整个内存是通过一个链表管理的，释放内存就是将空闲的内存插入到链表头部</li>
<li>但是申请的内存没有真正释放，所以可能会存在使用峰值的问题</li>
</ul>
</li>
</ul>
<p><img src="https://Baymine.github.io/images/C-Memory-Management/1671541094430.png" alt="1671541094430"></p>
<ul>
<li>可以自定义handler来让更多的空间可用，或者调用abort() 或 exit();</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set_new_handler</span>(handlerFunctionPoint);</span><br></pre></td></tr></table></figure>
<ul>
<li>default, delete 关键字</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-10-12T11:46:55.000Z" title="10/12/2022, 7:46:55 PM">2022-10-12</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-06-16T09:13:24.202Z" title="6/16/2024, 5:13:24 PM">2024-06-16</time></span><span class="level-item">22 minutes read (About 3323 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/10/12/STL%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/">STL和泛型编程</a></p><div class="content"><h3 id="1-认识header、版本、重要资源"><a href="#1-认识header、版本、重要资源" class="headerlink" title="1. 认识header、版本、重要资源"></a>1. 认识header、版本、重要资源</h3><p>头文件命名形式：</p>
<ul>
<li>C++标准库header files 不带（.h）</li>
<li>新型的C头文件不带.h</li>
<li>原先的C头文件(带有.h)的，仍旧可以使用（但是最好还是使用最新的形式）</li>
<li>所有的新式headers都在名字域“std”中</li>
<li>旧式的头文件不被包含在“std”中</li>
</ul>
<h3 id="2-STL体系结构基础介绍"><a href="#2-STL体系结构基础介绍" class="headerlink" title="2.STL体系结构基础介绍"></a>2.STL体系结构基础介绍</h3><p>STL的六大部件：</p>
<ul>
<li>容器</li>
<li>分配器</li>
<li>算法</li>
<li>迭代器</li>
<li>适配器</li>
<li>仿函数(Functors)</li>
</ul>
<p><img src="https://Baymine.github.io/images/STL和泛型编程/20220915211226.png" alt></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;vector&gt;</span>  <span class="comment">// 与容器同名</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">int</span> ia[<span class="number">6</span>] = {<span class="number">27</span>, <span class="number">210</span>, <span class="number">12</span>, <span class="number">47</span>, <span class="number">109</span>, <span class="number">83</span>};</span><br><span class="line">	vector&lt;<span class="type">int</span>, allocator&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">vi</span>(ia, ia+<span class="number">6</span>);<span class="comment">// 分配器用于分配内存（一般默认）</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	count_if: algorithm;</span></span><br><span class="line"><span class="comment">	not1: function adapter(negator);</span></span><br><span class="line"><span class="comment">	bind2nd: 绑定第二参数，function adapter(binder)</span></span><br><span class="line"><span class="comment">	less: function object</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; <span class="built_in">count_if</span>(vi.<span class="built_in">begin</span>(), vi.<span class="built_in">end</span>(),</span><br><span class="line">				<span class="built_in">not1</span>(<span class="built_in">bind2nd</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(), <span class="number">40</span>)));  <span class="comment">// 大于等于40</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>标准库中的容器都是前开后闭的。但是容器的end()方法指向的是容器最后的元素的下一个元素，所以直接将这个指针解引用出来，得到的是一个未知的东西。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Container&lt;T&gt; c;</span><br><span class="line">....</span><br><span class="line">Container&lt;T&gt;::iterator ite = c.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span>(; ite != c.<span class="built_in">end</span>(); ++ite)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++11</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; elem : c){</span><br><span class="line">	...</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<h3 id="3-6-容器分类与各种测试"><a href="#3-6-容器分类与各种测试" class="headerlink" title="3~6. 容器分类与各种测试"></a>3~6. 容器分类与各种测试</h3><p>标准库中的集合和map一般用红黑树实现。</p>
<blockquote>
<p>代码习惯：测试程序放在名字域中，对应的库放在对应的名字域中，对应的定义变量需要的时候再写，为了注明，定义变量不会进行缩进。</p>
</blockquote>
<p><strong>vector</strong>： 对于空间扩充是呈现两倍增长的。这个增长是通过找到一个新的内存，然后将原先的元素全部复制到这个新的空间中，所以这个增长的过程实际上是比较缓慢的。</p>
<p><code>deque</code> : 分段，但是逻辑上是连续的。没有自己的sort</p>
<p>关联式容器查找都非常快</p>
<p><code>multiset</code>:内部是红黑树实现的,可以包含重复元素<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">multiset&lt;string&gt;c;</span><br></pre></td></tr></table></figure><br><code>multimap</code>:不可以使用<code>[]</code>作为插入<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">multimap&lt;<span class="type">long</span>, string&gt;c;</span><br><span class="line">c.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">long</span>, string&gt;(i, buf));</span><br><span class="line"><span class="comment">// 访问需要使用first &amp; second</span></span><br></pre></td></tr></table></figure><br><code>unordered_multiset</code>:散列表实现的（哈希表）</p>
<p><code>set</code>: 不会出现重复的元素</p>
<p><code>map</code>: 底层实现是红黑树， 可以使用<code>[]</code>添加元素，key不重复，value是有重复的</p>
<h3 id="7-分配器测试"><a href="#7-分配器测试" class="headerlink" title="7. 分配器测试"></a>7. 分配器测试</h3><p>分配器用于内存分配<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p;</span><br><span class="line">__gnu_cxx::malloc_allocator&lt;<span class="type">int</span>&gt; alloc;</span><br><span class="line">p = alloc.<span class="built_in">allocate</span>(<span class="number">1</span>);</span><br><span class="line">alloc.<span class="built_in">deallocate</span>(p, <span class="number">1</span>);  <span class="comment">// 不建议使用，需要记住申请的内存的大小（用于空间释放）</span></span><br></pre></td></tr></table></figure></p>
<h3 id="8-源代码分布"><a href="#8-源代码分布" class="headerlink" title="8.源代码分布"></a>8.源代码分布</h3><h3 id="9-OOP-amp-泛化编程"><a href="#9-OOP-amp-泛化编程" class="headerlink" title="9. OOP & 泛化编程"></a>9. OOP &amp; 泛化编程</h3><p>泛化编程是将数据和方法分开来了。容器与算法（方法）之间通过迭代器相互关联。 </p>
<blockquote>
<p>为什么list不能使用<code>::sort()</code>?\<br>因为<code>::sort()</code>中使用的迭代器指针需要是能够随机访问的（能前能后），但是在list中，这种性质不满足。</p>
</blockquote>
<p><strong>特化</strong>\<br>模板在特定类型的时候使用特定的方法（更优的）<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">type</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__type_traits</span>{</span><br><span class="line">	....</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">__type_traits</span>&lt;<span class="type">int</span>&gt;{</span><br><span class="line">	....</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">__type_traits</span>&lt;<span class="type">double</span>&gt;{</span><br><span class="line">	....</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 偏特化，如果传入的是一个指针（范围上的偏特化）</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">type</span>&gt; <span class="keyword">struct</span> <span class="title class_">__type_traits</span>&lt;type*&gt;{</span><br><span class="line">	....</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt;</span><br><span class="line"><span class="keyword">class</span> vector{</span><br><span class="line">	....</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 偏特化：仅将其中一个模板参数进行特化（数量上的局部）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">vector</span>&lt;<span class="type">bool</span>, Alloc&gt;</span><br><span class="line">{</span><br><span class="line">	....</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="11-分配器"><a href="#11-分配器" class="headerlink" title="11.分配器"></a>11.分配器</h3><p><code>malloc</code>申请内存的时候是有额外的开销的（其中包括了申请的空间的大小）。当申请的空间比较小的时候，这种开销占比比较大\<br>在VC6的allocator中知识以<code>::operator new</code> 和 <code>::operator delete</code> 完成allocate() 和 deallocate() 没有特殊设计。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _FARQ</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> _FARQ</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> _PDFT ptrdiff_t</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> _SIZT  size_t</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _POINTER_X(T, A) T_FARQ*</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _REFFERENCE_X(T, A) T_FARQ&amp;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>&gt; <span class="keyword">inline</span></span><br><span class="line">_Ty _FARQ* _Allocate(_PDFT _N, _Ty _FARQ*)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(_N &lt; <span class="number">0</span>) _N = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ((_Ty _FARQ*) <span class="keyword">operator</span> <span class="built_in">new</span>((_SIZT)_N*<span class="built_in">sizeof</span>(_Ty)));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">allocator</span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> _SIZT size_type;</span><br><span class="line">    <span class="keyword">typedef</span> _PDFT difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Ty _FARQ * pointer;</span><br><span class="line">    <span class="keyword">typedef</span> _Ty value_type;</span><br><span class="line">    <span class="function">pointer <span class="title">allocate</span><span class="params">(size_type _N, <span class="type">const</span> <span class="type">void</span>*)</span> <span class="comment">// 第二个是任意参数</span></span></span><br><span class="line"><span class="function">    </span>{ <span class="keyword">return</span> (_Allocate((difference_type) _N, (pointer)<span class="number">0</span>)); }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deallocate</span><span class="params">(<span class="type">void</span> _FARQ *_P, size_type)</span></span></span><br><span class="line"><span class="function">    </span>{ <span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(_P)</span></span>; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配512 ints</span></span><br><span class="line"><span class="type">int</span>* p = <span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">allocate</span>(<span class="number">512</span>, (<span class="type">int</span>*<span class="number">0</span>));</span><br><span class="line"><span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">deallocate</span>(p, <span class="number">512</span>);  <span class="comment">// 用临时变量调用类方法</span></span><br></pre></td></tr></table></figure><br>这种方式可能会导致太大的额外开销，所以，一些改进的方法是一次申请固定倍数大小的空间，这样可以减少malloc的使用（与vector中的空间拓展思想类似）</p>
<h3 id="13、14-list源代码"><a href="#13、14-list源代码" class="headerlink" title="13、14. list源代码"></a>13、14. list源代码</h3><blockquote>
<p>i++ 和 ++i\<br>因为符号一样，所以给后置版本加一个int形参作为区分，这个形参是0，但是在函数体中是用不到的，只是为了区分前置后置。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self <span class="keyword">operator</span>++(<span class="type">int</span>) { ... } <span class="comment">// i++</span></span><br><span class="line">self <span class="keyword">operator</span>++() { ... } <span class="comment">// ++i （可以认为i作为参数已经传入了）</span></span><br></pre></td></tr></table></figure><br>另外整数不能连续进行两次后连加，可以前加（++++i √，i++++ × ）</p>
</blockquote>
<p>为了满足容器前闭后开的性质，在list链表中会有一个空白的头节点，这个就是end指针指向的节点，其内部实际上是一个环形双向链表。</p>
<h3 id="15-Iterator-必须提供的5种相关类别"><a href="#15-Iterator-必须提供的5种相关类别" class="headerlink" title="15. Iterator 必须提供的5种相关类别"></a>15. Iterator 必须提供的5种相关类别</h3><ul>
<li>iterator_category</li>
<li>value_type</li>
<li>pointer</li>
<li>reference</li>
<li>difference_type</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">I</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::reference;</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<p><strong>萃取机（iterator_traits）</strong>: 用于分离class iterator 和 non-class iterator。这是用过偏特化实现的<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;calss I&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>{</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type value_type;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两种偏特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;T*&gt;{</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;<span class="type">const</span> T*&gt;{</span><br><span class="line">	<span class="keyword">typedef</span> T value_type; <span class="comment">// 不能用const T，因为这样声明的变量无法赋值</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取I的value_type</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> I, ...&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">algorithmn</span><span class="params">(...)</span></span>{</span><br><span class="line">	<span class="keyword">typename</span> iterator_traits&lt;I&gt;::value_type v1;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个实例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;T*&gt;</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> T* pointer;</span><br><span class="line">    <span class="keyword">typedef</span> T&amp; reference;</span><br><span class="line">};</span><br></pre></td></tr></table></figure></p>
<h3 id="16-vector深度探索"><a href="#16-vector深度探索" class="headerlink" title="16.vector深度探索"></a>16.vector深度探索</h3><p><img src="https://Baymine.github.io/images/STL和泛型编程/20220921095514.png" alt></p>
<p>在进行扩充的时候，需要重新申请空间，并且原先的空间将会被销毁，这使得这个过程中需要调用大量的构造函数和析构函数。</p>
<p>如果是连续空间，那么这个容器的迭代器就可以单纯地使用指针来表现。</p>
<h3 id="17-array、forward-list-深度探索"><a href="#17-array、forward-list-深度探索" class="headerlink" title="17. array、forward_list 深度探索"></a>17. array、forward_list 深度探索</h3><p>在特化array的时候，需要指明大小，这是因为array的大小是固定的，它没有构造器和析构器。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>, 10&gt; myArray;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义数组</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">100</span>]; <span class="comment">// √</span></span><br><span class="line"><span class="comment">//int[100] a;  // ×</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> T[<span class="number">100</span>];</span><br><span class="line">T c;  <span class="comment">// √</span></span><br></pre></td></tr></table></figure></p>
<h3 id="18，19-deque、queue和stack深度探索"><a href="#18，19-deque、queue和stack深度探索" class="headerlink" title="18，19. deque、queue和stack深度探索"></a>18，19. deque、queue和stack深度探索</h3><p><strong>deque</strong>：这个容器的地址是由几个内存段产生的，用一个向量存储每一个内存段的首地址。对于迭代器，是由一个类组成，其中包含当前内存块的边界，当前指针指向的元素，以及当前内存块在地址向量中的位置<br><img src="https://Baymine.github.io/images/STL和泛型编程/20220921134657.png" alt></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里会找到离边界最近的方向移动元素</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="type">const</span> value_type&amp; x)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(position.cur == start.cur){  <span class="comment">// 是否是在开头</span></span><br><span class="line">        <span class="built_in">push_front</span>(x);</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(position.cur == finish.cur){<span class="comment">// 是否是在尾部 </span></span><br><span class="line">        <span class="built_in">push_back</span>(x);</span><br><span class="line">        iterator tmp = finish;</span><br><span class="line">        --tmp;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">insert_aux</span>(position, x);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> BufSize&gt;</span><br><span class="line"><span class="keyword">typename</span> deque&lt;T, Alloc, BufSize&gt;::iterator</span><br><span class="line">deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">insert_aux</span>(iterator pos, <span class="type">const</span> value_type){</span><br><span class="line">	difference_type index = pos - start;</span><br><span class="line">	value_type x_copy = x;</span><br><span class="line">	<span class="keyword">if</span>(index &lt; <span class="built_in">size</span>()/<span class="number">2</span>){  <span class="comment">// 检查是否小于中点</span></span><br><span class="line">		<span class="built_in">push_front</span>(<span class="built_in">front</span>()); <span class="comment">//复制第一个元素</span></span><br><span class="line">		...</span><br><span class="line">		<span class="built_in">copy</span>(front2, pos1, front1);  <span class="comment">// 全部往前移动</span></span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span>{</span><br><span class="line">		<span class="built_in">push_back</span>(<span class="built_in">back</span>());</span><br><span class="line">		....</span><br><span class="line">		<span class="built_in">copy_backward</span>(pos, back2, back1);</span><br><span class="line">	}</span><br><span class="line">	*pos = x_copy;</span><br><span class="line">	<span class="keyword">return</span> pos;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>模拟连续空间，累加，<code>[]</code>，向前移动<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewbox="0 -442 600 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>元素</p>
<p>在stack和queue中，默认一个deque。 这两者可选择list或deque作为底层结构。二者不可用set或map作为底层结构。转调用的时候，一些函数不满容器特性。<br><code>这二者不允许遍历，也不提供iterator</code>，这种操作会干扰容器的特性（FIFO 或 FILO）</p>
<p>二者不同的是，queue 不可选择vector作为底层结构，stack可以。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Sequence</span>=deque&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> queue{</span><br><span class="line">	....</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	Sequence c;<span class="comment">// 底层容器</span></span><br><span class="line">	...</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">stack&lt;string, llist&lt;string&gt;&gt;c;</span><br></pre></td></tr></table></figure>
<h3 id="RB-tree"><a href="#RB-tree" class="headerlink" title="RB-tree"></a>RB-tree</h3><p>关联式容器。<br>RB-tree：平衡二叉搜索树。有利于search和insert。rb_tree 的迭代器不应该用于修改元素，但是未被禁止这种操作，因为它为set和map服务，而map允许data被修改，只有key不可以被修改，此时，红黑树是根据map的key进行排序的。<br>红黑树提供两种insertion操作：<code>insert_unique()</code>, <code>insert_equal</code>前者key是要求独一无二的，后者可以有重复<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">KeyOfValue</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>=alloc&gt;</span><br><span class="line"><span class="keyword">class</span> rb_tree{</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">typedef</span> __rb_tree_node&lt;Value&gt; rb_tree_node;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> rb_tree_node* link_type;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">// 大小为9，但是为了内存对齐，这里实际上占用的内存为12 </span></span><br><span class="line">	size_type node_count;  <span class="comment">// 节点个数</span></span><br><span class="line">	link_type header;</span><br><span class="line">	Compare key_compare;  <span class="comment">// key的大小比较准则，是一个函数对象.理论上是0，但是实现为1</span></span><br><span class="line">	...</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<h3 id="21-set-amp-multiset"><a href="#21-set-amp-multiset" class="headerlink" title="21.set & multiset"></a>21.set &amp; multiset</h3><ul>
<li>一个元素不可重复，一个可以重复。</li>
<li>无法使用二者的iterator改变元素值，这些容器中的key有其固定的排列规则，这种iterator底层是RB tree的const iterator</li>
<li>元素特性是key就是value， value就是key</li>
<li>在实现中，set都是在调用rb tree中的操作，所以可以说set是一个容器的适配器</li>
</ul>
<h3 id="22-map-amp-multimap"><a href="#22-map-amp-multimap" class="headerlink" title="22.map & multimap"></a>22.map &amp; multimap</h3><ul>
<li>与之前不同的是，这里的value被分为key和data</li>
<li>其他的性质与22中提到的类似</li>
<li>multimap 不可使用<code>[]</code>, map可以，如果找到，则返回值，如果没有就将键值插入到map中。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用逻辑</span></span><br><span class="line">map&lt;<span class="type">int</span>, string&gt;my_map;</span><br><span class="line">map&lt;<span class="type">int</span>, string, less&lt;<span class="type">int</span>&gt;, alloc&gt;my_map;</span><br><span class="line"></span><br><span class="line"><span class="comment">// selectlst: 获取键值，第一个元素</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span>, pair&lt;<span class="type">const</span> <span class="type">int</span>, string&gt;, selectlst&lt;pair&lt;<span class="type">const</span> <span class="type">int</span>, string&gt;&gt;, less&lt;<span class="type">int</span>&gt;, alloc&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">rb_tree</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="23，24、hash-table"><a href="#23，24、hash-table" class="headerlink" title="23，24、hash table"></a>23，24、hash table</h3><ul>
<li>直接使用原始数字作为键值需要大量的空间，所以通常采用原始数据与一个素数的余数作为键值，这个素数可以被成为“篮子”(扩充大小实际上时固定的，根据不同的版本存在不同)</li>
<li>当元素个数大于篮子的数时，需要rehashing，重新规划篮子的大小（选下一个素数作为篮子大小，这样所有的元素都要重新计算）。</li>
</ul>
<h3 id="26-unodered容器概念"><a href="#26-unodered容器概念" class="headerlink" title="26.unodered容器概念"></a>26.unodered容器概念</h3><p>C++之后，将原先的hash_set、hash_miltiset、hash_map、hash_miltimap中的hash编程unordered</p>
<h3 id="27-算法形式"><a href="#27-算法形式" class="headerlink" title="27.算法形式"></a>27.算法形式</h3><p>算法的所需的一切信息都由迭代器取得</p>
<h3 id="28-迭代器的分类"><a href="#28-迭代器的分类" class="headerlink" title="28. 迭代器的分类"></a>28. 迭代器的分类</h3><p>随机访问迭代器、双向迭代器、单向迭代器<br>random_access_iterator, bidirectional_iterator, forward_iterator.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 特殊的迭代器</span></span><br><span class="line"><span class="built_in">display_category</span>(<span class="built_in">istream_iterator</span>&lt;<span class="type">int</span>&gt;()); <span class="comment">// input_iterator</span></span><br><span class="line"><span class="built_in">display_category</span>(<span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(cout, <span class="string">""</span>)); <span class="comment">// output_iterator</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="built_in">typeid</span>(itr).<span class="built_in">name</span>(); <span class="comment">// 查看变量类型</span></span><br></pre></td></tr></table></figure></p>
<h3 id="29-迭代器分类对算法的影响"><a href="#29-迭代器分类对算法的影响" class="headerlink" title="29. 迭代器分类对算法的影响"></a>29. 迭代器分类对算法的影响</h3><p>如果是随机访问迭代器，那么迭代器可以直接到达指定的位置，如果是input_iterator，迭代器只能一个个加到指定的位置，这种功能可以通过偏特化实现（特化迭代器的类型）</p>
<p>对于output iterator是write-only，无法像forward iterator那样可以read， 所以不可以使用<code>*</code>运算符进行读取</p>
<h3 id="30-算法源码剖析"><a href="#30-算法源码剖析" class="headerlink" title="30.算法源码剖析"></a>30.算法源码剖析</h3><p><strong>accumulate</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> jj34</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">myfunc</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>{ <span class="keyword">return</span> x + <span class="number">2</span> * y }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> myclass{</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="built_in">operator</span>()(<span class="type">int</span> x, <span class="type">int</span> y){ <span class="keyword">return</span> x + <span class="number">3</span> * y; }</span><br><span class="line"></span><br><span class="line">    }myobj;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test_accumlate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="type">int</span> init = <span class="number">100</span>;</span><br><span class="line">        <span class="type">int</span> nums[] = {<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>};</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// default</span></span><br><span class="line">        cout &lt;&lt; <span class="built_in">accumulate</span>(nums, nums + <span class="number">3</span>, init); <span class="comment">// 160</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// using functional's minus</span></span><br><span class="line">        cout &lt;&lt; <span class="built_in">accumulate</span>(nums, nums + <span class="number">3</span>, init, <span class="built_in">minus</span>&lt;<span class="type">int</span>&gt;());  <span class="comment">//40</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Using self-defined function</span></span><br><span class="line">        cout &lt;&lt; <span class="built_in">accumulate</span>(nums, nums + <span class="number">3</span>, init, myobj);  <span class="comment">// </span></span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">       init = binary_op(init, *first) // binary_op 就是传入的函数，可以传入函数或者仿函数（重载括号运算符）</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<p><strong>for_each</strong></p>
<p><strong>replace, replace_if, replace_copy</strong><br>1.替换元素，2。在给定条件下替换  3.不删除被替换元素，将其复制到其他位置</p>
<p><strong>count， count_if</strong></p>
<p><strong>find, find_if</strong><br>find:循序查找</p>
<p><strong>sort</strong>：<br>传入迭代器范围<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">begin</span>() + <span class="number">3</span>); <span class="comment">// 默认从小到大， i &lt; j</span></span><br><span class="line">vec.<span class="built_in">rbegin</span>() = vec.<span class="built_in">end</span>(); <span class="comment">// 一个反向的迭代器</span></span><br></pre></td></tr></table></figure></p>
<p><strong>binary_search</strong></p>
<h3 id="仿函数和函数对象"><a href="#仿函数和函数对象" class="headerlink" title="仿函数和函数对象"></a>仿函数和函数对象</h3><h3 id="binder2nd"><a href="#binder2nd" class="headerlink" title="binder2nd"></a>binder2nd</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里的less&lt;int&gt;() 不是在调用，这是一个对象</span></span><br><span class="line"><span class="built_in">count_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">not</span>(<span class="built_in">bind2nd</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(), <span class="number">40</span>)));</span><br></pre></td></tr></table></figure>
<p>仿函数可被适配的条件<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Arg</span>, <span class="keyword">class</span> <span class="title class_">Result</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">unary_function</span>{</span><br><span class="line">	<span class="keyword">typedef</span> Arg argument_type;</span><br><span class="line">	<span class="keyword">typedef</span> Result result_type;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Arg1</span>, <span class="keyword">class</span> <span class="title class_">Arg2</span>, <span class="keyword">class</span> <span class="title class_">Result</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">binary_function</span>{</span><br><span class="line">	<span class="keyword">typedef</span> Arg1 first_argument_type;</span><br><span class="line">	<span class="keyword">typedef</span> Arg2 second_argument_type;</span><br><span class="line">	<span class="keyword">typedef</span> Result result_type;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 每一个可适配的函数都会继承上面的结构体，因为需要向Function adapter提供上面结构体定义的信息</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">less</span> : <span class="keyword">public</span> binary_function&lt;T, T, <span class="type">bool</span>&gt;{</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; x, <span class="type">const</span> T&amp; y)</span><span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>{<span class="keyword">return</span> x &lt; y;}</span><br><span class="line">};</span><br></pre></td></tr></table></figure><br>新型适配器<code>bind</code>上述适配器已被弃用。</p>
<h3 id="34-not1"><a href="#34-not1" class="headerlink" title="34. not1"></a>34. not1</h3><h3 id="35-bind-（C-11）"><a href="#35-bind-（C-11）" class="headerlink" title="35.bind （C++11）"></a>35.bind （C++11）</h3><p>可以绑定：</p>
<ul>
<li>functions</li>
<li>function object</li>
<li>member function (_1需要是地址)</li>
<li>data member(_1需要是地址)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">my_divide</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span></span></span><br><span class="line"><span class="function">	</span>{ <span class="keyword">return</span> x/y; }</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyPair</span>{</span><br><span class="line">	<span class="type">double</span> a, b;</span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">multiply</span><span class="params">()</span></span>{<span class="keyword">return</span> a*b;}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholder; <span class="comment">// adds visibility of _1, _2 ....</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> fn_five = <span class="built_in">bind</span>(my_divide, <span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; <span class="built_in">fn_five</span>() ; <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> fn_five = <span class="built_in">bind</span>(my_divide, _1, <span class="number">2</span>);  <span class="comment">// _1 占位符</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">fn_five</span>(<span class="number">10</span>) ; <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> fn_five = <span class="built_in">bind</span>(my_divide, _2, _1); <span class="comment">// _2 第二个占位符</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">fn_five</span>(<span class="number">10</span>, <span class="number">2</span>) ; <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定return type 为int</span></span><br><span class="line"><span class="keyword">auto</span> fn_five = <span class="built_in">bind</span>&lt;<span class="type">int</span>&gt;(my_divide, _2, _1); <span class="comment">// _2 第二个占位符</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">fn_five</span>(<span class="number">10</span>, <span class="number">2</span>) ; <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">MyPair ten_two{<span class="number">10</span>, <span class="number">2</span>};</span><br><span class="line"><span class="keyword">auto</span> bound_memfn = <span class="built_in">bind</span>(&amp;MyPair::multiply, _1);</span><br><span class="line">cout &lt;&lt; <span class="built_in">vound_memfn</span>(ten_two); <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 本质上就是将函数中的一个参数绑定一个固定的值</span></span><br><span class="line"><span class="comment">// ps： cbegin：表示constant</span></span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-10-12T11:46:26.000Z" title="10/12/2022, 7:46:26 PM">2022-10-12</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-10-14T08:19:20.608Z" title="10/14/2022, 4:19:20 PM">2022-10-14</time></span><span class="level-item">15 minutes read (About 2179 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/10/12/C-%E6%A0%87%E5%87%8611-14/">C++标准11-14</a></p><div class="content"><h3 id="1-演进、环境与资源"><a href="#1-演进、环境与资源" class="headerlink" title="1.演进、环境与资源"></a>1.演进、环境与资源</h3><p>C++1.0 : C++ 98<br>C++2.0: C++11</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查看支持的版本</span></span><br><span class="line">cout &lt;&lt; __cplusplus &lt;&lt; enl;</span><br></pre></td></tr></table></figure>
<h3 id="2-Variadic-Templates-1-21"><a href="#2-Variadic-Templates-1-21" class="headerlink" title="2. Variadic Templates + 1~21"></a>2. Variadic Templates + 1~21</h3><p>数量不定的模板参数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>{} <span class="comment">// 处理最后的情况，没有参数被传入，这个作为函数出口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样可以传入任意个数任意类型的参数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Types&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> T&amp; firstArg, <span class="type">const</span> Types&amp;... args)</span></span>{</span><br><span class="line">	cout &lt;&lt; firstArg &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">print</span>(args...)； <span class="comment">// 传入后不断被分开（这实际上是一个包）n = (n - 1) + 1</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">sizeof</span>...(args); <span class="comment">// 查看包中的参数个数</span></span><br></pre></td></tr></table></figure><br><code>...</code>: 实际上就是一个所谓的包</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用"..." 实现递归继承</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Values&gt; <span class="keyword">class</span> <span class="title class_">tuple</span>; <span class="comment">// 这种数据结构可以方任意个数以及任意类型的数据</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">class</span> <span class="title class_">tuple</span>&lt;&gt;{};</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Head, <span class="keyword">typename</span>... Tail&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">tuple</span>&lt;Head, Tail...&gt;</span><br><span class="line">    : <span class="keyword">private</span> tuple&lt;Tail...&gt;</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">typedef</span> tuple&lt;Tail...&gt; inherited;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">tuple</span>(){}</span><br><span class="line">    <span class="built_in">tuple</span>(Head v, Tail... vtail)</span><br><span class="line">        : <span class="built_in">m_head</span>(v), <span class="built_in">inherited</span>(vtail...){}  <span class="comment">// 这是个初始化列表</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获得变量类型</span></span><br><span class="line">    <span class="comment">// typename Head::type head() {return m_head;}  // 这样写会报错，因为像int这样的类型没有无法调用type</span></span><br><span class="line">	<span class="function"><span class="keyword">auto</span> <span class="title">head</span><span class="params">()</span>-&gt;<span class="title">decltype</span><span class="params">(m_head)</span></span>{<span class="keyword">return</span> m_head;}</span><br><span class="line">	<span class="comment">// 或者</span></span><br><span class="line">	<span class="comment">// Head head() {return m_head; }</span></span><br><span class="line">    <span class="function">inherited&amp; <span class="title">tail</span><span class="params">()</span> </span>{<span class="keyword">return</span> *<span class="keyword">this</span>;}</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Head m_head;</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<p>谁更特化，就优先调用谁。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个版本更加特化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Types&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> T&amp; firstArg, <span class="type">const</span> Types&amp;... args)</span></span>{</span><br><span class="line">	cout &lt;&lt; firstArg &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">print</span>(args...)； <span class="comment">// 传入后不断被分开（这实际上是一个包）n = (n - 1) + 1 </span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与上面的函数共存的话，这个函数永远不会被调用</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Types&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printX</span><span class="params">(<span class="type">const</span> Types&amp;... args)</span></span>{<span class="comment">/**********/</span>}</span><br></pre></td></tr></table></figure><br>一些应用实例<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在多个参数中找到最大值。这一点也可以通过初始化列表直接调用标准库中的max函数:max({1,3,2,5})</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maximum</span><span class="params">(<span class="type">int</span> n)</span> <span class="keyword">return</span> n</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maximum</span><span class="params">(<span class="type">int</span> n, Args... args)</span> <span class="keyword">return</span> <span class="title">std::max</span><span class="params">(n, maximum(args...))</span></span>;</span><br><span class="line"><span class="comment">// 标准库中的max函数只能接收两个参数，这里这样调用就像是一个栈</span></span><br></pre></td></tr></table></figure></p>
<p>递归复合<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Values&gt;<span class="keyword">class</span> <span class="title class_">tup</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;<span class="keyword">class</span> <span class="title class_">tup</span>&lt;&gt;{ };</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Head, <span class="keyword">typename</span>... Tail&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">tup</span>&lt;Head, Tail&gt;</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">typedef</span> tup&lt;Tail...&gt;composited;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	composited m_tail;</span><br><span class="line">	Head m_head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">tup</span>(){ }</span><br><span class="line">	<span class="built_in">tup</span>(Head v, Tail... vtail)</span><br><span class="line">		: <span class="built_in">m_tail</span>(vtail...), <span class="built_in">m_head</span>(v) { }</span><br><span class="line"></span><br><span class="line">	<span class="function">Head <span class="title">head</span><span class="params">()</span> </span>{<span class="keyword">return</span> m_head;}</span><br><span class="line">	<span class="function">composited&amp; <span class="title">tail</span><span class="params">()</span></span>{<span class="keyword">return</span> m_tail;}</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p><strong>空指针</strong>： <code>nullptr</code></p>
<p>还可以用<code>0</code>或者<code>NULL</code>定义空指针.但是在传递参数的时候可能会存在歧义<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">void</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(<span class="literal">nullptr</span>); <span class="comment">// call void f(void*)</span></span><br></pre></td></tr></table></figure></p>
<p><strong>auto</strong>: 尽量当类型比较长或者复杂的时候才使用，或者需要写lambda的类型</p>
<h3 id="4-Uniform-Initialization"><a href="#4-Uniform-Initialization" class="headerlink" title="4.Uniform Initialization"></a>4.Uniform Initialization</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化对象的方法</span></span><br><span class="line">className c = {...};</span><br><span class="line"><span class="function">className <span class="title">c</span><span class="params">(...)</span></span>;</span><br><span class="line">className c{...}; <span class="comment">// Uniform Initialization 直接在变量后面的大括号中写初始化的数值</span></span><br><span class="line"><span class="type">int</span> values[] {...};</span><br></pre></td></tr></table></figure>
<p>当编译器遇到{}时，会创建一个 initializer_list\<t\>，然后关联到array<t, n>,然后由此传给构造函数（分解之后，变成构造函数接收的形式）</t,></t\></p>
<h3 id="4，5、Initializer-list"><a href="#4，5、Initializer-list" class="headerlink" title="4，5、Initializer_list"></a>4，5、Initializer_list</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;  <span class="comment">// 未定义</span></span><br><span class="line"><span class="type">int</span> i{}; <span class="comment">// 初始化为0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">P</span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">P</span>(<span class="type">int</span> a, <span class="type">int</span> b){...}</span><br><span class="line"></span><br><span class="line">	<span class="built_in">P</span>(initializer_list&lt;list&gt; initlist){ ...}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">P <span class="title">p</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>; </span><br><span class="line">P q{<span class="number">77</span>, <span class="number">5</span>};  <span class="comment">// 如果第二个构造函数不存在，那么编译器会将这两个数拆解，找到接收对应数目的参数的构造函数</span></span><br><span class="line"></span><br><span class="line">P r{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>}; <span class="comment">// 如果第二个构造函数不存在，则会报错，因为不存在接收三个参数的构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以利用初始化列表和max函数在三个或以上的数据中找到最大值</span></span><br><span class="line"><span class="built_in">max</span>({<span class="number">1</span>,<span class="number">2</span>,<span class="number">9</span>}); </span><br></pre></td></tr></table></figure>
<h3 id="7-Explicit-for-constructor-taking-more-than-one-argument"><a href="#7-Explicit-for-constructor-taking-more-than-one-argument" class="headerlink" title="7. Explicit for constructor taking more than one argument"></a>7. Explicit for constructor taking more than one argument</h3><p>这个关键字存在时，构造函数不会被隐式调用。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">12</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">Complex c2 = c1 + <span class="number">5</span>; <span class="comment">// 5会被隐式地转换成complex类型，如果构造函数被加上了explicit 则会报错</span></span><br></pre></td></tr></table></figure></p>
<h3 id="8-range-based-for-statement"><a href="#8-range-based-for-statement" class="headerlink" title="8. range-based for statement"></a>8. range-based for statement</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个循环中会有一个赋值地动作，所以可能会出现类型转换</span></span><br><span class="line"><span class="keyword">for</span> (decl : coll) {</span><br><span class="line">	statement;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="9-default-delete"><a href="#9-default-delete" class="headerlink" title="9. =default, =delete"></a>9. =default, =delete</h3><p>只能用于构造函数和析构函数，以及赋值重载的函数中。普通的函数没有这种性质。</p>
<blockquote>
<p>什么时候需要自己定义Big-Three 呢？<br>大多数时候，当类中有指针的需要写。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Foo</span>(<span class="type">int</span> i) : _i(i) { }</span><br><span class="line">	<span class="built_in">Foo</span>() =<span class="keyword">default</span>;<span class="comment">// 保留默认的构造函数</span></span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Foo</span>() = <span class="keyword">delete</span>;<span class="comment">// 删除默认的析构函数</span></span><br><span class="line">	~<span class="built_in">Foo</span>(<span class="keyword">typename</span> arg);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="10-Alias-Template"><a href="#10-Alias-Template" class="headerlink" title="10.Alias Template"></a>10.Alias Template</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Vec = std::vector&lt;T, MyAlloc&lt;T&gt;&gt;;  <span class="comment">// 设置化名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意不能对别名进行特化或者偏特化</span></span><br><span class="line">Vec&lt;<span class="type">int</span>&gt; coll; <span class="comment">// 等价于 std::vector&lt;int, MyAlloc&lt;int&gt;&gt; coll; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意使用define是无法达到相同的效果的，define仅仅会将指定的内容原封不动套入</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传入任意类型的数据, 这里借助容器的萃取机来获取数值类型</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_moveable</span><span class="params">(Container c)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	typerdef typername iterator_traits&lt;<span class="keyword">typename</span> Container::iterator&gt;::value_type Valtype;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">long</span> i = <span class="number">0</span>; i &lt; SIZE; ++i) c.<span class="built_in">insert</span>(c.<span class="built_in">end</span>(), <span class="built_in">Valtype</span>());</span><br><span class="line"></span><br><span class="line">	<span class="built_in">output_static_data</span>(*(c.<span class="built_in">begin</span>());</span><br><span class="line">	Container <span class="built_in">c1</span>(c);</span><br><span class="line">	Container <span class="built_in">c2</span>(std::<span class="built_in">move</span>(c));</span><br><span class="line">	c1.<span class="built_in">swap</span>(c2);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="11-template-template-parameter"><a href="#11-template-template-parameter" class="headerlink" title="11.template template parameter"></a>11.template template parameter</h3><p>化名模板<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">template</span>&lt;<span class="keyword">class</span>&gt; <span class="keyword">class</span> <span class="title class_">Container</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XCls</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Container&lt;T&gt; c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">XCls</span>(){</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">long</span> i = <span class="number">0</span>; i &lt; SIZE; ++i) c.<span class="built_in">insert</span>(c.end, <span class="built_in">T</span>());</span><br><span class="line">		<span class="built_in">output_static_data</span>(<span class="built_in">T</span>());</span><br><span class="line">		Container&lt;T&gt;<span class="built_in">c1</span>(c);</span><br><span class="line">		Container&lt;T&gt;<span class="built_in">c2</span>(std::<span class="built_in">move</span>(c));</span><br><span class="line">		c1.<span class="built_in">swap</span>(c2);</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 想要声明变量，你需要定义alias template</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 这个不能在function body之中声明</span></span><br><span class="line"><span class="keyword">using</span> Vec = vector&lt;T, allocator&lt;T&gt;&gt;;</span><br><span class="line"></span><br><span class="line">XCls&lt;MyString, Vec&gt;c1;</span><br></pre></td></tr></table></figure></p>
<h3 id="12-Type-Alias-noexcept-override-final"><a href="#12-Type-Alias-noexcept-override-final" class="headerlink" title="12.Type Alias, noexcept, override, final"></a>12.Type Alias, noexcept, override, final</h3><p><strong>Type Alias</strong>:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> func = <span class="built_in">void</span>(*)(<span class="type">int</span>, <span class="type">int</span>);  <span class="comment">// 这时候就是一个函数指针</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">example</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>{}</span><br><span class="line">func fn = example;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以使用类型化名隐藏模板参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">CharT</span>&gt; <span class="keyword">using</span> mystring = std::basic_string&lt;CahrT, std::char_traits&lt;CahrT&gt;&gt;;</span><br><span class="line">mystring&lt;<span class="type">char</span>&gt;std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//放到结构体中</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Container</span>{</span><br><span class="line">	<span class="keyword">using</span> value_type = T;</span><br><span class="line">};</span><br></pre></td></tr></table></figure></p>
<p><strong>noexcept</strong>:<br>不抛出异常，需要在vector的构造函数上使用，使得vector在增长的时候能够调用构造函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;  <span class="comment">// void foo() noexcept(true);</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Type&amp; x, Type&amp; y)</span> <span class="title">noexcept</span> <span class="params">(<span class="keyword">noexcept</span> (x.swap(y)))</span></span>{</span><br><span class="line">	x.<span class="built_in">swap</span>(y);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<p><strong>Override</strong>:\<br>覆写需要签名一致，但是如果不一致编译器不会报错，这会产生一个新的函数，加上关键字<code>override</code>会让函数抛出异常。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived2</span>:Base{</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vfunc</span><span class="params">(<span class="type">int</span>)</span> <span class="keyword">override</span> </span>{}</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vfunc</span><span class="params">(<span class="type">float</span>)</span> <span class="keyword">override</span></span>{}</span><br><span class="line">};</span><br></pre></td></tr></table></figure></p>
<p><strong>final</strong>: 无法被继承</p>
<h3 id="13-decltype"><a href="#13-decltype" class="headerlink" title="13. decltype"></a>13. decltype</h3><p>找出表达式的类型，相当于typeof。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">float</span>&gt;coll;</span><br><span class="line"><span class="keyword">decltype</span>(coll)::value_type elem;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义返回类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">decltype</span>(x+y) <span class="built_in">add</span>(T1 x, T2 y); <span class="comment">// 在C++11之前不可实现，因为对象在这个范围内还没有引入</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T1 x, T2 y)</span>-&gt;<span class="title">decltype</span><span class="params">(x+y)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="title">decltype</span><span class="params">(obj)</span>::iterator iType</span>; <span class="comment">// 等价于typedef typename T::iterator iType;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将decltype used to pass the type of a lambda</span></span><br><span class="line"><span class="keyword">auto</span> cmp = [](<span class="type">const</span> Person&amp; p1, <span class="type">const</span> Person&amp; p2){</span><br><span class="line">	<span class="keyword">return</span> p1.<span class="built_in">lastname</span>() &lt; p2.<span class="built_in">lastname</span>() || </span><br><span class="line">			(p1.<span class="built_in">lastname</span>() == p2.<span class="built_in">lastname</span>() &amp;&amp; </span><br><span class="line">			p1.<span class="built_in">firstname</span>() &lt; p2.<span class="built_in">firstname</span>());</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">std::set&lt;Person, <span class="title">decltype</span><span class="params">(cmp)</span>&gt; <span class="title">coll</span><span class="params">(cmp)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="lambdas"><a href="#lambdas" class="headerlink" title="lambdas"></a>lambdas</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [id] <span class="keyword">mutable</span> { <span class="comment">// 不加mutable就没有办法修改id</span></span><br><span class="line">	std::cout &lt;&lt; id &lt;&lt; std::endl;</span><br><span class="line">	++id;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价形式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Functor</span>{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> id;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">()</span></span>{</span><br><span class="line">		std::cout &lt;&lt; id &lt;&lt; std::endl;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line">Functor f;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法举例</span></span><br><span class="line">[x, y](<span class="type">int</span> n) {<span class="keyword">return</span> x &lt; n &amp;&amp; n &lt; y; }</span><br></pre></td></tr></table></figure>
<p>lambda没有默认构造函数和赋值操作。</p>
<h2 id="第二讲：标准库"><a href="#第二讲：标准库" class="headerlink" title="第二讲：标准库"></a>第二讲：标准库</h2><h3 id="23-Rvalue-refernces-and-Move-Semantics"><a href="#23-Rvalue-refernces-and-Move-Semantics" class="headerlink" title="23. Rvalue refernces and Move Semantics"></a>23. Rvalue refernces and Move Semantics</h3><ul>
<li>临时对象就是一种右值（对于自定义的类（例如string）可以，int等类型不可以）</li>
<li>右值不可以放在左边</li>
<li>右值在被使用之后，应该被销毁，因为对于它的操作实际上就是改变指针指向，原先的右值的指针会被删除，这样这个右值也需要被删除</li>
</ul>
<h3 id="24-Perfect-Forwarding（完美传递）"><a href="#24-Perfect-Forwarding（完美传递）" class="headerlink" title="24. Perfect Forwarding（完美传递）"></a>24. Perfect Forwarding（完美传递）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入左值的版本</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp; i)</span></span>{</span><br><span class="line">	......</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 传入右值的版本</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp;&amp; i)</span></span>{</span><br><span class="line">	......</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">process</span>(a); <span class="comment">// 变量被视为左值</span></span><br><span class="line"><span class="built_in">process</span>(<span class="number">1</span>); <span class="comment">// 临时对象被视为右值</span></span><br><span class="line"><span class="built_in">process</span>(<span class="built_in">move</span>(a));  <span class="comment">// 强制将a由左值转换成右值</span></span><br></pre></td></tr></table></figure>
<p>不完美传递：在参数传递过程中，参数的左值右值可能会发生变化。这个问题可以使用标准库中的forward函数避免。</p>
<h3 id="25-写一个move-aware-class"><a href="#25-写一个move-aware-class" class="headerlink" title="25. 写一个move-aware class"></a>25. 写一个move-aware class</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 复制构造 </span></span><br><span class="line"><span class="built_in">MyString</span>(<span class="type">const</span> Mystring&amp; str) : _len(str._len){</span><br><span class="line">	_init_data(str._data);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// &amp;&amp;：右值引用; 这个是移动构造</span></span><br><span class="line"><span class="built_in">MyString</span>(MyString&amp;&amp; str) <span class="keyword">noexcept</span></span><br><span class="line">	: _data(str._data), _len(str._len){</span><br><span class="line">		str._len = <span class="number">0</span>;</span><br><span class="line">		str._data = <span class="literal">NULL</span>; <span class="comment">// 因为传入的如果是临时变量，这个变量的生命周期只在这个函数中，如果这个指针还是指向原先的地址，那么在这个变量生命周期结束的时候，原先地址的数据也会被删除。</span></span><br><span class="line">		<span class="comment">// 有那么一瞬间，复制对象和这个临时对象之间指向的是同一个地址</span></span><br><span class="line">	}</span><br></pre></td></tr></table></figure>
<h3 id="26-Move-aware-class-对容器的效能测试"><a href="#26-Move-aware-class-对容器的效能测试" class="headerlink" title="26.Move-aware class 对容器的效能测试"></a>26.Move-aware class 对容器的效能测试</h3><p>似乎只对vector的影响很大。（两种不同的构造函数）<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">M <span class="title">c1</span><span class="params">(c)</span></span>;  <span class="comment">// 如果是vector的话，在内存拓展的时候，需要一个个调用构造函数</span></span><br><span class="line"><span class="built_in">vector</span>(<span class="type">const</span> vector&amp; __x) : _Base(....){....} <span class="comment">// 调用的构造函数 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">M <span class="title">c2</span><span class="params">(std::move(c))</span></span>;  <span class="comment">// 将c当成右值(这样只是交换了指针)； 往下c就不能再用了，指针被修改了</span></span><br><span class="line"><span class="comment">// 调用的构造函数</span></span><br><span class="line"><span class="built_in">vector</span>(vector&amp;&amp; __x) <span class="keyword">noexcept</span> : _Base(std::<span class="built_in">move</span>(__x)) {}</span><br></pre></td></tr></table></figure></p>
<h3 id="30-Hash-function"><a href="#30-Hash-function" class="headerlink" title="30.Hash function"></a>30.Hash function</h3><ul>
<li>对于整数（数字，long也行），其哈希值就是其本身</li>
<li>对于字符串，用一个哈希函数，得到一个尽可能乱的哈希值</li>
</ul>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="动态内存（C-Primer-chapter12）"><a href="#动态内存（C-Primer-chapter12）" class="headerlink" title="动态内存（C++ Primer chapter12）"></a>动态内存（C++ Primer chapter12）</h3><ul>
<li>分配在静态或栈内存中的对象由编译器自动创建和销毁</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-10-12T11:45:30.000Z" title="10/12/2022, 7:45:30 PM">2022-10-12</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-06-16T09:14:59.733Z" title="6/16/2024, 5:14:59 PM">2024-06-16</time></span><span class="level-item">14 minutes read (About 2138 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/10/12/%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%AD%E9%9B%86/">面对对象的续集</a></p><div class="content"><h3 id="1-主要的内容"><a href="#1-主要的内容" class="headerlink" title="1.主要的内容"></a>1.主要的内容</h3><ul>
<li>泛型编程</li>
<li>面对对象的继承关系（底层内容）</li>
<li>书籍： Effective （modern）C++<br>标准库——&gt; 如何用，如何实现</li>
</ul>
<h3 id="转换函数-conversion-function"><a href="#转换函数-conversion-function" class="headerlink" title="转换函数 conversion function"></a>转换函数 conversion function</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fraction</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Fraction</span>(<span class="type">int</span> num, <span class="type">int</span> den = <span class="number">1</span>)</span><br><span class="line">		: <span class="built_in">m_numerator</span>(num), <span class="built_in">m_denominator</span>(den) { }</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 转换函数</span></span><br><span class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> (doubl) (m_numerator / m_denominator);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_numerator;</span><br><span class="line">	<span class="type">int</span> m_denominator;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="function">Fraction <span class="title">f</span><span class="params">(<span class="number">3</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="comment">// 先检查是否重载了+，然后尝试将f转换成允许的类型（还是要检查需要的函数是否被重载）</span></span><br><span class="line"><span class="type">double</span> d = <span class="number">4</span> + f;</span><br></pre></td></tr></table></figure>
<h3 id="non-explicit-one-argument-constructor"><a href="#non-explicit-one-argument-constructor" class="headerlink" title="non-explicit-one-argument constructor"></a>non-explicit-one-argument constructor</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fraction</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Fraction</span>(<span class="type">int</span> num, <span class="type">int</span> den=<span class="number">1</span>)</span><br><span class="line">		: <span class="built_in">m_numerator</span>(num), <span class="built_in">m_denominator</span>(den){ }</span><br><span class="line"></span><br><span class="line">	Fraction <span class="keyword">operator</span>+(<span class="type">const</span> Fraction&amp; f){</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Fraction</span>(...);</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// 在这里的案例中，会产生歧义，这会报错（这使得两种可以的选择）</span></span><br><span class="line">	<span class="comment">//operator double() const {</span></span><br><span class="line">	<span class="comment">//	return (doubl) (m_numerator / m_denominator);%%tor / m_denominator);</span></span><br><span class="line">	<span class="comment">//}</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_numerator;</span><br><span class="line">	<span class="type">int</span> m_denominator;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="function">Fraction <span class="title">f</span><span class="params">(<span class="number">3</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="comment">// 这里会将3转换成Fraction类型，以适应重载函数</span></span><br><span class="line"><span class="type">double</span> d = f + <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fraction</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// explicit：不会自动调用</span></span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">Fraction</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> den=<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">		: m_numerator(num), m_denominator(den){</span> }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> (doubl) (m_numerator / m_denominator);</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	Fraction <span class="keyword">operator</span>+(<span class="type">const</span> Fraction&amp; f){</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Fraction</span>(...);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_numerator;</span><br><span class="line">	<span class="type">int</span> m_denominator;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="function">Fraction <span class="title">f</span><span class="params">(<span class="number">3</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="comment">// 这里3将不能转换为Fraction，会报错（double 无法转换成Fraction）</span></span><br><span class="line"><span class="type">double</span> d = f + <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<h3 id="4-pointer-like-classes"><a href="#4-pointer-like-classes" class="headerlink" title="4.pointer-like classes"></a>4.pointer-like classes</h3><p><strong>智能指针</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shared_ptr</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T&amp; <span class="keyword">operator</span>*() <span class="type">const</span></span><br><span class="line">	{ <span class="keyword">return</span> *px; }</span><br><span class="line"></span><br><span class="line">	T* <span class="keyword">operator</span>-&gt;() <span class="type">const</span></span><br><span class="line">	{ <span class="keyword">return</span> px; }</span><br><span class="line"></span><br><span class="line">	<span class="built_in">shared_ptr</span>(T* p) : <span class="built_in">px</span>(p){ }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T* px;</span><br><span class="line">	<span class="type">long</span>* pn;</span><br><span class="line">....</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span></span><br><span class="line">{</span><br><span class="line">	....</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">method</span><span class="params">(<span class="type">void</span>)</span> </span>{....}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">shared_ptr&lt;Foo&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> Foo)</span></span>;</span><br><span class="line"><span class="function">Foo <span class="title">f</span><span class="params">(*sp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里比较特殊，箭头操作符在执行之后会继续对返回值执行操作</span></span><br><span class="line"><span class="comment">// 注意这里的→操作符用于获取指针，同时还用于获取指针所指向的类中的方法</span></span><br><span class="line">sp-&gt;<span class="built_in">method</span>();</span><br><span class="line"><span class="comment">// 等价</span></span><br><span class="line">px-&gt;<span class="built_in">method</span>();</span><br></pre></td></tr></table></figure></p>
<p><strong>迭代器</strong></p>
<h3 id="5-function-like-classes-仿函数"><a href="#5-function-like-classes-仿函数" class="headerlink" title="5.function-like classes 仿函数"></a>5.function-like classes 仿函数</h3><p>我们将任何一个能够接受”（）”（函数调用符号）的东西叫做函数或者时像函数的东西。<br>实际上，就是尝试对”（）“进行重载<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">identity</span> : <span class="keyword">public</span> unary_function { <span class="comment">// 在标准库中会继承这样的base classes</span></span><br><span class="line">	<span class="function"><span class="type">const</span> T&amp;</span></span><br><span class="line"><span class="function">	<span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; x)</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> x; }</span><br><span class="line">};</span><br></pre></td></tr></table></figure></p>
<h3 id="6-namespace-经验谈"><a href="#6-namespace-经验谈" class="headerlink" title="6.namespace 经验谈"></a>6.namespace 经验谈</h3><p>这样在进行测试的时候可以使用重名的函数，不用去想其他的名字（Great thoughts）<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------------------------</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> jj01</span><br><span class="line">{</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">test_member_template</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{ ..... }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// --------------------------------</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> jj02</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">	<span class="keyword">using</span> Lst = list&lt;T, allocator&lt;T&gt;&gt;;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">test_template_param</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{ ... }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	jj01::<span class="built_in">test_member_template</span>();</span><br><span class="line">	jj02::<span class="built_in">test_template_template_param</span>();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<h3 id="9-成员模板"><a href="#9-成员模板" class="headerlink" title="9. 成员模板"></a>9. 成员模板</h3><p>在模板函数中，在被调用之前函数可以被编译，在传入参数之后，这个函数会被重新编译，这可能导致编译失败（不支持的类型）<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pair</span> {</span><br><span class="line">	<span class="keyword">typedef</span> T1 first_type;</span><br><span class="line">	<span class="keyword">typedef</span> T2 second_type;</span><br><span class="line"></span><br><span class="line">	T1 first;</span><br><span class="line">	T2 second;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">pair</span>()</span><br><span class="line">		: <span class="built_in">first</span>(<span class="built_in">T1</span>()), <span class="built_in">second</span>(<span class="built_in">T2</span>()) { }</span><br><span class="line">	<span class="built_in">pair</span>(<span class="type">const</span> T1&amp; a, <span class="type">const</span> T2&amp; b)</span><br><span class="line">		: <span class="built_in">first</span>(a), <span class="built_in">second</span>(b) { }</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 成员模板（外部被确定之后，内部还是不确定的）</span></span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">U1</span>, <span class="keyword">class</span> <span class="title class_">U2</span>&gt;</span><br><span class="line">	<span class="built_in">pair</span>(<span class="type">const</span> pair&lt;U1, U2&gt;&amp; p)  <span class="comment">// 这里是要求传入的初始值需要能够转换成T类型（一次作为初始化值，是T的子类）</span></span><br><span class="line">		: <span class="built_in">first</span>(p.first), <span class="built_in">second</span>(p.second)</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">pair&lt;Derived1, Derived2&gt; p;</span><br><span class="line">pair&lt;Base1, Base2&gt;<span class="built_in">p2</span>(p);</span><br><span class="line">|</span><br><span class="line">pair&lt;Base1, Base2&gt;<span class="built_in">p2</span>(<span class="built_in">pair</span>&lt;Derived1, Derived2&gt;());</span><br></pre></td></tr></table></figure></p>
<p>子类指针能够指向父类，但是反之不能</p>
<blockquote>
<p>鲤鱼是一种鱼类，但是鱼类不是鲤鱼<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base1* ptr = <span class="keyword">new</span> Derived1;  <span class="comment">// up-cast</span></span><br><span class="line">shared_ptr&lt;Base1&gt;<span class="built_in">sptr</span>(<span class="keyword">new</span> Derived1);  <span class="comment">// 模拟up-cast</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="10、11-模板特化"><a href="#10、11-模板特化" class="headerlink" title="10、11. 模板特化"></a>10、11. 模板特化</h3><p>泛化<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">has</span> { };</span><br></pre></td></tr></table></figure></p>
<p>特化<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hash</span>&lt;<span class="type">char</span>&gt;{</span><br><span class="line">	<span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">char</span> x)</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> x; }</span><br><span class="line">};</span><br></pre></td></tr></table></figure><br>偏特化<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数量特化：只对其中一个参数进行特化（不完全特化）</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc=...&gt;</span><br><span class="line"><span class="keyword">class</span> vector</span><br><span class="line">{</span><br><span class="line">	.....</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Alloc=....&gt;</span><br><span class="line"><span class="keyword">class</span> vector&lt;<span class="type">bool</span>, Alloc&gt;{ .... }  <span class="comment">// 只有一个参数被指定了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 范围特化：指定特化的范围</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">class</span> C</span><br><span class="line">{</span><br><span class="line">	....</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的模板变量与前面的不是同一个</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&lt;T*&gt;  <span class="comment">// 指定的是任意的指针</span></span><br><span class="line">{</span><br><span class="line">	.....</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">C&lt;string&gt; obj1;</span><br><span class="line">C&lt;string*&gt; obj2;  <span class="comment">// 调用的函数不同</span></span><br></pre></td></tr></table></figure></p>
<h3 id="12-模板模板参数"><a href="#12-模板模板参数" class="headerlink" title="12.模板模板参数"></a>12.模板模板参数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,</span><br><span class="line">		<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">			<span class="keyword">class</span> <span class="title class_">Container</span></span><br><span class="line">		&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XCls</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Container&lt;T&gt; c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	.....</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------------------</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Lst = list&lt;T, allocator&lt;T&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------------------</span></span><br><span class="line"><span class="comment">// 这种参数能够让用户传入一个未被指定的容器</span></span><br><span class="line">XCls&lt;string, list&gt;mylst1;  <span class="comment">// 直接使用会报错</span></span><br><span class="line">XCLs&lt;string, Lst&gt; mylst2;</span><br></pre></td></tr></table></figure>
<h3 id="14-三个主题"><a href="#14-三个主题" class="headerlink" title="14.三个主题"></a>14.三个主题</h3><p><strong>variadic templates(C++11)</strong>：数量不确定的模板<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">// 最后会仅仅传入0个参数，这时候会调用这个重载函数</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 实际上是一种操作符了</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> T&amp; firstArg, <span class="type">const</span> Types&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">// 查看包的大小： sizeof...(args)</span></span><br><span class="line">	cout &lt;&lt; firstArg &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">print</span>(args...); <span class="comment">// 递归打印其中的组合的元素</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">7.5</span>, <span class="string">"hello"</span>, <span class="built_in">bitset</span>&lt;<span class="number">16</span>&gt;(<span class="number">377</span>), <span class="number">42</span>);</span><br></pre></td></tr></table></figure></p>
<p><strong>auto(C++11)</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">list&lt;string&gt; c;</span><br><span class="line">...</span><br><span class="line">list&lt;string&gt;::iterator ite;</span><br><span class="line">ite = <span class="built_in">find</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), target);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用auto，仅用于类型推导</span></span><br><span class="line"><span class="keyword">auto</span> ite = <span class="built_in">find</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), target);</span><br><span class="line"><span class="comment">//但是不能用于申明变量</span></span><br><span class="line"><span class="keyword">auto</span> ite;  <span class="comment">// ×</span></span><br></pre></td></tr></table></figure></p>
<p><strong>ranged-base <code>for</code></strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> elem : vec) { <span class="comment">// copy</span></span><br><span class="line">	.....</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要修改原始数据，则需要传引用（引用就是指针）</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; elem : vec){</span><br><span class="line">	elem *= <span class="number">3</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<h3 id="15-Reference"><a href="#15-Reference" class="headerlink" title="15. Reference"></a>15. Reference</h3><p>引用类型一定要设定初值<br><img src="https://Baymine.github.io/images/面对对象的续集/20220913134632.png" alt></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span>* p = &amp;x;</span><br><span class="line"><span class="type">int</span>&amp; r = x; <span class="comment">// r代表x，现在r, x 都是0。 实际上就是一个别名</span></span><br><span class="line"><span class="type">int</span> x2 = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">r = x2; <span class="comment">// r不能重新代表其他实物，心啊在r, x都是5</span></span><br><span class="line"><span class="type">int</span>&amp; r2 = r;</span><br></pre></td></tr></table></figure>
<p>对象和他的reference大小相同，地址也相同（全都是假象）<br>reference通常不用与声明，而是用于参数类型和返回类型的描述<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面两种函数不能共存.二者之间的签名一致</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">imag</span> <span class="params">(<span class="type">const</span> <span class="type">double</span>&amp; im)</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">imag</span> <span class="params">(<span class="type">const</span> <span class="type">double</span> im)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这时候的函数签名与上面不同</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">imag</span> <span class="params">(<span class="type">const</span> <span class="type">double</span>&amp; im)</span> <span class="type">const</span> </span>{ ... }</span><br></pre></td></tr></table></figure><br><code>注意</code>: const也是签名的一部分，</p>
<h3 id="16-复合-amp-继承关系下的构造和析构"><a href="#16-复合-amp-继承关系下的构造和析构" class="headerlink" title="16. 复合&继承关系下的构造和析构"></a>16. 复合&amp;继承关系下的构造和析构</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由内到外调用构造函数</span></span><br><span class="line">Derived::<span class="built_in">Derived</span>(..):<span class="built_in">Base</span>() {....};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由外到内调用析构函数</span></span><br><span class="line">Derived::~<span class="built_in">Derived</span>(...){....~<span class="built_in">Base</span>()};</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="关于vptr和vtbl"><a href="#关于vptr和vtbl" class="headerlink" title="关于vptr和vtbl"></a>关于vptr和vtbl</h3><blockquote>
<p>vtbl: virtual table, 为了实现C++的多态，C++使用了一种动态绑定的技术。这个技术的核心是虚函数表</p>
</blockquote>
<p>一个类占用了多少的内存，主要看类中声明的变量。继承不仅仅会<code>继承变量</code>，同时也会继承<code>父类的函数的调用权</code>，所以父类有虚函数，子类一定有。<br>当子类重载虚函数的时候，会重新申请一个函数空间，让对应的虚表中的元素指向这个空间。</p>
<p><img src="https://Baymine.github.io/images/面对对象的续集/20220914135123.png" alt></p>
<p>这里子类重载了父类的虚函数，所以在子类的虚表中，对应的虚表中的指针会指向一个新的虚函数（B::vfunc1()），所以这三次继承下来，一共会产生四个虚函数。<br>对于p的调用，用C语言写出来是<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(*(p-&gt;vptr[n])(p); <span class="comment">/*或者图中下方的形式*/</span></span><br><span class="line"> <span class="comment">/*这时候，调用出来的函数是不确定的，需要根据p指向的类型进行确定，这个就是动态绑定（虚机制）*/</span></span><br></pre></td></tr></table></figure><br>静态绑定&amp;动态绑定<br>动态绑定的条件：</p>
<ol>
<li>通过指针调用函数</li>
<li>有一个向上的转型（子类调用，到时候会调用子类的重载函数）</li>
<li>调用的是虚函数</li>
</ol>
<h3 id="18-关于this"><a href="#18-关于this" class="headerlink" title="18.关于this"></a>18.关于this</h3><p>在C++类中，都有一个隐藏的参数<code>this</code></p>
<h3 id="19-动态绑定"><a href="#19-动态绑定" class="headerlink" title="19. 动态绑定"></a>19. 动态绑定</h3><p>关于<code>const</code>：const对象能够调用const函数，不能调用非const函数，非const对象两者都可以调用。实际上一个常量对象会被多个用户使用（指向同一个对象），当某一个用户需要修改的对象的时候，只需要将其做一份拷贝，这个过程称为Copy on Write. 所以，设置两种不同的函数，一种给常量对象调用，一种是给非常量对象调用，同时，在C++中，规定<code>常量成员函数的const和non-const版本同时存在，const对象只能调用const版本，non-const只能调用non-const版本</code>。</p>
<h3 id="22-示例"><a href="#22-示例" class="headerlink" title="22.示例"></a>22.示例</h3><p>当一个对象拥有虚函数的时候，则对应的会多出一个指针（虚指针）<br>构建对象数组的时候，每一个元素都会调用一次构造函数<br>分配数组内存的时候，会额外申请一块，用于记录数组的大小（多一个counter）</p>
<h3 id="23-重载new-amp-delete"><a href="#23-重载new-amp-delete" class="headerlink" title="23.重载new() & delete()"></a>23.重载new() &amp; delete()</h3><p>前提：1.每一版本的声明都必须是独特的参数列表，参数列表的第一参数必须是<code>size_t</code>，其余参数以<code>new</code>所指定的placement arguments为初值，出现在<code>new(...)</code>小括号内的就是placement arguments。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size, <span class="type">long</span> extra)</span></span>{</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">malloc</span>(size + extra);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-10-12T06:35:56.000Z" title="10/12/2022, 2:35:56 PM">2022-10-12</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-06-16T09:16:01.015Z" title="6/16/2024, 5:16:01 PM">2024-06-16</time></span><span class="level-item">27 minutes read (About 3978 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/10/12/%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/">面对对象编程</a></p><div class="content"><h3 id="1-C-编程简介"><a href="#1-C-编程简介" class="headerlink" title="1.C++编程简介"></a>1.C++编程简介</h3><p>C++: 语言+标准库</p>
<h3 id="2-头文件与类的声明"><a href="#2-头文件与类的声明" class="headerlink" title="2. 头文件与类的声明"></a>2. 头文件与类的声明</h3><p><strong>防卫式声明</strong>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Header file: complex.h*/</span></span><br><span class="line"><span class="meta"># <span class="keyword">ifndef</span> __COMPLEX__</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __COMPLEX__</span></span><br><span class="line">....</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><br>写任意一个头文件都应该加上这种防卫语句</p>
<p><strong>头文件的布局</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">ifndef</span> __headerName__</span></span><br><span class="line"># ....</span><br><span class="line"><span class="comment">// 前置声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">className</span>;</span><br><span class="line"><span class="function">type&amp; <span class="title">func</span><span class="params">(type* var1)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Name</span>{</span><br><span class="line">.....</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类定义</span></span><br><span class="line">Name::function ...</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<h3 id="3-构造函数"><a href="#3-构造函数" class="headerlink" title="3. 构造函数"></a>3. 构造函数</h3><p>函数可以进行重载，编译器会将函数根据函数签名和其中的参数进行编码，以此作为区分。</p>
<h3 id="4-参数传递与返回值"><a href="#4-参数传递与返回值" class="headerlink" title="4.参数传递与返回值"></a>4.参数传递与返回值</h3><p>当构造函数放在<code>private</code>区域中，外界将不能够直接创建这个类。但是在一种设计模式<code>Singleton</code>中，会将构造函数放在<code>private</code>区域中。</p>
<blockquote>
<p>单例类Singleton保证了程序中同一时刻最多存在该类的一个对象。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> A&amp; <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="built_in">setup</span>(){...}</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">A</span>();</span><br><span class="line">	<span class="built_in">A</span>(<span class="type">const</span> A&amp; rhs);</span><br><span class="line">	.....</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">A&amp; <span class="title">A::getInstance</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="type">static</span> A a;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建</span></span><br><span class="line">A::<span class="built_in">getInstance</span>().<span class="built_in">setup</span>();</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p><strong>传递函数参数</strong><br>由于pass by value 是将变量整体进行传递，当变量比较大的时候，效率比较低，所以在传递参数的时候，应该尽量pass by reference(底层是传递指针)， 这样传递的参数可能会在函数中被修改，所以可以通过传递到const中<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> className&amp;)</span></span>;  <span class="comment">// 这样传递的方式不会修改传递的值</span></span><br><span class="line"></span><br><span class="line">ostream&amp;</span><br><span class="line"><span class="keyword">operator</span> &lt;&lt; (ostream&amp; os, <span class="type">const</span> <span class="type">int</span>&amp; x){....} </span><br></pre></td></tr></table></figure><br><strong>返回值传递</strong><br>在返回的时候也应该尽量使用pass by reference</p>
<p><strong>友元函数</strong><br>友元函数可以使用<code>private</code>中的数据。</p>
<p>相同class的各个object互为友元：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">complex</span> (<span class="type">double</span> r = <span class="number">0</span>, <span class="type">double</span> i = <span class="number">0</span>)</span><br><span class="line">		: <span class="built_in">re</span> (r), <span class="built_in">im</span> (i)</span><br><span class="line">	{   }</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">const</span> complex&amp; param)</span></span></span><br><span class="line"><span class="function">	</span>{ <span class="keyword">return</span> param.re + param.im; }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">double</span> re, im;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/******************************************************************/</span></span><br><span class="line">{</span><br><span class="line">	<span class="function">complex <span class="title">c1</span><span class="params">(<span class="number">2</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">	complex c2;</span><br><span class="line">	</span><br><span class="line">	c2.<span class="built_in">func</span>(c1);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<p><strong>设计类的几个要点</strong></p>
<ol>
<li>数据尽量放在<code>private</code>中</li>
<li>参数、返回值尽量pass by reference（可能）</li>
<li>需要加<code>const</code>尽量加</li>
<li>构造函数尽量使用冒号的赋值方法</li>
</ol>
<p><strong>什么时候不能返回引用</strong><br>一些参数通过一些操作之后的结果，需要在函数中申请一个空间存储这个结果，但是在函数结束的时候，这个空间就会被释放掉，这时候再返回原先这里的地址就没有意义了。（局部变量在函数结束的时候被删除）<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> complex&amp;</span><br><span class="line">__doapl(complex* ths, <span class="type">const</span> complex&amp; r) <span class="comment">// 第一个参数会被改变，第二不会</span></span><br><span class="line">{</span><br><span class="line">	ths-&gt;re += r.re;</span><br><span class="line">	ths-&gt;im += r.im;</span><br><span class="line">	<span class="keyword">return</span> *ths;*</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> complex&amp;</span><br><span class="line">complex::<span class="keyword">operator</span> += (<span class="type">const</span> complex&amp; r)</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">return</span> __doapl (<span class="keyword">this</span>, r);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<h3 id="4-操作符重载与临时对象"><a href="#4-操作符重载与临时对象" class="headerlink" title="4. 操作符重载与临时对象"></a>4. 操作符重载与临时对象</h3><p>操作符重载中包含一个隐藏参数this（不能写出来）<br><img src="https://Baymine.github.io/images/面对对象编程/20220831211854.png" alt></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// do assinment plus(doapl)</span></span><br><span class="line"><span class="keyword">inline</span> complex&amp;  <span class="comment">// 用reference速度快 </span></span><br><span class="line">__adopl(complex* ths, <span class="type">const</span> complexr)</span><br><span class="line">{</span><br><span class="line">    ths-&gt;re += r.re;</span><br><span class="line">    ths-&gt;im += r.im;</span><br><span class="line">    <span class="keyword">return</span> *ths;  <span class="comment">// 返回该地址上的值</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// c1 += c2 时，可以改用void接受，但是当连加出现时（c3 += c2 += c1）时，不行</span></span><br><span class="line"><span class="keyword">inline</span> complex&amp;  </span><br><span class="line">complex::<span class="keyword">operator</span> += (<span class="type">const</span> complex&amp; r)</span><br><span class="line">{</span><br><span class="line">	<span class="comment">// 使用这种方法的原因是可复用性</span></span><br><span class="line">    <span class="keyword">return</span> __adopl (<span class="keyword">this</span>, r); <span class="comment">// this在参数列表中不能写出来，但是能够使用</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>传递者无需知道接受者是以reference形式接受<br><strong>非成员函数（无this）</strong>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> complex <span class="comment">// 不能返回引用，因为这里返回的必定时局部对象</span></span><br><span class="line"><span class="keyword">operator</span> = (<span class="type">const</span> complex&amp; x, <span class="type">const</span> complex&amp; y)</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">complex</span> ( <span class="built_in">real</span> (x) + <span class="built_in">real</span> (y) ,</span><br><span class="line">					 <span class="built_in">imag</span> (x) + <span class="built_in">imag</span> (y)) ;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> complex</span><br><span class="line"><span class="keyword">operator</span> + (<span class="type">const</span> complex&amp; x, <span class="type">double</span> y)</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">complex</span> (<span class="built_in">real</span> (x) + y, <span class="built_in">imag</span> (x)); <span class="comment">// 临时对象（无名称，STL用得多）</span></span><br><span class="line">}</span><br><span class="line">....</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">	<span class="function">complex <span class="title">c1</span><span class="params">(<span class="number">2</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">	complex c2;</span><br><span class="line"></span><br><span class="line">	complex c3 = c1 + c2;</span><br><span class="line">	complex c4 = c1 + <span class="number">4</span>;</span><br><span class="line">	complex c5 = <span class="number">4</span> + c1;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这种重载函数只能写为全局函数，不能写成成员函数（cout可能不认识你的参数类型， 访问定义的类)</span></span><br><span class="line"><span class="comment">// cout的数据类型是iostream， os的状态会被改变（传入的内容改变的）</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span> <span class="comment">// 不一定放在文件开头</span></span></span><br><span class="line">ostream&amp;  <span class="comment">// cout &lt;&lt; c1;时可以使用void接收，但是cout&lt;&lt;c1&lt;&lt;c2;时，不能用void接收</span></span><br><span class="line"><span class="keyword">operator</span> &lt;&lt; (ostream&amp; os, <span class="type">const</span> complex&amp; x)</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">return</span> os &lt;&lt; <span class="string">'('</span> &lt;&lt; <span class="built_in">real</span> (x) &lt;&lt; <span class="string">','</span> </span><br><span class="line">			  &lt;&lt; <span class="built_in">imag</span> (x) &lt;&lt; <span class="string">')'</span> ;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>传递的是double类型的时候，传值和传引用效率一样。</p>
<h3 id="7-三大函数：拷贝函数，拷贝复制，析构"><a href="#7-三大函数：拷贝函数，拷贝复制，析构" class="headerlink" title="7.三大函数：拷贝函数，拷贝复制，析构"></a>7.三大函数：拷贝函数，拷贝复制，析构</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYSTRING__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYSTRING__</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// Big Three </span></span><br><span class="line">	<span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* cstr = <span class="number">0</span>); <span class="comment">// 需要赋值，不能设置为const</span></span><br><span class="line">	<span class="comment">//如果class中带有指针， 一定不能使用默认版本（符号重载等）</span></span><br><span class="line">	<span class="built_in">String</span>(<span class="type">const</span> String&amp; str);  <span class="comment">// 拷贝构造</span></span><br><span class="line">	String&amp; <span class="keyword">operator</span>=(<span class="type">const</span> String&amp; str); <span class="comment">// 拷贝复制</span></span><br><span class="line">	~<span class="built_in">String</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">char</span>* <span class="title">get_c_str</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> m_data; }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span>* m_data;  <span class="comment">// 指针占4byte</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span></span></span><br><span class="line"><span class="function"><span class="title">String::String</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* cstr = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span>(cstr) {</span><br><span class="line">		m_data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(cstr) + <span class="number">1</span>];  <span class="comment">// 最后还有一个结束符号</span></span><br><span class="line">		<span class="built_in">strcpy</span>(m_data, cstr);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span>{  <span class="comment">// 空字符串</span></span><br><span class="line">		m_data = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">1</span>];</span><br><span class="line">		*m_data = <span class="string">'\0'</span>;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> </span><br><span class="line">String::~<span class="built_in">String</span>()</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">delete</span>[] m_data;  <span class="comment">// 释放申请的动态内存</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝赋值：先将原先的变量中的内容删除，然后将新的内容赋值给这个变量</span></span><br><span class="line"><span class="comment">// 返回类型是考虑到了连串的赋值的情况（否则可以将void作为返回类型）</span></span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line">String&amp; String::<span class="keyword">operator</span>=(<span class="type">const</span> String&amp; str) <span class="comment">// &amp;：reference</span></span><br><span class="line">{</span><br><span class="line">	<span class="comment">// &amp;： 取地址</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str) <span class="comment">// 效率高且防止赋值内容的地址被释放，这会报错！</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">// 三步</span></span><br><span class="line">	<span class="keyword">delete</span>[] m_data;</span><br><span class="line">	m_data = <span class="keyword">new</span> <span class="type">char</span>[ <span class="built_in">strlen</span>(str.m_data) + <span class="number">1</span> ];</span><br><span class="line">	<span class="built_in">strcpy</span>(m_data, str.m_data);</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="type">const</span> String&amp; str)</span><br><span class="line">{</span><br><span class="line">	os &lt;&lt; str.<span class="built_in">get_c_str</span>(); </span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="function">String <span class="title">s3</span><span class="params">(s1)</span></span>;  <span class="comment">//拷贝构造</span></span><br><span class="line">s3 = s2;  <span class="comment">// 拷贝赋值</span></span><br></pre></td></tr></table></figure>
<p><strong>当类中存在指针成员的时候，必须要有拷贝构造和拷贝赋值</strong><br>使用默认的操作会使得赋值对象和原先的对象指向相同的地址（浅拷贝），你实际上会得到一个别名（alias）。 </p>
<h3 id="8-堆，栈与内存管理"><a href="#8-堆，栈与内存管理" class="headerlink" title="8.堆，栈与内存管理"></a>8.堆，栈与内存管理</h3><p><strong>栈</strong>：存在于作用域的一类内存空间。函数本体中声明的任何变量其所使用的内存块都取自这种栈。</p>
<p><strong>堆（heap）</strong>：用操作系统分配的一种global内存变量，动态申请的变量的内存会被放到堆中。</p>
<p>stack object: 作用域结束之后会被自动清理<br>static object: 作用域结束之后依旧存在。程序结束才被删除<br>global object: 整个程序结束之后才会删除，可以看成一种static object<br>heap object: </p>
<p>如果不释放，可能导致<code>内存泄漏</code>，因为在函数中声明的指针变量在作用域结束之后就会被删除，而对应的内存块还被占用着，这时候我们就失去了对这个内存块的控制了。 </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Complex* pc = <span class="keyword">new</span> <span class="built_in">Complex</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// transformed by compiler</span></span><br><span class="line">Complex *pc;</span><br><span class="line"></span><br><span class="line"><span class="comment">// complex 中的私有变量需要的内存大小</span></span><br><span class="line"><span class="type">void</span>* mem = <span class="keyword">operator</span> <span class="built_in">new</span> ( <span class="built_in">sizeof</span>(Complex) ); <span class="comment">// allocating the memory</span></span><br><span class="line">pc = <span class="built_in">static_cast</span>&lt;Complex*&gt;(mem);  <span class="comment">// change variable type</span></span><br><span class="line">pc-&gt;Complex::<span class="built_in">Complex</span>(<span class="number">1</span>, <span class="number">2</span>);  <span class="comment">// constructor function</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Delete</span></span><br><span class="line">String* ps = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"Hello"</span>);</span><br><span class="line"><span class="keyword">delete</span> ps;</span><br><span class="line"><span class="comment">// equal</span></span><br><span class="line">String::~<span class="built_in">String</span>(ps);</span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(ps)</span></span>;</span><br></pre></td></tr></table></figure>
<p>为了标记占用的内存块，规定在内存块的开头和结尾加上一个cookie标记内存块的大小和状态。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String* p = <span class="keyword">new</span> String[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span>[] p; <span class="comment">// 唤起3次析构函数</span></span><br><span class="line"><span class="keyword">delete</span> p;  <span class="comment">// 只调用一次析构函数，导致除了头元素外的元素所在的空间出现内存泄漏</span></span><br></pre></td></tr></table></figure>
<h3 id="拓展补充：类模板、函数模板及其他"><a href="#拓展补充：类模板、函数模板及其他" class="headerlink" title="拓展补充：类模板、函数模板及其他"></a>拓展补充：类模板、函数模板及其他</h3><p><strong>static</strong>：<br>非<code>static</code>类中，成员函数只有一份，不同类调用的实际上是同一个成员函数，只是传入了不同的成员变量。<br>静态数据，在内存中只有一份，这意味着这个数据对所有类都是一致的。<br>静态函数，没有this 指针，所以不能处理普通数据，只能处理静态数据<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">double</span> m_rate;</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">set_rate</span><span class="params">(<span class="type">const</span> <span class="type">double</span>&amp; x)</span> </span>{ m_rate = x; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态变量需要在类外进行初始化</span></span><br><span class="line"><span class="type">double</span> Account::m_rate = <span class="number">8.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="comment">// 两种调用静态函数的方法</span></span><br><span class="line">	Account::<span class="built_in">set_rate</span>(<span class="number">5.0</span>);</span><br><span class="line">	</span><br><span class="line">	Account a;</span><br><span class="line">	a.<span class="built_in">set_rate</span>(<span class="number">7.0</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<p>Singleton中调用静态函数的方法<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> A&amp; <span class="title">getInstance</span><span class="params">( <span class="keyword">return</span> a; )</span></span>;</span><br><span class="line">	<span class="built_in">setup</span>() { ... };</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">A</span>();</span><br><span class="line">	<span class="built_in">A</span>(<span class="type">const</span> A&amp; rhs);</span><br><span class="line">	<span class="type">static</span> A a;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// Call</span></span><br><span class="line">A::<span class="built_in">getInstance</span>().<span class="built_in">setup</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>更好的实现方法，单例仅使用的时候才会被构建<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> A&amp; <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="built_in">setup</span>() { ... }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">A</span>();</span><br><span class="line">	<span class="built_in">A</span>(<span class="type">const</span> A&amp; rhs);</span><br><span class="line">	...</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">A&amp; <span class="title">A::getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">static</span> A a;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">A::<span class="built_in">getInstance</span>().<span class="built_in">setup</span>();</span><br></pre></td></tr></table></figure></p>
<p><strong>进一步补充：cout</strong><br>对<code>&lt;&lt;</code>操作符进行了多种多样的重载</p>
<p><strong>类模板</strong><br>类型未指定,在定义类的时候使用。在调用的时候需要指定类型</p>
<p><strong>函数模板</strong><br>函数模板不需要指定类型，可以根据传入变量的类型进行自动推导<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span></span></span><br><span class="line"><span class="function"><span class="type">const</span> T&amp; <span class="title">min</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">return</span> b &lt; a ? b : a;  <span class="comment">// 对于操作数的重载需要在类定义中定义</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<p><strong>namespace</strong><br>避免重名函数、类冲突<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 三种打开方式</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std:cout;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; ;</span><br></pre></td></tr></table></figure></p>
<h3 id="11-组合与继承"><a href="#11-组合与继承" class="headerlink" title="11.组合与继承"></a>11.组合与继承</h3><p><strong>复合</strong>： 容器中包含其他类型（类似结构体）<br>设计模式：配接（adapter）<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">queue</span>{</span><br><span class="line">	....</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	deque&lt;T&gt; c;  <span class="comment">// 底层容器</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 所有的方法实际上都是由c中的操作函数完成的</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> c.<span class="built_in">empty</span>(); }</span><br><span class="line">	<span class="function">size_type <span class="title">soze</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> c.<span class="built_in">size</span>(); }</span><br><span class="line">	<span class="function">reference <span class="title">front</span><span class="params">()</span> </span>{ <span class="keyword">return</span> c.<span class="built_in">front</span>(); }</span><br><span class="line">	<span class="function">reference <span class="title">back</span><span class="params">()</span> </span>{ <span class="keyword">return</span> c.<span class="built_in">back</span>(); }</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span> </span>{ c.<span class="built_in">push_back</span>(x); }</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>{ c.<span class="built_in">pop_front</span>(); }</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure><br><strong>复合情况下的构造和析构</strong><br>container -&gt; component</p>
<ul>
<li>构造由内而外（内部的成分, 默认会调用默认的构造函数）</li>
<li>析构由外而内</li>
</ul>
<p><strong>委托(Delegation): composition by reference</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file String.cpp</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StringRep</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">String</span>();</span><br><span class="line">	<span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* s);</span><br><span class="line">	<span class="built_in">String</span>(<span class="type">const</span> String&amp; s);</span><br><span class="line">	String &amp;<span class="keyword">operator</span>=(<span class="type">const</span> String&amp; s);</span><br><span class="line">	~<span class="built_in">String</span>();</span><br><span class="line">	....</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 所有的实现都在这个类中 </span></span><br><span class="line">	StringRep* rep; <span class="comment">// pimpl</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>Pimpl(<strong>P</strong>ointer to <strong>impl</strong>ementation) 是一种减少代码依赖和编译时间的C++编程技巧，其基本思想是将一个外部可见类(visible class)的实现细节（一般是所有私有的非虚成员）放在一个单独的实现类(implementation class)中，而在可见类中通过一个私有指针来间接访问该实现类<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">"String.hpp"</span></span></span><br><span class="line"><span class="keyword">namespace</span>{</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StringRep</span>{</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">String</span>;</span><br><span class="line">	<span class="built_in">StringRep</span>(<span class="type">const</span> <span class="type">char</span>* s);</span><br><span class="line">	~<span class="built_in">StringRep</span>();</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	<span class="type">char</span>* rep;</span><br><span class="line">};</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">String::<span class="built_in">String</span>(){ .... }</span><br></pre></td></tr></table></figure><br>这时候多个类实际上共享一组变量，当需要修改的时候，会单独复制一个出来 </p>
</blockquote>
<p><strong>继承</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">_List_node_base</span></span><br><span class="line">{</span><br><span class="line">	_List_node_base* _M_next;</span><br><span class="line">	_List_node_base* _M_prev;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp_&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_List_node</span></span><br><span class="line">	: <span class="keyword">public</span> _List_node_base  <span class="comment">// 三种继承public、private、protected</span></span><br><span class="line">{</span><br><span class="line">	_Tp _M_data;</span><br><span class="line">};</span><br></pre></td></tr></table></figure></p>
<p>构造和析构与复合一致（先调用父类的构造函数， 析构则是先执行子类的析构函数）<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Derived::<span class="built_in">Deriveed</span>(...):<span class="built_in">Base</span>() {....}; </span><br><span class="line">Derived::~<span class="built_in">Derived</span>(...){... ~<span class="built_in">Base</span>() };</span><br></pre></td></tr></table></figure><br><code>base class的构造函数必须是虚函数，否则会出现 undefined behavior</code></p>
<h3 id="12-虚函数与多态"><a href="#12-虚函数与多态" class="headerlink" title="12.虚函数与多态"></a>12.虚函数与多态</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;  <span class="comment">// pure virtual: 必须重定义（无法事先定义的函数）</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">error</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span></span>;  <span class="comment">// impure virtual：有默认定义</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">objectID</span><span class="params">()</span> <span class="type">const</span></span>;  <span class="comment">// non-vitual：不希望重定义</span></span><br><span class="line">	...</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>: <span class="keyword">public</span> Shape { ... };</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ellipse</span>: <span class="keyword">public</span> Shape { ... };</span><br></pre></td></tr></table></figure>
<p><strong>虚函数继承</strong>: <code>Template Method</code>(模板函数法 )<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Application framework</span></span><br><span class="line">CDocument::</span><br><span class="line"><span class="built_in">OnFileOpen</span>()</span><br><span class="line">{</span><br><span class="line">	....</span><br><span class="line">	<span class="built_in">Serialize</span>()  <span class="comment">// 这个函数延缓到子类中实现</span></span><br><span class="line">	.....</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Application</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CMyDoc</span>:</span><br><span class="line">	<span class="keyword">public</span> CDocument</span><br><span class="line">{</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="title">Serialize</span><span class="params">()</span> </span>{ ... }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// Call the father function by son</span></span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">{</span><br><span class="line">	CMyDoc myDoc;</span><br><span class="line">	....</span><br><span class="line">	myDoc.<span class="built_in">OnFileOpen</span>();  </span><br><span class="line">	<span class="comment">// 实际上的调用动作</span></span><br><span class="line">	CDocument::<span class="built_in">OnFileOpen</span>(&amp;myDoc);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><br><strong>委托+继承</strong><br>*******************************</p>
<font size="5" color="red">需要补充</font>
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> m_value;</span><br><span class="line">	vector&lt;Observer*&gt;m_views;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 注册</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">attach</span><span class="params">(Observer* obs)</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		m_views.<span class="built_in">push_back</span>(obs);</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">set_val</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		m_value = value;</span><br><span class="line">		<span class="built_in">notify</span>();</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// 通知更新数据</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">notify</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_views.<span class="built_in">size</span>(); ++i)</span><br><span class="line">			m_views[i]-&gt;<span class="built_in">update</span>(<span class="keyword">this</span>, m_value);</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">update</span><span class="params">(Subject* sub, <span class="type">int</span> value)</span></span>;</span><br><span class="line">};</span><br></pre></td></tr></table></figure>

### 13.委托相关设计 
![](https://Baymine.github.io/images/面对对象编程/20220907193955.png)

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Component</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Component</span>(<span class="type">int</span> val) { value=val; }</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 不能设置为纯虚函数，因为有一些子类对这个动作是没有定义的</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">add</span><span class="params">(Component*)</span> </span>{ }  </span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Primitive</span>: <span class="keyword">public</span> Component</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Primitive</span>(<span class="type">int</span> val): <span class="built_in">Component</span>(val) {}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Composite</span>: <span class="keyword">public</span> Component</span><br><span class="line">{</span><br><span class="line">	vector&lt;Component*&gt;c;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Composite</span>(<span class="type">int</span> val): <span class="built_in">Component</span>(val) { }</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">add</span> <span class="params">(Component* elem)</span></span>{</span><br><span class="line">		c.<span class="built_in">push_back</span>(elem);</span><br><span class="line">	}</span><br><span class="line">	....</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<font color="red">为什么父类指针能够指向子类，但是子类指针指向父类可能导致不安全？</font>

<p><strong>委托+继承</strong><br>将新建的类与框架搭配到一起，需要创建好的类加入到框架的容器中去。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原型</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">imageType</span></span><br><span class="line">{</span><br><span class="line">	LAST, SPOT</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Image</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="type">static</span> Image *<span class="title">findAndColone</span><span class="params">(imageType)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> imageType <span class="title">returnType</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> Image *<span class="title">clone</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">addPrototype</span><span class="params">(Image *image)</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		_prototypes[_nextSlot++] = image;</span><br><span class="line">	}</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 存放类原型</span></span><br><span class="line">	<span class="type">static</span> Image *_prototypes[<span class="number">10</span>];</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> _nextSlot;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态变量需要在类外进行初始化</span></span><br><span class="line">Image *Image::_prototypes[];</span><br><span class="line"><span class="type">int</span> Imgage::_nextSlot;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过变量类型找出需要调用的原型</span></span><br><span class="line"><span class="function">Image *<span class="title">Image::findAndClone</span><span class="params">(imageType type)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; _nextSlot; i++)</span><br><span class="line">		<span class="keyword">if</span>(_prototypes[i]-&gt;<span class="built_in">returnType</span>() == type)</span><br><span class="line">			<span class="keyword">return</span> _prototypes[i]-&gt;<span class="built_in">clone</span>();  <span class="comment">// 得到目标类的一个备份</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LandSatImage</span>:<span class="keyword">public</span> Image{</span><br><span class="line">	<span class="comment">// 创建一个静态的自己，然后放到父类的那个容器中</span></span><br><span class="line">	<span class="comment">// 这里需要两个不同的构造函数，一个用于给父类原型时创建类用的，一个时父类在调用这个原型clone时用的，为了将这两种构造函数进行区分，他们的参数之间存在差异</span></span><br><span class="line">	....</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="模版模式"><a href="#模版模式" class="headerlink" title="模版模式"></a>模版模式</h3><ul>
<li>写代码过程中有种只见树木不见森林的感觉，因为一些主流程被封装起来了。（框架）</li>
<li>晚绑定</li>
<li>找到系统当中的稳定因素，对不稳定因素进行封装。<ul>
<li>练习：类图当中区分稳定因素和不稳定因素</li>
</ul>
</li>
</ul>
<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>考虑未来的代码的可能的变化。</p>
<ul>
<li>复用是二进制层面上额复用，不是代码复制粘贴。</li>
<li>多继承：主继承+接口继承，这是一种比较好的编程实践。Java当中是支持接口多继承的</li>
</ul>
<h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><p>优化理由：使用继承得到的类汪汪是随着需求进行变化，这样子类急剧膨胀，同时充斥着重复代码。</p>
<ul>
<li>由于继承带来的代码量的提升（在继承过程中的分化，继承类之间存在一定重复的代码，但是他们之间又存在差异）<ul>
<li>基类指针作为成员变量，这样在运行时确定具体的类，从而实现不同的功能</li>
</ul>
</li>
<li>组合优于继承</li>
<li>相同的字段往上提，重新写一个类作为接口（马丁福勒思想）</li>
</ul>
<h3 id="桥模式"><a href="#桥模式" class="headerlink" title="桥模式"></a>桥模式</h3><ul>
<li>主要为了避免一个类在多个维度上拓展功能而出现的类爆炸<ul>
<li>这个时候会对类进行拆分，这样使得这两个维度的拓展不会相互影响（其中一个继承其他的功能通过组合的方式加入到类当中）</li>
</ul>
</li>
</ul>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><ul>
<li>面向接口编程，将变量声明为一个抽象类</li>
<li>优化场景：在面向接口编程的时候，成员变量是抽象类，但是在创建的时候又需要依赖具体的类</li>
<li>通过面对对象的手段，将所要创建的具体对象工作延迟到子类，从而实现一种拓展（而非更改）的<ul>
<li>绕开new</li>
</ul>
</li>
<li>抽象工厂<ul>
<li>将一系列相关的类创建过程放到一个类当中 </li>
<li>其中方式一系列的工厂方法</li>
</ul>
</li>
</ul>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>在成员变量当中加入一个原型变量，在使用的时候，通过这个原型变量进行拷贝，从而实现一个新的对象。</p>
<p>当一个对象的创建过程比较复杂的时候，可以使用原型模式，将这个对象的创建过程放到一个类当中，然后通过这个类进行拷贝，从而实现一个新的对象。</p>
<h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><ul>
<li>有时候将一个初始化的过程放到一个Init函数当中是为了避免在构造函数当中调用虚函数<ul>
<li>由于在构造函数数当中调用虚函数可能导致在子类中调用的是父类的虚函数（因为构造顺序是：先构造父类然后构造子类，这个时候子类的虚函数还不存在，但是父类在构造函数当中已经对其进行调用了。）</li>
</ul>
</li>
<li>分步骤构建一个复杂的对象，其中分步骤是一个稳定的算法，而复杂的各个对象则经常发生变化</li>
</ul>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><ul>
<li>双检查锁<ul>
<li>在加锁之前先检查实例是否为空，之后加锁之后再次检查实例是否为空<ul>
<li>避免读的状态不加锁</li>
<li>存在的问题：由于内存读写reorder导致的不安全<ul>
<li>在申请空间的时候可能会因为指令重拍，先将地址赋值给单例对象，然后再调用构造函数初始化，这个时候可能会导致其他线程访问到一个未初始化的对象（只有内存地址但是没有构造）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><ul>
<li>用共享技术支持大量细粒度的对象</li>
<li>对象池</li>
</ul>
<h3 id="门面模式"><a href="#门面模式" class="headerlink" title="门面模式"></a>门面模式</h3><ul>
<li>在子系统内部和外部的解耦，用一个稳定的接口隔离变化体</li>
<li>更加注重架构的层次看整个系统</li>
</ul>
</div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="York Cao"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">York Cao</p><p class="is-size-6 is-block">Data Engineer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Beijing</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">41</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">8</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/Baymine" target="_blank" rel="me noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Github" href="https://github.com/Baymine"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-06-03T02:56:51.000Z">2024-06-03</time></p><p class="title"><a href="/2024/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%95%99%E8%82%B2%E7%BC%BA%E5%A4%B1%E7%9A%84%E4%B8%80%E8%AF%BE/">计算机教育缺失的一课</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-05-29T13:26:01.000Z">2024-05-29</time></p><p class="title"><a href="/2024/05/29/Clickhouse%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E6%97%A5%E8%AE%B0/">Clickhouse源码阅读日记</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-01-05T08:48:47.000Z">2023-01-05</time></p><p class="title"><a href="/2023/01/05/GeePRC-notes/">GeePRC notes</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-12-18T07:04:19.000Z">2022-12-18</time></p><p class="title"><a href="/2022/12/18/C-Memory-Management/">C++ Memory Management</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-12-16T03:53:01.000Z">2022-12-16</time></p><p class="title"><a href="/2022/12/16/MIT6-S081/">MIT6.S081</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/06/"><span class="level-start"><span class="level-item">June 2024</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/05/"><span class="level-start"><span class="level-item">May 2024</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/01/"><span class="level-start"><span class="level-item">January 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/12/"><span class="level-start"><span class="level-item">December 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/11/"><span class="level-start"><span class="level-item">November 2022</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/10/"><span class="level-start"><span class="level-item">October 2022</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/07/"><span class="level-start"><span class="level-item">July 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/06/"><span class="level-start"><span class="level-item">June 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">May 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">April 2021</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">March 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/02/"><span class="level-start"><span class="level-item">February 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">January 2021</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/12/"><span class="level-start"><span class="level-item">December 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C++</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C-primer/"><span class="tag">C++ primer</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/DB/"><span class="tag">DB</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OS/"><span class="tag">OS</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Projects/"><span class="tag">Projects</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/bugs/"><span class="tag">bugs</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/computer-network/"><span class="tag">computer network</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BE%AF%E6%8D%B7C/"><span class="tag">侯捷C++</span><span class="tag">5</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">Subscribe for updates</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div><div class="card widget"><div class="card-content"><div class="notification is-danger">You need to set <code>client_id</code> and <code>slot_id</code> to show this AD unit. Please set it in <code>_config.yml</code>.</div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Baymine&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2024 John Doe</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>