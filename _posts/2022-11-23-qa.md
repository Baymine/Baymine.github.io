---
layout: post
title: "Q&A"
date: 2022-11-23 08:06:49 +0000
categories: [blog]
tags: []
---

## [](#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E7%9A%84%E7%94%A8%E6%B3%95)右值引用的用法

1
2

// 引用右值，避免生成新对象
Foo&amp;&amp; foo2 = FooFactory();

**[关于std::move函数](https://zhuanlan.zhihu.com/p/335994370)**

> 

std::move移动不了什么，唯一的功能是把左值强制转化为右值，让右值引用可以指向左值。其实现等同于一个类型转换：static_cast(lvalue)。 所以，单纯的std::move(xxx)不会有性能提升. move返回值如果有名称就是左值（被赋值给一个变量），没有名称就是右值。

**使用建议**：可移动对象在&lt;需要拷贝且被拷贝者之后不再被需要&gt;的场景，建议使用std::move触发移动语义，提升性能。（类似于 `push_back`等的函数）。

对于 `unique_ptr`只能进行移动构造函数，所以可以使用 `move`实现赋值构造
`std::unique_ptr&lt;A&gt; ptr = std::move(ptr_a);`.

**完美转发 std::forward**

> 

std::forward `&lt;T&gt;`(u)有两个参数：T与 u。 a. 当T为左值引用类型时，u将被转换为T类型的左值； b. 否则u将被转换为T类型右值。

- const右值引用传入的参数可以被修改，而const左值传入的则不可以修改。

## [](#C-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8vector)[C++为什么不推荐使用vector\](https://www.zhihu.com/question/23367698)

vector&lt; bool&gt;不是一个标准容器，就是因为它不能支持一些容器该有的基本操作，诸如取地址给指针初始化操作.

1
2

vector&lt;bool&gt; c{false, false};
bool b = c[0]; // 这里有一个隐式的类型转换

## [](#%E5%86%B7%E4%B8%8D%E5%91%BD%E4%B8%AD-cold-miss)冷不命中(cold miss)
缓存会在断电之后清空，那么是不是意味着在刚开机的时候，电脑运行的速度会相对较慢？

## [](#ssh%E5%91%BD%E4%BB%A4%E4%BC%A0%E8%BE%93%E6%96%B9%E5%BC%8F)ssh命令传输方式

为什么会因为网络波动而导致无法输入的情况

## [](#%E6%9D%82%E9%A1%B9)杂项

- 为什么在Xftp中删除文件那么慢，而直接使用rm会快很多？
- 写入空白和覆盖哪个速度更快？
- 为什么这么写？while(-1 != (opt = getopt(argc, argv, “x:y:”)))
防止将==写成=，此时，如果写成a=1编译会通过，如果写成1=a编译不会通过，这样做也可减少这种隐形的bug的出现

函数指针（typedef）

1
2
3
4
5
6
7
8
9

// note that the typedef name is indeed myFuncDef
// Confused here ???????
typedef int (*myFuncDef)(int, int);

myFuncDef functionFactory(int n) {
    printf("Got parameter %d", n);
    myFuncDef functionPtr = &amp;addInt;
    return functionPtr;
}

- void (*0)( ) ：是⼀个返回值为void，参数为空的函数指针0 (这里的意思是函数名为0吗？)
- 为什么在Linux下不能同时安装多个软件，但是在Windows下可以？（并行和串行的优劣？）
- 在fork之后，父进程和子进程的运行有先后顺序吗？
- 
函数名是不是就是函数指针？(是，那么为什么不需要解引用，直接可以调用？)我可以通过函数名调用函数，那可不可以认为这个函数名就是一个句柄？如何理解句柄？异常表中存储就是各种异常处理函数的句柄？能不能理解为一个整数到一个指针的映射？

> 

**为什么要用 handle，而不直接用指针呢？**

指针作用太强，可做的事情太多。可做的事情越多，就会越危险。接口设计中，功能刚刚好就够了，并非越多权限越好的。
- handle 通常只是个整数，实现被隐藏起来，假如直接暴露了指针，也就暴露了指针类型（有时也可以暴露 void* 指针作为某种 handle）。用户看到越多细节，其代码就越有可能依赖这些细节。将来情况有变，但又要兼容用户代码，库内部改起来就更麻烦。
- 资源在内部管理，通过 handle 作为中间层，可以有效判断 handle 是否合法，也可以通过权限检查防止某种危险操作。
- handle 通常只是个整数，所有的语言都有整数这种类型，但并非所有语言都有指针。接口只出现整数，方便同一实现绑定到各种语言。

在编写信号处理器的时候，最好调用异步信号安全性函数，那为什么不能再执行函数的时候阻塞所有的信号，这样不能保证函数的原子性吗？
printf 和cout混用会有什么后果吗？
free 或者delete掉malloc 或 new 出来的内存会发生什么？
csapp p588: 在32位模式中，  malloc返回的块的地址总是8的倍数，64位模式中，总是16的倍数。 这是为什么？
双字对齐的约束下，块的大小总是为8的倍数，且块大小的最低三位总是为0（这样才能是8的倍数，这里双字表示8字节）
csapp: 练习题9.6中的块大小的计算方法(get)
docker &amp; virtual machine 之间有什么区别？

> 

向上转型：子类除继承父类数据成员，并且还会有自己的数据成员，但是在向上转型后子类的数据成员会被舍弃

转型之后的指针为什么可以通过子类的共有方法调用子类成员变量？
多线程：如何理解多线程代码的执行过程，虚假唤醒

## [](#%E4%BB%A3%E7%A0%81%E5%93%B2%E5%AD%A6)代码哲学

- 为什么说各个编程语言之间粒度不同呢？在什么方面体现？
如果相应的库被实现了，那么这个语言的粒度会不会改变？

短期内形成对方案的评估的能力，能够知晓方案的可行性、难点的能力，这种能力叫什么？如何训练（在刷算法题的时候，往往在完成过程中才能知晓这些，可能的原因有考虑不充分等）
见到一种技术，如何从技术实现得到技术的类型？
将碎片知识进行体系化
解决一个算法问题的过程
为什么说计算机领域最难的两个问题是变量命名和缓存不命中？